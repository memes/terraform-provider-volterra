// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/dns_compliance_checks/types.proto

package dns_compliance_checks

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Disallowed Query Type
//
// x-displayName: "Disallowed Query Type"
// Disallowed Query Type
type DisallowedQueryType int32

const (
	// QUERY
	//
	// x-displayName: "QUERY"
	QUERY DisallowedQueryType = 0
	// IQUERY
	//
	// x-displayName: "IQUERY"
	IQUERY DisallowedQueryType = 1
	// STATUS
	//
	// x-displayName: "STATUS"
	STATUS DisallowedQueryType = 2
	// NOTIFY
	//
	// x-displayName: "NOTIFY"
	NOTIFY DisallowedQueryType = 4
	// UPDATE
	//
	// x-displayName: "UPDATE"
	UPDATE DisallowedQueryType = 5
)

var DisallowedQueryType_name = map[int32]string{
	0: "QUERY",
	1: "IQUERY",
	2: "STATUS",
	4: "NOTIFY",
	5: "UPDATE",
}

var DisallowedQueryType_value = map[string]int32{
	"QUERY":  0,
	"IQUERY": 1,
	"STATUS": 2,
	"NOTIFY": 4,
	"UPDATE": 5,
}

func (DisallowedQueryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8811bd4a007e3e44, []int{0}
}

// DisallowedResourceRecord
//
// x-displayName: "Disallowed Resource Record"
// Disallowed Resource Record
type DisallowedResourceRecordType int32

const (
	// T
	//
	// x-displayName: "T"
	T DisallowedResourceRecordType = 0
	// A
	//
	// x-displayName: "A"
	A DisallowedResourceRecordType = 1
	// NS
	//
	// x-displayName: "NS"
	NS DisallowedResourceRecordType = 2
	// MD
	//
	// x-displayName: "MD"
	MD DisallowedResourceRecordType = 3
	// MF
	//
	// x-displayName: "MF"
	MF DisallowedResourceRecordType = 4
	// CNAME
	//
	// x-displayName: "CNAME"
	CNAME DisallowedResourceRecordType = 5
	// SOA
	//
	// x-displayName: "SOA"
	SOA DisallowedResourceRecordType = 6
	// MB
	//
	// x-displayName: "MB"
	MB DisallowedResourceRecordType = 7
	// MG
	//
	// x-displayName: "MG"
	MG DisallowedResourceRecordType = 8
	// MR
	//
	// x-displayName: "MR"
	MR DisallowedResourceRecordType = 9
	// NULL
	//
	// x-displayName: "NULL"
	NULL DisallowedResourceRecordType = 10
	// WKS
	//
	// x-displayName: "WKS"
	WKS DisallowedResourceRecordType = 11
	// PTR
	//
	// x-displayName: "PTR"
	PTR DisallowedResourceRecordType = 12
	// HINFO
	//
	// x-displayName: "HINFO"
	HINFO DisallowedResourceRecordType = 13
	// MINFO
	//
	// x-displayName: "MINFO"
	MINFO DisallowedResourceRecordType = 14
	// MX
	//
	// x-displayName: "MX"
	MX DisallowedResourceRecordType = 15
	// TXT
	//
	// x-displayName: "TXT"
	TXT DisallowedResourceRecordType = 16
	// RP
	//
	// x-displayName: "RP"
	RP DisallowedResourceRecordType = 17
	// AFSDB
	//
	// x-displayName: "AFSDB"
	AFSDB DisallowedResourceRecordType = 18
	// X25
	//
	// x-displayName: "X25"
	X25 DisallowedResourceRecordType = 19
	// ISDN
	//
	// x-displayName: "ISDN"
	ISDN DisallowedResourceRecordType = 20
	// RT
	//
	// x-displayName: "RT"
	RT DisallowedResourceRecordType = 21
	// NSAP
	//
	// x-displayName: "NSAP"
	NSAP DisallowedResourceRecordType = 22
	// NSAP-PTR
	//
	// x-displayName: "NSAP-PTR"
	NSAP_PTR DisallowedResourceRecordType = 23
	// SIG
	//
	// x-displayName: "SIG"
	SIG DisallowedResourceRecordType = 24
	// KEY
	//
	// x-displayName: "KEY"
	KEY DisallowedResourceRecordType = 25
	// PX
	//
	// x-displayName: "PX"
	PX DisallowedResourceRecordType = 26
	// GPOS
	//
	// x-displayName: "GPOS"
	GPOS DisallowedResourceRecordType = 27
	// AAAA
	//
	// x-displayName: "AAAA"
	AAAA DisallowedResourceRecordType = 28
	// LOC
	//
	// x-displayName: "LOC"
	LOC DisallowedResourceRecordType = 29
	// NXT
	//
	// x-displayName: "NXT"
	NXT DisallowedResourceRecordType = 30
	// EID
	//
	// x-displayName: "EID"
	EID DisallowedResourceRecordType = 31
	// NIMLOC
	//
	// x-displayName: "NIMLOC"
	NIMLOC DisallowedResourceRecordType = 32
	// SRV
	//
	// x-displayName: "SRV"
	SRV DisallowedResourceRecordType = 33
	// ATMA
	//
	// x-displayName: "ATMA"
	ATMA DisallowedResourceRecordType = 34
	// NAPTR
	//
	// x-displayName: "NAPTR"
	NAPTR DisallowedResourceRecordType = 35
	// KX
	//
	// x-displayName: "KX"
	KX DisallowedResourceRecordType = 36
	// CERT
	//
	// x-displayName: "CERT"
	CERT DisallowedResourceRecordType = 37
	// A6
	//
	// x-displayName: "A6"
	A6 DisallowedResourceRecordType = 38
	// DNAME
	//
	// x-displayName: "DNAME"
	DNAME DisallowedResourceRecordType = 39
	// SINK
	//
	// x-displayName: "SINK"
	SINK DisallowedResourceRecordType = 40
	// OPT
	//
	// x-displayName: "OPT"
	OPT DisallowedResourceRecordType = 41
	// APL
	//
	// x-displayName: "APL"
	APL DisallowedResourceRecordType = 42
	// DS
	//
	// x-displayName: "DS"
	DS DisallowedResourceRecordType = 43
	// SSHFP
	//
	// x-displayName: "SSHFP"
	SSHFP DisallowedResourceRecordType = 44
	// IPSECKEY
	//
	// x-displayName: "IPSECKEY"
	IPSECKEY DisallowedResourceRecordType = 45
	// RRSIG
	//
	// x-displayName: "RRSIG"
	RRSIG DisallowedResourceRecordType = 46
	// NSEC
	//
	// x-displayName: "NSEC"
	NSEC DisallowedResourceRecordType = 47
	// DNSKEY
	//
	// x-displayName: "DNSKEY"
	DNSKEY DisallowedResourceRecordType = 48
	// DHCID
	//
	// x-displayName: "DHCID"
	DHCID DisallowedResourceRecordType = 49
	// NSEC3
	//
	// x-displayName: "NSEC3"
	NSEC3 DisallowedResourceRecordType = 50
	// NSEC3PARAM
	//
	// x-displayName: "NSEC3PARAM"
	NSEC3PARAM DisallowedResourceRecordType = 51
	// TLSA
	//
	// x-displayName: "TLSA"
	TLSA DisallowedResourceRecordType = 52
	// SMIMEA
	//
	// x-displayName: "SMIMEA"
	SMIMEA DisallowedResourceRecordType = 53
	// HIP
	//
	// x-displayName: "HIP"
	HIP DisallowedResourceRecordType = 55
	// NINFO
	//
	// x-displayName: "NINFO"
	NINFO DisallowedResourceRecordType = 56
	// RKEY
	//
	// x-displayName: "RKEY"
	RKEY DisallowedResourceRecordType = 57
	// TALINK
	//
	// x-displayName: "TALINK"
	TALINK DisallowedResourceRecordType = 58
	// CDS
	//
	// x-displayName: "CDS"
	CDS DisallowedResourceRecordType = 59
	// CDNSKEY
	//
	// x-displayName: "CDNSKEY"
	CDNSKEY DisallowedResourceRecordType = 60
	// OPENPGPKEY
	//
	// x-displayName: "OPENPGPKEY"
	OPENPGPKEY DisallowedResourceRecordType = 61
	// CSYNC
	//
	// x-displayName: "CSYNC"
	CSYNC DisallowedResourceRecordType = 62
	// SPF
	//
	// x-displayName: "SPF"
	SPF DisallowedResourceRecordType = 99
	// UINFO
	//
	// x-displayName: "UINFO"
	UINFO DisallowedResourceRecordType = 100
	// UID
	//
	// x-displayName: "UID"
	UID DisallowedResourceRecordType = 101
	// GID
	//
	// x-displayName: "GID"
	GID DisallowedResourceRecordType = 102
	// UNSPEC
	//
	// x-displayName: "UNSPEC"
	UNSPEC DisallowedResourceRecordType = 103
	// NID
	//
	// x-displayName: "NID"
	NID DisallowedResourceRecordType = 104
	// L32
	//
	// x-displayName: "L32"
	L32 DisallowedResourceRecordType = 105
	// L64
	//
	// x-displayName: "L64"
	L64 DisallowedResourceRecordType = 106
	// LP
	//
	// x-displayName: "LP"
	LP DisallowedResourceRecordType = 107
	// EUI48
	//
	// x-displayName: "EUI48"
	EUI48 DisallowedResourceRecordType = 108
	// EUI64
	//
	// x-displayName: "EUI64"
	EUI64 DisallowedResourceRecordType = 109
	// TKEY
	//
	// x-displayName: "TKEY"
	TKEY DisallowedResourceRecordType = 249
	// TSIG
	//
	// x-displayName: "TSIG"
	TSIG DisallowedResourceRecordType = 250
	// IXFR
	//
	// x-displayName: "IXFR"
	IXFR DisallowedResourceRecordType = 251
	// AXFR
	//
	// x-displayName: "AXFR"
	AXFR DisallowedResourceRecordType = 252
	// MAILB
	//
	// x-displayName: "MAILB"
	MAILB DisallowedResourceRecordType = 253
	// MAILA
	//
	// x-displayName: "MAILA"
	MAILA DisallowedResourceRecordType = 254
	// URI
	//
	// x-displayName: "URI"
	URI DisallowedResourceRecordType = 256
	// CAA
	//
	// x-displayName: "CAA"
	CAA DisallowedResourceRecordType = 257
	// TA
	//
	// x-displayName: "TA"
	TA DisallowedResourceRecordType = 32768
	// DLV
	//
	// x-displayName: "DLV"
	DLV DisallowedResourceRecordType = 32769
)

var DisallowedResourceRecordType_name = map[int32]string{
	0:     "T",
	1:     "A",
	2:     "NS",
	3:     "MD",
	4:     "MF",
	5:     "CNAME",
	6:     "SOA",
	7:     "MB",
	8:     "MG",
	9:     "MR",
	10:    "NULL",
	11:    "WKS",
	12:    "PTR",
	13:    "HINFO",
	14:    "MINFO",
	15:    "MX",
	16:    "TXT",
	17:    "RP",
	18:    "AFSDB",
	19:    "X25",
	20:    "ISDN",
	21:    "RT",
	22:    "NSAP",
	23:    "NSAP_PTR",
	24:    "SIG",
	25:    "KEY",
	26:    "PX",
	27:    "GPOS",
	28:    "AAAA",
	29:    "LOC",
	30:    "NXT",
	31:    "EID",
	32:    "NIMLOC",
	33:    "SRV",
	34:    "ATMA",
	35:    "NAPTR",
	36:    "KX",
	37:    "CERT",
	38:    "A6",
	39:    "DNAME",
	40:    "SINK",
	41:    "OPT",
	42:    "APL",
	43:    "DS",
	44:    "SSHFP",
	45:    "IPSECKEY",
	46:    "RRSIG",
	47:    "NSEC",
	48:    "DNSKEY",
	49:    "DHCID",
	50:    "NSEC3",
	51:    "NSEC3PARAM",
	52:    "TLSA",
	53:    "SMIMEA",
	55:    "HIP",
	56:    "NINFO",
	57:    "RKEY",
	58:    "TALINK",
	59:    "CDS",
	60:    "CDNSKEY",
	61:    "OPENPGPKEY",
	62:    "CSYNC",
	99:    "SPF",
	100:   "UINFO",
	101:   "UID",
	102:   "GID",
	103:   "UNSPEC",
	104:   "NID",
	105:   "L32",
	106:   "L64",
	107:   "LP",
	108:   "EUI48",
	109:   "EUI64",
	249:   "TKEY",
	250:   "TSIG",
	251:   "IXFR",
	252:   "AXFR",
	253:   "MAILB",
	254:   "MAILA",
	256:   "URI",
	257:   "CAA",
	32768: "TA",
	32769: "DLV",
}

var DisallowedResourceRecordType_value = map[string]int32{
	"T":          0,
	"A":          1,
	"NS":         2,
	"MD":         3,
	"MF":         4,
	"CNAME":      5,
	"SOA":        6,
	"MB":         7,
	"MG":         8,
	"MR":         9,
	"NULL":       10,
	"WKS":        11,
	"PTR":        12,
	"HINFO":      13,
	"MINFO":      14,
	"MX":         15,
	"TXT":        16,
	"RP":         17,
	"AFSDB":      18,
	"X25":        19,
	"ISDN":       20,
	"RT":         21,
	"NSAP":       22,
	"NSAP_PTR":   23,
	"SIG":        24,
	"KEY":        25,
	"PX":         26,
	"GPOS":       27,
	"AAAA":       28,
	"LOC":        29,
	"NXT":        30,
	"EID":        31,
	"NIMLOC":     32,
	"SRV":        33,
	"ATMA":       34,
	"NAPTR":      35,
	"KX":         36,
	"CERT":       37,
	"A6":         38,
	"DNAME":      39,
	"SINK":       40,
	"OPT":        41,
	"APL":        42,
	"DS":         43,
	"SSHFP":      44,
	"IPSECKEY":   45,
	"RRSIG":      46,
	"NSEC":       47,
	"DNSKEY":     48,
	"DHCID":      49,
	"NSEC3":      50,
	"NSEC3PARAM": 51,
	"TLSA":       52,
	"SMIMEA":     53,
	"HIP":        55,
	"NINFO":      56,
	"RKEY":       57,
	"TALINK":     58,
	"CDS":        59,
	"CDNSKEY":    60,
	"OPENPGPKEY": 61,
	"CSYNC":      62,
	"SPF":        99,
	"UINFO":      100,
	"UID":        101,
	"GID":        102,
	"UNSPEC":     103,
	"NID":        104,
	"L32":        105,
	"L64":        106,
	"LP":         107,
	"EUI48":      108,
	"EUI64":      109,
	"TKEY":       249,
	"TSIG":       250,
	"IXFR":       251,
	"AXFR":       252,
	"MAILB":      253,
	"MAILA":      254,
	"URI":        256,
	"CAA":        257,
	"TA":         32768,
	"DLV":        32769,
}

func (DisallowedResourceRecordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8811bd4a007e3e44, []int{1}
}

// GlobalSpecType
//
// x-displayName: "View Specification"
// Desired state of DNS Compliance Checks Specification
type GlobalSpecType struct {
	// Disallowed Resource Record Types
	//
	// x-displayName: "Disallowed Resource Record Types"
	// Disallowed Resource Record Type List
	DisallowedResourceRecordTypeList []DisallowedResourceRecordType `protobuf:"varint,1,rep,packed,name=disallowed_resource_record_type_list,json=disallowedResourceRecordTypeList,proto3,enum=ves.io.schema.dns_compliance_checks.DisallowedResourceRecordType" json:"disallowed_resource_record_type_list,omitempty"`
	// Domain Deny List
	//
	// x-example: "www.f5.com"
	// x-required
	// x-displayName: "Domain Deny list"
	// List of domains to be denied by configuration object
	DomainDenylist []string `protobuf:"bytes,2,rep,name=domain_denylist,json=domainDenylist,proto3" json:"domain_denylist,omitempty"`
	// Disallowed Query Type Values
	//
	// x-displayName: "Disallowed Query Type Values"
	// Disallowed Query Type Values
	DisallowedQueryTypeList []DisallowedQueryType `protobuf:"varint,3,rep,packed,name=disallowed_query_type_list,json=disallowedQueryTypeList,proto3,enum=ves.io.schema.dns_compliance_checks.DisallowedQueryType" json:"disallowed_query_type_list,omitempty"`
	// backref_objs
	//
	// x-displayName: "Protocol Inspection Config"
	// A list of protocol inspection configs using dns compliance checks
	ProtocolInspection []*views.ObjectRefType `protobuf:"bytes,4,rep,name=protocol_inspection,json=protocolInspection,proto3" json:"protocol_inspection,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8811bd4a007e3e44, []int{0}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetDisallowedResourceRecordTypeList() []DisallowedResourceRecordType {
	if m != nil {
		return m.DisallowedResourceRecordTypeList
	}
	return nil
}

func (m *GlobalSpecType) GetDomainDenylist() []string {
	if m != nil {
		return m.DomainDenylist
	}
	return nil
}

func (m *GlobalSpecType) GetDisallowedQueryTypeList() []DisallowedQueryType {
	if m != nil {
		return m.DisallowedQueryTypeList
	}
	return nil
}

func (m *GlobalSpecType) GetProtocolInspection() []*views.ObjectRefType {
	if m != nil {
		return m.ProtocolInspection
	}
	return nil
}

// Create DNS Compliance Checks
//
// x-displayName: "Create DNS Compliance Checks"
// Create DNS Compliance Checks Specification in a given namespace. If one already exists it will give an error.
type CreateSpecType struct {
	DisallowedResourceRecordTypeList []DisallowedResourceRecordType `protobuf:"varint,1,rep,packed,name=disallowed_resource_record_type_list,json=disallowedResourceRecordTypeList,proto3,enum=ves.io.schema.dns_compliance_checks.DisallowedResourceRecordType" json:"disallowed_resource_record_type_list,omitempty"`
	DomainDenylist                   []string                       `protobuf:"bytes,2,rep,name=domain_denylist,json=domainDenylist,proto3" json:"domain_denylist,omitempty"`
	DisallowedQueryTypeList          []DisallowedQueryType          `protobuf:"varint,3,rep,packed,name=disallowed_query_type_list,json=disallowedQueryTypeList,proto3,enum=ves.io.schema.dns_compliance_checks.DisallowedQueryType" json:"disallowed_query_type_list,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8811bd4a007e3e44, []int{1}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetDisallowedResourceRecordTypeList() []DisallowedResourceRecordType {
	if m != nil {
		return m.DisallowedResourceRecordTypeList
	}
	return nil
}

func (m *CreateSpecType) GetDomainDenylist() []string {
	if m != nil {
		return m.DomainDenylist
	}
	return nil
}

func (m *CreateSpecType) GetDisallowedQueryTypeList() []DisallowedQueryType {
	if m != nil {
		return m.DisallowedQueryTypeList
	}
	return nil
}

// Replace DNS Compliance Checks
//
// x-displayName: "Replace DNS Compliance Checks "
// Replace DNS Compliance Checks specification in a given namespace.
type ReplaceSpecType struct {
	DisallowedResourceRecordTypeList []DisallowedResourceRecordType `protobuf:"varint,1,rep,packed,name=disallowed_resource_record_type_list,json=disallowedResourceRecordTypeList,proto3,enum=ves.io.schema.dns_compliance_checks.DisallowedResourceRecordType" json:"disallowed_resource_record_type_list,omitempty"`
	DomainDenylist                   []string                       `protobuf:"bytes,2,rep,name=domain_denylist,json=domainDenylist,proto3" json:"domain_denylist,omitempty"`
	DisallowedQueryTypeList          []DisallowedQueryType          `protobuf:"varint,3,rep,packed,name=disallowed_query_type_list,json=disallowedQueryTypeList,proto3,enum=ves.io.schema.dns_compliance_checks.DisallowedQueryType" json:"disallowed_query_type_list,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8811bd4a007e3e44, []int{2}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetDisallowedResourceRecordTypeList() []DisallowedResourceRecordType {
	if m != nil {
		return m.DisallowedResourceRecordTypeList
	}
	return nil
}

func (m *ReplaceSpecType) GetDomainDenylist() []string {
	if m != nil {
		return m.DomainDenylist
	}
	return nil
}

func (m *ReplaceSpecType) GetDisallowedQueryTypeList() []DisallowedQueryType {
	if m != nil {
		return m.DisallowedQueryTypeList
	}
	return nil
}

// Get DNS Compliance Checks
//
// x-displayName: "Get DNS Compliance Checks "
// Get DNS Compliance Checks details.
type GetSpecType struct {
	DisallowedResourceRecordTypeList []DisallowedResourceRecordType `protobuf:"varint,1,rep,packed,name=disallowed_resource_record_type_list,json=disallowedResourceRecordTypeList,proto3,enum=ves.io.schema.dns_compliance_checks.DisallowedResourceRecordType" json:"disallowed_resource_record_type_list,omitempty"`
	DomainDenylist                   []string                       `protobuf:"bytes,2,rep,name=domain_denylist,json=domainDenylist,proto3" json:"domain_denylist,omitempty"`
	DisallowedQueryTypeList          []DisallowedQueryType          `protobuf:"varint,3,rep,packed,name=disallowed_query_type_list,json=disallowedQueryTypeList,proto3,enum=ves.io.schema.dns_compliance_checks.DisallowedQueryType" json:"disallowed_query_type_list,omitempty"`
	ProtocolInspection               []*views.ObjectRefType         `protobuf:"bytes,4,rep,name=protocol_inspection,json=protocolInspection,proto3" json:"protocol_inspection,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8811bd4a007e3e44, []int{3}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetDisallowedResourceRecordTypeList() []DisallowedResourceRecordType {
	if m != nil {
		return m.DisallowedResourceRecordTypeList
	}
	return nil
}

func (m *GetSpecType) GetDomainDenylist() []string {
	if m != nil {
		return m.DomainDenylist
	}
	return nil
}

func (m *GetSpecType) GetDisallowedQueryTypeList() []DisallowedQueryType {
	if m != nil {
		return m.DisallowedQueryTypeList
	}
	return nil
}

func (m *GetSpecType) GetProtocolInspection() []*views.ObjectRefType {
	if m != nil {
		return m.ProtocolInspection
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.dns_compliance_checks.DisallowedQueryType", DisallowedQueryType_name, DisallowedQueryType_value)
	golang_proto.RegisterEnum("ves.io.schema.dns_compliance_checks.DisallowedQueryType", DisallowedQueryType_name, DisallowedQueryType_value)
	proto.RegisterEnum("ves.io.schema.dns_compliance_checks.DisallowedResourceRecordType", DisallowedResourceRecordType_name, DisallowedResourceRecordType_value)
	golang_proto.RegisterEnum("ves.io.schema.dns_compliance_checks.DisallowedResourceRecordType", DisallowedResourceRecordType_name, DisallowedResourceRecordType_value)
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.dns_compliance_checks.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.dns_compliance_checks.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.dns_compliance_checks.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.dns_compliance_checks.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.dns_compliance_checks.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.dns_compliance_checks.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.dns_compliance_checks.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.dns_compliance_checks.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/dns_compliance_checks/types.proto", fileDescriptor_8811bd4a007e3e44)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/dns_compliance_checks/types.proto", fileDescriptor_8811bd4a007e3e44)
}

var fileDescriptor_8811bd4a007e3e44 = []byte{
	// 1248 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xcb, 0x53, 0xdb, 0x56,
	0x17, 0xf7, 0xb5, 0x0d, 0x81, 0x4b, 0x3e, 0x38, 0x51, 0x5e, 0xc4, 0xc9, 0x27, 0xfc, 0x91, 0x7c,
	0x0d, 0x4d, 0x8b, 0xdd, 0x00, 0x49, 0xd3, 0xb4, 0xcd, 0xcc, 0x45, 0x92, 0x8d, 0x06, 0x5b, 0x56,
	0x24, 0x39, 0x31, 0xdd, 0x78, 0x8c, 0x7c, 0x31, 0x0a, 0x36, 0x72, 0x65, 0x41, 0xca, 0xa2, 0x33,
	0x64, 0xdd, 0x4d, 0xdb, 0x4d, 0xff, 0x84, 0x3e, 0xfe, 0x84, 0x66, 0x93, 0xe9, 0xaa, 0xd3, 0x55,
	0x76, 0x65, 0xa6, 0x9b, 0xc6, 0x74, 0xd1, 0xee, 0xb2, 0x4c, 0x9f, 0xd3, 0x39, 0xd7, 0x86, 0x40,
	0x20, 0x4c, 0xfa, 0x5c, 0x65, 0x75, 0x7f, 0xba, 0xe7, 0x77, 0x7e, 0xe7, 0x29, 0x8d, 0x4d, 0xd3,
	0xab, 0xbc, 0x95, 0xf2, 0xfc, 0x74, 0xcb, 0x5d, 0xe4, 0x8d, 0x4a, 0xba, 0xba, 0xdc, 0x2a, 0xbb,
	0x7e, 0xa3, 0x59, 0xf7, 0x2a, 0xcb, 0x2e, 0x2f, 0xbb, 0x8b, 0xdc, 0x5d, 0x6a, 0xa5, 0xc3, 0xb5,
	0x26, 0x6f, 0xa5, 0x9a, 0x81, 0x1f, 0xfa, 0xd2, 0xd9, 0x8e, 0x43, 0xaa, 0xe3, 0x90, 0xda, 0xd7,
	0x21, 0x31, 0x5e, 0xf3, 0xc2, 0xc5, 0x95, 0xf9, 0x94, 0xeb, 0x37, 0xd2, 0x35, 0xbf, 0xe6, 0xa7,
	0x85, 0xef, 0xfc, 0xca, 0x82, 0x78, 0x12, 0x0f, 0x02, 0x75, 0x34, 0x13, 0x23, 0x35, 0xdf, 0xaf,
	0xd5, 0xf9, 0x63, 0x56, 0xe8, 0x35, 0x78, 0x2b, 0xac, 0x34, 0x9a, 0x5d, 0xc2, 0xe9, 0xdd, 0x59,
	0xfa, 0xcd, 0xd0, 0xf3, 0x97, 0xbb, 0x19, 0x25, 0x4e, 0xed, 0x36, 0xee, 0x48, 0x36, 0x71, 0x66,
	0xb7, 0x69, 0xb5, 0x52, 0xf7, 0xaa, 0x95, 0x90, 0x77, 0xad, 0xc9, 0x27, 0xac, 0x1e, 0xbf, 0x5d,
	0xde, 0x2d, 0x3d, 0xb2, 0x97, 0xb1, 0xab, 0x1b, 0xa3, 0xdf, 0xc4, 0xe9, 0x60, 0xb6, 0xee, 0xcf,
	0x57, 0xea, 0x76, 0x93, 0xbb, 0xce, 0x5a, 0x93, 0x4b, 0x1f, 0x13, 0x7a, 0xae, 0xea, 0xb5, 0x2a,
	0xf5, 0xba, 0x7f, 0x9b, 0x57, 0xcb, 0x01, 0x6f, 0xf9, 0x2b, 0x81, 0xcb, 0xcb, 0x01, 0x77, 0xfd,
	0xa0, 0x5a, 0x46, 0xef, 0x72, 0xdd, 0x6b, 0x85, 0xc3, 0x24, 0x19, 0x1b, 0x1b, 0x9c, 0x60, 0xa9,
	0x67, 0x68, 0x68, 0x4a, 0xdd, 0x16, 0xb4, 0xba, 0x7a, 0x96, 0x90, 0xc3, 0x88, 0xd3, 0xc7, 0x3e,
	0xff, 0xe1, 0x5e, 0xac, 0xe7, 0x43, 0x12, 0x85, 0xbe, 0x2d, 0x34, 0x4c, 0xac, 0x64, 0xf5, 0x00,
	0x9f, 0x9c, 0xd7, 0x0a, 0xa5, 0x59, 0x3a, 0x54, 0xf5, 0x1b, 0x15, 0x6f, 0xb9, 0x5c, 0xe5, 0xcb,
	0x6b, 0x22, 0xa7, 0x68, 0x32, 0x36, 0xd6, 0x3f, 0x3d, 0xfa, 0xe8, 0x2e, 0x89, 0x6c, 0x8b, 0xca,
	0x8f, 0x45, 0x05, 0x0a, 0x62, 0x8f, 0xa2, 0xc4, 0x1a, 0xec, 0xb8, 0xaa, 0x5d, 0x4f, 0xe9, 0x3d,
	0x42, 0x13, 0x3b, 0xca, 0x7e, 0x7b, 0x85, 0x07, 0x6b, 0x3b, 0x8a, 0x8d, 0x89, 0x62, 0xaf, 0xfc,
	0xc1, 0x62, 0xaf, 0xa3, 0xca, 0x01, 0x35, 0x9e, 0xac, 0xee, 0xa5, 0x8a, 0xd2, 0x96, 0xe8, 0x51,
	0x31, 0x20, 0xd7, 0xaf, 0x97, 0xbd, 0xe5, 0x56, 0x93, 0xbb, 0x38, 0xd6, 0xe1, 0x78, 0x32, 0x36,
	0x36, 0x30, 0x31, 0xfa, 0x44, 0x16, 0x62, 0xac, 0xa9, 0xc2, 0xfc, 0x2d, 0xee, 0x86, 0x16, 0x5f,
	0x10, 0xf1, 0x4e, 0x7c, 0xf6, 0xee, 0x7e, 0x0a, 0x96, 0xb4, 0x75, 0xa9, 0x6f, 0xdf, 0x5d, 0xbd,
	0xf9, 0xc5, 0x5d, 0x62, 0xd3, 0x11, 0x9a, 0x78, 0x9c, 0x78, 0x72, 0xab, 0xe5, 0xc9, 0x4e, 0xcf,
	0x25, 0x72, 0x91, 0x1e, 0xa3, 0x43, 0xaa, 0xe8, 0x59, 0x12, 0x9b, 0x26, 0xd2, 0x24, 0x13, 0x34,
	0x41, 0x8f, 0xef, 0x70, 0x13, 0x55, 0x24, 0xc5, 0x1e, 0x91, 0xc9, 0xd1, 0xaf, 0xa3, 0x74, 0x50,
	0x09, 0x78, 0x25, 0xe4, 0xdb, 0xdb, 0xf5, 0xc1, 0xbf, 0xbd, 0x5d, 0xcf, 0xb0, 0x47, 0xe7, 0x9f,
	0xb2, 0x47, 0x7b, 0x76, 0x64, 0xe5, 0x9f, 0x5c, 0x91, 0xa7, 0x2e, 0xc3, 0xd5, 0x23, 0x5f, 0x5d,
	0x7b, 0xe2, 0x25, 0x1d, 0xdd, 0x88, 0xd2, 0x21, 0x8b, 0x37, 0xeb, 0x15, 0xf7, 0x79, 0x6b, 0xff,
	0xe6, 0xd6, 0x7e, 0x1a, 0xa3, 0x03, 0x59, 0x1e, 0x3e, 0x6f, 0xeb, 0x9f, 0x6f, 0xab, 0x64, 0xff,
	0xc5, 0xcf, 0xd7, 0xbe, 0x9f, 0xa9, 0xbd, 0xb3, 0xba, 0x70, 0x83, 0x1e, 0xdd, 0x27, 0x2f, 0xa9,
	0x9f, 0xf6, 0x5c, 0x2f, 0x6a, 0xd6, 0x1c, 0x44, 0x24, 0x4a, 0x7b, 0xf5, 0x0e, 0x26, 0x88, 0x6d,
	0x87, 0x39, 0x45, 0x1b, 0xa2, 0x88, 0x8d, 0x82, 0xa3, 0x67, 0xe6, 0x20, 0x8e, 0xb8, 0x68, 0xaa,
	0xcc, 0xd1, 0xa0, 0x27, 0x11, 0xbf, 0x77, 0x97, 0x44, 0x2e, 0x7c, 0xd7, 0x4b, 0xcf, 0x1c, 0x34,
	0x22, 0xa9, 0x87, 0x12, 0x07, 0x22, 0x78, 0x30, 0x20, 0x52, 0x2f, 0x8d, 0x1a, 0x28, 0xda, 0x4b,
	0xa3, 0x79, 0x15, 0x62, 0xe2, 0xcc, 0x40, 0x1c, 0xf3, 0x50, 0x0c, 0x96, 0xd7, 0xa0, 0x47, 0x3a,
	0x44, 0x63, 0x76, 0x81, 0x41, 0xaf, 0xb0, 0x4d, 0xc3, 0x21, 0x71, 0x66, 0xa1, 0x4f, 0x9c, 0x16,
	0xf4, 0x4b, 0x7d, 0x34, 0x6e, 0x14, 0x73, 0x39, 0xa0, 0x48, 0xbd, 0x39, 0x6b, 0xc3, 0x00, 0x02,
	0xd3, 0xb1, 0xe0, 0x30, 0xea, 0xcc, 0xe8, 0x46, 0xa6, 0x00, 0xff, 0x41, 0x98, 0x17, 0x70, 0x50,
	0x78, 0x96, 0x60, 0x08, 0x69, 0x4e, 0xc9, 0x01, 0xc0, 0x0b, 0xcb, 0x84, 0x23, 0xc8, 0x61, 0x19,
	0x5b, 0x9d, 0x06, 0x09, 0x6d, 0xa5, 0x89, 0x4b, 0x70, 0x14, 0xe5, 0x75, 0x5b, 0x35, 0xe0, 0x98,
	0x60, 0x39, 0x70, 0x5c, 0x04, 0xb4, 0x99, 0x09, 0x27, 0xa4, 0xc3, 0xb4, 0x0f, 0x51, 0x19, 0x83,
	0x9d, 0x14, 0x99, 0xea, 0x59, 0x18, 0x46, 0x30, 0xab, 0xcd, 0xc1, 0x29, 0xf4, 0x30, 0x4b, 0x90,
	0x40, 0x8f, 0xac, 0x59, 0xb0, 0xe1, 0x34, 0x22, 0xc6, 0x18, 0x83, 0x33, 0x48, 0xca, 0x15, 0x14,
	0xf8, 0x2f, 0x02, 0xa3, 0xe4, 0x80, 0x8c, 0x40, 0xd3, 0x55, 0x18, 0x11, 0x2d, 0xd6, 0xf3, 0x68,
	0x4d, 0x0a, 0x51, 0xeb, 0x06, 0xfc, 0x4f, 0x78, 0x3a, 0x79, 0x06, 0xa3, 0x98, 0xa5, 0xc1, 0x30,
	0xe4, 0x59, 0x0c, 0x30, 0x5b, 0x82, 0x73, 0x68, 0x54, 0x34, 0xcb, 0x81, 0xff, 0xe3, 0x0d, 0xbb,
	0x0c, 0x2f, 0x20, 0x49, 0x15, 0x1d, 0x3c, 0x8f, 0x46, 0x5b, 0x37, 0x66, 0x61, 0x0c, 0xc5, 0x0a,
	0xa6, 0x03, 0x2f, 0x22, 0x60, 0x66, 0x0e, 0x2e, 0x20, 0x5d, 0xb5, 0xe1, 0x25, 0xa4, 0xdb, 0xf6,
	0x4c, 0xc6, 0x84, 0x97, 0xb1, 0x28, 0xdd, 0xb4, 0x35, 0x05, 0x4b, 0x18, 0x47, 0x83, 0x65, 0x61,
	0x59, 0xa9, 0x4e, 0xdd, 0x9a, 0x02, 0x69, 0x4c, 0x50, 0x35, 0x6c, 0x24, 0xbc, 0x22, 0x02, 0xcd,
	0x28, 0xba, 0x0a, 0x17, 0x45, 0x62, 0xb6, 0xa6, 0x4c, 0xc2, 0x84, 0x34, 0x48, 0xa9, 0x80, 0x26,
	0xb3, 0x58, 0x1e, 0x26, 0xd1, 0xd7, 0xc9, 0xd9, 0x0c, 0xa6, 0xc4, 0x2e, 0xe5, 0xf5, 0xbc, 0xc6,
	0xe0, 0x12, 0xa6, 0x31, 0xa3, 0x9b, 0xf0, 0xaa, 0xf0, 0x14, 0xc3, 0xb9, 0x82, 0x4c, 0x0b, 0x95,
	0x5f, 0x43, 0xa6, 0xc3, 0x72, 0x98, 0xf9, 0x55, 0x64, 0x2a, 0xaa, 0x0d, 0xaf, 0x4b, 0x03, 0xf4,
	0x90, 0xd2, 0x8d, 0xfd, 0x06, 0x46, 0x29, 0x98, 0x9a, 0x61, 0x66, 0x4d, 0x7c, 0x7e, 0x53, 0xac,
	0x8d, 0x3d, 0x67, 0x28, 0x70, 0x4d, 0xf4, 0xcd, 0xcc, 0x80, 0x8b, 0x77, 0x45, 0x21, 0x5d, 0xc5,
	0xbb, 0xa2, 0xae, 0x02, 0x47, 0x90, 0xd5, 0x55, 0x58, 0x10, 0x0b, 0x6c, 0xd8, 0xa6, 0xa6, 0x40,
	0x4d, 0xcc, 0x41, 0x57, 0x61, 0x51, 0x4c, 0x66, 0x72, 0x02, 0x3c, 0x01, 0x2e, 0x4f, 0xc1, 0x2d,
	0xec, 0x52, 0xce, 0x84, 0x25, 0xd4, 0xd2, 0x8a, 0xfa, 0xd4, 0x15, 0xa8, 0x77, 0xe1, 0xe5, 0x29,
	0x68, 0x48, 0xfd, 0x34, 0xee, 0x60, 0xfc, 0x1f, 0x89, 0x80, 0xd8, 0xac, 0x9f, 0x04, 0xd4, 0x4b,
	0x19, 0x0b, 0x7e, 0x16, 0x90, 0x21, 0xfc, 0x05, 0xdf, 0xa4, 0x9e, 0x3c, 0xd3, 0x73, 0xd3, 0xf0,
	0xeb, 0x36, 0x66, 0xf0, 0x1b, 0x91, 0xfa, 0x68, 0xac, 0x68, 0xe9, 0xb0, 0x1e, 0x45, 0xa4, 0x30,
	0x06, 0x77, 0x10, 0x45, 0x1d, 0x06, 0xeb, 0xeb, 0x51, 0xa9, 0x9f, 0xc6, 0xd4, 0xdc, 0x0d, 0xb8,
	0xb3, 0x1e, 0xed, 0xbc, 0x66, 0xd3, 0x1f, 0x91, 0xfb, 0x0f, 0xe4, 0xc8, 0xc6, 0x03, 0x39, 0xf2,
	0xf0, 0x81, 0x4c, 0xd6, 0xdb, 0x32, 0xf9, 0xa4, 0x2d, 0x93, 0x2f, 0xdb, 0x32, 0xb9, 0xdf, 0x96,
	0xc9, 0x46, 0x5b, 0x26, 0xdf, 0xb6, 0x65, 0xf2, 0x7d, 0x5b, 0x8e, 0x3c, 0x6c, 0xcb, 0xe4, 0xfd,
	0x4d, 0x39, 0x72, 0x6f, 0x53, 0x26, 0xf7, 0x37, 0xe5, 0xc8, 0xc6, 0xa6, 0x1c, 0x79, 0x6b, 0xae,
	0xe6, 0x37, 0x97, 0x6a, 0xa9, 0x55, 0xbf, 0x1e, 0xf2, 0x20, 0xa8, 0xa4, 0x56, 0x5a, 0x69, 0x01,
	0x16, 0xfc, 0xa0, 0x31, 0xde, 0x0c, 0xfc, 0x55, 0xaf, 0xca, 0x83, 0xf1, 0x2d, 0x73, 0xba, 0x39,
	0x5f, 0xf3, 0xd3, 0xfc, 0x9d, 0xb0, 0xfb, 0x63, 0xf8, 0xa0, 0x7f, 0x0c, 0xf3, 0xbd, 0xe2, 0xfb,
	0x33, 0xf9, 0x7b, 0x00, 0x00, 0x00, 0xff, 0xff, 0x29, 0x2c, 0xba, 0xd6, 0x5f, 0x0c, 0x00, 0x00,
}

func (x DisallowedQueryType) String() string {
	s, ok := DisallowedQueryType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DisallowedResourceRecordType) String() string {
	s, ok := DisallowedResourceRecordType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DisallowedResourceRecordTypeList) != len(that1.DisallowedResourceRecordTypeList) {
		return false
	}
	for i := range this.DisallowedResourceRecordTypeList {
		if this.DisallowedResourceRecordTypeList[i] != that1.DisallowedResourceRecordTypeList[i] {
			return false
		}
	}
	if len(this.DomainDenylist) != len(that1.DomainDenylist) {
		return false
	}
	for i := range this.DomainDenylist {
		if this.DomainDenylist[i] != that1.DomainDenylist[i] {
			return false
		}
	}
	if len(this.DisallowedQueryTypeList) != len(that1.DisallowedQueryTypeList) {
		return false
	}
	for i := range this.DisallowedQueryTypeList {
		if this.DisallowedQueryTypeList[i] != that1.DisallowedQueryTypeList[i] {
			return false
		}
	}
	if len(this.ProtocolInspection) != len(that1.ProtocolInspection) {
		return false
	}
	for i := range this.ProtocolInspection {
		if !this.ProtocolInspection[i].Equal(that1.ProtocolInspection[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DisallowedResourceRecordTypeList) != len(that1.DisallowedResourceRecordTypeList) {
		return false
	}
	for i := range this.DisallowedResourceRecordTypeList {
		if this.DisallowedResourceRecordTypeList[i] != that1.DisallowedResourceRecordTypeList[i] {
			return false
		}
	}
	if len(this.DomainDenylist) != len(that1.DomainDenylist) {
		return false
	}
	for i := range this.DomainDenylist {
		if this.DomainDenylist[i] != that1.DomainDenylist[i] {
			return false
		}
	}
	if len(this.DisallowedQueryTypeList) != len(that1.DisallowedQueryTypeList) {
		return false
	}
	for i := range this.DisallowedQueryTypeList {
		if this.DisallowedQueryTypeList[i] != that1.DisallowedQueryTypeList[i] {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DisallowedResourceRecordTypeList) != len(that1.DisallowedResourceRecordTypeList) {
		return false
	}
	for i := range this.DisallowedResourceRecordTypeList {
		if this.DisallowedResourceRecordTypeList[i] != that1.DisallowedResourceRecordTypeList[i] {
			return false
		}
	}
	if len(this.DomainDenylist) != len(that1.DomainDenylist) {
		return false
	}
	for i := range this.DomainDenylist {
		if this.DomainDenylist[i] != that1.DomainDenylist[i] {
			return false
		}
	}
	if len(this.DisallowedQueryTypeList) != len(that1.DisallowedQueryTypeList) {
		return false
	}
	for i := range this.DisallowedQueryTypeList {
		if this.DisallowedQueryTypeList[i] != that1.DisallowedQueryTypeList[i] {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DisallowedResourceRecordTypeList) != len(that1.DisallowedResourceRecordTypeList) {
		return false
	}
	for i := range this.DisallowedResourceRecordTypeList {
		if this.DisallowedResourceRecordTypeList[i] != that1.DisallowedResourceRecordTypeList[i] {
			return false
		}
	}
	if len(this.DomainDenylist) != len(that1.DomainDenylist) {
		return false
	}
	for i := range this.DomainDenylist {
		if this.DomainDenylist[i] != that1.DomainDenylist[i] {
			return false
		}
	}
	if len(this.DisallowedQueryTypeList) != len(that1.DisallowedQueryTypeList) {
		return false
	}
	for i := range this.DisallowedQueryTypeList {
		if this.DisallowedQueryTypeList[i] != that1.DisallowedQueryTypeList[i] {
			return false
		}
	}
	if len(this.ProtocolInspection) != len(that1.ProtocolInspection) {
		return false
	}
	for i := range this.ProtocolInspection {
		if !this.ProtocolInspection[i].Equal(that1.ProtocolInspection[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dns_compliance_checks.GlobalSpecType{")
	s = append(s, "DisallowedResourceRecordTypeList: "+fmt.Sprintf("%#v", this.DisallowedResourceRecordTypeList)+",\n")
	s = append(s, "DomainDenylist: "+fmt.Sprintf("%#v", this.DomainDenylist)+",\n")
	s = append(s, "DisallowedQueryTypeList: "+fmt.Sprintf("%#v", this.DisallowedQueryTypeList)+",\n")
	if this.ProtocolInspection != nil {
		s = append(s, "ProtocolInspection: "+fmt.Sprintf("%#v", this.ProtocolInspection)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dns_compliance_checks.CreateSpecType{")
	s = append(s, "DisallowedResourceRecordTypeList: "+fmt.Sprintf("%#v", this.DisallowedResourceRecordTypeList)+",\n")
	s = append(s, "DomainDenylist: "+fmt.Sprintf("%#v", this.DomainDenylist)+",\n")
	s = append(s, "DisallowedQueryTypeList: "+fmt.Sprintf("%#v", this.DisallowedQueryTypeList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dns_compliance_checks.ReplaceSpecType{")
	s = append(s, "DisallowedResourceRecordTypeList: "+fmt.Sprintf("%#v", this.DisallowedResourceRecordTypeList)+",\n")
	s = append(s, "DomainDenylist: "+fmt.Sprintf("%#v", this.DomainDenylist)+",\n")
	s = append(s, "DisallowedQueryTypeList: "+fmt.Sprintf("%#v", this.DisallowedQueryTypeList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dns_compliance_checks.GetSpecType{")
	s = append(s, "DisallowedResourceRecordTypeList: "+fmt.Sprintf("%#v", this.DisallowedResourceRecordTypeList)+",\n")
	s = append(s, "DomainDenylist: "+fmt.Sprintf("%#v", this.DomainDenylist)+",\n")
	s = append(s, "DisallowedQueryTypeList: "+fmt.Sprintf("%#v", this.DisallowedQueryTypeList)+",\n")
	if this.ProtocolInspection != nil {
		s = append(s, "ProtocolInspection: "+fmt.Sprintf("%#v", this.ProtocolInspection)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProtocolInspection) > 0 {
		for iNdEx := len(m.ProtocolInspection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProtocolInspection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DisallowedQueryTypeList) > 0 {
		dAtA2 := make([]byte, len(m.DisallowedQueryTypeList)*10)
		var j1 int
		for _, num := range m.DisallowedQueryTypeList {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DomainDenylist) > 0 {
		for iNdEx := len(m.DomainDenylist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DomainDenylist[iNdEx])
			copy(dAtA[i:], m.DomainDenylist[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainDenylist[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DisallowedResourceRecordTypeList) > 0 {
		dAtA4 := make([]byte, len(m.DisallowedResourceRecordTypeList)*10)
		var j3 int
		for _, num := range m.DisallowedResourceRecordTypeList {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisallowedQueryTypeList) > 0 {
		dAtA6 := make([]byte, len(m.DisallowedQueryTypeList)*10)
		var j5 int
		for _, num := range m.DisallowedQueryTypeList {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTypes(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DomainDenylist) > 0 {
		for iNdEx := len(m.DomainDenylist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DomainDenylist[iNdEx])
			copy(dAtA[i:], m.DomainDenylist[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainDenylist[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DisallowedResourceRecordTypeList) > 0 {
		dAtA8 := make([]byte, len(m.DisallowedResourceRecordTypeList)*10)
		var j7 int
		for _, num := range m.DisallowedResourceRecordTypeList {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintTypes(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisallowedQueryTypeList) > 0 {
		dAtA10 := make([]byte, len(m.DisallowedQueryTypeList)*10)
		var j9 int
		for _, num := range m.DisallowedQueryTypeList {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintTypes(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DomainDenylist) > 0 {
		for iNdEx := len(m.DomainDenylist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DomainDenylist[iNdEx])
			copy(dAtA[i:], m.DomainDenylist[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainDenylist[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DisallowedResourceRecordTypeList) > 0 {
		dAtA12 := make([]byte, len(m.DisallowedResourceRecordTypeList)*10)
		var j11 int
		for _, num := range m.DisallowedResourceRecordTypeList {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintTypes(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProtocolInspection) > 0 {
		for iNdEx := len(m.ProtocolInspection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProtocolInspection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DisallowedQueryTypeList) > 0 {
		dAtA14 := make([]byte, len(m.DisallowedQueryTypeList)*10)
		var j13 int
		for _, num := range m.DisallowedQueryTypeList {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintTypes(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DomainDenylist) > 0 {
		for iNdEx := len(m.DomainDenylist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DomainDenylist[iNdEx])
			copy(dAtA[i:], m.DomainDenylist[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainDenylist[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DisallowedResourceRecordTypeList) > 0 {
		dAtA16 := make([]byte, len(m.DisallowedResourceRecordTypeList)*10)
		var j15 int
		for _, num := range m.DisallowedResourceRecordTypeList {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintTypes(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DisallowedResourceRecordTypeList) > 0 {
		l = 0
		for _, e := range m.DisallowedResourceRecordTypeList {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.DomainDenylist) > 0 {
		for _, s := range m.DomainDenylist {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DisallowedQueryTypeList) > 0 {
		l = 0
		for _, e := range m.DisallowedQueryTypeList {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.ProtocolInspection) > 0 {
		for _, e := range m.ProtocolInspection {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DisallowedResourceRecordTypeList) > 0 {
		l = 0
		for _, e := range m.DisallowedResourceRecordTypeList {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.DomainDenylist) > 0 {
		for _, s := range m.DomainDenylist {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DisallowedQueryTypeList) > 0 {
		l = 0
		for _, e := range m.DisallowedQueryTypeList {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DisallowedResourceRecordTypeList) > 0 {
		l = 0
		for _, e := range m.DisallowedResourceRecordTypeList {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.DomainDenylist) > 0 {
		for _, s := range m.DomainDenylist {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DisallowedQueryTypeList) > 0 {
		l = 0
		for _, e := range m.DisallowedQueryTypeList {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DisallowedResourceRecordTypeList) > 0 {
		l = 0
		for _, e := range m.DisallowedResourceRecordTypeList {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.DomainDenylist) > 0 {
		for _, s := range m.DomainDenylist {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DisallowedQueryTypeList) > 0 {
		l = 0
		for _, e := range m.DisallowedQueryTypeList {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.ProtocolInspection) > 0 {
		for _, e := range m.ProtocolInspection {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForProtocolInspection := "[]*ObjectRefType{"
	for _, f := range this.ProtocolInspection {
		repeatedStringForProtocolInspection += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForProtocolInspection += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`DisallowedResourceRecordTypeList:` + fmt.Sprintf("%v", this.DisallowedResourceRecordTypeList) + `,`,
		`DomainDenylist:` + fmt.Sprintf("%v", this.DomainDenylist) + `,`,
		`DisallowedQueryTypeList:` + fmt.Sprintf("%v", this.DisallowedQueryTypeList) + `,`,
		`ProtocolInspection:` + repeatedStringForProtocolInspection + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`DisallowedResourceRecordTypeList:` + fmt.Sprintf("%v", this.DisallowedResourceRecordTypeList) + `,`,
		`DomainDenylist:` + fmt.Sprintf("%v", this.DomainDenylist) + `,`,
		`DisallowedQueryTypeList:` + fmt.Sprintf("%v", this.DisallowedQueryTypeList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`DisallowedResourceRecordTypeList:` + fmt.Sprintf("%v", this.DisallowedResourceRecordTypeList) + `,`,
		`DomainDenylist:` + fmt.Sprintf("%v", this.DomainDenylist) + `,`,
		`DisallowedQueryTypeList:` + fmt.Sprintf("%v", this.DisallowedQueryTypeList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForProtocolInspection := "[]*ObjectRefType{"
	for _, f := range this.ProtocolInspection {
		repeatedStringForProtocolInspection += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForProtocolInspection += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`DisallowedResourceRecordTypeList:` + fmt.Sprintf("%v", this.DisallowedResourceRecordTypeList) + `,`,
		`DomainDenylist:` + fmt.Sprintf("%v", this.DomainDenylist) + `,`,
		`DisallowedQueryTypeList:` + fmt.Sprintf("%v", this.DisallowedQueryTypeList) + `,`,
		`ProtocolInspection:` + repeatedStringForProtocolInspection + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v DisallowedResourceRecordType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DisallowedResourceRecordType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DisallowedResourceRecordTypeList = append(m.DisallowedResourceRecordTypeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DisallowedResourceRecordTypeList) == 0 {
					m.DisallowedResourceRecordTypeList = make([]DisallowedResourceRecordType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DisallowedResourceRecordType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DisallowedResourceRecordType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DisallowedResourceRecordTypeList = append(m.DisallowedResourceRecordTypeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowedResourceRecordTypeList", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainDenylist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainDenylist = append(m.DomainDenylist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v DisallowedQueryType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DisallowedQueryType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DisallowedQueryTypeList = append(m.DisallowedQueryTypeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DisallowedQueryTypeList) == 0 {
					m.DisallowedQueryTypeList = make([]DisallowedQueryType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DisallowedQueryType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DisallowedQueryType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DisallowedQueryTypeList = append(m.DisallowedQueryTypeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowedQueryTypeList", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolInspection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolInspection = append(m.ProtocolInspection, &views.ObjectRefType{})
			if err := m.ProtocolInspection[len(m.ProtocolInspection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v DisallowedResourceRecordType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DisallowedResourceRecordType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DisallowedResourceRecordTypeList = append(m.DisallowedResourceRecordTypeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DisallowedResourceRecordTypeList) == 0 {
					m.DisallowedResourceRecordTypeList = make([]DisallowedResourceRecordType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DisallowedResourceRecordType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DisallowedResourceRecordType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DisallowedResourceRecordTypeList = append(m.DisallowedResourceRecordTypeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowedResourceRecordTypeList", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainDenylist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainDenylist = append(m.DomainDenylist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v DisallowedQueryType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DisallowedQueryType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DisallowedQueryTypeList = append(m.DisallowedQueryTypeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DisallowedQueryTypeList) == 0 {
					m.DisallowedQueryTypeList = make([]DisallowedQueryType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DisallowedQueryType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DisallowedQueryType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DisallowedQueryTypeList = append(m.DisallowedQueryTypeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowedQueryTypeList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v DisallowedResourceRecordType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DisallowedResourceRecordType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DisallowedResourceRecordTypeList = append(m.DisallowedResourceRecordTypeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DisallowedResourceRecordTypeList) == 0 {
					m.DisallowedResourceRecordTypeList = make([]DisallowedResourceRecordType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DisallowedResourceRecordType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DisallowedResourceRecordType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DisallowedResourceRecordTypeList = append(m.DisallowedResourceRecordTypeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowedResourceRecordTypeList", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainDenylist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainDenylist = append(m.DomainDenylist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v DisallowedQueryType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DisallowedQueryType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DisallowedQueryTypeList = append(m.DisallowedQueryTypeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DisallowedQueryTypeList) == 0 {
					m.DisallowedQueryTypeList = make([]DisallowedQueryType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DisallowedQueryType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DisallowedQueryType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DisallowedQueryTypeList = append(m.DisallowedQueryTypeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowedQueryTypeList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v DisallowedResourceRecordType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DisallowedResourceRecordType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DisallowedResourceRecordTypeList = append(m.DisallowedResourceRecordTypeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DisallowedResourceRecordTypeList) == 0 {
					m.DisallowedResourceRecordTypeList = make([]DisallowedResourceRecordType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DisallowedResourceRecordType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DisallowedResourceRecordType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DisallowedResourceRecordTypeList = append(m.DisallowedResourceRecordTypeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowedResourceRecordTypeList", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainDenylist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainDenylist = append(m.DomainDenylist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v DisallowedQueryType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DisallowedQueryType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DisallowedQueryTypeList = append(m.DisallowedQueryTypeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DisallowedQueryTypeList) == 0 {
					m.DisallowedQueryTypeList = make([]DisallowedQueryType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DisallowedQueryType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DisallowedQueryType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DisallowedQueryTypeList = append(m.DisallowedQueryTypeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowedQueryTypeList", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolInspection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolInspection = append(m.ProtocolInspection, &views.ObjectRefType{})
			if err := m.ProtocolInspection[len(m.ProtocolInspection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
