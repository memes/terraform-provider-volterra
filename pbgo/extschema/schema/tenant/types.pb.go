// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/tenant/types.proto

package tenant

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DeletionReason
//
// x-displayName: "DeletionReason"
// List of available reason for account deletion.
type DeletionReason int32

const (
	// Unknown reason
	//
	// x-displayName: "Unknown"
	// Unknown reason
	REASON_UNKNOWN DeletionReason = 0
	// Switch to free plan
	//
	// x-displayName: "Switch to free plan"
	// Switch to free plan
	REASON_SWITCH_TO_FREE_PLAN DeletionReason = 1
	// No longer needed
	//
	// x-displayName: "No longer needed"
	// No longer needed
	REASON_NO_LONGER_NEEDED DeletionReason = 2
	// Too expensive
	//
	// x-displayName: "Too expensive"
	// Too expensive
	REASON_NOT_JUSTIFY_COSTS DeletionReason = 3
	// Difficult to use
	//
	// x-displayName: "Difficult to use"
	// Difficult to use
	REASON_DIFFICULT_TO_USE DeletionReason = 4
)

var DeletionReason_name = map[int32]string{
	0: "REASON_UNKNOWN",
	1: "REASON_SWITCH_TO_FREE_PLAN",
	2: "REASON_NO_LONGER_NEEDED",
	3: "REASON_NOT_JUSTIFY_COSTS",
	4: "REASON_DIFFICULT_TO_USE",
}

var DeletionReason_value = map[string]int32{
	"REASON_UNKNOWN":             0,
	"REASON_SWITCH_TO_FREE_PLAN": 1,
	"REASON_NO_LONGER_NEEDED":    2,
	"REASON_NOT_JUSTIFY_COSTS":   3,
	"REASON_DIFFICULT_TO_USE":    4,
}

func (DeletionReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_de41f8b87043178a, []int{0}
}

// States
//
// x-displayName: "States"
// Tenant states https://gitlab.com/volterra/ves.io/eywa/-/wikis/Tenant-State-Machine.
type FSMState int32

const (
	// StateUndefined
	//
	// x-displayName: "StateUndefined"
	// Tenant state when it was created without any state.
	StateUndefined FSMState = 0
	// StateCreating
	//
	// x-displayName: "StateCreating"
	// Tenant state of initial bootstrapping tenant, registering tenant in other service and
	// pre-create default objects for the tenant like default namespaces, default roles etc.
	StateCreating FSMState = 1
	// StateCreateFailed
	//
	// x-displayName: "StateCreateFailed"
	// Tenant state when initial bootstrapping was failed by some reason and must be retried
	// after issue is solved.
	StateCreateFailed FSMState = 2
	// StateInactive
	//
	// x-displayName: "StateInactive"
	// Tenant state when initial creation is completed and we have trigger next stage of tenant
	// registration like creating support account, billing account in third party services.
	StateInactive FSMState = 3
	// StateActive
	//
	// x-displayName: "StateActive"
	// Tenant state of completely registered tenant and available to use.
	StateActive FSMState = 4
	// StateSuspended
	//
	// x-displayName: "StateSuspended"
	// Tenant state of suspended tenant by some reason like not finished billing payments,
	// manually suspended by administrator, etc.
	StateSuspended FSMState = 5
	// StateDisabled
	//
	// x-displayName: "StateDisabled"
	// Tenant state of disabled tenant which are in pre-deletion state.
	StateDisabled FSMState = 6
	// StateConfiguring
	//
	// x-displayName: "StateConfiguring"
	// Configuring state of the specific tenant, can be set for instance if tenant is setting up billing account, etc..
	StateConfiguring FSMState = 7
	// StateConfiguringFailed
	//
	// x-displayName: "StateConfiguring"
	// Configuring state of the specific tenant, can be set for instance if tenant is setting up billing account, etc..
	StateConfiguringFailed FSMState = 8
)

var FSMState_name = map[int32]string{
	0: "StateUndefined",
	1: "StateCreating",
	2: "StateCreateFailed",
	3: "StateInactive",
	4: "StateActive",
	5: "StateSuspended",
	6: "StateDisabled",
	7: "StateConfiguring",
	8: "StateConfiguringFailed",
}

var FSMState_value = map[string]int32{
	"StateUndefined":         0,
	"StateCreating":          1,
	"StateCreateFailed":      2,
	"StateInactive":          3,
	"StateActive":            4,
	"StateSuspended":         5,
	"StateDisabled":          6,
	"StateConfiguring":       7,
	"StateConfiguringFailed": 8,
}

func (FSMState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_de41f8b87043178a, []int{1}
}

// OtpStatus
//
// x-displayName: "OtpStatus"
// OtpStatus can be either enabled/disabled or processing.
// Applying new policy can take time, especially if tenant has many users so for this purpose processing state is introduced.
type OtpStatus int32

const (
	// OTP_DISABLED
	//
	// x-displayName: "OTP_DISABLED"
	// OTP disabled
	OTP_DISABLED OtpStatus = 0
	// OTP_ENABLED
	//
	// x-displayName: "OTP_ENABLED"
	// OTP enabled
	OTP_ENABLED OtpStatus = 1
	// OTP_PROCESSING
	//
	// x-displayName: "OTP_PROCESSING"
	// OTP is being updated
	OTP_PROCESSING OtpStatus = 2
	// OTP_PROCESSING
	//
	// x-displayName: "OTP_PROCESS_DISABLING"
	// OTP is being updated to be disabled
	OTP_PROCESS_DISABLING OtpStatus = 3
)

var OtpStatus_name = map[int32]string{
	0: "OTP_DISABLED",
	1: "OTP_ENABLED",
	2: "OTP_PROCESSING",
	3: "OTP_PROCESS_DISABLING",
}

var OtpStatus_value = map[string]int32{
	"OTP_DISABLED":          0,
	"OTP_ENABLED":           1,
	"OTP_PROCESSING":        2,
	"OTP_PROCESS_DISABLING": 3,
}

func (OtpStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_de41f8b87043178a, []int{2}
}

// Sub CA Usage
//
// x-displayName: "Sub CA"
// Sub CA information.
type SubCA struct {
	// Name
	//
	// x-displayName: "Name"
	// Name for this CA
	CaName string `protobuf:"bytes,1,opt,name=CaName,proto3" json:"CaName,omitempty"`
	// CA PEM
	//
	// x-displayName: "PEM encoded certificate for"
	// PEM encoded certificate
	SubCAPEM string `protobuf:"bytes,2,opt,name=SubCAPEM,proto3" json:"SubCAPEM,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// Password for CA
	Password *EncryptedPassword `protobuf:"bytes,3,opt,name=Password,proto3" json:"Password,omitempty"`
	// Version
	//
	// x-displayName: "Version"
	// Certificate version
	Version uint32 `protobuf:"varint,4,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *SubCA) Reset()      { *m = SubCA{} }
func (*SubCA) ProtoMessage() {}
func (*SubCA) Descriptor() ([]byte, []int) {
	return fileDescriptor_de41f8b87043178a, []int{0}
}
func (m *SubCA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubCA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubCA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubCA.Merge(m, src)
}
func (m *SubCA) XXX_Size() int {
	return m.Size()
}
func (m *SubCA) XXX_DiscardUnknown() {
	xxx_messageInfo_SubCA.DiscardUnknown(m)
}

var xxx_messageInfo_SubCA proto.InternalMessageInfo

func (m *SubCA) GetCaName() string {
	if m != nil {
		return m.CaName
	}
	return ""
}

func (m *SubCA) GetSubCAPEM() string {
	if m != nil {
		return m.SubCAPEM
	}
	return ""
}

func (m *SubCA) GetPassword() *EncryptedPassword {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *SubCA) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

// CA Usage
//
// x-displayName: "CA"
// CA information.
type CA struct {
	// Name
	//
	// x-displayName: "Name"
	// Name for this CA
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// CA PEM
	//
	// x-displayName: "PEM encoded certificate"
	// PEM encoded certificate
	Pem string `protobuf:"bytes,2,opt,name=pem,proto3" json:"pem,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// Password for CA
	Password *EncryptedPassword `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	// Version
	//
	// x-displayName: "Version"
	// Certificate version
	Version uint32 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *CA) Reset()      { *m = CA{} }
func (*CA) ProtoMessage() {}
func (*CA) Descriptor() ([]byte, []int) {
	return fileDescriptor_de41f8b87043178a, []int{1}
}
func (m *CA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CA.Merge(m, src)
}
func (m *CA) XXX_Size() int {
	return m.Size()
}
func (m *CA) XXX_DiscardUnknown() {
	xxx_messageInfo_CA.DiscardUnknown(m)
}

var xxx_messageInfo_CA proto.InternalMessageInfo

func (m *CA) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CA) GetPem() string {
	if m != nil {
		return m.Pem
	}
	return ""
}

func (m *CA) GetPassword() *EncryptedPassword {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *CA) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

// EncryptedPassword
//
// x-displayName: "EncryptedPassword"
// Encrypted Password type.
type EncryptedPassword struct {
	// Version
	//
	// x-displayName: "Version"
	// Password version
	Version uint32 `protobuf:"varint,1,opt,name=Version,proto3" json:"Version,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// x-required
	// Encrypted Password
	Password string `protobuf:"bytes,2,opt,name=Password,proto3" json:"Password,omitempty"`
}

func (m *EncryptedPassword) Reset()      { *m = EncryptedPassword{} }
func (*EncryptedPassword) ProtoMessage() {}
func (*EncryptedPassword) Descriptor() ([]byte, []int) {
	return fileDescriptor_de41f8b87043178a, []int{2}
}
func (m *EncryptedPassword) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptedPassword) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EncryptedPassword) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptedPassword.Merge(m, src)
}
func (m *EncryptedPassword) XXX_Size() int {
	return m.Size()
}
func (m *EncryptedPassword) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptedPassword.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptedPassword proto.InternalMessageInfo

func (m *EncryptedPassword) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *EncryptedPassword) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// GlobalSpecType
//
// x-displayName: "Global Specification"
// This is the shape of the tenant representation in the database at Global Controller.
type GlobalSpecType struct {
	// public_vip
	//
	// x-displayName: "Dedicated Public VIP"
	// VIP to be used for all listeners for this tenant in public network.
	// x-example: "72.19.3.128"
	PublicVip string `protobuf:"bytes,1,opt,name=public_vip,json=publicVip,proto3" json:"public_vip,omitempty"`
	// Deleted Flag
	//
	// x-displayName: "Deleted"
	// Represents tenant object of deletion state.
	Deleted bool `protobuf:"varint,2,opt,name=deleted,proto3" json:"deleted,omitempty"`
	// TGW ASN Offset
	//
	// x-displayName: "TGW ASN Offset"
	// x-example: 4293918720
	// Starting ASN for automatic allocation of ASNs for AWS TGW.
	TgwAsnOffset uint32 `protobuf:"varint,3,opt,name=tgw_asn_offset,json=tgwAsnOffset,proto3" json:"tgw_asn_offset,omitempty"`
	// Direct Connect GW ASN Offset
	//
	// x-displayName: "Direct Connect GW ASN Offset"
	// x-example: 4293918720
	// Starting ASN for automatic allocation of ASNs for AWS Direct Connect GW.
	DirectConnectAsnOffset uint32 `protobuf:"varint,15,opt,name=direct_connect_asn_offset,json=directConnectAsnOffset,proto3" json:"direct_connect_asn_offset,omitempty"`
	// Shared Public VIP
	//
	// this is a ref to a shared public ip object
	// this will be used for all of this tenant's VHs in public if dedicated public vip is not set
	// x-displayName: "Shared Public VIP"
	SharedPublicVip []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=shared_public_vip,json=sharedPublicVip,proto3" json:"shared_public_vip,omitempty"`
	// K8S Server Sub CAs
	//
	// Array of SubCAs, the latest one will be used for minting k8s server cert for tenant
	// x-displayName: "K8S Server Sub CAs"
	K8SServerSubCas []*SubCA `protobuf:"bytes,5,rep,name=k8s_server_sub_cas,json=k8sServerSubCas,proto3" json:"k8s_server_sub_cas,omitempty"`
	// K8S Server Sub CA Version
	//
	// SubCA version which is the latest and will be used for k8s server cert for tenant
	// x-displayName: "K8S Server Sub CA Version"
	K8SServerSubCaLatestVersion uint32 `protobuf:"varint,6,opt,name=k8s_server_sub_ca_latest_version,json=k8sServerSubCaLatestVersion,proto3" json:"k8s_server_sub_ca_latest_version,omitempty"`
	// Proxy Root CAs
	//
	// Array of CAas, the latest one will be used for proxy feature.
	// x-displayName: "Proxy Root CAs"
	ProxyRootCas []*CA `protobuf:"bytes,7,rep,name=proxy_root_cas,json=proxyRootCas,proto3" json:"proxy_root_cas,omitempty"`
	// Proxy Root CA version
	//
	// CA version which is the latest and will be used for proxy feature.
	// x-displayName: "Proxy Root CA version"
	ProxyRootCaLatestVersion uint32 `protobuf:"varint,8,opt,name=proxy_root_ca_latest_version,json=proxyRootCaLatestVersion,proto3" json:"proxy_root_ca_latest_version,omitempty"`
	// Default disable advertisement on public
	//
	// Disable advertisement on public by default if true.
	// x-displayName: "Default disable advertisement on public"
	DefaultDisablePublicAp bool `protobuf:"varint,9,opt,name=default_disable_public_ap,json=defaultDisablePublicAp,proto3" json:"default_disable_public_ap,omitempty"`
	// Use Global Ain Vrf
	//
	// Flag to indicate that all CEs belonging to the tenant are
	// upgraded to use Global RE Ain Vrf to reach RE so that RE
	// can export AIN routes only to Global Ain Vrf without exporting
	// to tenant specific Ain Vrf
	//
	// All new tenants should have this flag set
	// x-displayName: "Use Global Ain Vrf"
	UseGlobalAinVrf bool `protobuf:"varint,10,opt,name=use_global_ain_vrf,json=useGlobalAinVrf,proto3" json:"use_global_ain_vrf,omitempty"`
	// Shared Shape Instance API auth key
	//
	// x-displayName: "API auth key"
	// x-example: "iL48DRzej6_UX1cOypny7NmtnJVBL9iSuT-0ImUsKlU"
	// API Auth Key for Shared Shape Bot Defense. This value is
	// set when tenant is created and comes from Shape IBD backend
	ShapeSharedInstanceAuthKey *schema.SecretType `protobuf:"bytes,11,opt,name=shape_shared_instance_auth_key,json=shapeSharedInstanceAuthKey,proto3" json:"shape_shared_instance_auth_key,omitempty"`
	// Company Name
	//
	// x-displayName: "Company Name"
	// Name of the company the tenant represents.
	// This is an optional value and mostly set for enterprise tenants - tenants with non volterra-xxx tenant ids
	CompanyName string `protobuf:"bytes,12,opt,name=company_name,json=companyName,proto3" json:"company_name,omitempty"`
	// Tenant FQDN
	//
	// x-displayName: "Tenant FQDN"
	// x-example: "abc.console.ves.volterra.io"
	// Tenant's fully qualified domain name for external access via Volterra's global controller.
	// Freemium tenant will have common access domain for eg: console.ves.volterra.io and in case of enterprise tenant,
	// it will include domain name tenant admin chose as cname for specific tenant access; for eg: abc.console.ves.volterra.io
	TenantFqdn string `protobuf:"bytes,13,opt,name=tenant_fqdn,json=tenantFqdn,proto3" json:"tenant_fqdn,omitempty"`
	// Addon Services Subscribed
	//
	// x-displayName: "Addon Services Subscribed"
	// x-example: "shape-bot"
	// List of addon service names currently subscribed by the tenant.
	AddonServicesSubscribed []string `protobuf:"bytes,14,rep,name=addon_services_subscribed,json=addonServicesSubscribed,proto3" json:"addon_services_subscribed,omitempty"`
	// Tenant Type
	//
	// x-displayName: "Tenant Type"
	// Type of the tenant (FREEMIUM, ENTERPRISE)
	// Freemium type includes Free or individual account signups and
	// Enterprise type includes all tenants signed up for a team account with a team plan or organizational plan
	TenantType schema.TenantType `protobuf:"varint,16,opt,name=tenant_type,json=tenantType,proto3,enum=ves.io.schema.TenantType" json:"tenant_type,omitempty"`
	// Plan type
	//
	// x-displayName: "Plan Type"
	// Type of the billing plan the tenant is subscribed to. Value can be one of FREE, INDIVIDUAL, TEAM, ORGANIZATION.
	PlanType schema.PlanType `protobuf:"varint,17,opt,name=plan_type,json=planType,proto3,enum=ves.io.schema.PlanType" json:"plan_type,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_de41f8b87043178a, []int{3}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetPublicVip() string {
	if m != nil {
		return m.PublicVip
	}
	return ""
}

func (m *GlobalSpecType) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *GlobalSpecType) GetTgwAsnOffset() uint32 {
	if m != nil {
		return m.TgwAsnOffset
	}
	return 0
}

func (m *GlobalSpecType) GetDirectConnectAsnOffset() uint32 {
	if m != nil {
		return m.DirectConnectAsnOffset
	}
	return 0
}

func (m *GlobalSpecType) GetSharedPublicVip() []*schema.ObjectRefType {
	if m != nil {
		return m.SharedPublicVip
	}
	return nil
}

func (m *GlobalSpecType) GetK8SServerSubCas() []*SubCA {
	if m != nil {
		return m.K8SServerSubCas
	}
	return nil
}

func (m *GlobalSpecType) GetK8SServerSubCaLatestVersion() uint32 {
	if m != nil {
		return m.K8SServerSubCaLatestVersion
	}
	return 0
}

func (m *GlobalSpecType) GetProxyRootCas() []*CA {
	if m != nil {
		return m.ProxyRootCas
	}
	return nil
}

func (m *GlobalSpecType) GetProxyRootCaLatestVersion() uint32 {
	if m != nil {
		return m.ProxyRootCaLatestVersion
	}
	return 0
}

func (m *GlobalSpecType) GetDefaultDisablePublicAp() bool {
	if m != nil {
		return m.DefaultDisablePublicAp
	}
	return false
}

func (m *GlobalSpecType) GetUseGlobalAinVrf() bool {
	if m != nil {
		return m.UseGlobalAinVrf
	}
	return false
}

func (m *GlobalSpecType) GetShapeSharedInstanceAuthKey() *schema.SecretType {
	if m != nil {
		return m.ShapeSharedInstanceAuthKey
	}
	return nil
}

func (m *GlobalSpecType) GetCompanyName() string {
	if m != nil {
		return m.CompanyName
	}
	return ""
}

func (m *GlobalSpecType) GetTenantFqdn() string {
	if m != nil {
		return m.TenantFqdn
	}
	return ""
}

func (m *GlobalSpecType) GetAddonServicesSubscribed() []string {
	if m != nil {
		return m.AddonServicesSubscribed
	}
	return nil
}

func (m *GlobalSpecType) GetTenantType() schema.TenantType {
	if m != nil {
		return m.TenantType
	}
	return schema.UNKNOWN
}

func (m *GlobalSpecType) GetPlanType() schema.PlanType {
	if m != nil {
		return m.PlanType
	}
	return schema.FREE
}

// CredentialsExpiry
//
// x-displayName: "CredentialsExpiry"
// CredentialsExpiry is a struct that holds max expiration days setting for the different credentials.
type CredentialsExpiry struct {
	// Certificate expiry period
	//
	// x-displayName: "Certificate expiry period"
	// x-example: "90"
	// Certificate expiry period as days
	MaxApiCertificateExpiryDays int32 `protobuf:"varint,1,opt,name=max_api_certificate_expiry_days,json=maxApiCertificateExpiryDays,proto3" json:"max_api_certificate_expiry_days,omitempty"`
	// Token expiry period
	//
	// x-displayName: "Token expiry period"
	// x-example: "90"
	// Token expiry period as days
	MaxApiTokenExpiryDays int32 `protobuf:"varint,2,opt,name=max_api_token_expiry_days,json=maxApiTokenExpiryDays,proto3" json:"max_api_token_expiry_days,omitempty"`
	// Kubeconfig expiry period
	//
	// x-displayName: "Kubeconfig expiry period"
	// x-example: "90"
	// TokeKubeconfign expiry period as days
	MaxKubeConfigExpiryDays int32 `protobuf:"varint,3,opt,name=max_kube_config_expiry_days,json=maxKubeConfigExpiryDays,proto3" json:"max_kube_config_expiry_days,omitempty"`
}

func (m *CredentialsExpiry) Reset()      { *m = CredentialsExpiry{} }
func (*CredentialsExpiry) ProtoMessage() {}
func (*CredentialsExpiry) Descriptor() ([]byte, []int) {
	return fileDescriptor_de41f8b87043178a, []int{4}
}
func (m *CredentialsExpiry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialsExpiry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CredentialsExpiry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialsExpiry.Merge(m, src)
}
func (m *CredentialsExpiry) XXX_Size() int {
	return m.Size()
}
func (m *CredentialsExpiry) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialsExpiry.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialsExpiry proto.InternalMessageInfo

func (m *CredentialsExpiry) GetMaxApiCertificateExpiryDays() int32 {
	if m != nil {
		return m.MaxApiCertificateExpiryDays
	}
	return 0
}

func (m *CredentialsExpiry) GetMaxApiTokenExpiryDays() int32 {
	if m != nil {
		return m.MaxApiTokenExpiryDays
	}
	return 0
}

func (m *CredentialsExpiry) GetMaxKubeConfigExpiryDays() int32 {
	if m != nil {
		return m.MaxKubeConfigExpiryDays
	}
	return 0
}

// Empty
//
// x-displayName: "Empty"
// This can be used for messages where no values are needed
type Empty struct {
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_de41f8b87043178a, []int{5}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("ves.io.schema.tenant.DeletionReason", DeletionReason_name, DeletionReason_value)
	golang_proto.RegisterEnum("ves.io.schema.tenant.DeletionReason", DeletionReason_name, DeletionReason_value)
	proto.RegisterEnum("ves.io.schema.tenant.FSMState", FSMState_name, FSMState_value)
	golang_proto.RegisterEnum("ves.io.schema.tenant.FSMState", FSMState_name, FSMState_value)
	proto.RegisterEnum("ves.io.schema.tenant.OtpStatus", OtpStatus_name, OtpStatus_value)
	golang_proto.RegisterEnum("ves.io.schema.tenant.OtpStatus", OtpStatus_name, OtpStatus_value)
	proto.RegisterType((*SubCA)(nil), "ves.io.schema.tenant.SubCA")
	golang_proto.RegisterType((*SubCA)(nil), "ves.io.schema.tenant.SubCA")
	proto.RegisterType((*CA)(nil), "ves.io.schema.tenant.CA")
	golang_proto.RegisterType((*CA)(nil), "ves.io.schema.tenant.CA")
	proto.RegisterType((*EncryptedPassword)(nil), "ves.io.schema.tenant.EncryptedPassword")
	golang_proto.RegisterType((*EncryptedPassword)(nil), "ves.io.schema.tenant.EncryptedPassword")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.tenant.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.tenant.GlobalSpecType")
	proto.RegisterType((*CredentialsExpiry)(nil), "ves.io.schema.tenant.CredentialsExpiry")
	golang_proto.RegisterType((*CredentialsExpiry)(nil), "ves.io.schema.tenant.CredentialsExpiry")
	proto.RegisterType((*Empty)(nil), "ves.io.schema.tenant.Empty")
	golang_proto.RegisterType((*Empty)(nil), "ves.io.schema.tenant.Empty")
}

func init() { proto.RegisterFile("ves.io/schema/tenant/types.proto", fileDescriptor_de41f8b87043178a) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/tenant/types.proto", fileDescriptor_de41f8b87043178a)
}

var fileDescriptor_de41f8b87043178a = []byte{
	// 1373 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4f, 0x6f, 0xdb, 0x46,
	0x16, 0x17, 0x25, 0xff, 0x91, 0xc7, 0xff, 0xe8, 0x41, 0x62, 0xd3, 0xb2, 0xc1, 0x15, 0xbc, 0x58,
	0xc4, 0x70, 0x62, 0x29, 0x71, 0x9c, 0xac, 0xbd, 0x58, 0x04, 0x90, 0x25, 0x2a, 0x51, 0xe2, 0x48,
	0x06, 0x29, 0x27, 0xd8, 0x05, 0x82, 0xd9, 0x11, 0x39, 0x92, 0xb9, 0x96, 0x86, 0x13, 0xce, 0x50,
	0xb1, 0x0e, 0x05, 0x72, 0x6c, 0x6f, 0x45, 0x8f, 0x45, 0x3f, 0x40, 0xd1, 0x8f, 0xd0, 0x53, 0x50,
	0xa0, 0x40, 0x8f, 0xe9, 0x2d, 0xb7, 0x36, 0xf2, 0xa5, 0xbd, 0xe5, 0x13, 0x34, 0x05, 0x87, 0x94,
	0x2c, 0xd9, 0x39, 0x55, 0x17, 0xcd, 0x7b, 0xef, 0xf7, 0x7b, 0xef, 0x37, 0x6f, 0xde, 0x0c, 0x08,
	0xb2, 0x5d, 0xc2, 0x73, 0xae, 0x97, 0xe7, 0xf6, 0x09, 0xe9, 0xe0, 0xbc, 0x20, 0x14, 0x53, 0x91,
	0x17, 0x3d, 0x46, 0x78, 0x8e, 0xf9, 0x9e, 0xf0, 0xe0, 0xb5, 0x08, 0x91, 0x8b, 0x10, 0xb9, 0x08,
	0x91, 0xd9, 0x6e, 0xb9, 0xe2, 0x24, 0x68, 0xe4, 0x6c, 0xaf, 0x93, 0x6f, 0x79, 0x2d, 0x2f, 0x2f,
	0xc1, 0x8d, 0xa0, 0x29, 0x2d, 0x69, 0xc8, 0x55, 0x94, 0x24, 0xb3, 0x36, 0x5e, 0xc6, 0x63, 0xc2,
	0xf5, 0x68, 0x5c, 0x21, 0xb3, 0x7a, 0x49, 0xc3, 0x45, 0xf1, 0xcc, 0xfa, 0x78, 0xa8, 0x8b, 0xdb,
	0xae, 0x83, 0x05, 0x89, 0xa2, 0x1b, 0x5f, 0x2b, 0x60, 0xd2, 0x0a, 0x1a, 0xc5, 0x02, 0x5c, 0x06,
	0x53, 0x45, 0x5c, 0xc5, 0x1d, 0xa2, 0x29, 0x59, 0x65, 0x73, 0xc6, 0x8c, 0x2d, 0x98, 0x01, 0x69,
	0x09, 0x38, 0x32, 0x9e, 0x6a, 0x49, 0x19, 0x19, 0xda, 0xb0, 0x08, 0xd2, 0x47, 0x98, 0xf3, 0x57,
	0x9e, 0xef, 0x68, 0xa9, 0xac, 0xb2, 0x39, 0xbb, 0x73, 0x23, 0xf7, 0xa9, 0xbd, 0xe6, 0x0c, 0x6a,
	0xfb, 0x3d, 0x26, 0x88, 0x33, 0x80, 0x9b, 0x43, 0x22, 0xd4, 0xc0, 0xf4, 0x33, 0xe2, 0x73, 0xd7,
	0xa3, 0xda, 0x44, 0x56, 0xd9, 0x9c, 0x37, 0x07, 0xe6, 0xc6, 0x17, 0x0a, 0x48, 0x16, 0x0b, 0x10,
	0x82, 0x09, 0x7a, 0xa1, 0x4b, 0xae, 0xa1, 0x0a, 0x52, 0x8c, 0x74, 0x62, 0x41, 0xe1, 0x32, 0xd4,
	0xc2, 0xfe, 0xaa, 0x16, 0x36, 0xa2, 0xa5, 0x3b, 0xae, 0x25, 0x36, 0x37, 0x2a, 0x60, 0xe9, 0x0a,
	0x71, 0x54, 0xba, 0x32, 0x26, 0x3d, 0xec, 0xda, 0xb0, 0x33, 0x71, 0xd7, 0x06, 0xf6, 0xc6, 0x0f,
	0x69, 0xb0, 0xf0, 0xb0, 0xed, 0x35, 0x70, 0xdb, 0x62, 0xc4, 0xae, 0xf7, 0x18, 0x81, 0x9b, 0x00,
	0xb0, 0xa0, 0xd1, 0x76, 0x6d, 0xd4, 0x75, 0x59, 0xb4, 0xd1, 0x83, 0x99, 0xef, 0x7f, 0x7f, 0x93,
	0x9a, 0xf0, 0x93, 0x4c, 0x31, 0x67, 0xa2, 0xe0, 0x33, 0x97, 0x85, 0x25, 0x1d, 0xd2, 0x26, 0x82,
	0x44, 0x79, 0xd3, 0xe6, 0xc0, 0x84, 0x77, 0xc1, 0x82, 0x68, 0xbd, 0x42, 0x98, 0x53, 0xe4, 0x35,
	0x9b, 0x9c, 0x08, 0xd9, 0x86, 0xf9, 0x83, 0xf9, 0x30, 0x4f, 0x7a, 0x6b, 0x4a, 0xfb, 0xe3, 0x97,
	0x8f, 0x1f, 0x17, 0xcd, 0x39, 0xd1, 0x7a, 0x55, 0xe0, 0xb4, 0x26, 0x21, 0xb0, 0x05, 0x56, 0x1d,
	0xd7, 0x27, 0xb6, 0x40, 0xb6, 0x47, 0x69, 0xf8, 0x3f, 0xc2, 0x5f, 0x94, 0xfc, 0x5b, 0x21, 0xff,
	0xc6, 0xd6, 0x3f, 0x0e, 0xfe, 0x7e, 0xfb, 0xd6, 0xfd, 0xdd, 0x7b, 0x77, 0x76, 0xb6, 0xef, 0xdf,
	0xdb, 0xfd, 0xe7, 0x9d, 0x5b, 0xbb, 0x3b, 0xb7, 0xe3, 0xdf, 0xf6, 0xee, 0xce, 0xfe, 0xee, 0xfe,
	0xfd, 0xbb, 0x77, 0xf6, 0xf7, 0xcc, 0xe5, 0x28, 0x5d, 0x31, 0xca, 0x76, 0x51, 0xe8, 0x7f, 0x60,
	0x89, 0x9f, 0x60, 0x9f, 0x38, 0x68, 0x64, 0xa3, 0x13, 0xd9, 0xd4, 0xe6, 0xec, 0xce, 0xfa, 0xa5,
	0x73, 0xaa, 0x35, 0xfe, 0x4f, 0x6c, 0x61, 0x92, 0x66, 0xd8, 0x9a, 0x83, 0xe5, 0xef, 0x3e, 0x8b,
	0xb7, 0x8f, 0x5c, 0x16, 0x4a, 0x99, 0xfc, 0x4a, 0x49, 0xaa, 0x8a, 0xb9, 0x18, 0xa5, 0x3b, 0x1a,
	0x76, 0xe6, 0x11, 0x80, 0xa7, 0x7b, 0x1c, 0x71, 0xe2, 0x77, 0x89, 0x8f, 0x78, 0xd0, 0x40, 0x36,
	0xe6, 0xda, 0xa4, 0x2c, 0xb1, 0xf6, 0xe9, 0x51, 0x90, 0x83, 0x6c, 0x2e, 0x9e, 0xee, 0x71, 0x4b,
	0xb2, 0x42, 0x1b, 0x73, 0x68, 0x80, 0xec, 0x95, 0x4c, 0xa8, 0x8d, 0x05, 0xe1, 0x02, 0x0d, 0xc6,
	0x63, 0x4a, 0x9e, 0xf7, 0xda, 0x38, 0xf5, 0x50, 0x62, 0x06, 0x33, 0xf0, 0x00, 0x2c, 0x30, 0xdf,
	0x3b, 0xeb, 0x21, 0xdf, 0xf3, 0x84, 0x14, 0x33, 0x2d, 0xc5, 0x68, 0x9f, 0x16, 0x53, 0x2c, 0x98,
	0x73, 0x12, 0x6f, 0x7a, 0x9e, 0x08, 0x65, 0x3c, 0x00, 0xeb, 0x63, 0xfc, 0xcb, 0x12, 0xd2, 0x52,
	0x82, 0x36, 0xc2, 0x19, 0xaf, 0xbf, 0x0f, 0x56, 0x1d, 0xd2, 0xc4, 0x41, 0x5b, 0x20, 0xc7, 0xe5,
	0xb8, 0xd1, 0x26, 0x83, 0xde, 0x63, 0xa6, 0xcd, 0xc8, 0xe1, 0x59, 0x8e, 0x01, 0xa5, 0x28, 0x1e,
	0x35, 0xb3, 0xc0, 0xe0, 0x4d, 0x00, 0x03, 0x4e, 0x50, 0x4b, 0x4e, 0x29, 0xc2, 0x2e, 0x45, 0x5d,
	0xbf, 0xa9, 0x01, 0xc9, 0x59, 0x0c, 0x38, 0x89, 0xc6, 0xb7, 0xe0, 0xd2, 0x67, 0x7e, 0x13, 0xbe,
	0x00, 0x3a, 0x3f, 0xc1, 0x8c, 0xa0, 0xf8, 0x80, 0x5d, 0xca, 0x05, 0xa6, 0x36, 0x41, 0x38, 0x10,
	0x27, 0xe8, 0x94, 0xf4, 0xb4, 0x59, 0x79, 0x1f, 0x57, 0x2f, 0xed, 0xdb, 0x22, 0xb6, 0x4f, 0x44,
	0x78, 0xc8, 0x66, 0x46, 0x26, 0xb0, 0x24, 0xbf, 0x12, 0xd3, 0x0b, 0x81, 0x38, 0x79, 0x42, 0x7a,
	0x70, 0x1b, 0xcc, 0xd9, 0x5e, 0x87, 0x61, 0xda, 0x43, 0xf2, 0x19, 0x98, 0x93, 0xb7, 0x03, 0xc8,
	0x51, 0xf0, 0x53, 0xda, 0xeb, 0xa4, 0x39, 0x1b, 0xc7, 0xe5, 0x7b, 0x75, 0x13, 0xcc, 0x46, 0x0d,
	0x45, 0xcd, 0x97, 0x0e, 0xd5, 0xe6, 0xaf, 0xa0, 0x41, 0x14, 0x2e, 0xbf, 0x74, 0x28, 0x2c, 0x83,
	0x55, 0xec, 0x38, 0x1e, 0x95, 0x67, 0xed, 0xda, 0x84, 0x87, 0xa7, 0xcd, 0x6d, 0xdf, 0x6d, 0x10,
	0x47, 0x5b, 0xc8, 0xa6, 0x86, 0xd4, 0x70, 0xe6, 0xb2, 0xe6, 0x8a, 0x04, 0x5b, 0x31, 0xd6, 0x1a,
	0x42, 0xe1, 0xbf, 0x86, 0x45, 0xc3, 0xa7, 0x57, 0x53, 0xb3, 0xca, 0xe6, 0xc2, 0x95, 0xfd, 0xd6,
	0x25, 0x42, 0xee, 0x37, 0xd6, 0x20, 0xef, 0xfe, 0x2e, 0x98, 0x61, 0x6d, 0x4c, 0x23, 0xe6, 0x92,
	0x64, 0xae, 0x5c, 0x62, 0x1e, 0xb5, 0x31, 0x95, 0xbc, 0x34, 0x8b, 0x57, 0x1b, 0x3f, 0x2b, 0x60,
	0xa9, 0xe8, 0x13, 0x87, 0x50, 0xe1, 0xe2, 0x36, 0x37, 0xce, 0x98, 0xeb, 0xf7, 0x60, 0x09, 0xfc,
	0xad, 0x83, 0xcf, 0x10, 0x66, 0x2e, 0xb2, 0x89, 0x2f, 0xdc, 0xa6, 0x6b, 0x63, 0x41, 0x10, 0x91,
	0x51, 0xe4, 0xe0, 0x1e, 0x97, 0x8f, 0xcb, 0xa4, 0xb9, 0xd6, 0xc1, 0x67, 0x05, 0xe6, 0x16, 0x2f,
	0x40, 0x51, 0x86, 0x12, 0xee, 0x71, 0xb8, 0x07, 0x56, 0x07, 0x59, 0x84, 0x77, 0x4a, 0xe8, 0x18,
	0x3f, 0x29, 0xf9, 0xd7, 0x23, 0x7e, 0x3d, 0x0c, 0x8f, 0x30, 0xff, 0x0d, 0xc2, 0xc4, 0xe8, 0x34,
	0x68, 0x90, 0xf0, 0x41, 0x69, 0xba, 0xad, 0x31, 0x6e, 0x4a, 0x72, 0x57, 0x3a, 0xf8, 0xec, 0x49,
	0xd0, 0x20, 0x45, 0x09, 0xb8, 0x60, 0x6f, 0x4c, 0x83, 0x49, 0xa3, 0xc3, 0x44, 0x6f, 0xeb, 0x1b,
	0x05, 0x2c, 0x94, 0xc2, 0x67, 0xcd, 0xf5, 0xa8, 0x49, 0x30, 0xf7, 0x28, 0x84, 0x60, 0xc1, 0x34,
	0x0a, 0x56, 0xad, 0x8a, 0x8e, 0xab, 0x4f, 0xaa, 0xb5, 0xe7, 0x55, 0x35, 0x01, 0x75, 0x90, 0x89,
	0x7d, 0xd6, 0xf3, 0x4a, 0xbd, 0xf8, 0x08, 0xd5, 0x6b, 0xa8, 0x6c, 0x1a, 0x06, 0x3a, 0x3a, 0x2c,
	0x54, 0x55, 0x05, 0xae, 0x81, 0x95, 0x38, 0x5e, 0xad, 0xa1, 0xc3, 0x5a, 0xf5, 0xa1, 0x61, 0xa2,
	0xaa, 0x61, 0x94, 0x8c, 0x92, 0x9a, 0x84, 0xeb, 0x40, 0x1b, 0x06, 0xeb, 0xe8, 0xf1, 0xb1, 0x55,
	0xaf, 0x94, 0xff, 0x83, 0x8a, 0x35, 0xab, 0x6e, 0xa9, 0xa9, 0x11, 0x6a, 0xa9, 0x52, 0x2e, 0x57,
	0x8a, 0xc7, 0x87, 0xf5, 0x30, 0xfb, 0xb1, 0x65, 0xa8, 0x13, 0x5b, 0x3f, 0x2a, 0x20, 0x5d, 0xb6,
	0x9e, 0x5a, 0x02, 0x0b, 0x12, 0x0a, 0x93, 0x8b, 0x63, 0xea, 0x90, 0xa6, 0x4b, 0x89, 0xa3, 0x26,
	0xe0, 0x12, 0x98, 0x97, 0xbe, 0xa2, 0x4f, 0xb0, 0x70, 0x69, 0x4b, 0x55, 0xe0, 0x75, 0xb0, 0x74,
	0xe1, 0x22, 0x65, 0xec, 0xb6, 0x89, 0xa3, 0x26, 0x87, 0xc8, 0x0a, 0xc5, 0xb6, 0x70, 0xbb, 0x44,
	0x4d, 0xc1, 0x45, 0x30, 0x2b, 0x5d, 0x85, 0xc8, 0x31, 0x31, 0xac, 0x60, 0x05, 0x9c, 0x11, 0xea,
	0x10, 0x47, 0x9d, 0x1c, 0xf2, 0xe2, 0x8b, 0xeb, 0xa8, 0x53, 0xf0, 0x1a, 0x50, 0xa3, 0x0a, 0xb2,
	0xad, 0x81, 0x1f, 0xd6, 0x9d, 0x86, 0x19, 0xb0, 0x7c, 0xd9, 0x1b, 0x17, 0x4f, 0x6f, 0xbd, 0x00,
	0x33, 0x35, 0xc1, 0xc2, 0x70, 0xc0, 0xa1, 0x0a, 0xe6, 0x6a, 0xf5, 0x23, 0x54, 0xaa, 0x58, 0x85,
	0x83, 0x43, 0xa3, 0xa4, 0x26, 0x42, 0x21, 0xa1, 0xc7, 0xa8, 0x46, 0x0e, 0x25, 0x14, 0x12, 0x3a,
	0x8e, 0xcc, 0x5a, 0xd1, 0xb0, 0xac, 0x4a, 0xf5, 0xa1, 0x9a, 0x84, 0xab, 0xe0, 0xfa, 0x88, 0x2f,
	0xa6, 0x87, 0xa1, 0xd4, 0xc1, 0xe7, 0xca, 0xdb, 0xf7, 0x7a, 0xe2, 0xdd, 0x7b, 0x3d, 0xf1, 0xe1,
	0xbd, 0xae, 0xbc, 0xee, 0xeb, 0xca, 0xb7, 0x7d, 0x5d, 0xf9, 0xa9, 0xaf, 0x2b, 0x6f, 0xfb, 0xba,
	0xf2, 0xae, 0xaf, 0x2b, 0xbf, 0xf6, 0x75, 0xe5, 0xb7, 0xbe, 0x9e, 0xf8, 0xd0, 0xd7, 0x95, 0x2f,
	0xcf, 0xf5, 0xc4, 0x9b, 0x73, 0x5d, 0x79, 0x7b, 0xae, 0x27, 0xde, 0x9d, 0xeb, 0x89, 0xff, 0x3e,
	0x6e, 0x79, 0xec, 0xb4, 0x95, 0xeb, 0x7a, 0x6d, 0x41, 0x7c, 0x1f, 0xe7, 0x02, 0x9e, 0x97, 0x8b,
	0xa6, 0xe7, 0x77, 0xb6, 0x99, 0xef, 0x75, 0x5d, 0x87, 0xf8, 0xdb, 0x83, 0x70, 0x9e, 0x35, 0x5a,
	0x5e, 0x9e, 0x9c, 0x89, 0xf8, 0x3b, 0x67, 0xec, 0x6b, 0xac, 0x31, 0x25, 0xbf, 0x76, 0xee, 0xfe,
	0x19, 0x00, 0x00, 0xff, 0xff, 0x32, 0x4e, 0xa1, 0x3e, 0xac, 0x09, 0x00, 0x00,
}

func (x DeletionReason) String() string {
	s, ok := DeletionReason_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FSMState) String() string {
	s, ok := FSMState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OtpStatus) String() string {
	s, ok := OtpStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *SubCA) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubCA)
	if !ok {
		that2, ok := that.(SubCA)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CaName != that1.CaName {
		return false
	}
	if this.SubCAPEM != that1.SubCAPEM {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *CA) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CA)
	if !ok {
		that2, ok := that.(CA)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Pem != that1.Pem {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *EncryptedPassword) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EncryptedPassword)
	if !ok {
		that2, ok := that.(EncryptedPassword)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Password != that1.Password {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PublicVip != that1.PublicVip {
		return false
	}
	if this.Deleted != that1.Deleted {
		return false
	}
	if this.TgwAsnOffset != that1.TgwAsnOffset {
		return false
	}
	if this.DirectConnectAsnOffset != that1.DirectConnectAsnOffset {
		return false
	}
	if len(this.SharedPublicVip) != len(that1.SharedPublicVip) {
		return false
	}
	for i := range this.SharedPublicVip {
		if !this.SharedPublicVip[i].Equal(that1.SharedPublicVip[i]) {
			return false
		}
	}
	if len(this.K8SServerSubCas) != len(that1.K8SServerSubCas) {
		return false
	}
	for i := range this.K8SServerSubCas {
		if !this.K8SServerSubCas[i].Equal(that1.K8SServerSubCas[i]) {
			return false
		}
	}
	if this.K8SServerSubCaLatestVersion != that1.K8SServerSubCaLatestVersion {
		return false
	}
	if len(this.ProxyRootCas) != len(that1.ProxyRootCas) {
		return false
	}
	for i := range this.ProxyRootCas {
		if !this.ProxyRootCas[i].Equal(that1.ProxyRootCas[i]) {
			return false
		}
	}
	if this.ProxyRootCaLatestVersion != that1.ProxyRootCaLatestVersion {
		return false
	}
	if this.DefaultDisablePublicAp != that1.DefaultDisablePublicAp {
		return false
	}
	if this.UseGlobalAinVrf != that1.UseGlobalAinVrf {
		return false
	}
	if !this.ShapeSharedInstanceAuthKey.Equal(that1.ShapeSharedInstanceAuthKey) {
		return false
	}
	if this.CompanyName != that1.CompanyName {
		return false
	}
	if this.TenantFqdn != that1.TenantFqdn {
		return false
	}
	if len(this.AddonServicesSubscribed) != len(that1.AddonServicesSubscribed) {
		return false
	}
	for i := range this.AddonServicesSubscribed {
		if this.AddonServicesSubscribed[i] != that1.AddonServicesSubscribed[i] {
			return false
		}
	}
	if this.TenantType != that1.TenantType {
		return false
	}
	if this.PlanType != that1.PlanType {
		return false
	}
	return true
}
func (this *CredentialsExpiry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CredentialsExpiry)
	if !ok {
		that2, ok := that.(CredentialsExpiry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxApiCertificateExpiryDays != that1.MaxApiCertificateExpiryDays {
		return false
	}
	if this.MaxApiTokenExpiryDays != that1.MaxApiTokenExpiryDays {
		return false
	}
	if this.MaxKubeConfigExpiryDays != that1.MaxKubeConfigExpiryDays {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SubCA) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tenant.SubCA{")
	s = append(s, "CaName: "+fmt.Sprintf("%#v", this.CaName)+",\n")
	s = append(s, "SubCAPEM: "+fmt.Sprintf("%#v", this.SubCAPEM)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CA) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tenant.CA{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Pem: "+fmt.Sprintf("%#v", this.Pem)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EncryptedPassword) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tenant.EncryptedPassword{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&tenant.GlobalSpecType{")
	s = append(s, "PublicVip: "+fmt.Sprintf("%#v", this.PublicVip)+",\n")
	s = append(s, "Deleted: "+fmt.Sprintf("%#v", this.Deleted)+",\n")
	s = append(s, "TgwAsnOffset: "+fmt.Sprintf("%#v", this.TgwAsnOffset)+",\n")
	s = append(s, "DirectConnectAsnOffset: "+fmt.Sprintf("%#v", this.DirectConnectAsnOffset)+",\n")
	if this.SharedPublicVip != nil {
		s = append(s, "SharedPublicVip: "+fmt.Sprintf("%#v", this.SharedPublicVip)+",\n")
	}
	if this.K8SServerSubCas != nil {
		s = append(s, "K8SServerSubCas: "+fmt.Sprintf("%#v", this.K8SServerSubCas)+",\n")
	}
	s = append(s, "K8SServerSubCaLatestVersion: "+fmt.Sprintf("%#v", this.K8SServerSubCaLatestVersion)+",\n")
	if this.ProxyRootCas != nil {
		s = append(s, "ProxyRootCas: "+fmt.Sprintf("%#v", this.ProxyRootCas)+",\n")
	}
	s = append(s, "ProxyRootCaLatestVersion: "+fmt.Sprintf("%#v", this.ProxyRootCaLatestVersion)+",\n")
	s = append(s, "DefaultDisablePublicAp: "+fmt.Sprintf("%#v", this.DefaultDisablePublicAp)+",\n")
	s = append(s, "UseGlobalAinVrf: "+fmt.Sprintf("%#v", this.UseGlobalAinVrf)+",\n")
	if this.ShapeSharedInstanceAuthKey != nil {
		s = append(s, "ShapeSharedInstanceAuthKey: "+fmt.Sprintf("%#v", this.ShapeSharedInstanceAuthKey)+",\n")
	}
	s = append(s, "CompanyName: "+fmt.Sprintf("%#v", this.CompanyName)+",\n")
	s = append(s, "TenantFqdn: "+fmt.Sprintf("%#v", this.TenantFqdn)+",\n")
	s = append(s, "AddonServicesSubscribed: "+fmt.Sprintf("%#v", this.AddonServicesSubscribed)+",\n")
	s = append(s, "TenantType: "+fmt.Sprintf("%#v", this.TenantType)+",\n")
	s = append(s, "PlanType: "+fmt.Sprintf("%#v", this.PlanType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CredentialsExpiry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tenant.CredentialsExpiry{")
	s = append(s, "MaxApiCertificateExpiryDays: "+fmt.Sprintf("%#v", this.MaxApiCertificateExpiryDays)+",\n")
	s = append(s, "MaxApiTokenExpiryDays: "+fmt.Sprintf("%#v", this.MaxApiTokenExpiryDays)+",\n")
	s = append(s, "MaxKubeConfigExpiryDays: "+fmt.Sprintf("%#v", this.MaxKubeConfigExpiryDays)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&tenant.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SubCA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubCA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubCA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubCAPEM) > 0 {
		i -= len(m.SubCAPEM)
		copy(dAtA[i:], m.SubCAPEM)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubCAPEM)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CaName) > 0 {
		i -= len(m.CaName)
		copy(dAtA[i:], m.CaName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CaName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Pem) > 0 {
		i -= len(m.Pem)
		copy(dAtA[i:], m.Pem)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Pem)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptedPassword) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedPassword) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptedPassword) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlanType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PlanType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.TenantType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TenantType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.DirectConnectAsnOffset != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DirectConnectAsnOffset))
		i--
		dAtA[i] = 0x78
	}
	if len(m.AddonServicesSubscribed) > 0 {
		for iNdEx := len(m.AddonServicesSubscribed) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddonServicesSubscribed[iNdEx])
			copy(dAtA[i:], m.AddonServicesSubscribed[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AddonServicesSubscribed[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.TenantFqdn) > 0 {
		i -= len(m.TenantFqdn)
		copy(dAtA[i:], m.TenantFqdn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TenantFqdn)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.CompanyName) > 0 {
		i -= len(m.CompanyName)
		copy(dAtA[i:], m.CompanyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CompanyName)))
		i--
		dAtA[i] = 0x62
	}
	if m.ShapeSharedInstanceAuthKey != nil {
		{
			size, err := m.ShapeSharedInstanceAuthKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.UseGlobalAinVrf {
		i--
		if m.UseGlobalAinVrf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.DefaultDisablePublicAp {
		i--
		if m.DefaultDisablePublicAp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.ProxyRootCaLatestVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ProxyRootCaLatestVersion))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ProxyRootCas) > 0 {
		for iNdEx := len(m.ProxyRootCas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProxyRootCas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.K8SServerSubCaLatestVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.K8SServerSubCaLatestVersion))
		i--
		dAtA[i] = 0x30
	}
	if len(m.K8SServerSubCas) > 0 {
		for iNdEx := len(m.K8SServerSubCas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.K8SServerSubCas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SharedPublicVip) > 0 {
		for iNdEx := len(m.SharedPublicVip) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SharedPublicVip[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TgwAsnOffset != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TgwAsnOffset))
		i--
		dAtA[i] = 0x18
	}
	if m.Deleted {
		i--
		if m.Deleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.PublicVip) > 0 {
		i -= len(m.PublicVip)
		copy(dAtA[i:], m.PublicVip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicVip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CredentialsExpiry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialsExpiry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialsExpiry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxKubeConfigExpiryDays != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxKubeConfigExpiryDays))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxApiTokenExpiryDays != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxApiTokenExpiryDays))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxApiCertificateExpiryDays != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxApiCertificateExpiryDays))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SubCA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CaName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubCAPEM)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	return n
}

func (m *CA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Pem)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	return n
}

func (m *EncryptedPassword) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicVip)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Deleted {
		n += 2
	}
	if m.TgwAsnOffset != 0 {
		n += 1 + sovTypes(uint64(m.TgwAsnOffset))
	}
	if len(m.SharedPublicVip) > 0 {
		for _, e := range m.SharedPublicVip {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.K8SServerSubCas) > 0 {
		for _, e := range m.K8SServerSubCas {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.K8SServerSubCaLatestVersion != 0 {
		n += 1 + sovTypes(uint64(m.K8SServerSubCaLatestVersion))
	}
	if len(m.ProxyRootCas) > 0 {
		for _, e := range m.ProxyRootCas {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ProxyRootCaLatestVersion != 0 {
		n += 1 + sovTypes(uint64(m.ProxyRootCaLatestVersion))
	}
	if m.DefaultDisablePublicAp {
		n += 2
	}
	if m.UseGlobalAinVrf {
		n += 2
	}
	if m.ShapeSharedInstanceAuthKey != nil {
		l = m.ShapeSharedInstanceAuthKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CompanyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TenantFqdn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AddonServicesSubscribed) > 0 {
		for _, s := range m.AddonServicesSubscribed {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DirectConnectAsnOffset != 0 {
		n += 1 + sovTypes(uint64(m.DirectConnectAsnOffset))
	}
	if m.TenantType != 0 {
		n += 2 + sovTypes(uint64(m.TenantType))
	}
	if m.PlanType != 0 {
		n += 2 + sovTypes(uint64(m.PlanType))
	}
	return n
}

func (m *CredentialsExpiry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxApiCertificateExpiryDays != 0 {
		n += 1 + sovTypes(uint64(m.MaxApiCertificateExpiryDays))
	}
	if m.MaxApiTokenExpiryDays != 0 {
		n += 1 + sovTypes(uint64(m.MaxApiTokenExpiryDays))
	}
	if m.MaxKubeConfigExpiryDays != 0 {
		n += 1 + sovTypes(uint64(m.MaxKubeConfigExpiryDays))
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SubCA) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubCA{`,
		`CaName:` + fmt.Sprintf("%v", this.CaName) + `,`,
		`SubCAPEM:` + fmt.Sprintf("%v", this.SubCAPEM) + `,`,
		`Password:` + strings.Replace(this.Password.String(), "EncryptedPassword", "EncryptedPassword", 1) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CA) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CA{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Pem:` + fmt.Sprintf("%v", this.Pem) + `,`,
		`Password:` + strings.Replace(this.Password.String(), "EncryptedPassword", "EncryptedPassword", 1) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EncryptedPassword) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EncryptedPassword{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Password:` + fmt.Sprintf("%v", this.Password) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSharedPublicVip := "[]*ObjectRefType{"
	for _, f := range this.SharedPublicVip {
		repeatedStringForSharedPublicVip += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSharedPublicVip += "}"
	repeatedStringForK8SServerSubCas := "[]*SubCA{"
	for _, f := range this.K8SServerSubCas {
		repeatedStringForK8SServerSubCas += strings.Replace(f.String(), "SubCA", "SubCA", 1) + ","
	}
	repeatedStringForK8SServerSubCas += "}"
	repeatedStringForProxyRootCas := "[]*CA{"
	for _, f := range this.ProxyRootCas {
		repeatedStringForProxyRootCas += strings.Replace(f.String(), "CA", "CA", 1) + ","
	}
	repeatedStringForProxyRootCas += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`PublicVip:` + fmt.Sprintf("%v", this.PublicVip) + `,`,
		`Deleted:` + fmt.Sprintf("%v", this.Deleted) + `,`,
		`TgwAsnOffset:` + fmt.Sprintf("%v", this.TgwAsnOffset) + `,`,
		`SharedPublicVip:` + repeatedStringForSharedPublicVip + `,`,
		`K8SServerSubCas:` + repeatedStringForK8SServerSubCas + `,`,
		`K8SServerSubCaLatestVersion:` + fmt.Sprintf("%v", this.K8SServerSubCaLatestVersion) + `,`,
		`ProxyRootCas:` + repeatedStringForProxyRootCas + `,`,
		`ProxyRootCaLatestVersion:` + fmt.Sprintf("%v", this.ProxyRootCaLatestVersion) + `,`,
		`DefaultDisablePublicAp:` + fmt.Sprintf("%v", this.DefaultDisablePublicAp) + `,`,
		`UseGlobalAinVrf:` + fmt.Sprintf("%v", this.UseGlobalAinVrf) + `,`,
		`ShapeSharedInstanceAuthKey:` + strings.Replace(fmt.Sprintf("%v", this.ShapeSharedInstanceAuthKey), "SecretType", "schema.SecretType", 1) + `,`,
		`CompanyName:` + fmt.Sprintf("%v", this.CompanyName) + `,`,
		`TenantFqdn:` + fmt.Sprintf("%v", this.TenantFqdn) + `,`,
		`AddonServicesSubscribed:` + fmt.Sprintf("%v", this.AddonServicesSubscribed) + `,`,
		`DirectConnectAsnOffset:` + fmt.Sprintf("%v", this.DirectConnectAsnOffset) + `,`,
		`TenantType:` + fmt.Sprintf("%v", this.TenantType) + `,`,
		`PlanType:` + fmt.Sprintf("%v", this.PlanType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CredentialsExpiry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CredentialsExpiry{`,
		`MaxApiCertificateExpiryDays:` + fmt.Sprintf("%v", this.MaxApiCertificateExpiryDays) + `,`,
		`MaxApiTokenExpiryDays:` + fmt.Sprintf("%v", this.MaxApiTokenExpiryDays) + `,`,
		`MaxKubeConfigExpiryDays:` + fmt.Sprintf("%v", this.MaxKubeConfigExpiryDays) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SubCA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubCA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubCA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCAPEM", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubCAPEM = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &EncryptedPassword{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &EncryptedPassword{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptedPassword) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedPassword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedPassword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwAsnOffset", wireType)
			}
			m.TgwAsnOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TgwAsnOffset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedPublicVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharedPublicVip = append(m.SharedPublicVip, &schema.ObjectRefType{})
			if err := m.SharedPublicVip[len(m.SharedPublicVip)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SServerSubCas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K8SServerSubCas = append(m.K8SServerSubCas, &SubCA{})
			if err := m.K8SServerSubCas[len(m.K8SServerSubCas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SServerSubCaLatestVersion", wireType)
			}
			m.K8SServerSubCaLatestVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.K8SServerSubCaLatestVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyRootCas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyRootCas = append(m.ProxyRootCas, &CA{})
			if err := m.ProxyRootCas[len(m.ProxyRootCas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyRootCaLatestVersion", wireType)
			}
			m.ProxyRootCaLatestVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProxyRootCaLatestVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultDisablePublicAp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultDisablePublicAp = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseGlobalAinVrf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseGlobalAinVrf = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShapeSharedInstanceAuthKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShapeSharedInstanceAuthKey == nil {
				m.ShapeSharedInstanceAuthKey = &schema.SecretType{}
			}
			if err := m.ShapeSharedInstanceAuthKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompanyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompanyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddonServicesSubscribed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddonServicesSubscribed = append(m.AddonServicesSubscribed, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectAsnOffset", wireType)
			}
			m.DirectConnectAsnOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectConnectAsnOffset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantType", wireType)
			}
			m.TenantType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantType |= schema.TenantType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanType", wireType)
			}
			m.PlanType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanType |= schema.PlanType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialsExpiry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialsExpiry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialsExpiry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxApiCertificateExpiryDays", wireType)
			}
			m.MaxApiCertificateExpiryDays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxApiCertificateExpiryDays |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxApiTokenExpiryDays", wireType)
			}
			m.MaxApiTokenExpiryDays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxApiTokenExpiryDays |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxKubeConfigExpiryDays", wireType)
			}
			m.MaxKubeConfigExpiryDays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxKubeConfigExpiryDays |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
