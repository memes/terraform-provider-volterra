// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/cloud_link/object.proto

package cloud_link

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Cloud Link Object
//
// x-displayName: "Cloud Link"
// Cloud Link object represents private connectivity from customer network to CE Site or RE Site to CE Site
type Object struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// Standard object's metadata
	Metadata *schema.ObjectMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// system_metadata
	//
	// x-displayName: "System Metadata"
	// System generated object's metadata
	SystemMetadata *schema.SystemObjectMetaType `protobuf:"bytes,2,opt,name=system_metadata,json=systemMetadata,proto3" json:"system_metadata,omitempty"`
	// spec
	//
	// x-displayName: "Spec"
	// Specification of the desired behavior of the Cloud Link
	Spec *SpecType `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *Object) Reset()      { *m = Object{} }
func (*Object) ProtoMessage() {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{0}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetMetadata() *schema.ObjectMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Object) GetSystemMetadata() *schema.SystemObjectMetaType {
	if m != nil {
		return m.SystemMetadata
	}
	return nil
}

func (m *Object) GetSpec() *SpecType {
	if m != nil {
		return m.Spec
	}
	return nil
}

// Specification for Cloud Link
//
// x-displayName: "Specification"
// Shape of the Cloud Link specification
type SpecType struct {
	// gc_spec
	//
	// x-displayName: "GC Spec"
	GcSpec *GlobalSpecType `protobuf:"bytes,2,opt,name=gc_spec,json=gcSpec,proto3" json:"gc_spec,omitempty"`
}

func (m *SpecType) Reset()      { *m = SpecType{} }
func (*SpecType) ProtoMessage() {}
func (*SpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{1}
}
func (m *SpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecType.Merge(m, src)
}
func (m *SpecType) XXX_Size() int {
	return m.Size()
}
func (m *SpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecType.DiscardUnknown(m)
}

var xxx_messageInfo_SpecType proto.InternalMessageInfo

func (m *SpecType) GetGcSpec() *GlobalSpecType {
	if m != nil {
		return m.GcSpec
	}
	return nil
}

// Status for Cloud Link
//
// x-displayName: "Status"
// Most recently observed status of object
type StatusObject struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// Standard status's metadata
	Metadata *schema.StatusMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// object_refs
	//
	// x-displayName: "Config Object"
	// Reference to object for current status
	ObjectRefs []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=object_refs,json=objectRefs,proto3" json:"object_refs,omitempty"`
	// conditions
	//
	// x-displayName: "Conditions"
	// Conditions reported by various component of the system
	Conditions []*schema.ConditionType `protobuf:"bytes,3,rep,name=conditions,proto3" json:"conditions,omitempty"`
	// Cloud Link Status
	//
	// x-displayName: "Cloud Link Status"
	// Status reported to this Cloud Link and associated cloud components
	//
	// Types that are valid to be assigned to CloudLinkStatus:
	//	*StatusObject_AwsStatus
	//	*StatusObject_AzureStatus
	CloudLinkStatus isStatusObject_CloudLinkStatus `protobuf_oneof:"cloud_link_status"`
}

func (m *StatusObject) Reset()      { *m = StatusObject{} }
func (*StatusObject) ProtoMessage() {}
func (*StatusObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{2}
}
func (m *StatusObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatusObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusObject.Merge(m, src)
}
func (m *StatusObject) XXX_Size() int {
	return m.Size()
}
func (m *StatusObject) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusObject.DiscardUnknown(m)
}

var xxx_messageInfo_StatusObject proto.InternalMessageInfo

type isStatusObject_CloudLinkStatus interface {
	isStatusObject_CloudLinkStatus()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StatusObject_AwsStatus struct {
	AwsStatus *AWSStatusType `protobuf:"bytes,5,opt,name=aws_status,json=awsStatus,proto3,oneof" json:"aws_status,omitempty"`
}
type StatusObject_AzureStatus struct {
	AzureStatus *AzureStatusType `protobuf:"bytes,6,opt,name=azure_status,json=azureStatus,proto3,oneof" json:"azure_status,omitempty"`
}

func (*StatusObject_AwsStatus) isStatusObject_CloudLinkStatus()   {}
func (*StatusObject_AzureStatus) isStatusObject_CloudLinkStatus() {}

func (m *StatusObject) GetCloudLinkStatus() isStatusObject_CloudLinkStatus {
	if m != nil {
		return m.CloudLinkStatus
	}
	return nil
}

func (m *StatusObject) GetMetadata() *schema.StatusMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *StatusObject) GetObjectRefs() []*schema.ObjectRefType {
	if m != nil {
		return m.ObjectRefs
	}
	return nil
}

func (m *StatusObject) GetConditions() []*schema.ConditionType {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *StatusObject) GetAwsStatus() *AWSStatusType {
	if x, ok := m.GetCloudLinkStatus().(*StatusObject_AwsStatus); ok {
		return x.AwsStatus
	}
	return nil
}

func (m *StatusObject) GetAzureStatus() *AzureStatusType {
	if x, ok := m.GetCloudLinkStatus().(*StatusObject_AzureStatus); ok {
		return x.AzureStatus
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StatusObject) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StatusObject_AwsStatus)(nil),
		(*StatusObject_AzureStatus)(nil),
	}
}

// Amazon Web Services (AWS) Cloud Link Status
//
// x-displayName: "Amazon Web Services (AWS) Cloud Link Status"
// Status reported by this Cloud Link and associated Amazon Web Services (AWS) cloud components
type AWSStatusType struct {
	// CloudLink Direct Connect Connection Status
	//
	// x-displayName: "CloudLink Direct Connect Connection Status"
	// Status reported by Amazon Web Services (AWS) CloudLink Connection
	ConnectionStatus []*DirectConnectConnectionStatusType `protobuf:"bytes,2,rep,name=connection_status,json=connectionStatus,proto3" json:"connection_status,omitempty"`
}

func (m *AWSStatusType) Reset()      { *m = AWSStatusType{} }
func (*AWSStatusType) ProtoMessage() {}
func (*AWSStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{3}
}
func (m *AWSStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSStatusType.Merge(m, src)
}
func (m *AWSStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AWSStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSStatusType proto.InternalMessageInfo

func (m *AWSStatusType) GetConnectionStatus() []*DirectConnectConnectionStatusType {
	if m != nil {
		return m.ConnectionStatus
	}
	return nil
}

// CloudLink Direct Connect Connection Status
//
// x-displayName: "CloudLink Direct Connect Connection Status"
// Status reported by Amazon Web Services (AWS) Direct Connect Connection related to this Cloud Link
type DirectConnectConnectionStatusType struct {
	// Bandwidth
	//
	// x-displayName: "Bandwidth"
	// The bandwidth of the connection.
	Bandwidth string `protobuf:"bytes,1,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	// Connection Id
	//
	// x-displayName: "Connection Id"
	// The ID of the direct connect connection
	ConnectionId string `protobuf:"bytes,2,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	// Connection Name
	//
	// x-displayName: "Connection Name"
	// The Name of the connection
	ConnectionName string `protobuf:"bytes,3,opt,name=connection_name,json=connectionName,proto3" json:"connection_name,omitempty"`
	// Connection State
	//
	// x-displayName: "Connection State"
	// The state of the Direct Connect Connection
	ConnectionState string `protobuf:"bytes,4,opt,name=connection_state,json=connectionState,proto3" json:"connection_state,omitempty"`
	// Logical Redundancy Status
	//
	// x-displayName: "Logical Redundancy Status"
	// Whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6)
	HasLogicalRedundancy string `protobuf:"bytes,5,opt,name=has_logical_redundancy,json=hasLogicalRedundancy,proto3" json:"has_logical_redundancy,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// Location of the connection
	Location string `protobuf:"bytes,6,opt,name=location,proto3" json:"location,omitempty"`
	// Connection Partner
	//
	// x-displayName: "Connection Partner"
	// The name of the AWS Direct Connect service provider associated with the connection.
	PartnerName string `protobuf:"bytes,7,opt,name=partner_name,json=partnerName,proto3" json:"partner_name,omitempty"`
	// Connection Provider
	//
	// x-displayName: "Connection Provider"
	// The name of the service provider associated with the connection.
	ProviderName string `protobuf:"bytes,8,opt,name=provider_name,json=providerName,proto3" json:"provider_name,omitempty"`
	// Region
	//
	// x-displayName: "Region"
	// Region where the connection is located
	Region string `protobuf:"bytes,9,opt,name=region,proto3" json:"region,omitempty"`
	// AWS Tags
	//
	// x-displayName: "AWS Tags"
	// x-example: "dev: staging"
	// AWS Tags is a label consisting of a user-defined key and value which are assocaited with this coonnection.
	// It helps to manage, identify, organize, search for, and filter resources in AWS console.
	Tags map[string]string `protobuf:"bytes,10,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Virtual Local Area Network (VLAN)
	//
	// x-displayName: "Virtual Local Area Network (VLAN)"
	// x-example: "700"
	// Virtual Local Area Network number for the new virtual interface to be configured on the AWS.
	Vlan uint32 `protobuf:"varint,11,opt,name=vlan,proto3" json:"vlan,omitempty"`
	// Jumbo Frame Capable
	//
	// x-displayName: "Jumbo Frame Capable"
	// Indicates whether jumbo frames (9001 MTU) are supported.
	JumboFrameCapable bool `protobuf:"varint,12,opt,name=jumbo_frame_capable,json=jumboFrameCapable,proto3" json:"jumbo_frame_capable,omitempty"`
	// Owner Account
	//
	// x-displayName: "Owner Account"
	// The ID of the AWS account that owns the connection
	OwnerAccount string `protobuf:"bytes,13,opt,name=owner_account,json=ownerAccount,proto3" json:"owner_account,omitempty"`
	// Virtual Interface Status
	//
	// x-displayName: "Virtual Interface Status"
	// Status reported by Amazon Web Services (AWS) Virtual Interface Status related to this Cloud Link
	VifStatus *VirtualInterfaceStatusType `protobuf:"bytes,14,opt,name=vif_status,json=vifStatus,proto3" json:"vif_status,omitempty"`
	// Direct Connect Gateway Status
	//
	// x-displayName: "Direct Connect Gateway Status"
	// Status reported by Amazon Web Services (AWS) Direct Connect Gateway Status and associations related to this Cloud Link
	GatewayStatus *DirectConnectGatewayStatusType `protobuf:"bytes,15,opt,name=gateway_status,json=gatewayStatus,proto3" json:"gateway_status,omitempty"`
	// CloudLink Connection Coordinates
	//
	// x-displayName: "CloudLink Connection Coordinates"
	// Coordinates of the CloudLink Connection based on connection's physical location
	Coordinates *Coordinates `protobuf:"bytes,16,opt,name=coordinates,proto3" json:"coordinates,omitempty"`
	// AWS Object Link
	//
	// x-displayName: "AWS Object Link"
	// Link to Amazon Web Services (AWS) object
	AwsPath string `protobuf:"bytes,17,opt,name=aws_path,json=awsPath,proto3" json:"aws_path,omitempty"`
}

func (m *DirectConnectConnectionStatusType) Reset()      { *m = DirectConnectConnectionStatusType{} }
func (*DirectConnectConnectionStatusType) ProtoMessage() {}
func (*DirectConnectConnectionStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{4}
}
func (m *DirectConnectConnectionStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectConnectConnectionStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DirectConnectConnectionStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectConnectConnectionStatusType.Merge(m, src)
}
func (m *DirectConnectConnectionStatusType) XXX_Size() int {
	return m.Size()
}
func (m *DirectConnectConnectionStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectConnectConnectionStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_DirectConnectConnectionStatusType proto.InternalMessageInfo

func (m *DirectConnectConnectionStatusType) GetBandwidth() string {
	if m != nil {
		return m.Bandwidth
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetConnectionName() string {
	if m != nil {
		return m.ConnectionName
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetConnectionState() string {
	if m != nil {
		return m.ConnectionState
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetHasLogicalRedundancy() string {
	if m != nil {
		return m.HasLogicalRedundancy
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetPartnerName() string {
	if m != nil {
		return m.PartnerName
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetProviderName() string {
	if m != nil {
		return m.ProviderName
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DirectConnectConnectionStatusType) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *DirectConnectConnectionStatusType) GetJumboFrameCapable() bool {
	if m != nil {
		return m.JumboFrameCapable
	}
	return false
}

func (m *DirectConnectConnectionStatusType) GetOwnerAccount() string {
	if m != nil {
		return m.OwnerAccount
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetVifStatus() *VirtualInterfaceStatusType {
	if m != nil {
		return m.VifStatus
	}
	return nil
}

func (m *DirectConnectConnectionStatusType) GetGatewayStatus() *DirectConnectGatewayStatusType {
	if m != nil {
		return m.GatewayStatus
	}
	return nil
}

func (m *DirectConnectConnectionStatusType) GetCoordinates() *Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *DirectConnectConnectionStatusType) GetAwsPath() string {
	if m != nil {
		return m.AwsPath
	}
	return ""
}

// Virtual Interface Status
//
// x-displayName: "Virtual Interface Status"
// Status reported by Amazon Web Services (AWS) Virtual Interface Status related to this Cloud Link
type VirtualInterfaceStatusType struct {
	// Address Family
	//
	// x-displayName: "Address Family"
	// The address family setup for the BGP peer.
	AddressFamily string `protobuf:"bytes,1,opt,name=address_family,json=addressFamily,proto3" json:"address_family,omitempty"`
	// AWS Router Peer IP
	//
	// x-displayName: "AWS Router Peer IP"
	// The BGP peer IP configured on the AWS endpoint
	AmazonAddress string `protobuf:"bytes,2,opt,name=amazon_address,json=amazonAddress,proto3" json:"amazon_address,omitempty"`
	// Amazon Web Services (AWS) ASN
	//
	// x-displayName: "Amazon Web Services (AWS) ASN"
	// The autonomous system number (ASN) for the Amazon side of the connection
	AmazonAsn uint64 `protobuf:"varint,3,opt,name=amazon_asn,json=amazonAsn,proto3" json:"amazon_asn,omitempty"`
	// Border Gateway Protocol (BGP) ASN
	//
	// x-displayName: "Border Gateway Protocol (BGP) ASN"
	// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration
	BgpAsn uint32 `protobuf:"varint,4,opt,name=bgp_asn,json=bgpAsn,proto3" json:"bgp_asn,omitempty"`
	// Connection Id
	//
	// x-displayName: "Connection Id"
	// The ID of the direct connect connection
	ConnectionId string `protobuf:"bytes,5,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	// Gateway Id
	//
	// x-displayName: "Gateway Id"
	// The ID of the direct connect gateway
	DirectConnectGatewayId string `protobuf:"bytes,6,opt,name=direct_connect_gateway_id,json=directConnectGatewayId,proto3" json:"direct_connect_gateway_id,omitempty"`
	// Gateway Name
	//
	// x-displayName: "Gateway Name"
	// The Name of the direct connect gateway
	DirectConnectGatewayName string `protobuf:"bytes,7,opt,name=direct_connect_gateway_name,json=directConnectGatewayName,proto3" json:"direct_connect_gateway_name,omitempty"`
	// Virtual Interface State
	//
	// x-displayName: "Virtual Interface State"
	// The state of the virtual interface
	VirtualInterfaceState string `protobuf:"bytes,8,opt,name=virtual_interface_state,json=virtualInterfaceState,proto3" json:"virtual_interface_state,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// Location where the virtual interface is located
	Location string `protobuf:"bytes,9,opt,name=location,proto3" json:"location,omitempty"`
	// Region
	//
	// x-displayName: "Region"
	// Region where the virtual interface is located
	Region string `protobuf:"bytes,10,opt,name=region,proto3" json:"region,omitempty"`
	// AWS Tags
	//
	// x-displayName: "AWS Tags"
	// x-example: "dev: staging"
	// AWS Tags is a label consisting of a user-defined key and value which are assocaited with this coonnection.
	// It helps to manage, identify, organize, search for, and filter resources in AWS console.
	Tags map[string]string `protobuf:"bytes,11,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Virtual Local Area Network (VLAN)
	//
	// x-displayName: "Virtual Local Area Network (VLAN)"
	// x-example: "700"
	// Virtual Local Area Network number for the new virtual interface to be configured on the AWS.
	Vlan uint32 `protobuf:"varint,12,opt,name=vlan,proto3" json:"vlan,omitempty"`
	// Virtual Interface Id
	//
	// x-displayName: "Virtual Interface Id"
	// ID of the virtual interface
	VirtualInterfaceId string `protobuf:"bytes,13,opt,name=virtual_interface_id,json=virtualInterfaceId,proto3" json:"virtual_interface_id,omitempty"`
	// Virtual Interface Name
	//
	// x-displayName: "Virtual Interface Name"
	// Name of the virtual interface
	VirtualInterfaceName string `protobuf:"bytes,14,opt,name=virtual_interface_name,json=virtualInterfaceName,proto3" json:"virtual_interface_name,omitempty"`
	// Virtual Interface Type
	//
	// x-displayName: "Virtual Interface Type"
	// Type of the virtual interface
	VirtualInterfaceType string `protobuf:"bytes,15,opt,name=virtual_interface_type,json=virtualInterfaceType,proto3" json:"virtual_interface_type,omitempty"`
	// BGP Peers
	//
	// x-displayName: "BGP Peers"
	// The BGP peers configured on this virtual interface.
	BgpPeers []*BGPPeerType `protobuf:"bytes,16,rep,name=bgp_peers,json=bgpPeers,proto3" json:"bgp_peers,omitempty"`
	// Jumbo Frame Capable
	//
	// x-displayName: "Jumbo Frame Capable"
	// Indicates whether jumbo frames (9001 MTU) are supported.
	JumboFrameCapable bool `protobuf:"varint,17,opt,name=jumbo_frame_capable,json=jumboFrameCapable,proto3" json:"jumbo_frame_capable,omitempty"`
	// Maximum Transmission Unit (MTU)
	//
	// x-displayName: "Maximum Transmission Unit (MTU)"
	// The maximum transmission unit (MTU), in bytes.
	Mtu uint32 `protobuf:"varint,18,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Owner Account
	//
	// x-displayName: "Owner Account"
	// The ID of the AWS account that owns the connection
	OwnerAccount string `protobuf:"bytes,19,opt,name=owner_account,json=ownerAccount,proto3" json:"owner_account,omitempty"`
	// Direct Connect Attachment State
	//
	// x-displayName: "Direct Connect  Attachment State"
	// The state of the Attachment.
	DirectConnectAttachmentState string `protobuf:"bytes,20,opt,name=direct_connect_attachment_state,json=directConnectAttachmentState,proto3" json:"direct_connect_attachment_state,omitempty"`
	// Gateway Attachment State Error
	//
	// x-displayName: "Gateway Attachment State Error"
	// The error message if the state of an object failed to advance.
	AttachmentStateChangeError string `protobuf:"bytes,21,opt,name=attachment_state_change_error,json=attachmentStateChangeError,proto3" json:"attachment_state_change_error,omitempty"`
	// AWS Object Link
	//
	// x-displayName: "AWS Object Link"
	// Link to Amazon Web Services (AWS) object
	AwsPath string `protobuf:"bytes,22,opt,name=aws_path,json=awsPath,proto3" json:"aws_path,omitempty"`
}

func (m *VirtualInterfaceStatusType) Reset()      { *m = VirtualInterfaceStatusType{} }
func (*VirtualInterfaceStatusType) ProtoMessage() {}
func (*VirtualInterfaceStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{5}
}
func (m *VirtualInterfaceStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualInterfaceStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VirtualInterfaceStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualInterfaceStatusType.Merge(m, src)
}
func (m *VirtualInterfaceStatusType) XXX_Size() int {
	return m.Size()
}
func (m *VirtualInterfaceStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualInterfaceStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualInterfaceStatusType proto.InternalMessageInfo

func (m *VirtualInterfaceStatusType) GetAddressFamily() string {
	if m != nil {
		return m.AddressFamily
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetAmazonAddress() string {
	if m != nil {
		return m.AmazonAddress
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetAmazonAsn() uint64 {
	if m != nil {
		return m.AmazonAsn
	}
	return 0
}

func (m *VirtualInterfaceStatusType) GetBgpAsn() uint32 {
	if m != nil {
		return m.BgpAsn
	}
	return 0
}

func (m *VirtualInterfaceStatusType) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetDirectConnectGatewayId() string {
	if m != nil {
		return m.DirectConnectGatewayId
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetDirectConnectGatewayName() string {
	if m != nil {
		return m.DirectConnectGatewayName
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetVirtualInterfaceState() string {
	if m != nil {
		return m.VirtualInterfaceState
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *VirtualInterfaceStatusType) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *VirtualInterfaceStatusType) GetVirtualInterfaceId() string {
	if m != nil {
		return m.VirtualInterfaceId
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetVirtualInterfaceName() string {
	if m != nil {
		return m.VirtualInterfaceName
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetVirtualInterfaceType() string {
	if m != nil {
		return m.VirtualInterfaceType
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetBgpPeers() []*BGPPeerType {
	if m != nil {
		return m.BgpPeers
	}
	return nil
}

func (m *VirtualInterfaceStatusType) GetJumboFrameCapable() bool {
	if m != nil {
		return m.JumboFrameCapable
	}
	return false
}

func (m *VirtualInterfaceStatusType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *VirtualInterfaceStatusType) GetOwnerAccount() string {
	if m != nil {
		return m.OwnerAccount
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetDirectConnectAttachmentState() string {
	if m != nil {
		return m.DirectConnectAttachmentState
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetAttachmentStateChangeError() string {
	if m != nil {
		return m.AttachmentStateChangeError
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetAwsPath() string {
	if m != nil {
		return m.AwsPath
	}
	return ""
}

// BGP Peer
//
// x-displayName: "BGP Peer"
// The BGP peer object.
type BGPPeerType struct {
	// Address Family
	//
	// x-displayName: "Address Family"
	// The address family setup for the BGP peer.
	AddressFamily string `protobuf:"bytes,1,opt,name=address_family,json=addressFamily,proto3" json:"address_family,omitempty"`
	// AWS Router Peer IP
	//
	// x-displayName: "AWS Router Peer IP"
	// The BGP peer IP configured on the AWS endpoint
	AmazonAddress string `protobuf:"bytes,2,opt,name=amazon_address,json=amazonAddress,proto3" json:"amazon_address,omitempty"`
	// Amazon Web Services (AWS) ASN
	//
	// x-displayName: "Amazon Web Services (AWS) ASN"
	// The autonomous system number (ASN) for the Amazon side of the connection
	Asn uint32 `protobuf:"varint,3,opt,name=asn,proto3" json:"asn,omitempty"`
	// BGP Peer IP
	//
	// x-displayName: "BGP Peer IP"
	// The ID of the BGP peer
	BgpPeerId string `protobuf:"bytes,4,opt,name=bgp_peer_id,json=bgpPeerId,proto3" json:"bgp_peer_id,omitempty"`
	// BGP Peer State
	//
	// x-displayName: "BGP Peer State"
	// The state of the BGP peer.
	BgpPeerState string `protobuf:"bytes,5,opt,name=bgp_peer_state,json=bgpPeerState,proto3" json:"bgp_peer_state,omitempty"`
	// BGP Peer Status
	//
	// x-displayName: "BGP Peer Status"
	// The status of the BGP peer.
	BgpStatus string `protobuf:"bytes,6,opt,name=bgp_status,json=bgpStatus,proto3" json:"bgp_status,omitempty"`
	// Customer Peer IP
	//
	// x-displayName: "Customer Peer IP"
	// The BGP peer IP configured on the Customer endpoint
	CustomerAddress string `protobuf:"bytes,7,opt,name=customer_address,json=customerAddress,proto3" json:"customer_address,omitempty"`
}

func (m *BGPPeerType) Reset()      { *m = BGPPeerType{} }
func (*BGPPeerType) ProtoMessage() {}
func (*BGPPeerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{6}
}
func (m *BGPPeerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BGPPeerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerType.Merge(m, src)
}
func (m *BGPPeerType) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerType) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerType.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerType proto.InternalMessageInfo

func (m *BGPPeerType) GetAddressFamily() string {
	if m != nil {
		return m.AddressFamily
	}
	return ""
}

func (m *BGPPeerType) GetAmazonAddress() string {
	if m != nil {
		return m.AmazonAddress
	}
	return ""
}

func (m *BGPPeerType) GetAsn() uint32 {
	if m != nil {
		return m.Asn
	}
	return 0
}

func (m *BGPPeerType) GetBgpPeerId() string {
	if m != nil {
		return m.BgpPeerId
	}
	return ""
}

func (m *BGPPeerType) GetBgpPeerState() string {
	if m != nil {
		return m.BgpPeerState
	}
	return ""
}

func (m *BGPPeerType) GetBgpStatus() string {
	if m != nil {
		return m.BgpStatus
	}
	return ""
}

func (m *BGPPeerType) GetCustomerAddress() string {
	if m != nil {
		return m.CustomerAddress
	}
	return ""
}

// Direct Connect Gateway Status
//
// x-displayName: "Direct Connect Gateway Status"
// Status reported by Amazon Web Services (AWS) Direct Connect Gateway Status and associations related to this Cloud Link
type DirectConnectGatewayStatusType struct {
	// Amazon Web Services (AWS) ASN
	//
	// x-displayName: "Amazon Web Services (AWS) ASN"
	// The autonomous system number (ASN) for the Amazon side of the connection
	AmazonAsn uint64 `protobuf:"varint,1,opt,name=amazon_asn,json=amazonAsn,proto3" json:"amazon_asn,omitempty"`
	// Gateway Id
	//
	// x-displayName: "Gateway Id"
	// The ID of the direct connect gateway
	DirectConnectGatewayId string `protobuf:"bytes,2,opt,name=direct_connect_gateway_id,json=directConnectGatewayId,proto3" json:"direct_connect_gateway_id,omitempty"`
	// Gateway Name
	//
	// x-displayName: "Gateway Name"
	// The Name of the direct connect gateway
	DirectConnectGatewayName string `protobuf:"bytes,3,opt,name=direct_connect_gateway_name,json=directConnectGatewayName,proto3" json:"direct_connect_gateway_name,omitempty"`
	// Direct Connect Gateway State
	//
	// x-displayName: "Direct Connect Gateway State"
	// The state of the Direct Connect gateway
	DirectConnectGatewayState string `protobuf:"bytes,4,opt,name=direct_connect_gateway_state,json=directConnectGatewayState,proto3" json:"direct_connect_gateway_state,omitempty"`
	// Direct Connect Gateway Error
	//
	// x-displayName: "Direct Connect Gateway Error"
	// The error message if the state of an object failed to advance
	StateChangeError string `protobuf:"bytes,6,opt,name=state_change_error,json=stateChangeError,proto3" json:"state_change_error,omitempty"`
	// Owner Account
	//
	// x-displayName: "Owner Account"
	// The ID of the AWS account that owns the connection
	OwnerAccount string `protobuf:"bytes,7,opt,name=owner_account,json=ownerAccount,proto3" json:"owner_account,omitempty"`
	// AWS Object Link
	//
	// x-displayName: "AWS Object Link"
	// Link to Amazon Web Services (AWS) object
	AwsPath string `protobuf:"bytes,8,opt,name=aws_path,json=awsPath,proto3" json:"aws_path,omitempty"`
}

func (m *DirectConnectGatewayStatusType) Reset()      { *m = DirectConnectGatewayStatusType{} }
func (*DirectConnectGatewayStatusType) ProtoMessage() {}
func (*DirectConnectGatewayStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{7}
}
func (m *DirectConnectGatewayStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectConnectGatewayStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DirectConnectGatewayStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectConnectGatewayStatusType.Merge(m, src)
}
func (m *DirectConnectGatewayStatusType) XXX_Size() int {
	return m.Size()
}
func (m *DirectConnectGatewayStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectConnectGatewayStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_DirectConnectGatewayStatusType proto.InternalMessageInfo

func (m *DirectConnectGatewayStatusType) GetAmazonAsn() uint64 {
	if m != nil {
		return m.AmazonAsn
	}
	return 0
}

func (m *DirectConnectGatewayStatusType) GetDirectConnectGatewayId() string {
	if m != nil {
		return m.DirectConnectGatewayId
	}
	return ""
}

func (m *DirectConnectGatewayStatusType) GetDirectConnectGatewayName() string {
	if m != nil {
		return m.DirectConnectGatewayName
	}
	return ""
}

func (m *DirectConnectGatewayStatusType) GetDirectConnectGatewayState() string {
	if m != nil {
		return m.DirectConnectGatewayState
	}
	return ""
}

func (m *DirectConnectGatewayStatusType) GetStateChangeError() string {
	if m != nil {
		return m.StateChangeError
	}
	return ""
}

func (m *DirectConnectGatewayStatusType) GetOwnerAccount() string {
	if m != nil {
		return m.OwnerAccount
	}
	return ""
}

func (m *DirectConnectGatewayStatusType) GetAwsPath() string {
	if m != nil {
		return m.AwsPath
	}
	return ""
}

// Connection Coordinates
//
// x-displayName: "Connection Coordinates"
// Coordinates of the Direct Connect Connection location
type Coordinates struct {
	// latitude
	//
	// x-displayName: "Latitude"
	// x-example: "10.0"
	// Latitude of the Direct Connect Connection location
	Latitude float32 `protobuf:"fixed32,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// longitude
	//
	// x-displayName: "Longitude"
	// x-example: "20.0"
	// longitude of Direct Connect Connection location
	Longitude float32 `protobuf:"fixed32,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
}

func (m *Coordinates) Reset()      { *m = Coordinates{} }
func (*Coordinates) ProtoMessage() {}
func (*Coordinates) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{8}
}
func (m *Coordinates) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Coordinates) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Coordinates) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Coordinates.Merge(m, src)
}
func (m *Coordinates) XXX_Size() int {
	return m.Size()
}
func (m *Coordinates) XXX_DiscardUnknown() {
	xxx_messageInfo_Coordinates.DiscardUnknown(m)
}

var xxx_messageInfo_Coordinates proto.InternalMessageInfo

func (m *Coordinates) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Coordinates) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

// Azure Cloud Link Status
//
// x-displayName: "Azure Cloud Link Status"
// Status reported by associated Azure cloud components
type AzureStatusType struct {
}

func (m *AzureStatusType) Reset()      { *m = AzureStatusType{} }
func (*AzureStatusType) ProtoMessage() {}
func (*AzureStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{9}
}
func (m *AzureStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureStatusType.Merge(m, src)
}
func (m *AzureStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AzureStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureStatusType proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Object)(nil), "ves.io.schema.cloud_link.Object")
	golang_proto.RegisterType((*Object)(nil), "ves.io.schema.cloud_link.Object")
	proto.RegisterType((*SpecType)(nil), "ves.io.schema.cloud_link.SpecType")
	golang_proto.RegisterType((*SpecType)(nil), "ves.io.schema.cloud_link.SpecType")
	proto.RegisterType((*StatusObject)(nil), "ves.io.schema.cloud_link.StatusObject")
	golang_proto.RegisterType((*StatusObject)(nil), "ves.io.schema.cloud_link.StatusObject")
	proto.RegisterType((*AWSStatusType)(nil), "ves.io.schema.cloud_link.AWSStatusType")
	golang_proto.RegisterType((*AWSStatusType)(nil), "ves.io.schema.cloud_link.AWSStatusType")
	proto.RegisterType((*DirectConnectConnectionStatusType)(nil), "ves.io.schema.cloud_link.DirectConnectConnectionStatusType")
	golang_proto.RegisterType((*DirectConnectConnectionStatusType)(nil), "ves.io.schema.cloud_link.DirectConnectConnectionStatusType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_link.DirectConnectConnectionStatusType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_link.DirectConnectConnectionStatusType.TagsEntry")
	proto.RegisterType((*VirtualInterfaceStatusType)(nil), "ves.io.schema.cloud_link.VirtualInterfaceStatusType")
	golang_proto.RegisterType((*VirtualInterfaceStatusType)(nil), "ves.io.schema.cloud_link.VirtualInterfaceStatusType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_link.VirtualInterfaceStatusType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_link.VirtualInterfaceStatusType.TagsEntry")
	proto.RegisterType((*BGPPeerType)(nil), "ves.io.schema.cloud_link.BGPPeerType")
	golang_proto.RegisterType((*BGPPeerType)(nil), "ves.io.schema.cloud_link.BGPPeerType")
	proto.RegisterType((*DirectConnectGatewayStatusType)(nil), "ves.io.schema.cloud_link.DirectConnectGatewayStatusType")
	golang_proto.RegisterType((*DirectConnectGatewayStatusType)(nil), "ves.io.schema.cloud_link.DirectConnectGatewayStatusType")
	proto.RegisterType((*Coordinates)(nil), "ves.io.schema.cloud_link.Coordinates")
	golang_proto.RegisterType((*Coordinates)(nil), "ves.io.schema.cloud_link.Coordinates")
	proto.RegisterType((*AzureStatusType)(nil), "ves.io.schema.cloud_link.AzureStatusType")
	golang_proto.RegisterType((*AzureStatusType)(nil), "ves.io.schema.cloud_link.AzureStatusType")
}

func init() {
	proto.RegisterFile("ves.io/schema/cloud_link/object.proto", fileDescriptor_c87a7a97fd6ae754)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/cloud_link/object.proto", fileDescriptor_c87a7a97fd6ae754)
}

var fileDescriptor_c87a7a97fd6ae754 = []byte{
	// 1926 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4f, 0x6c, 0x1b, 0xc7,
	0xf5, 0xe6, 0x8a, 0x94, 0xc4, 0x7d, 0xfc, 0x23, 0x6a, 0x2c, 0x2b, 0x2b, 0x46, 0x66, 0x68, 0x3a,
	0xfe, 0x59, 0xfe, 0xc1, 0xa2, 0x6a, 0x57, 0x48, 0x63, 0xb5, 0x75, 0x21, 0x2a, 0x8e, 0xa2, 0xc0,
	0x76, 0x8c, 0x55, 0x5a, 0x21, 0x45, 0x51, 0x62, 0xb8, 0x3b, 0x5c, 0x6e, 0xb4, 0xdc, 0xd9, 0xce,
	0xce, 0x52, 0x51, 0x80, 0x02, 0xbd, 0xb5, 0x87, 0x1c, 0xda, 0x4b, 0x51, 0x14, 0x3d, 0xf5, 0x92,
	0xa2, 0xbd, 0xe6, 0x54, 0x5f, 0x12, 0xf7, 0x52, 0xe4, 0x64, 0xf4, 0xe4, 0x63, 0x2d, 0x5f, 0x5a,
	0xf4, 0x12, 0xf4, 0x5e, 0xa0, 0x98, 0xd9, 0x5d, 0x72, 0xb9, 0x24, 0x6d, 0xa3, 0x2e, 0x7a, 0x11,
	0x66, 0xdf, 0xfb, 0xde, 0x37, 0x33, 0x6f, 0xde, 0xfb, 0x66, 0x44, 0xb8, 0x3c, 0x20, 0x7e, 0xd3,
	0xa6, 0x5b, 0xbe, 0xd1, 0x23, 0x7d, 0xbc, 0x65, 0x38, 0x34, 0x30, 0xdb, 0x8e, 0xed, 0x1e, 0x6f,
	0xd1, 0xce, 0x87, 0xc4, 0xe0, 0x4d, 0x8f, 0x51, 0x4e, 0x91, 0x16, 0xc2, 0x9a, 0x21, 0xac, 0x39,
	0x82, 0x55, 0x37, 0x2d, 0x9b, 0xf7, 0x82, 0x4e, 0xd3, 0xa0, 0xfd, 0x2d, 0x8b, 0x5a, 0x74, 0x4b,
	0x06, 0x74, 0x82, 0xae, 0xfc, 0x92, 0x1f, 0x72, 0x14, 0x12, 0x55, 0x5f, 0x9f, 0x39, 0x1f, 0x3f,
	0xf5, 0x88, 0x1f, 0xa1, 0x5e, 0x1d, 0x47, 0x51, 0x8f, 0xdb, 0xd4, 0x8d, 0x9d, 0x6b, 0xe3, 0xce,
	0x64, 0xdc, 0xfa, 0xb8, 0x6b, 0x80, 0x1d, 0xdb, 0xc4, 0x9c, 0x44, 0xde, 0x46, 0xca, 0x4b, 0x7c,
	0xe2, 0x0e, 0x52, 0xe4, 0xf5, 0x14, 0xc6, 0x26, 0x27, 0xed, 0x71, 0xc4, 0x6b, 0x93, 0x08, 0x3f,
	0xb9, 0x88, 0xc6, 0x3f, 0x14, 0x58, 0x78, 0x4f, 0x26, 0x0f, 0xdd, 0x84, 0x7c, 0x9f, 0x70, 0x6c,
	0x62, 0x8e, 0x35, 0xa5, 0xae, 0x6c, 0x14, 0x6e, 0x5c, 0x68, 0x8e, 0x67, 0x32, 0x04, 0xde, 0x25,
	0x1c, 0xbf, 0x7f, 0xea, 0x11, 0x7d, 0x08, 0x47, 0x77, 0x60, 0xc9, 0x3f, 0xf5, 0x39, 0xe9, 0xb7,
	0x87, 0x0c, 0x73, 0x92, 0xe1, 0x52, 0x8a, 0xe1, 0x50, 0xa2, 0x52, 0x3c, 0xe5, 0x30, 0xf6, 0x6e,
	0xcc, 0xf6, 0x06, 0xe4, 0x7c, 0x8f, 0x18, 0x5a, 0x56, 0x52, 0x34, 0x9a, 0xb3, 0x8e, 0xb3, 0x79,
	0xe8, 0x11, 0x43, 0x32, 0x48, 0xfc, 0x4e, 0xfd, 0xd7, 0xdf, 0x99, 0x37, 0x49, 0x9f, 0x5e, 0x7f,
	0xf8, 0x85, 0x36, 0x57, 0x51, 0xbe, 0xfc, 0x42, 0x2b, 0x0f, 0x88, 0xbf, 0x69, 0xd3, 0x4d, 0x97,
	0xf0, 0x13, 0xca, 0x8e, 0x1b, 0x77, 0x21, 0x1f, 0xc7, 0xa0, 0x5d, 0x58, 0xb4, 0x8c, 0xb6, 0x9c,
	0x28, 0x5c, 0xeb, 0xc6, 0xec, 0x89, 0xf6, 0x1d, 0xda, 0xc1, 0xce, 0x70, 0xba, 0x05, 0xcb, 0x10,
	0xe3, 0xc6, 0x1f, 0xb2, 0x50, 0x3c, 0xe4, 0x98, 0x07, 0xfe, 0x0b, 0xa7, 0x30, 0x84, 0x4f, 0x4d,
	0x61, 0x21, 0x2c, 0xe2, 0x36, 0x23, 0x5d, 0x5f, 0x9b, 0xab, 0x67, 0x37, 0x0a, 0x37, 0xd6, 0xa7,
	0x1e, 0x80, 0x4e, 0xba, 0x22, 0xb8, 0x55, 0xfa, 0xfd, 0x8f, 0x61, 0xb4, 0x48, 0x1d, 0x68, 0xec,
	0xf5, 0xd1, 0xb7, 0x00, 0x0c, 0xea, 0x9a, 0xb6, 0xac, 0x05, 0x2d, 0x3b, 0x95, 0x6c, 0x2f, 0x06,
	0xc8, 0x95, 0x24, 0xf0, 0xe8, 0x1d, 0x00, 0x7c, 0xe2, 0xb7, 0x7d, 0xb9, 0x56, 0x6d, 0x5e, 0x6e,
	0xe4, 0xca, 0xec, 0xec, 0xec, 0x1e, 0x1d, 0x86, 0xdb, 0x12, 0x44, 0xef, 0x64, 0x74, 0x15, 0x9f,
	0xf8, 0xa1, 0x01, 0xdd, 0x83, 0x22, 0xfe, 0x38, 0x60, 0x24, 0xe6, 0x5a, 0x90, 0x5c, 0x57, 0x9f,
	0xc1, 0x25, 0xd0, 0x63, 0x6c, 0x05, 0x3c, 0x32, 0xed, 0xac, 0xfd, 0xe5, 0x56, 0x05, 0xca, 0x50,
	0x8c, 0xd3, 0xd6, 0x0c, 0x6c, 0xf3, 0x9f, 0xb7, 0xb2, 0xd7, 0xaf, 0x6d, 0xb7, 0xd6, 0x60, 0x79,
	0xc4, 0x13, 0xcd, 0x87, 0x72, 0x8f, 0x1e, 0x28, 0xb9, 0x77, 0x73, 0xf9, 0x5c, 0x65, 0xbe, 0xf1,
	0x1b, 0x05, 0x4a, 0x63, 0x4b, 0x45, 0x3d, 0x58, 0x36, 0xa8, 0xeb, 0x12, 0x43, 0x6c, 0x3b, 0x5e,
	0x62, 0x98, 0xf9, 0x6f, 0xce, 0x5e, 0xe2, 0x5b, 0x36, 0x23, 0x06, 0xdf, 0x0b, 0x03, 0xf7, 0x86,
	0xf1, 0x23, 0x5e, 0xbd, 0x62, 0xa4, 0xac, 0x3b, 0xe7, 0x1f, 0x3e, 0x50, 0x96, 0x61, 0x09, 0x60,
	0xf7, 0xe8, 0xb0, 0x1e, 0xe5, 0x46, 0xb9, 0xf1, 0x6e, 0x2e, 0x9f, 0xad, 0xc4, 0xcb, 0xfb, 0x54,
	0x85, 0x8b, 0xcf, 0xa5, 0x46, 0xeb, 0xa0, 0x76, 0xb0, 0x6b, 0x9e, 0xd8, 0x26, 0xef, 0xc9, 0x12,
	0x53, 0xf5, 0x91, 0x01, 0x5d, 0x82, 0x52, 0x62, 0x43, 0xb6, 0x29, 0x2b, 0x5b, 0xd5, 0x8b, 0x23,
	0xe3, 0x81, 0x89, 0xae, 0xc0, 0x52, 0x02, 0xe4, 0xe2, 0x3e, 0x91, 0x9d, 0xa6, 0xea, 0xe5, 0x91,
	0xf9, 0x1e, 0xee, 0x13, 0xf4, 0x53, 0x05, 0x2a, 0xa9, 0xfc, 0x10, 0x2d, 0x27, 0xa0, 0xad, 0x1f,
	0xfc, 0xf1, 0xef, 0x9f, 0x67, 0x8f, 0xd8, 0x77, 0xf5, 0x3c, 0x65, 0x26, 0x61, 0xb6, 0x6b, 0xe9,
	0x2a, 0x23, 0x3f, 0x0a, 0x88, 0xcf, 0x89, 0xa9, 0x2f, 0x7a, 0xc4, 0x35, 0xa5, 0x0d, 0x0f, 0xb0,
	0xed, 0xe0, 0x8e, 0x43, 0xf4, 0x9c, 0x49, 0x4f, 0x5c, 0x3d, 0x6f, 0x12, 0x87, 0x70, 0xe1, 0x5a,
	0x94, 0x23, 0x62, 0xea, 0x79, 0x46, 0x44, 0xd9, 0x8a, 0xb0, 0xc0, 0x3d, 0x76, 0x05, 0x6a, 0x69,
	0x3c, 0x7f, 0x04, 0xbd, 0x07, 0xab, 0x3d, 0xec, 0xb7, 0x1d, 0x6a, 0xd9, 0x06, 0x76, 0xda, 0x8c,
	0x98, 0x81, 0x6b, 0x62, 0xd7, 0x38, 0x95, 0xc5, 0xa9, 0xb6, 0xd6, 0xc4, 0x72, 0x56, 0x18, 0x1a,
	0x51, 0x64, 0x4f, 0x89, 0xaf, 0xcf, 0xb9, 0x54, 0x5f, 0xe9, 0x61, 0xff, 0x4e, 0x18, 0xa7, 0x0f,
	0xc3, 0x50, 0x15, 0xf2, 0x0e, 0x35, 0xb0, 0x98, 0x41, 0xd6, 0xa4, 0xaa, 0x0f, 0xbf, 0xd1, 0x45,
	0x28, 0x7a, 0x98, 0x71, 0x97, 0xb0, 0x30, 0x39, 0x8b, 0xd2, 0x5f, 0x88, 0x6c, 0x32, 0x33, 0x97,
	0xa0, 0xe4, 0x31, 0x3a, 0xb0, 0xcd, 0x18, 0x93, 0x0f, 0xf3, 0x1c, 0x1b, 0x25, 0x68, 0x15, 0x16,
	0x18, 0xb1, 0xc4, 0x0c, 0xaa, 0xf4, 0x46, 0x5f, 0xe8, 0x03, 0xc8, 0x71, 0x6c, 0xf9, 0x1a, 0xc8,
	0x42, 0xbb, 0xfd, 0x12, 0x85, 0xd6, 0x7c, 0x1f, 0x5b, 0xfe, 0x6d, 0x97, 0xb3, 0x53, 0x5d, 0x52,
	0x22, 0x04, 0xb9, 0x81, 0x83, 0x5d, 0xad, 0x50, 0x57, 0x36, 0x4a, 0xba, 0x1c, 0xa3, 0x26, 0x9c,
	0xfb, 0x30, 0xe8, 0x77, 0x68, 0xbb, 0xcb, 0x70, 0x9f, 0xb4, 0x0d, 0xec, 0x89, 0xf3, 0xd0, 0x8a,
	0x75, 0x65, 0x23, 0xaf, 0x2f, 0x4b, 0xd7, 0xdb, 0xc2, 0xb3, 0x17, 0x3a, 0xc4, 0xde, 0xe8, 0x89,
	0xd8, 0x3c, 0x36, 0x0c, 0x1a, 0xb8, 0x5c, 0x2b, 0x85, 0x7b, 0x93, 0xc6, 0xdd, 0xd0, 0x86, 0x0e,
	0x01, 0x06, 0x76, 0x37, 0x6e, 0x99, 0xb2, 0xec, 0xea, 0xed, 0xd9, 0x3b, 0xf9, 0x9e, 0xcd, 0x78,
	0x80, 0x9d, 0x03, 0x97, 0x13, 0xd6, 0xc5, 0x46, 0xa2, 0xc1, 0x75, 0x75, 0x60, 0x77, 0xa3, 0x86,
	0x68, 0x43, 0xd9, 0xc2, 0x9c, 0x9c, 0xe0, 0xd3, 0x98, 0x78, 0x49, 0x12, 0xbf, 0xf9, 0x82, 0x29,
	0xda, 0x0f, 0x83, 0x13, 0xe4, 0x25, 0x2b, 0x69, 0x42, 0xfb, 0x50, 0x30, 0x28, 0x65, 0xa6, 0xed,
	0x62, 0x4e, 0x7c, 0xad, 0x22, 0xd9, 0x2f, 0xcf, 0x66, 0xdf, 0x1b, 0x81, 0xf5, 0x64, 0x24, 0x5a,
	0x83, 0xbc, 0x10, 0x48, 0x0f, 0xf3, 0x9e, 0xb6, 0x2c, 0xd3, 0xb3, 0x88, 0x4f, 0xfc, 0xfb, 0x98,
	0xf7, 0xaa, 0xdf, 0x00, 0x75, 0x78, 0x2a, 0xa8, 0x02, 0xd9, 0x63, 0x72, 0x1a, 0xf5, 0xa9, 0x18,
	0xa2, 0x15, 0x98, 0x1f, 0x60, 0x27, 0x20, 0x51, 0x67, 0x86, 0x1f, 0x3b, 0x73, 0x6f, 0x2a, 0x3b,
	0x9f, 0x2a, 0x5f, 0x3e, 0x50, 0x7e, 0xab, 0x40, 0x1d, 0x4a, 0xa3, 0xb3, 0xae, 0x1f, 0xbc, 0x55,
	0x5d, 0x4a, 0x35, 0x35, 0xbc, 0x0e, 0x4b, 0x09, 0x84, 0xa8, 0xb5, 0xea, 0xf2, 0x44, 0x4f, 0xc3,
	0xff, 0x41, 0x25, 0x81, 0x92, 0x7d, 0x54, 0x45, 0x93, 0x0d, 0x0d, 0x1a, 0xa8, 0xad, 0x58, 0x40,
	0xaa, 0x85, 0x84, 0xbc, 0xc0, 0x2a, 0xe4, 0xef, 0x44, 0x4d, 0x51, 0x85, 0x51, 0xc3, 0x34, 0x7e,
	0x06, 0x50, 0x9d, 0x7d, 0xa2, 0x68, 0x07, 0xca, 0xd8, 0x34, 0x19, 0xf1, 0xfd, 0x76, 0x17, 0xf7,
	0x6d, 0x27, 0xda, 0x7f, 0xeb, 0x9c, 0x68, 0xd2, 0x32, 0x2b, 0xea, 0x39, 0xdb, 0x1b, 0x6c, 0xcb,
	0xbf, 0x6f, 0xe8, 0xa5, 0x08, 0xfa, 0xb6, 0x44, 0xa2, 0xcb, 0x50, 0xc6, 0x7d, 0xfc, 0x31, 0x75,
	0xdb, 0x91, 0x3d, 0xca, 0x53, 0x29, 0xb4, 0xee, 0x86, 0x46, 0x74, 0x01, 0x20, 0x86, 0xf9, 0xae,
	0x54, 0xaf, 0x9c, 0xae, 0x46, 0x10, 0xdf, 0x45, 0xaf, 0xc0, 0x62, 0xc7, 0xf2, 0xa4, 0x2f, 0x27,
	0x3b, 0x61, 0xa1, 0x63, 0x79, 0xc2, 0x31, 0xa1, 0x8f, 0xf3, 0x53, 0xf4, 0xf1, 0x26, 0xac, 0x99,
	0xb2, 0xac, 0xda, 0x91, 0xb9, 0x1d, 0x57, 0xa5, 0x6d, 0x46, 0x62, 0xb1, 0x6a, 0x4e, 0xa9, 0xbb,
	0x03, 0x13, 0x7d, 0x1b, 0x5e, 0x9d, 0x11, 0x9a, 0x50, 0x12, 0x6d, 0x5a, 0xb0, 0x54, 0x8c, 0x5f,
	0x2a, 0xf0, 0xca, 0x20, 0x4c, 0x6c, 0xdb, 0x8e, 0x33, 0x1b, 0xe9, 0xae, 0x54, 0x98, 0xd6, 0x0f,
	0x45, 0x0e, 0x3f, 0x60, 0x47, 0xf2, 0xba, 0xee, 0xda, 0xac, 0x2f, 0x55, 0x76, 0x40, 0x98, 0xdd,
	0x3d, 0x95, 0xaa, 0xfa, 0x92, 0xca, 0x7b, 0x7e, 0x30, 0xe5, 0x5c, 0xc9, 0x98, 0x5c, 0xaa, 0x29,
	0xb9, 0x1c, 0xc9, 0x1c, 0x8c, 0xc9, 0x9c, 0x1e, 0xc9, 0x5c, 0x41, 0xca, 0xdc, 0xad, 0xff, 0x44,
	0x1c, 0x66, 0xea, 0x5b, 0x31, 0xa1, 0x6f, 0x5f, 0x83, 0x95, 0xc9, 0x9c, 0xd9, 0x66, 0x24, 0x5b,
	0x28, 0xbd, 0xa1, 0x03, 0x13, 0x6d, 0xc3, 0xea, 0x64, 0x84, 0x3c, 0xa0, 0xb2, 0x8c, 0x59, 0x49,
	0xc7, 0xc8, 0xc3, 0x39, 0x9a, 0x16, 0x25, 0x9e, 0xd2, 0x52, 0xa5, 0xd4, 0xd6, 0x45, 0x71, 0x34,
	0xeb, 0xac, 0xaa, 0x2f, 0x7a, 0xcc, 0x1e, 0x60, 0x4e, 0xf4, 0x05, 0x2f, 0xe8, 0x38, 0xb6, 0xa1,
	0x2f, 0x72, 0x86, 0x5d, 0xdf, 0xe6, 0x93, 0xc4, 0xb2, 0x5f, 0x5a, 0xa0, 0x8a, 0x6a, 0xf5, 0x08,
	0x61, 0x42, 0x93, 0xb2, 0xcf, 0xd6, 0xa4, 0xd6, 0xfe, 0xfd, 0xfb, 0x84, 0xb0, 0xf0, 0xf5, 0xd8,
	0xb1, 0x3c, 0xf1, 0xe1, 0xcf, 0x12, 0xf9, 0xe5, 0x59, 0x22, 0x5f, 0x81, 0x6c, 0x9f, 0x07, 0x1a,
	0x92, 0x79, 0x14, 0xc3, 0x49, 0xd9, 0x3f, 0x37, 0x45, 0xf6, 0x3f, 0x82, 0xd7, 0x52, 0xf5, 0x8d,
	0x39, 0xc7, 0x46, 0xaf, 0x4f, 0x5c, 0x1e, 0xd5, 0xe9, 0x8a, 0x4c, 0xc6, 0x75, 0x91, 0x8c, 0x6b,
	0xec, 0xff, 0x75, 0x35, 0x04, 0x88, 0xba, 0xcb, 0x87, 0x43, 0x62, 0xea, 0xaa, 0x49, 0x86, 0xc6,
	0x70, 0x48, 0x4c, 0x7d, 0x7d, 0xac, 0x2d, 0x76, 0x87, 0xbc, 0x61, 0x05, 0xee, 0xc2, 0x85, 0xf4,
	0x54, 0x6d, 0xa3, 0x87, 0x5d, 0x8b, 0xb4, 0x09, 0x63, 0x94, 0x69, 0xe7, 0xe5, 0x72, 0xab, 0x78,
	0x3c, 0x6e, 0x4f, 0x42, 0x6e, 0x0b, 0xc4, 0x98, 0x68, 0xaf, 0xfe, 0x77, 0x44, 0xbb, 0xf1, 0xaf,
	0x2c, 0x14, 0x12, 0x27, 0xf2, 0xbf, 0xd0, 0xbe, 0x0a, 0x64, 0x63, 0xd1, 0x2b, 0xe9, 0x62, 0x88,
	0x6a, 0x50, 0x88, 0x0b, 0x48, 0x14, 0x7e, 0x2e, 0x7a, 0x15, 0x86, 0xb5, 0x71, 0x60, 0x8a, 0x7b,
	0x75, 0xe8, 0x0f, 0x0f, 0x29, 0x7c, 0x35, 0xdd, 0x14, 0x8b, 0xda, 0x66, 0x37, 0x9e, 0x27, 0x20,
	0x53, 0xa4, 0xa3, 0x18, 0xb1, 0x87, 0x87, 0x73, 0x13, 0x40, 0x4c, 0x90, 0x78, 0xe3, 0xab, 0xad,
	0xaa, 0x20, 0x3f, 0xcf, 0xce, 0xe9, 0x73, 0x81, 0x17, 0x49, 0xd0, 0x50, 0x65, 0xc4, 0xda, 0xa2,
	0x2b, 0xf9, 0x2a, 0x54, 0x8c, 0xc0, 0xe7, 0xb4, 0x2f, 0x2a, 0x2f, 0xda, 0x76, 0x28, 0x93, 0x4b,
	0xb1, 0x3d, 0xda, 0xf8, 0xce, 0x2f, 0xc4, 0x05, 0xf9, 0x89, 0x02, 0x0d, 0x28, 0xef, 0xca, 0x8c,
	0xd4, 0x23, 0x4f, 0xb5, 0x92, 0xce, 0x9c, 0xbc, 0xfc, 0xa2, 0xf0, 0x21, 0x0a, 0x4d, 0x4e, 0x25,
	0xb8, 0x5a, 0xfb, 0xf7, 0xeb, 0x62, 0x2b, 0xd1, 0x15, 0x59, 0x49, 0x27, 0x0b, 0xaa, 0x00, 0x02,
	0x13, 0x2e, 0xb8, 0x5a, 0x4c, 0xee, 0xb5, 0xf1, 0xab, 0x2c, 0xd4, 0x9e, 0xfd, 0x06, 0x49, 0xdd,
	0x55, 0x4a, 0xfa, 0xae, 0x7a, 0xe6, 0x6d, 0x33, 0xf7, 0x32, 0xb7, 0x4d, 0xf6, 0x39, 0xb7, 0x0d,
	0x85, 0xf5, 0x19, 0xe1, 0xc9, 0x97, 0x7e, 0x53, 0x9c, 0xe3, 0x55, 0x76, 0xe5, 0x45, 0x2b, 0x63,
	0xcd, 0x9c, 0x91, 0x0e, 0x82, 0xae, 0x01, 0x9a, 0xd2, 0xb8, 0xe1, 0x8d, 0x5a, 0xf1, 0xd3, 0xed,
	0x3a, 0x21, 0x48, 0x8b, 0x53, 0x04, 0x29, 0xd9, 0xd3, 0xf9, 0xb1, 0x9e, 0x6e, 0xf4, 0xa1, 0x90,
	0x78, 0xbf, 0xa1, 0x4d, 0xc8, 0x3b, 0x98, 0xdb, 0x3c, 0x30, 0x89, 0x3c, 0x84, 0xb9, 0xd6, 0xb2,
	0xd8, 0x59, 0x11, 0xe0, 0x42, 0x26, 0xf3, 0x59, 0x6b, 0x33, 0x93, 0xf9, 0xec, 0xa1, 0x3e, 0x84,
	0xa0, 0x2d, 0x50, 0x1d, 0xea, 0x5a, 0x21, 0x7e, 0x2e, 0x8d, 0xdf, 0xde, 0xdb, 0xcc, 0x64, 0xb6,
	0xff, 0xa4, 0x8f, 0x30, 0x8d, 0x65, 0x58, 0x4a, 0xfd, 0xef, 0xda, 0xfa, 0x44, 0x79, 0xf4, 0xa4,
	0x96, 0x79, 0xfc, 0xa4, 0x96, 0xf9, 0xea, 0x49, 0x4d, 0xf9, 0xc9, 0x59, 0x4d, 0xf9, 0xdd, 0x59,
	0x4d, 0xf9, 0xf3, 0x59, 0x4d, 0x79, 0x74, 0x56, 0x53, 0x1e, 0x9f, 0xd5, 0x94, 0xbf, 0x9e, 0xd5,
	0x94, 0xbf, 0x9d, 0xd5, 0x32, 0x5f, 0x9d, 0xd5, 0x94, 0x9f, 0x3f, 0xad, 0x65, 0x3e, 0x7f, 0x5a,
	0x53, 0x1e, 0x3d, 0xad, 0x65, 0x1e, 0x3f, 0xad, 0x65, 0xbe, 0x7f, 0xcf, 0xa2, 0xde, 0xb1, 0xd5,
	0x1c, 0x50, 0x87, 0x13, 0xc6, 0x70, 0x33, 0xf0, 0xb7, 0xe4, 0xa0, 0x4b, 0x59, 0x7f, 0x33, 0xfe,
	0x4f, 0x63, 0x33, 0x76, 0x6f, 0x79, 0x1d, 0x8b, 0x6e, 0x91, 0x8f, 0x78, 0xf4, 0x53, 0xcf, 0xc4,
	0x6f, 0x56, 0x9d, 0x05, 0xf9, 0x8b, 0xcf, 0xd7, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xdc, 0x0c,
	0xc2, 0x59, 0x46, 0x13, 0x00, 0x00,
}

func (this *Object) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Object)
	if !ok {
		that2, ok := that.(Object)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.SystemMetadata.Equal(that1.SystemMetadata) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *SpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpecType)
	if !ok {
		that2, ok := that.(SpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GcSpec.Equal(that1.GcSpec) {
		return false
	}
	return true
}
func (this *StatusObject) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusObject)
	if !ok {
		that2, ok := that.(StatusObject)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if len(this.ObjectRefs) != len(that1.ObjectRefs) {
		return false
	}
	for i := range this.ObjectRefs {
		if !this.ObjectRefs[i].Equal(that1.ObjectRefs[i]) {
			return false
		}
	}
	if len(this.Conditions) != len(that1.Conditions) {
		return false
	}
	for i := range this.Conditions {
		if !this.Conditions[i].Equal(that1.Conditions[i]) {
			return false
		}
	}
	if that1.CloudLinkStatus == nil {
		if this.CloudLinkStatus != nil {
			return false
		}
	} else if this.CloudLinkStatus == nil {
		return false
	} else if !this.CloudLinkStatus.Equal(that1.CloudLinkStatus) {
		return false
	}
	return true
}
func (this *StatusObject_AwsStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusObject_AwsStatus)
	if !ok {
		that2, ok := that.(StatusObject_AwsStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsStatus.Equal(that1.AwsStatus) {
		return false
	}
	return true
}
func (this *StatusObject_AzureStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusObject_AzureStatus)
	if !ok {
		that2, ok := that.(StatusObject_AzureStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AzureStatus.Equal(that1.AzureStatus) {
		return false
	}
	return true
}
func (this *AWSStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSStatusType)
	if !ok {
		that2, ok := that.(AWSStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ConnectionStatus) != len(that1.ConnectionStatus) {
		return false
	}
	for i := range this.ConnectionStatus {
		if !this.ConnectionStatus[i].Equal(that1.ConnectionStatus[i]) {
			return false
		}
	}
	return true
}
func (this *DirectConnectConnectionStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectConnectionStatusType)
	if !ok {
		that2, ok := that.(DirectConnectConnectionStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Bandwidth != that1.Bandwidth {
		return false
	}
	if this.ConnectionId != that1.ConnectionId {
		return false
	}
	if this.ConnectionName != that1.ConnectionName {
		return false
	}
	if this.ConnectionState != that1.ConnectionState {
		return false
	}
	if this.HasLogicalRedundancy != that1.HasLogicalRedundancy {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.PartnerName != that1.PartnerName {
		return false
	}
	if this.ProviderName != that1.ProviderName {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.Vlan != that1.Vlan {
		return false
	}
	if this.JumboFrameCapable != that1.JumboFrameCapable {
		return false
	}
	if this.OwnerAccount != that1.OwnerAccount {
		return false
	}
	if !this.VifStatus.Equal(that1.VifStatus) {
		return false
	}
	if !this.GatewayStatus.Equal(that1.GatewayStatus) {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if this.AwsPath != that1.AwsPath {
		return false
	}
	return true
}
func (this *VirtualInterfaceStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualInterfaceStatusType)
	if !ok {
		that2, ok := that.(VirtualInterfaceStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AddressFamily != that1.AddressFamily {
		return false
	}
	if this.AmazonAddress != that1.AmazonAddress {
		return false
	}
	if this.AmazonAsn != that1.AmazonAsn {
		return false
	}
	if this.BgpAsn != that1.BgpAsn {
		return false
	}
	if this.ConnectionId != that1.ConnectionId {
		return false
	}
	if this.DirectConnectGatewayId != that1.DirectConnectGatewayId {
		return false
	}
	if this.DirectConnectGatewayName != that1.DirectConnectGatewayName {
		return false
	}
	if this.VirtualInterfaceState != that1.VirtualInterfaceState {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.Vlan != that1.Vlan {
		return false
	}
	if this.VirtualInterfaceId != that1.VirtualInterfaceId {
		return false
	}
	if this.VirtualInterfaceName != that1.VirtualInterfaceName {
		return false
	}
	if this.VirtualInterfaceType != that1.VirtualInterfaceType {
		return false
	}
	if len(this.BgpPeers) != len(that1.BgpPeers) {
		return false
	}
	for i := range this.BgpPeers {
		if !this.BgpPeers[i].Equal(that1.BgpPeers[i]) {
			return false
		}
	}
	if this.JumboFrameCapable != that1.JumboFrameCapable {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if this.OwnerAccount != that1.OwnerAccount {
		return false
	}
	if this.DirectConnectAttachmentState != that1.DirectConnectAttachmentState {
		return false
	}
	if this.AttachmentStateChangeError != that1.AttachmentStateChangeError {
		return false
	}
	if this.AwsPath != that1.AwsPath {
		return false
	}
	return true
}
func (this *BGPPeerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BGPPeerType)
	if !ok {
		that2, ok := that.(BGPPeerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AddressFamily != that1.AddressFamily {
		return false
	}
	if this.AmazonAddress != that1.AmazonAddress {
		return false
	}
	if this.Asn != that1.Asn {
		return false
	}
	if this.BgpPeerId != that1.BgpPeerId {
		return false
	}
	if this.BgpPeerState != that1.BgpPeerState {
		return false
	}
	if this.BgpStatus != that1.BgpStatus {
		return false
	}
	if this.CustomerAddress != that1.CustomerAddress {
		return false
	}
	return true
}
func (this *DirectConnectGatewayStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectGatewayStatusType)
	if !ok {
		that2, ok := that.(DirectConnectGatewayStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AmazonAsn != that1.AmazonAsn {
		return false
	}
	if this.DirectConnectGatewayId != that1.DirectConnectGatewayId {
		return false
	}
	if this.DirectConnectGatewayName != that1.DirectConnectGatewayName {
		return false
	}
	if this.DirectConnectGatewayState != that1.DirectConnectGatewayState {
		return false
	}
	if this.StateChangeError != that1.StateChangeError {
		return false
	}
	if this.OwnerAccount != that1.OwnerAccount {
		return false
	}
	if this.AwsPath != that1.AwsPath {
		return false
	}
	return true
}
func (this *Coordinates) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Coordinates)
	if !ok {
		that2, ok := that.(Coordinates)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	return true
}
func (this *AzureStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureStatusType)
	if !ok {
		that2, ok := that.(AzureStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Object) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_link.Object{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.SystemMetadata != nil {
		s = append(s, "SystemMetadata: "+fmt.Sprintf("%#v", this.SystemMetadata)+",\n")
	}
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_link.SpecType{")
	if this.GcSpec != nil {
		s = append(s, "GcSpec: "+fmt.Sprintf("%#v", this.GcSpec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatusObject) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cloud_link.StatusObject{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.ObjectRefs != nil {
		s = append(s, "ObjectRefs: "+fmt.Sprintf("%#v", this.ObjectRefs)+",\n")
	}
	if this.Conditions != nil {
		s = append(s, "Conditions: "+fmt.Sprintf("%#v", this.Conditions)+",\n")
	}
	if this.CloudLinkStatus != nil {
		s = append(s, "CloudLinkStatus: "+fmt.Sprintf("%#v", this.CloudLinkStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatusObject_AwsStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_link.StatusObject_AwsStatus{` +
		`AwsStatus:` + fmt.Sprintf("%#v", this.AwsStatus) + `}`}, ", ")
	return s
}
func (this *StatusObject_AzureStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_link.StatusObject_AzureStatus{` +
		`AzureStatus:` + fmt.Sprintf("%#v", this.AzureStatus) + `}`}, ", ")
	return s
}
func (this *AWSStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_link.AWSStatusType{")
	if this.ConnectionStatus != nil {
		s = append(s, "ConnectionStatus: "+fmt.Sprintf("%#v", this.ConnectionStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DirectConnectConnectionStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&cloud_link.DirectConnectConnectionStatusType{")
	s = append(s, "Bandwidth: "+fmt.Sprintf("%#v", this.Bandwidth)+",\n")
	s = append(s, "ConnectionId: "+fmt.Sprintf("%#v", this.ConnectionId)+",\n")
	s = append(s, "ConnectionName: "+fmt.Sprintf("%#v", this.ConnectionName)+",\n")
	s = append(s, "ConnectionState: "+fmt.Sprintf("%#v", this.ConnectionState)+",\n")
	s = append(s, "HasLogicalRedundancy: "+fmt.Sprintf("%#v", this.HasLogicalRedundancy)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "PartnerName: "+fmt.Sprintf("%#v", this.PartnerName)+",\n")
	s = append(s, "ProviderName: "+fmt.Sprintf("%#v", this.ProviderName)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "Vlan: "+fmt.Sprintf("%#v", this.Vlan)+",\n")
	s = append(s, "JumboFrameCapable: "+fmt.Sprintf("%#v", this.JumboFrameCapable)+",\n")
	s = append(s, "OwnerAccount: "+fmt.Sprintf("%#v", this.OwnerAccount)+",\n")
	if this.VifStatus != nil {
		s = append(s, "VifStatus: "+fmt.Sprintf("%#v", this.VifStatus)+",\n")
	}
	if this.GatewayStatus != nil {
		s = append(s, "GatewayStatus: "+fmt.Sprintf("%#v", this.GatewayStatus)+",\n")
	}
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	s = append(s, "AwsPath: "+fmt.Sprintf("%#v", this.AwsPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VirtualInterfaceStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 26)
	s = append(s, "&cloud_link.VirtualInterfaceStatusType{")
	s = append(s, "AddressFamily: "+fmt.Sprintf("%#v", this.AddressFamily)+",\n")
	s = append(s, "AmazonAddress: "+fmt.Sprintf("%#v", this.AmazonAddress)+",\n")
	s = append(s, "AmazonAsn: "+fmt.Sprintf("%#v", this.AmazonAsn)+",\n")
	s = append(s, "BgpAsn: "+fmt.Sprintf("%#v", this.BgpAsn)+",\n")
	s = append(s, "ConnectionId: "+fmt.Sprintf("%#v", this.ConnectionId)+",\n")
	s = append(s, "DirectConnectGatewayId: "+fmt.Sprintf("%#v", this.DirectConnectGatewayId)+",\n")
	s = append(s, "DirectConnectGatewayName: "+fmt.Sprintf("%#v", this.DirectConnectGatewayName)+",\n")
	s = append(s, "VirtualInterfaceState: "+fmt.Sprintf("%#v", this.VirtualInterfaceState)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "Vlan: "+fmt.Sprintf("%#v", this.Vlan)+",\n")
	s = append(s, "VirtualInterfaceId: "+fmt.Sprintf("%#v", this.VirtualInterfaceId)+",\n")
	s = append(s, "VirtualInterfaceName: "+fmt.Sprintf("%#v", this.VirtualInterfaceName)+",\n")
	s = append(s, "VirtualInterfaceType: "+fmt.Sprintf("%#v", this.VirtualInterfaceType)+",\n")
	if this.BgpPeers != nil {
		s = append(s, "BgpPeers: "+fmt.Sprintf("%#v", this.BgpPeers)+",\n")
	}
	s = append(s, "JumboFrameCapable: "+fmt.Sprintf("%#v", this.JumboFrameCapable)+",\n")
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "OwnerAccount: "+fmt.Sprintf("%#v", this.OwnerAccount)+",\n")
	s = append(s, "DirectConnectAttachmentState: "+fmt.Sprintf("%#v", this.DirectConnectAttachmentState)+",\n")
	s = append(s, "AttachmentStateChangeError: "+fmt.Sprintf("%#v", this.AttachmentStateChangeError)+",\n")
	s = append(s, "AwsPath: "+fmt.Sprintf("%#v", this.AwsPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BGPPeerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cloud_link.BGPPeerType{")
	s = append(s, "AddressFamily: "+fmt.Sprintf("%#v", this.AddressFamily)+",\n")
	s = append(s, "AmazonAddress: "+fmt.Sprintf("%#v", this.AmazonAddress)+",\n")
	s = append(s, "Asn: "+fmt.Sprintf("%#v", this.Asn)+",\n")
	s = append(s, "BgpPeerId: "+fmt.Sprintf("%#v", this.BgpPeerId)+",\n")
	s = append(s, "BgpPeerState: "+fmt.Sprintf("%#v", this.BgpPeerState)+",\n")
	s = append(s, "BgpStatus: "+fmt.Sprintf("%#v", this.BgpStatus)+",\n")
	s = append(s, "CustomerAddress: "+fmt.Sprintf("%#v", this.CustomerAddress)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DirectConnectGatewayStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cloud_link.DirectConnectGatewayStatusType{")
	s = append(s, "AmazonAsn: "+fmt.Sprintf("%#v", this.AmazonAsn)+",\n")
	s = append(s, "DirectConnectGatewayId: "+fmt.Sprintf("%#v", this.DirectConnectGatewayId)+",\n")
	s = append(s, "DirectConnectGatewayName: "+fmt.Sprintf("%#v", this.DirectConnectGatewayName)+",\n")
	s = append(s, "DirectConnectGatewayState: "+fmt.Sprintf("%#v", this.DirectConnectGatewayState)+",\n")
	s = append(s, "StateChangeError: "+fmt.Sprintf("%#v", this.StateChangeError)+",\n")
	s = append(s, "OwnerAccount: "+fmt.Sprintf("%#v", this.OwnerAccount)+",\n")
	s = append(s, "AwsPath: "+fmt.Sprintf("%#v", this.AwsPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Coordinates) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_link.Coordinates{")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloud_link.AzureStatusType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringObject(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SystemMetadata != nil {
		{
			size, err := m.SystemMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GcSpec != nil {
		{
			size, err := m.GcSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *StatusObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudLinkStatus != nil {
		{
			size := m.CloudLinkStatus.Size()
			i -= size
			if _, err := m.CloudLinkStatus.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintObject(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ObjectRefs) > 0 {
		for iNdEx := len(m.ObjectRefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ObjectRefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintObject(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusObject_AwsStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusObject_AwsStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsStatus != nil {
		{
			size, err := m.AwsStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *StatusObject_AzureStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusObject_AzureStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AzureStatus != nil {
		{
			size, err := m.AzureStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AWSStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConnectionStatus) > 0 {
		for iNdEx := len(m.ConnectionStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConnectionStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintObject(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *DirectConnectConnectionStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectConnectConnectionStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectConnectionStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AwsPath) > 0 {
		i -= len(m.AwsPath)
		copy(dAtA[i:], m.AwsPath)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AwsPath)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Coordinates != nil {
		{
			size, err := m.Coordinates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.GatewayStatus != nil {
		{
			size, err := m.GatewayStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.VifStatus != nil {
		{
			size, err := m.VifStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.OwnerAccount) > 0 {
		i -= len(m.OwnerAccount)
		copy(dAtA[i:], m.OwnerAccount)
		i = encodeVarintObject(dAtA, i, uint64(len(m.OwnerAccount)))
		i--
		dAtA[i] = 0x6a
	}
	if m.JumboFrameCapable {
		i--
		if m.JumboFrameCapable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Vlan != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintObject(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintObject(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintObject(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ProviderName) > 0 {
		i -= len(m.ProviderName)
		copy(dAtA[i:], m.ProviderName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ProviderName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PartnerName) > 0 {
		i -= len(m.PartnerName)
		copy(dAtA[i:], m.PartnerName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.PartnerName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.HasLogicalRedundancy) > 0 {
		i -= len(m.HasLogicalRedundancy)
		copy(dAtA[i:], m.HasLogicalRedundancy)
		i = encodeVarintObject(dAtA, i, uint64(len(m.HasLogicalRedundancy)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ConnectionState) > 0 {
		i -= len(m.ConnectionState)
		copy(dAtA[i:], m.ConnectionState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ConnectionState)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ConnectionName) > 0 {
		i -= len(m.ConnectionName)
		copy(dAtA[i:], m.ConnectionName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ConnectionName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConnectionId) > 0 {
		i -= len(m.ConnectionId)
		copy(dAtA[i:], m.ConnectionId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ConnectionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bandwidth) > 0 {
		i -= len(m.Bandwidth)
		copy(dAtA[i:], m.Bandwidth)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Bandwidth)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VirtualInterfaceStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualInterfaceStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualInterfaceStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AwsPath) > 0 {
		i -= len(m.AwsPath)
		copy(dAtA[i:], m.AwsPath)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AwsPath)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.AttachmentStateChangeError) > 0 {
		i -= len(m.AttachmentStateChangeError)
		copy(dAtA[i:], m.AttachmentStateChangeError)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AttachmentStateChangeError)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.DirectConnectAttachmentState) > 0 {
		i -= len(m.DirectConnectAttachmentState)
		copy(dAtA[i:], m.DirectConnectAttachmentState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectAttachmentState)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.OwnerAccount) > 0 {
		i -= len(m.OwnerAccount)
		copy(dAtA[i:], m.OwnerAccount)
		i = encodeVarintObject(dAtA, i, uint64(len(m.OwnerAccount)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Mtu != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.JumboFrameCapable {
		i--
		if m.JumboFrameCapable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.BgpPeers) > 0 {
		for iNdEx := len(m.BgpPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BgpPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintObject(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.VirtualInterfaceType) > 0 {
		i -= len(m.VirtualInterfaceType)
		copy(dAtA[i:], m.VirtualInterfaceType)
		i = encodeVarintObject(dAtA, i, uint64(len(m.VirtualInterfaceType)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.VirtualInterfaceName) > 0 {
		i -= len(m.VirtualInterfaceName)
		copy(dAtA[i:], m.VirtualInterfaceName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.VirtualInterfaceName)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.VirtualInterfaceId) > 0 {
		i -= len(m.VirtualInterfaceId)
		copy(dAtA[i:], m.VirtualInterfaceId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.VirtualInterfaceId)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Vlan != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintObject(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintObject(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintObject(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.VirtualInterfaceState) > 0 {
		i -= len(m.VirtualInterfaceState)
		copy(dAtA[i:], m.VirtualInterfaceState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.VirtualInterfaceState)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DirectConnectGatewayName) > 0 {
		i -= len(m.DirectConnectGatewayName)
		copy(dAtA[i:], m.DirectConnectGatewayName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectGatewayName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DirectConnectGatewayId) > 0 {
		i -= len(m.DirectConnectGatewayId)
		copy(dAtA[i:], m.DirectConnectGatewayId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectGatewayId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ConnectionId) > 0 {
		i -= len(m.ConnectionId)
		copy(dAtA[i:], m.ConnectionId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ConnectionId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BgpAsn != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.BgpAsn))
		i--
		dAtA[i] = 0x20
	}
	if m.AmazonAsn != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.AmazonAsn))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AmazonAddress) > 0 {
		i -= len(m.AmazonAddress)
		copy(dAtA[i:], m.AmazonAddress)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AmazonAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AddressFamily) > 0 {
		i -= len(m.AddressFamily)
		copy(dAtA[i:], m.AddressFamily)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AddressFamily)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomerAddress) > 0 {
		i -= len(m.CustomerAddress)
		copy(dAtA[i:], m.CustomerAddress)
		i = encodeVarintObject(dAtA, i, uint64(len(m.CustomerAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BgpStatus) > 0 {
		i -= len(m.BgpStatus)
		copy(dAtA[i:], m.BgpStatus)
		i = encodeVarintObject(dAtA, i, uint64(len(m.BgpStatus)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BgpPeerState) > 0 {
		i -= len(m.BgpPeerState)
		copy(dAtA[i:], m.BgpPeerState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.BgpPeerState)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BgpPeerId) > 0 {
		i -= len(m.BgpPeerId)
		copy(dAtA[i:], m.BgpPeerId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.BgpPeerId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Asn != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.Asn))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AmazonAddress) > 0 {
		i -= len(m.AmazonAddress)
		copy(dAtA[i:], m.AmazonAddress)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AmazonAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AddressFamily) > 0 {
		i -= len(m.AddressFamily)
		copy(dAtA[i:], m.AddressFamily)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AddressFamily)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DirectConnectGatewayStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectConnectGatewayStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectGatewayStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AwsPath) > 0 {
		i -= len(m.AwsPath)
		copy(dAtA[i:], m.AwsPath)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AwsPath)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.OwnerAccount) > 0 {
		i -= len(m.OwnerAccount)
		copy(dAtA[i:], m.OwnerAccount)
		i = encodeVarintObject(dAtA, i, uint64(len(m.OwnerAccount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.StateChangeError) > 0 {
		i -= len(m.StateChangeError)
		copy(dAtA[i:], m.StateChangeError)
		i = encodeVarintObject(dAtA, i, uint64(len(m.StateChangeError)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DirectConnectGatewayState) > 0 {
		i -= len(m.DirectConnectGatewayState)
		copy(dAtA[i:], m.DirectConnectGatewayState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectGatewayState)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DirectConnectGatewayName) > 0 {
		i -= len(m.DirectConnectGatewayName)
		copy(dAtA[i:], m.DirectConnectGatewayName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectGatewayName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DirectConnectGatewayId) > 0 {
		i -= len(m.DirectConnectGatewayId)
		copy(dAtA[i:], m.DirectConnectGatewayId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectGatewayId)))
		i--
		dAtA[i] = 0x12
	}
	if m.AmazonAsn != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.AmazonAsn))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Coordinates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Coordinates) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Coordinates) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Longitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i--
		dAtA[i] = 0x15
	}
	if m.Latitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *AzureStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintObject(dAtA []byte, offset int, v uint64) int {
	offset -= sovObject(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	if m.SystemMetadata != nil {
		l = m.SystemMetadata.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}

func (m *SpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GcSpec != nil {
		l = m.GcSpec.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}

func (m *StatusObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	if len(m.ObjectRefs) > 0 {
		for _, e := range m.ObjectRefs {
			l = e.Size()
			n += 1 + l + sovObject(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovObject(uint64(l))
		}
	}
	if m.CloudLinkStatus != nil {
		n += m.CloudLinkStatus.Size()
	}
	return n
}

func (m *StatusObject_AwsStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsStatus != nil {
		l = m.AwsStatus.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}
func (m *StatusObject_AzureStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AzureStatus != nil {
		l = m.AzureStatus.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}
func (m *AWSStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConnectionStatus) > 0 {
		for _, e := range m.ConnectionStatus {
			l = e.Size()
			n += 1 + l + sovObject(uint64(l))
		}
	}
	return n
}

func (m *DirectConnectConnectionStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bandwidth)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.ConnectionId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.ConnectionName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.ConnectionState)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.HasLogicalRedundancy)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.PartnerName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.ProviderName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovObject(uint64(len(k))) + 1 + len(v) + sovObject(uint64(len(v)))
			n += mapEntrySize + 1 + sovObject(uint64(mapEntrySize))
		}
	}
	if m.Vlan != 0 {
		n += 1 + sovObject(uint64(m.Vlan))
	}
	if m.JumboFrameCapable {
		n += 2
	}
	l = len(m.OwnerAccount)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if m.VifStatus != nil {
		l = m.VifStatus.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	if m.GatewayStatus != nil {
		l = m.GatewayStatus.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 2 + l + sovObject(uint64(l))
	}
	l = len(m.AwsPath)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	return n
}

func (m *VirtualInterfaceStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AddressFamily)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.AmazonAddress)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if m.AmazonAsn != 0 {
		n += 1 + sovObject(uint64(m.AmazonAsn))
	}
	if m.BgpAsn != 0 {
		n += 1 + sovObject(uint64(m.BgpAsn))
	}
	l = len(m.ConnectionId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.DirectConnectGatewayId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.DirectConnectGatewayName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.VirtualInterfaceState)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovObject(uint64(len(k))) + 1 + len(v) + sovObject(uint64(len(v)))
			n += mapEntrySize + 1 + sovObject(uint64(mapEntrySize))
		}
	}
	if m.Vlan != 0 {
		n += 1 + sovObject(uint64(m.Vlan))
	}
	l = len(m.VirtualInterfaceId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.VirtualInterfaceName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.VirtualInterfaceType)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if len(m.BgpPeers) > 0 {
		for _, e := range m.BgpPeers {
			l = e.Size()
			n += 2 + l + sovObject(uint64(l))
		}
	}
	if m.JumboFrameCapable {
		n += 3
	}
	if m.Mtu != 0 {
		n += 2 + sovObject(uint64(m.Mtu))
	}
	l = len(m.OwnerAccount)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	l = len(m.DirectConnectAttachmentState)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	l = len(m.AttachmentStateChangeError)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	l = len(m.AwsPath)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	return n
}

func (m *BGPPeerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AddressFamily)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.AmazonAddress)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if m.Asn != 0 {
		n += 1 + sovObject(uint64(m.Asn))
	}
	l = len(m.BgpPeerId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.BgpPeerState)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.BgpStatus)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.CustomerAddress)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}

func (m *DirectConnectGatewayStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AmazonAsn != 0 {
		n += 1 + sovObject(uint64(m.AmazonAsn))
	}
	l = len(m.DirectConnectGatewayId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.DirectConnectGatewayName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.DirectConnectGatewayState)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.StateChangeError)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.OwnerAccount)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.AwsPath)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}

func (m *Coordinates) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	return n
}

func (m *AzureStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovObject(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozObject(x uint64) (n int) {
	return sovObject(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Object) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Object{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "ObjectMetaType", "schema.ObjectMetaType", 1) + `,`,
		`SystemMetadata:` + strings.Replace(fmt.Sprintf("%v", this.SystemMetadata), "SystemObjectMetaType", "schema.SystemObjectMetaType", 1) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "SpecType", "SpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpecType{`,
		`GcSpec:` + strings.Replace(fmt.Sprintf("%v", this.GcSpec), "GlobalSpecType", "GlobalSpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusObject) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForObjectRefs := "[]*ObjectRefType{"
	for _, f := range this.ObjectRefs {
		repeatedStringForObjectRefs += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForObjectRefs += "}"
	repeatedStringForConditions := "[]*ConditionType{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(fmt.Sprintf("%v", f), "ConditionType", "schema.ConditionType", 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&StatusObject{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "StatusMetaType", "schema.StatusMetaType", 1) + `,`,
		`ObjectRefs:` + repeatedStringForObjectRefs + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`CloudLinkStatus:` + fmt.Sprintf("%v", this.CloudLinkStatus) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusObject_AwsStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusObject_AwsStatus{`,
		`AwsStatus:` + strings.Replace(fmt.Sprintf("%v", this.AwsStatus), "AWSStatusType", "AWSStatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusObject_AzureStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusObject_AzureStatus{`,
		`AzureStatus:` + strings.Replace(fmt.Sprintf("%v", this.AzureStatus), "AzureStatusType", "AzureStatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConnectionStatus := "[]*DirectConnectConnectionStatusType{"
	for _, f := range this.ConnectionStatus {
		repeatedStringForConnectionStatus += strings.Replace(f.String(), "DirectConnectConnectionStatusType", "DirectConnectConnectionStatusType", 1) + ","
	}
	repeatedStringForConnectionStatus += "}"
	s := strings.Join([]string{`&AWSStatusType{`,
		`ConnectionStatus:` + repeatedStringForConnectionStatus + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectConnectionStatusType) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&DirectConnectConnectionStatusType{`,
		`Bandwidth:` + fmt.Sprintf("%v", this.Bandwidth) + `,`,
		`ConnectionId:` + fmt.Sprintf("%v", this.ConnectionId) + `,`,
		`ConnectionName:` + fmt.Sprintf("%v", this.ConnectionName) + `,`,
		`ConnectionState:` + fmt.Sprintf("%v", this.ConnectionState) + `,`,
		`HasLogicalRedundancy:` + fmt.Sprintf("%v", this.HasLogicalRedundancy) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`PartnerName:` + fmt.Sprintf("%v", this.PartnerName) + `,`,
		`ProviderName:` + fmt.Sprintf("%v", this.ProviderName) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`Vlan:` + fmt.Sprintf("%v", this.Vlan) + `,`,
		`JumboFrameCapable:` + fmt.Sprintf("%v", this.JumboFrameCapable) + `,`,
		`OwnerAccount:` + fmt.Sprintf("%v", this.OwnerAccount) + `,`,
		`VifStatus:` + strings.Replace(this.VifStatus.String(), "VirtualInterfaceStatusType", "VirtualInterfaceStatusType", 1) + `,`,
		`GatewayStatus:` + strings.Replace(this.GatewayStatus.String(), "DirectConnectGatewayStatusType", "DirectConnectGatewayStatusType", 1) + `,`,
		`Coordinates:` + strings.Replace(this.Coordinates.String(), "Coordinates", "Coordinates", 1) + `,`,
		`AwsPath:` + fmt.Sprintf("%v", this.AwsPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualInterfaceStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBgpPeers := "[]*BGPPeerType{"
	for _, f := range this.BgpPeers {
		repeatedStringForBgpPeers += strings.Replace(f.String(), "BGPPeerType", "BGPPeerType", 1) + ","
	}
	repeatedStringForBgpPeers += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&VirtualInterfaceStatusType{`,
		`AddressFamily:` + fmt.Sprintf("%v", this.AddressFamily) + `,`,
		`AmazonAddress:` + fmt.Sprintf("%v", this.AmazonAddress) + `,`,
		`AmazonAsn:` + fmt.Sprintf("%v", this.AmazonAsn) + `,`,
		`BgpAsn:` + fmt.Sprintf("%v", this.BgpAsn) + `,`,
		`ConnectionId:` + fmt.Sprintf("%v", this.ConnectionId) + `,`,
		`DirectConnectGatewayId:` + fmt.Sprintf("%v", this.DirectConnectGatewayId) + `,`,
		`DirectConnectGatewayName:` + fmt.Sprintf("%v", this.DirectConnectGatewayName) + `,`,
		`VirtualInterfaceState:` + fmt.Sprintf("%v", this.VirtualInterfaceState) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`Vlan:` + fmt.Sprintf("%v", this.Vlan) + `,`,
		`VirtualInterfaceId:` + fmt.Sprintf("%v", this.VirtualInterfaceId) + `,`,
		`VirtualInterfaceName:` + fmt.Sprintf("%v", this.VirtualInterfaceName) + `,`,
		`VirtualInterfaceType:` + fmt.Sprintf("%v", this.VirtualInterfaceType) + `,`,
		`BgpPeers:` + repeatedStringForBgpPeers + `,`,
		`JumboFrameCapable:` + fmt.Sprintf("%v", this.JumboFrameCapable) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`OwnerAccount:` + fmt.Sprintf("%v", this.OwnerAccount) + `,`,
		`DirectConnectAttachmentState:` + fmt.Sprintf("%v", this.DirectConnectAttachmentState) + `,`,
		`AttachmentStateChangeError:` + fmt.Sprintf("%v", this.AttachmentStateChangeError) + `,`,
		`AwsPath:` + fmt.Sprintf("%v", this.AwsPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BGPPeerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BGPPeerType{`,
		`AddressFamily:` + fmt.Sprintf("%v", this.AddressFamily) + `,`,
		`AmazonAddress:` + fmt.Sprintf("%v", this.AmazonAddress) + `,`,
		`Asn:` + fmt.Sprintf("%v", this.Asn) + `,`,
		`BgpPeerId:` + fmt.Sprintf("%v", this.BgpPeerId) + `,`,
		`BgpPeerState:` + fmt.Sprintf("%v", this.BgpPeerState) + `,`,
		`BgpStatus:` + fmt.Sprintf("%v", this.BgpStatus) + `,`,
		`CustomerAddress:` + fmt.Sprintf("%v", this.CustomerAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectGatewayStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectConnectGatewayStatusType{`,
		`AmazonAsn:` + fmt.Sprintf("%v", this.AmazonAsn) + `,`,
		`DirectConnectGatewayId:` + fmt.Sprintf("%v", this.DirectConnectGatewayId) + `,`,
		`DirectConnectGatewayName:` + fmt.Sprintf("%v", this.DirectConnectGatewayName) + `,`,
		`DirectConnectGatewayState:` + fmt.Sprintf("%v", this.DirectConnectGatewayState) + `,`,
		`StateChangeError:` + fmt.Sprintf("%v", this.StateChangeError) + `,`,
		`OwnerAccount:` + fmt.Sprintf("%v", this.OwnerAccount) + `,`,
		`AwsPath:` + fmt.Sprintf("%v", this.AwsPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Coordinates) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Coordinates{`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureStatusType{`,
		`}`,
	}, "")
	return s
}
func valueToStringObject(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.ObjectMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemMetadata == nil {
				m.SystemMetadata = &schema.SystemObjectMetaType{}
			}
			if err := m.SystemMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SpecType{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GcSpec == nil {
				m.GcSpec = &GlobalSpecType{}
			}
			if err := m.GcSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.StatusMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectRefs = append(m.ObjectRefs, &schema.ObjectRefType{})
			if err := m.ObjectRefs[len(m.ObjectRefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &schema.ConditionType{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSStatusType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudLinkStatus = &StatusObject_AwsStatus{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureStatusType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudLinkStatus = &StatusObject_AzureStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionStatus = append(m.ConnectionStatus, &DirectConnectConnectionStatusType{})
			if err := m.ConnectionStatus[len(m.ConnectionStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectConnectConnectionStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectConnectConnectionStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectConnectConnectionStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bandwidth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLogicalRedundancy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HasLogicalRedundancy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartnerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartnerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowObject
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowObject
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthObject
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthObject
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowObject
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthObject
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthObject
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipObject(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthObject
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumboFrameCapable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JumboFrameCapable = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VifStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VifStatus == nil {
				m.VifStatus = &VirtualInterfaceStatusType{}
			}
			if err := m.VifStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GatewayStatus == nil {
				m.GatewayStatus = &DirectConnectGatewayStatusType{}
			}
			if err := m.GatewayStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualInterfaceStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualInterfaceStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualInterfaceStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmazonAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmazonAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmazonAsn", wireType)
			}
			m.AmazonAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmazonAsn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpAsn", wireType)
			}
			m.BgpAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BgpAsn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualInterfaceState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualInterfaceState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowObject
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowObject
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthObject
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthObject
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowObject
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthObject
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthObject
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipObject(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthObject
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualInterfaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualInterfaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualInterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualInterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualInterfaceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualInterfaceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeers = append(m.BgpPeers, &BGPPeerType{})
			if err := m.BgpPeers[len(m.BgpPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumboFrameCapable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JumboFrameCapable = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectAttachmentState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectAttachmentState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentStateChangeError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachmentStateChangeError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmazonAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmazonAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn", wireType)
			}
			m.Asn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Asn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectConnectGatewayStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectConnectGatewayStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectConnectGatewayStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmazonAsn", wireType)
			}
			m.AmazonAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmazonAsn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateChangeError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateChangeError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Coordinates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Coordinates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Coordinates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipObject(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowObject
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowObject
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowObject
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthObject
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupObject
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthObject
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthObject        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowObject          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupObject = fmt.Errorf("proto: unexpected end of group")
)
