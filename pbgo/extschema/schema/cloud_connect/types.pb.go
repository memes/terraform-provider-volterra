// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/cloud_connect/types.proto

package cloud_connect

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	cloud_re_region "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/cloud_re_region"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Cloud Connect AWS Type
//
// x-displayName: "AWS"
type AWSREType struct {
	// Region
	//
	// x-displayName: "Cloud Edge"
	Region *views.ObjectRefType `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	// Cloud Credential
	//
	// x-displayName: "Credential"
	// Select a cloud credential to begin onboarding VPCs
	Cred *views.ObjectRefType `protobuf:"bytes,2,opt,name=cred,proto3" json:"cred,omitempty"`
	// VPC Attachement List
	//
	// x-displayName: "VPC Attachement List"
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
	// Cloud Links
	//
	// x-displayName: "CloudLink"
	// Reference to cloud link
	CloudLinks *CloudLinkListType `protobuf:"bytes,4,opt,name=cloud_links,json=cloudLinks,proto3" json:"cloud_links,omitempty"`
	// TGW Name
	//
	// x-displayName: "TGW Name"
	Tgw string `protobuf:"bytes,5,opt,name=tgw,proto3" json:"tgw,omitempty"`
	// Peers
	//
	// x-displayName: "Peers"
	// Peers
	Peers []*PeerType `protobuf:"bytes,9,rep,name=peers,proto3" json:"peers,omitempty"`
}

func (m *AWSREType) Reset()      { *m = AWSREType{} }
func (*AWSREType) ProtoMessage() {}
func (*AWSREType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{0}
}
func (m *AWSREType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSREType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSREType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSREType.Merge(m, src)
}
func (m *AWSREType) XXX_Size() int {
	return m.Size()
}
func (m *AWSREType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSREType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSREType proto.InternalMessageInfo

func (m *AWSREType) GetRegion() *views.ObjectRefType {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *AWSREType) GetCred() *views.ObjectRefType {
	if m != nil {
		return m.Cred
	}
	return nil
}

func (m *AWSREType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

func (m *AWSREType) GetCloudLinks() *CloudLinkListType {
	if m != nil {
		return m.CloudLinks
	}
	return nil
}

func (m *AWSREType) GetTgw() string {
	if m != nil {
		return m.Tgw
	}
	return ""
}

func (m *AWSREType) GetPeers() []*PeerType {
	if m != nil {
		return m.Peers
	}
	return nil
}

// Cloud Links
//
// x-displayName: "Cloud Links"
// List of Cloud Link references to be attached
type PeerType struct {
	// TGW Address
	//
	// x-displayName: "TGW Address"
	TgwAddress string `protobuf:"bytes,1,opt,name=tgw_address,json=tgwAddress,proto3" json:"tgw_address,omitempty"`
	// Peer ASN
	//
	// x-displayName: "Peer ASN"
	PeerAsn int64 `protobuf:"varint,2,opt,name=peer_asn,json=peerAsn,proto3" json:"peer_asn,omitempty"`
	// Node
	//
	// x-displayName: "Node"
	Node *cloud_re_region.NodeType `protobuf:"bytes,3,opt,name=node,proto3" json:"node,omitempty"`
	// Inside GRE Subnet
	//
	// x-displayName: "Inside GRE Subnet"
	InsideGreSubnet string `protobuf:"bytes,4,opt,name=inside_gre_subnet,json=insideGreSubnet,proto3" json:"inside_gre_subnet,omitempty"`
}

func (m *PeerType) Reset()      { *m = PeerType{} }
func (*PeerType) ProtoMessage() {}
func (*PeerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{1}
}
func (m *PeerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PeerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerType.Merge(m, src)
}
func (m *PeerType) XXX_Size() int {
	return m.Size()
}
func (m *PeerType) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerType.DiscardUnknown(m)
}

var xxx_messageInfo_PeerType proto.InternalMessageInfo

func (m *PeerType) GetTgwAddress() string {
	if m != nil {
		return m.TgwAddress
	}
	return ""
}

func (m *PeerType) GetPeerAsn() int64 {
	if m != nil {
		return m.PeerAsn
	}
	return 0
}

func (m *PeerType) GetNode() *cloud_re_region.NodeType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *PeerType) GetInsideGreSubnet() string {
	if m != nil {
		return m.InsideGreSubnet
	}
	return ""
}

// CloudLinks
//
// x-displayName: "CloudLink"
// List of CloudLink references to be attached
type CloudLinkListType struct {
	// CloudLink
	//
	// x-displayName: "CloudLink"
	// Attach a CloudLink to this Cloud Connect
	CloudLink []*views.ObjectRefType `protobuf:"bytes,1,rep,name=cloud_link,json=cloudLink,proto3" json:"cloud_link,omitempty"`
}

func (m *CloudLinkListType) Reset()      { *m = CloudLinkListType{} }
func (*CloudLinkListType) ProtoMessage() {}
func (*CloudLinkListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{2}
}
func (m *CloudLinkListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudLinkListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudLinkListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudLinkListType.Merge(m, src)
}
func (m *CloudLinkListType) XXX_Size() int {
	return m.Size()
}
func (m *CloudLinkListType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudLinkListType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudLinkListType proto.InternalMessageInfo

func (m *CloudLinkListType) GetCloudLink() []*views.ObjectRefType {
	if m != nil {
		return m.CloudLink
	}
	return nil
}

// VPC Attachments
//
// x-displayName: "VPC Attachments"
type AWSVPCAttachmentListType struct {
	// vpc_list
	//
	// x-displayName: "VPC List"
	VpcList []*AWSVPCAttachmentType `protobuf:"bytes,1,rep,name=vpc_list,json=vpcList,proto3" json:"vpc_list,omitempty"`
}

func (m *AWSVPCAttachmentListType) Reset()      { *m = AWSVPCAttachmentListType{} }
func (*AWSVPCAttachmentListType) ProtoMessage() {}
func (*AWSVPCAttachmentListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{3}
}
func (m *AWSVPCAttachmentListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCAttachmentListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCAttachmentListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCAttachmentListType.Merge(m, src)
}
func (m *AWSVPCAttachmentListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCAttachmentListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCAttachmentListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCAttachmentListType proto.InternalMessageInfo

func (m *AWSVPCAttachmentListType) GetVpcList() []*AWSVPCAttachmentType {
	if m != nil {
		return m.VpcList
	}
	return nil
}

// AWS VPC attachment
//
// x-displayName: "VPC Attachment"
type AWSVPCAttachmentType struct {
	// VPC ID
	//
	// x-displayName: "VPC ID"
	// x-example: "vpc-12345678901234567"
	// x-required
	// Enter the VPC ID of the VPC to be attached
	VpcId string `protobuf:"bytes,1,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
	// Subnet Choice
	//
	// x-displayName: "Onboard Subnets"
	// x-required
	// Select which subnets from this VPC should be onboarded on this site
	//
	// Types that are valid to be assigned to SubnetChoice:
	//	*AWSVPCAttachmentType_AllSubnets
	//	*AWSVPCAttachmentType_SubnetIds
	SubnetChoice isAWSVPCAttachmentType_SubnetChoice `protobuf_oneof:"subnet_choice"`
	// Routing Choice
	//
	// x-displayName: "Routing Choice"
	// x-required
	// Select which traffic should be routed towards the CE
	//
	// Types that are valid to be assigned to RoutingChoice:
	//	*AWSVPCAttachmentType_ManualRouting
	//	*AWSVPCAttachmentType_DefaultRoute
	//	*AWSVPCAttachmentType_CustomRouting
	RoutingChoice isAWSVPCAttachmentType_RoutingChoice `protobuf_oneof:"routing_choice"`
	// Labels For VPC ID
	//
	// x-displayName: "Labels For VPC ID"
	// x-example: "value"
	// Add Labels for each of the VPC ID, these labels can be used in firewall policy
	// These labels used must be from known key, label defined in shared namespace and unknown key.
	Labels map[string]string `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AWSVPCAttachmentType) Reset()      { *m = AWSVPCAttachmentType{} }
func (*AWSVPCAttachmentType) ProtoMessage() {}
func (*AWSVPCAttachmentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{4}
}
func (m *AWSVPCAttachmentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCAttachmentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCAttachmentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCAttachmentType.Merge(m, src)
}
func (m *AWSVPCAttachmentType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCAttachmentType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCAttachmentType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCAttachmentType proto.InternalMessageInfo

type isAWSVPCAttachmentType_SubnetChoice interface {
	isAWSVPCAttachmentType_SubnetChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAWSVPCAttachmentType_RoutingChoice interface {
	isAWSVPCAttachmentType_RoutingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCAttachmentType_AllSubnets struct {
	AllSubnets *schema.Empty `protobuf:"bytes,3,opt,name=all_subnets,json=allSubnets,proto3,oneof" json:"all_subnets,omitempty"`
}
type AWSVPCAttachmentType_SubnetIds struct {
	SubnetIds *AWSSubnetIDListType `protobuf:"bytes,4,opt,name=subnet_ids,json=subnetIds,proto3,oneof" json:"subnet_ids,omitempty"`
}
type AWSVPCAttachmentType_ManualRouting struct {
	ManualRouting *schema.Empty `protobuf:"bytes,6,opt,name=manual_routing,json=manualRouting,proto3,oneof" json:"manual_routing,omitempty"`
}
type AWSVPCAttachmentType_DefaultRoute struct {
	DefaultRoute *AWSRouteTableListType `protobuf:"bytes,9,opt,name=default_route,json=defaultRoute,proto3,oneof" json:"default_route,omitempty"`
}
type AWSVPCAttachmentType_CustomRouting struct {
	CustomRouting *AWSRouteTableListType `protobuf:"bytes,10,opt,name=custom_routing,json=customRouting,proto3,oneof" json:"custom_routing,omitempty"`
}

func (*AWSVPCAttachmentType_AllSubnets) isAWSVPCAttachmentType_SubnetChoice()     {}
func (*AWSVPCAttachmentType_SubnetIds) isAWSVPCAttachmentType_SubnetChoice()      {}
func (*AWSVPCAttachmentType_ManualRouting) isAWSVPCAttachmentType_RoutingChoice() {}
func (*AWSVPCAttachmentType_DefaultRoute) isAWSVPCAttachmentType_RoutingChoice()  {}
func (*AWSVPCAttachmentType_CustomRouting) isAWSVPCAttachmentType_RoutingChoice() {}

func (m *AWSVPCAttachmentType) GetSubnetChoice() isAWSVPCAttachmentType_SubnetChoice {
	if m != nil {
		return m.SubnetChoice
	}
	return nil
}
func (m *AWSVPCAttachmentType) GetRoutingChoice() isAWSVPCAttachmentType_RoutingChoice {
	if m != nil {
		return m.RoutingChoice
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

func (m *AWSVPCAttachmentType) GetAllSubnets() *schema.Empty {
	if x, ok := m.GetSubnetChoice().(*AWSVPCAttachmentType_AllSubnets); ok {
		return x.AllSubnets
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetSubnetIds() *AWSSubnetIDListType {
	if x, ok := m.GetSubnetChoice().(*AWSVPCAttachmentType_SubnetIds); ok {
		return x.SubnetIds
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetManualRouting() *schema.Empty {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_ManualRouting); ok {
		return x.ManualRouting
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetDefaultRoute() *AWSRouteTableListType {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_DefaultRoute); ok {
		return x.DefaultRoute
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetCustomRouting() *AWSRouteTableListType {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_CustomRouting); ok {
		return x.CustomRouting
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSVPCAttachmentType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSVPCAttachmentType_AllSubnets)(nil),
		(*AWSVPCAttachmentType_SubnetIds)(nil),
		(*AWSVPCAttachmentType_ManualRouting)(nil),
		(*AWSVPCAttachmentType_DefaultRoute)(nil),
		(*AWSVPCAttachmentType_CustomRouting)(nil),
	}
}

// AWS Subnet IDs
//
// x-displayName: "AWS Subnet IDs"
// AWS Subnet IDs
type AWSSubnetIDListType struct {
	// List of subnet IDs
	//
	// x-displayName: "List of subnet IDs"
	// x-required
	// x-example: "subnet-12345678901234567"
	// List of subnet IDs
	SubnetIds []string `protobuf:"bytes,1,rep,name=subnet_ids,json=subnetIds,proto3" json:"subnet_ids,omitempty"`
}

func (m *AWSSubnetIDListType) Reset()      { *m = AWSSubnetIDListType{} }
func (*AWSSubnetIDListType) ProtoMessage() {}
func (*AWSSubnetIDListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{5}
}
func (m *AWSSubnetIDListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSSubnetIDListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSSubnetIDListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSSubnetIDListType.Merge(m, src)
}
func (m *AWSSubnetIDListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSSubnetIDListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSSubnetIDListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSSubnetIDListType proto.InternalMessageInfo

func (m *AWSSubnetIDListType) GetSubnetIds() []string {
	if m != nil {
		return m.SubnetIds
	}
	return nil
}

// AWS Route Table List
//
// x-displayName: "AWS Route Table List"
// AWS Route Table List
type AWSRouteTableListType struct {
	// List of route tables
	//
	// x-required
	// x-displayName: "List of route tables"
	// Route Tables
	RouteTables []*AWSRouteTableType `protobuf:"bytes,1,rep,name=route_tables,json=routeTables,proto3" json:"route_tables,omitempty"`
}

func (m *AWSRouteTableListType) Reset()      { *m = AWSRouteTableListType{} }
func (*AWSRouteTableListType) ProtoMessage() {}
func (*AWSRouteTableListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{6}
}
func (m *AWSRouteTableListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSRouteTableListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSRouteTableListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSRouteTableListType.Merge(m, src)
}
func (m *AWSRouteTableListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSRouteTableListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSRouteTableListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSRouteTableListType proto.InternalMessageInfo

func (m *AWSRouteTableListType) GetRouteTables() []*AWSRouteTableType {
	if m != nil {
		return m.RouteTables
	}
	return nil
}

// AWS Route Table
//
// x-displayName: "AWS Route Table"
// AWS Route Table
type AWSRouteTableType struct {
	// Route table ID
	//
	// x-displayName: "Route table ID"
	// x-example: "rtb-12345678901234567"
	// Route table ID
	RouteTableId string `protobuf:"bytes,1,opt,name=route_table_id,json=routeTableId,proto3" json:"route_table_id,omitempty"`
	// static_routes
	//
	// x-displayName: "Static Routes"
	// x-example: "10.1.1.0/24"
	// x-required
	// List of Static Routes
	StaticRoutes []string `protobuf:"bytes,108,rep,name=static_routes,json=staticRoutes,proto3" json:"static_routes,omitempty"`
}

func (m *AWSRouteTableType) Reset()      { *m = AWSRouteTableType{} }
func (*AWSRouteTableType) ProtoMessage() {}
func (*AWSRouteTableType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{7}
}
func (m *AWSRouteTableType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSRouteTableType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSRouteTableType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSRouteTableType.Merge(m, src)
}
func (m *AWSRouteTableType) XXX_Size() int {
	return m.Size()
}
func (m *AWSRouteTableType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSRouteTableType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSRouteTableType proto.InternalMessageInfo

func (m *AWSRouteTableType) GetRouteTableId() string {
	if m != nil {
		return m.RouteTableId
	}
	return ""
}

func (m *AWSRouteTableType) GetStaticRoutes() []string {
	if m != nil {
		return m.StaticRoutes
	}
	return nil
}

// Cloud Connect ReplaceAWSREType Type
//
// x-displayName: "AWS RE Type"
// Cloud Connect AWS RE Type
type ReplaceAWSREType struct {
	// VPC Attachments
	//
	// x-displayName: "VPC Attachments"
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
}

func (m *ReplaceAWSREType) Reset()      { *m = ReplaceAWSREType{} }
func (*ReplaceAWSREType) ProtoMessage() {}
func (*ReplaceAWSREType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{8}
}
func (m *ReplaceAWSREType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceAWSREType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceAWSREType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceAWSREType.Merge(m, src)
}
func (m *ReplaceAWSREType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceAWSREType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceAWSREType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceAWSREType proto.InternalMessageInfo

func (m *ReplaceAWSREType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

// Cloud Connect AWS TGW Site Type
//
// x-displayName: "AWS TGW Site Type"
// Cloud Connect AWS TGW Site Type
type AWSTGWSiteType struct {
	// AWS TGW Site Reference
	//
	// x-displayName: "AWS TGW Site Reference"
	// AWS TGW Site Reference
	Site *views.ObjectRefType `protobuf:"bytes,1,opt,name=site,proto3" json:"site,omitempty"`
	// Cloud Credential
	//
	// x-displayName: "Credential Reference"
	// Reference to cloud credential to deploy resources
	Cred *views.ObjectRefType `protobuf:"bytes,2,opt,name=cred,proto3" json:"cred,omitempty"`
	// Spoke VPCs
	//
	// x-displayName: "Spoke VPCs"
	// Spoke VPCs to be attached to the AWS TGW Site
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
	// Cloud Links
	//
	// x-displayName: "CloudLink"
	// Reference to cloud link
	CloudLinks *CloudLinkListType `protobuf:"bytes,4,opt,name=cloud_links,json=cloudLinks,proto3" json:"cloud_links,omitempty"`
}

func (m *AWSTGWSiteType) Reset()      { *m = AWSTGWSiteType{} }
func (*AWSTGWSiteType) ProtoMessage() {}
func (*AWSTGWSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{9}
}
func (m *AWSTGWSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSTGWSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSTGWSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSTGWSiteType.Merge(m, src)
}
func (m *AWSTGWSiteType) XXX_Size() int {
	return m.Size()
}
func (m *AWSTGWSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSTGWSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSTGWSiteType proto.InternalMessageInfo

func (m *AWSTGWSiteType) GetSite() *views.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *AWSTGWSiteType) GetCred() *views.ObjectRefType {
	if m != nil {
		return m.Cred
	}
	return nil
}

func (m *AWSTGWSiteType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

func (m *AWSTGWSiteType) GetCloudLinks() *CloudLinkListType {
	if m != nil {
		return m.CloudLinks
	}
	return nil
}

// Cloud Connect Status
//
// x-displayName: "Cloud Connect Status"
// Cloud Connect Status
type CloudConnectStatusType struct {
	// Types that are valid to be assigned to CloudConnectDeployment:
	//	*CloudConnectStatusType_CloudConnectAwsSite
	CloudConnectDeployment isCloudConnectStatusType_CloudConnectDeployment `protobuf_oneof:"cloud_connect_deployment"`
}

func (m *CloudConnectStatusType) Reset()      { *m = CloudConnectStatusType{} }
func (*CloudConnectStatusType) ProtoMessage() {}
func (*CloudConnectStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{10}
}
func (m *CloudConnectStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudConnectStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudConnectStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudConnectStatusType.Merge(m, src)
}
func (m *CloudConnectStatusType) XXX_Size() int {
	return m.Size()
}
func (m *CloudConnectStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudConnectStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudConnectStatusType proto.InternalMessageInfo

type isCloudConnectStatusType_CloudConnectDeployment interface {
	isCloudConnectStatusType_CloudConnectDeployment()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudConnectStatusType_CloudConnectAwsSite struct {
	CloudConnectAwsSite *AWSAttachmentsListStatusType `protobuf:"bytes,2,opt,name=cloud_connect_aws_site,json=cloudConnectAwsSite,proto3,oneof" json:"cloud_connect_aws_site,omitempty"`
}

func (*CloudConnectStatusType_CloudConnectAwsSite) isCloudConnectStatusType_CloudConnectDeployment() {
}

func (m *CloudConnectStatusType) GetCloudConnectDeployment() isCloudConnectStatusType_CloudConnectDeployment {
	if m != nil {
		return m.CloudConnectDeployment
	}
	return nil
}

func (m *CloudConnectStatusType) GetCloudConnectAwsSite() *AWSAttachmentsListStatusType {
	if x, ok := m.GetCloudConnectDeployment().(*CloudConnectStatusType_CloudConnectAwsSite); ok {
		return x.CloudConnectAwsSite
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CloudConnectStatusType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CloudConnectStatusType_CloudConnectAwsSite)(nil),
	}
}

// AWS VPC Attachment List Status Type
//
// x-displayName: "AWS VPC Attachment List Status Type"
// AWS VPC Attachment List Status Type
type AWSAttachmentsListStatusType struct {
	// AWS VPC Attachment Status Type
	//
	// x-displayName: "AWS VPC Attachment Status Type"
	// AWS Attachment Status Type
	AttachmentStatus []*AWSAttachmentsStatusType `protobuf:"bytes,1,rep,name=attachment_status,json=attachmentStatus,proto3" json:"attachment_status,omitempty"`
}

func (m *AWSAttachmentsListStatusType) Reset()      { *m = AWSAttachmentsListStatusType{} }
func (*AWSAttachmentsListStatusType) ProtoMessage() {}
func (*AWSAttachmentsListStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{11}
}
func (m *AWSAttachmentsListStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSAttachmentsListStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSAttachmentsListStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSAttachmentsListStatusType.Merge(m, src)
}
func (m *AWSAttachmentsListStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AWSAttachmentsListStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSAttachmentsListStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSAttachmentsListStatusType proto.InternalMessageInfo

func (m *AWSAttachmentsListStatusType) GetAttachmentStatus() []*AWSAttachmentsStatusType {
	if m != nil {
		return m.AttachmentStatus
	}
	return nil
}

// AWS VPC Attachment Status Type
//
// x-displayName: "AWS Attachment Status Type"
// AWS Attachment Status Type
type AWSAttachmentsStatusType struct {
	// Attachment Creation Time
	//
	// x-displayName: "Attachment Creation Time"
	// Attachment Creation Time
	CreationTime *types.Timestamp `protobuf:"bytes,1,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
	// TGW Attachment ID
	//
	// x-displayName: "TGW Attachment ID"
	// TGW Attachment ID
	TgwAttachmentId string `protobuf:"bytes,2,opt,name=tgw_attachment_id,json=tgwAttachmentId,proto3" json:"tgw_attachment_id,omitempty"`
	// Subnets
	//
	// x-displayName: "Subnets"
	// Subnets to Route Traffic
	Subnets []string `protobuf:"bytes,3,rep,name=subnets,proto3" json:"subnets,omitempty"`
	// VPC ID
	//
	// x-displayName: "VPC ID"
	// VPC ID
	VpcId string `protobuf:"bytes,4,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
	// VPC Owner Account
	//
	// x-displayName: "VPC Owner Account"
	// VPC Owner Account
	VpcOwnerId string `protobuf:"bytes,5,opt,name=vpc_owner_id,json=vpcOwnerId,proto3" json:"vpc_owner_id,omitempty"`
	// Attachment State
	//
	// x-displayName: "Attachment State"
	// Attachment State
	State string `protobuf:"bytes,6,opt,name=state,proto3" json:"state,omitempty"`
	// Attachment Deployment Status
	//
	// x-displayName: "Attachment Deployment Status"
	// Attachment Deployment Status
	DeploymentStatus string `protobuf:"bytes,7,opt,name=deployment_status,json=deploymentStatus,proto3" json:"deployment_status,omitempty"`
	// Attachment Tags
	//
	// x-displayName: "Attachment Tags"
	// Attachment Tags
	Tags map[string]string `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AWSAttachmentsStatusType) Reset()      { *m = AWSAttachmentsStatusType{} }
func (*AWSAttachmentsStatusType) ProtoMessage() {}
func (*AWSAttachmentsStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{12}
}
func (m *AWSAttachmentsStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSAttachmentsStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSAttachmentsStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSAttachmentsStatusType.Merge(m, src)
}
func (m *AWSAttachmentsStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AWSAttachmentsStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSAttachmentsStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSAttachmentsStatusType proto.InternalMessageInfo

func (m *AWSAttachmentsStatusType) GetCreationTime() *types.Timestamp {
	if m != nil {
		return m.CreationTime
	}
	return nil
}

func (m *AWSAttachmentsStatusType) GetTgwAttachmentId() string {
	if m != nil {
		return m.TgwAttachmentId
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetSubnets() []string {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *AWSAttachmentsStatusType) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetVpcOwnerId() string {
	if m != nil {
		return m.VpcOwnerId
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetDeploymentStatus() string {
	if m != nil {
		return m.DeploymentStatus
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// Cloud Connect specification
//
// x-displayName: "Specification"
// Desired state for Cloud Connect
type GlobalSpecType struct {
	// Provider choice
	//
	// x-displayName: "Provider"
	// x-required
	//
	// Types that are valid to be assigned to Cloud:
	//	*GlobalSpecType_AwsRe
	//	*GlobalSpecType_AwsTgwSite
	Cloud isGlobalSpecType_Cloud `protobuf_oneof:"cloud"`
	// Segment
	//
	// x-displayName: "Segment"
	Segment *views.ObjectRefType `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
	// Bandwidth option
	//
	// x-displayName: "Bandwidth Option"
	// x-required
	// Supported bandwidth
	//
	// Types that are valid to be assigned to BandwidthOption:
	//	*GlobalSpecType_Bandwidth_500Mbs
	BandwidthOption isGlobalSpecType_BandwidthOption `protobuf_oneof:"bandwidth_option"`
	// Site Reference
	//
	// x-displayName: "Site"
	Sites []*schema.ObjectRefType `protobuf:"bytes,12,rep,name=sites,proto3" json:"sites,omitempty"`
	// Virtual Network Reference
	//
	// x-displayName: "Virtual Network"
	VirtualNetwork []*schema.ObjectRefType `protobuf:"bytes,14,rep,name=virtual_network,json=virtualNetwork,proto3" json:"virtual_network,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{13}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_Cloud interface {
	isGlobalSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_BandwidthOption interface {
	isGlobalSpecType_BandwidthOption()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type GlobalSpecType_AwsTgwSite struct {
	AwsTgwSite *AWSTGWSiteType `protobuf:"bytes,7,opt,name=aws_tgw_site,json=awsTgwSite,proto3,oneof" json:"aws_tgw_site,omitempty"`
}
type GlobalSpecType_Bandwidth_500Mbs struct {
	Bandwidth_500Mbs *schema.Empty `protobuf:"bytes,9,opt,name=bandwidth_500mbs,json=bandwidth500mbs,proto3,oneof" json:"bandwidth_500mbs,omitempty"`
}

func (*GlobalSpecType_AwsRe) isGlobalSpecType_Cloud()                      {}
func (*GlobalSpecType_AwsTgwSite) isGlobalSpecType_Cloud()                 {}
func (*GlobalSpecType_Bandwidth_500Mbs) isGlobalSpecType_BandwidthOption() {}

func (m *GlobalSpecType) GetCloud() isGlobalSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}
func (m *GlobalSpecType) GetBandwidthOption() isGlobalSpecType_BandwidthOption {
	if m != nil {
		return m.BandwidthOption
	}
	return nil
}

func (m *GlobalSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*GlobalSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *GlobalSpecType) GetAwsTgwSite() *AWSTGWSiteType {
	if x, ok := m.GetCloud().(*GlobalSpecType_AwsTgwSite); ok {
		return x.AwsTgwSite
	}
	return nil
}

func (m *GlobalSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *GlobalSpecType) GetBandwidth_500Mbs() *schema.Empty {
	if x, ok := m.GetBandwidthOption().(*GlobalSpecType_Bandwidth_500Mbs); ok {
		return x.Bandwidth_500Mbs
	}
	return nil
}

func (m *GlobalSpecType) GetSites() []*schema.ObjectRefType {
	if m != nil {
		return m.Sites
	}
	return nil
}

func (m *GlobalSpecType) GetVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.VirtualNetwork
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_AwsRe)(nil),
		(*GlobalSpecType_AwsTgwSite)(nil),
		(*GlobalSpecType_Bandwidth_500Mbs)(nil),
	}
}

// Create Cloud Connect
//
// x-displayName: "Create Cloud Connect"
// Shape of the Cloud Connect specification
type CreateSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*CreateSpecType_AwsRe
	Cloud   isCreateSpecType_Cloud `protobuf_oneof:"cloud"`
	Segment *views.ObjectRefType   `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{14}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_Cloud interface {
	isCreateSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}

func (*CreateSpecType_AwsRe) isCreateSpecType_Cloud() {}

func (m *CreateSpecType) GetCloud() isCreateSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}

func (m *CreateSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*CreateSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *CreateSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_AwsRe)(nil),
	}
}

// Replace Cloud Connect
//
// x-displayName: "Replace Cloud Connect"
// Shape of the Cloud Connect specification
type ReplaceSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*ReplaceSpecType_AwsRe
	Cloud   isReplaceSpecType_Cloud `protobuf_oneof:"cloud"`
	Segment *views.ObjectRefType    `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{15}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_Cloud interface {
	isReplaceSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_AwsRe struct {
	AwsRe *ReplaceAWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}

func (*ReplaceSpecType_AwsRe) isReplaceSpecType_Cloud() {}

func (m *ReplaceSpecType) GetCloud() isReplaceSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}

func (m *ReplaceSpecType) GetAwsRe() *ReplaceAWSREType {
	if x, ok := m.GetCloud().(*ReplaceSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *ReplaceSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_AwsRe)(nil),
	}
}

// Get Cloud Connect
//
// x-displayName: "Get Cloud Connect"
// Shape of the Cloud Connect specification
type GetSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*GetSpecType_AwsRe
	Cloud   isGetSpecType_Cloud  `protobuf_oneof:"cloud"`
	Segment *views.ObjectRefType `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{16}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_Cloud interface {
	isGetSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}

func (*GetSpecType_AwsRe) isGetSpecType_Cloud() {}

func (m *GetSpecType) GetCloud() isGetSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}

func (m *GetSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*GetSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *GetSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_AwsRe)(nil),
	}
}

func init() {
	proto.RegisterType((*AWSREType)(nil), "ves.io.schema.cloud_connect.AWSREType")
	golang_proto.RegisterType((*AWSREType)(nil), "ves.io.schema.cloud_connect.AWSREType")
	proto.RegisterType((*PeerType)(nil), "ves.io.schema.cloud_connect.PeerType")
	golang_proto.RegisterType((*PeerType)(nil), "ves.io.schema.cloud_connect.PeerType")
	proto.RegisterType((*CloudLinkListType)(nil), "ves.io.schema.cloud_connect.CloudLinkListType")
	golang_proto.RegisterType((*CloudLinkListType)(nil), "ves.io.schema.cloud_connect.CloudLinkListType")
	proto.RegisterType((*AWSVPCAttachmentListType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentListType")
	golang_proto.RegisterType((*AWSVPCAttachmentListType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentListType")
	proto.RegisterType((*AWSVPCAttachmentType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType")
	golang_proto.RegisterType((*AWSVPCAttachmentType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType.LabelsEntry")
	proto.RegisterType((*AWSSubnetIDListType)(nil), "ves.io.schema.cloud_connect.AWSSubnetIDListType")
	golang_proto.RegisterType((*AWSSubnetIDListType)(nil), "ves.io.schema.cloud_connect.AWSSubnetIDListType")
	proto.RegisterType((*AWSRouteTableListType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableListType")
	golang_proto.RegisterType((*AWSRouteTableListType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableListType")
	proto.RegisterType((*AWSRouteTableType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableType")
	golang_proto.RegisterType((*AWSRouteTableType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableType")
	proto.RegisterType((*ReplaceAWSREType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSREType")
	golang_proto.RegisterType((*ReplaceAWSREType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSREType")
	proto.RegisterType((*AWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.AWSTGWSiteType")
	golang_proto.RegisterType((*AWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.AWSTGWSiteType")
	proto.RegisterType((*CloudConnectStatusType)(nil), "ves.io.schema.cloud_connect.CloudConnectStatusType")
	golang_proto.RegisterType((*CloudConnectStatusType)(nil), "ves.io.schema.cloud_connect.CloudConnectStatusType")
	proto.RegisterType((*AWSAttachmentsListStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsListStatusType")
	golang_proto.RegisterType((*AWSAttachmentsListStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsListStatusType")
	proto.RegisterType((*AWSAttachmentsStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType")
	golang_proto.RegisterType((*AWSAttachmentsStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType.TagsEntry")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cloud_connect.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cloud_connect.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cloud_connect.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cloud_connect.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cloud_connect.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cloud_connect.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cloud_connect.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cloud_connect.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/cloud_connect/types.proto", fileDescriptor_245b6fb3a531fd11)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/cloud_connect/types.proto", fileDescriptor_245b6fb3a531fd11)
}

var fileDescriptor_245b6fb3a531fd11 = []byte{
	// 2188 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4d, 0x6c, 0x1b, 0xc7,
	0xf5, 0xe7, 0x90, 0x4b, 0x72, 0xf9, 0x28, 0x51, 0xab, 0xf1, 0xc7, 0x9f, 0x66, 0xfc, 0xa7, 0x59,
	0x56, 0xb1, 0x29, 0x5b, 0x5a, 0x49, 0x74, 0x5c, 0xc7, 0x6a, 0xe3, 0x94, 0xb4, 0x5d, 0x5b, 0x82,
	0xe3, 0x38, 0x2b, 0x35, 0x6e, 0x1a, 0xc4, 0xec, 0x72, 0x77, 0x4c, 0x6f, 0xbd, 0xe2, 0x12, 0xbb,
	0x4b, 0xb2, 0x6a, 0x2b, 0xc0, 0xcd, 0xa1, 0x87, 0xa0, 0x40, 0x0b, 0x1f, 0x7a, 0xc8, 0xa9, 0xa7,
	0xa2, 0xd0, 0xa5, 0x97, 0xb6, 0x01, 0x4c, 0x15, 0x30, 0x02, 0x14, 0x0d, 0xdc, 0x8b, 0x0a, 0xf4,
	0xe0, 0x43, 0x0f, 0x31, 0x7d, 0x71, 0x6f, 0x46, 0x4f, 0x41, 0x4f, 0xc5, 0xcc, 0xec, 0x2e, 0x3f,
	0x4c, 0x53, 0x76, 0x1a, 0x14, 0x6d, 0x2f, 0xc4, 0x7c, 0xbc, 0xdf, 0x7b, 0x6f, 0x7e, 0xef, 0xcd,
	0xe3, 0x9b, 0x85, 0x63, 0x2d, 0xe2, 0xc8, 0x86, 0xb5, 0xe0, 0x68, 0x37, 0xc9, 0x86, 0xba, 0xa0,
	0x99, 0x56, 0x53, 0xaf, 0x68, 0x56, 0xbd, 0x4e, 0x34, 0x77, 0xc1, 0xdd, 0x6c, 0x10, 0x47, 0x6e,
	0xd8, 0x96, 0x6b, 0xe1, 0x97, 0xb8, 0xa0, 0xcc, 0x05, 0xe5, 0x01, 0xc1, 0xcc, 0x7c, 0xcd, 0x70,
	0x6f, 0x36, 0xab, 0xb2, 0x66, 0x6d, 0x2c, 0xd4, 0xac, 0x9a, 0xb5, 0xc0, 0x30, 0xd5, 0xe6, 0x0d,
	0x36, 0x63, 0x13, 0x36, 0xe2, 0xba, 0x32, 0x47, 0x6a, 0x96, 0x55, 0x33, 0x49, 0x4f, 0xca, 0x35,
	0x36, 0x88, 0xe3, 0xaa, 0x1b, 0x0d, 0x4f, 0x60, 0x76, 0x94, 0x57, 0x36, 0xa9, 0xd8, 0xa4, 0x66,
	0x58, 0xf5, 0x7e, 0xbf, 0x32, 0x2f, 0x0d, 0x8a, 0x5a, 0x0d, 0xd7, 0xb0, 0xea, 0xfe, 0xe6, 0xa1,
	0xc1, 0xcd, 0x7e, 0xdc, 0xe1, 0xc1, 0xad, 0x96, 0x6a, 0x1a, 0xba, 0xea, 0x12, 0x6f, 0x37, 0x37,
	0xb4, 0x6b, 0x90, 0x76, 0x65, 0x50, 0xf5, 0x91, 0xa7, 0x25, 0x9c, 0x7e, 0x03, 0xf9, 0x0f, 0x04,
	0x48, 0x94, 0xae, 0xad, 0x29, 0x17, 0xd6, 0x37, 0x1b, 0x04, 0xab, 0x10, 0xe3, 0xce, 0xa7, 0x51,
	0x0e, 0x15, 0x92, 0xc5, 0xbc, 0x3c, 0xc8, 0x27, 0xc3, 0xcb, 0x6f, 0x56, 0xbf, 0x4b, 0x34, 0x57,
	0x21, 0x37, 0x28, 0xa6, 0xfc, 0xf2, 0xf6, 0xd6, 0x84, 0x7f, 0x74, 0x0a, 0xbd, 0xbd, 0x83, 0xd0,
	0xdd, 0x1d, 0x94, 0x12, 0x51, 0x01, 0x2d, 0xa2, 0xe5, 0x98, 0x66, 0xd5, 0x6f, 0x18, 0x35, 0xc5,
	0x53, 0x8c, 0xaf, 0x83, 0xa0, 0xd9, 0x44, 0x4f, 0x87, 0x9f, 0xdb, 0xc0, 0xd1, 0xed, 0xad, 0x69,
	0x2f, 0x90, 0x36, 0xd1, 0x49, 0xdd, 0x35, 0x54, 0xd3, 0x19, 0x61, 0x81, 0xe9, 0xc5, 0x3a, 0x4c,
	0xb5, 0x1a, 0x5a, 0x45, 0x75, 0x5d, 0x55, 0xbb, 0xb9, 0x41, 0xea, 0xae, 0x93, 0x8e, 0x30, 0x53,
	0xa7, 0xe4, 0x31, 0xb9, 0x21, 0x97, 0xae, 0xad, 0xbd, 0x7d, 0xf5, 0x5c, 0x29, 0x40, 0x5d, 0x36,
	0x1c, 0x97, 0x59, 0x17, 0x9e, 0x74, 0x10, 0x52, 0x52, 0xad, 0x86, 0xd6, 0xdb, 0x74, 0xf0, 0x37,
	0x21, 0xc9, 0xf1, 0xa6, 0x51, 0xbf, 0xe5, 0xa4, 0x05, 0x66, 0x41, 0x1e, 0x6b, 0xe1, 0x1c, 0x9d,
	0x5d, 0x36, 0xea, 0xb7, 0x86, 0x54, 0x83, 0xe6, 0x6f, 0x38, 0xf8, 0x10, 0x44, 0xdc, 0x5a, 0x3b,
	0x1d, 0xcd, 0xa1, 0x42, 0xa2, 0x1c, 0x7f, 0xb0, 0x85, 0x1e, 0x53, 0x09, 0xba, 0x86, 0xcf, 0x43,
	0xb4, 0x41, 0x88, 0xed, 0xa4, 0x13, 0xb9, 0x48, 0x21, 0x59, 0x7c, 0x79, 0xac, 0xad, 0xab, 0x84,
	0xd8, 0xcc, 0x44, 0xa0, 0x83, 0x83, 0x97, 0xe1, 0xef, 0x67, 0xe3, 0x4b, 0x73, 0xc5, 0xb9, 0x93,
	0x73, 0xaf, 0xac, 0x0a, 0x62, 0x4c, 0x8a, 0xaf, 0x0a, 0x62, 0x5c, 0x12, 0x57, 0x05, 0x51, 0x94,
	0x12, 0xf9, 0x5f, 0x23, 0x10, 0x7d, 0x28, 0x3e, 0x02, 0x49, 0xb7, 0xd6, 0xae, 0xa8, 0xba, 0x6e,
	0x13, 0xc7, 0x61, 0x09, 0x91, 0x50, 0xc0, 0xad, 0xb5, 0x4b, 0x7c, 0x05, 0x1f, 0x02, 0x91, 0x2a,
	0xad, 0xa8, 0x4e, 0x9d, 0x45, 0x33, 0xa2, 0xc4, 0xe9, 0xbc, 0xe4, 0xd4, 0xf1, 0x57, 0x41, 0xa8,
	0x5b, 0x3a, 0xf1, 0x98, 0x3f, 0x36, 0xd2, 0xd7, 0xe0, 0xa2, 0xc8, 0x57, 0x2c, 0x9d, 0x50, 0x93,
	0x0a, 0x03, 0xe1, 0xe3, 0x30, 0x6d, 0xd4, 0x1d, 0x43, 0x27, 0x95, 0x9a, 0x4d, 0x2a, 0x4e, 0xb3,
	0x5a, 0x27, 0x2e, 0x63, 0x38, 0xa1, 0x4c, 0xf1, 0x8d, 0x8b, 0x36, 0x59, 0x63, 0xcb, 0xf9, 0x1f,
	0x21, 0x98, 0x7e, 0x8a, 0x58, 0x6c, 0x02, 0xf4, 0xa2, 0x93, 0x46, 0x8c, 0xb0, 0xe7, 0xc9, 0xb4,
	0xd9, 0xed, 0xad, 0x3e, 0xe0, 0xd3, 0x29, 0x76, 0xf7, 0x6f, 0xf7, 0x22, 0xd1, 0x3b, 0x28, 0x2c,
	0x21, 0x25, 0x11, 0x44, 0x2d, 0xdf, 0x84, 0xf4, 0xb3, 0xb2, 0x07, 0xbf, 0x03, 0x22, 0xcd, 0x46,
	0xd3, 0x70, 0x5c, 0xcf, 0x8f, 0xa5, 0x17, 0x4a, 0x43, 0xe6, 0x56, 0x92, 0xda, 0x8d, 0xdd, 0x41,
	0x11, 0xe9, 0x36, 0x52, 0xe2, 0xad, 0x86, 0x46, 0xd5, 0xe7, 0x77, 0x45, 0xd8, 0x3f, 0x4a, 0x1c,
	0x6b, 0x10, 0xa3, 0x36, 0x0d, 0x9d, 0xc7, 0xac, 0x7c, 0xf9, 0xb3, 0x0e, 0x0a, 0xdd, 0xdd, 0x41,
	0x92, 0x48, 0x8f, 0xc2, 0x0f, 0x38, 0xaf, 0xab, 0xae, 0x4a, 0xd5, 0x0a, 0x76, 0x38, 0xfd, 0x75,
	0x3a, 0x38, 0x6a, 0xcf, 0x14, 0xf3, 0xd7, 0x0b, 0xad, 0x86, 0x36, 0x3f, 0x5b, 0x78, 0x57, 0x9d,
	0xff, 0xfe, 0xe2, 0xfc, 0x99, 0xf7, 0x7e, 0xf0, 0xea, 0xd6, 0x0f, 0x83, 0xf1, 0xd2, 0xe9, 0xad,
	0xd9, 0x19, 0x25, 0xda, 0x6a, 0x68, 0x2b, 0x3a, 0x3e, 0x0d, 0x49, 0xd5, 0x34, 0xbd, 0xe8, 0xf8,
	0x57, 0x6c, 0xff, 0xd0, 0xd9, 0x2e, 0x6c, 0x34, 0xdc, 0xcd, 0x4b, 0x21, 0x05, 0x54, 0xd3, 0xe4,
	0x01, 0x73, 0xf0, 0x5b, 0x00, 0x1c, 0x54, 0x31, 0x74, 0xff, 0xe2, 0x2c, 0xee, 0xc5, 0x09, 0x07,
	0xaf, 0x9c, 0xf7, 0x79, 0xbd, 0x14, 0x52, 0x12, 0x5c, 0xcb, 0x8a, 0xee, 0xe0, 0xd7, 0x20, 0xb5,
	0xa1, 0xd6, 0x9b, 0xaa, 0x59, 0xb1, 0xad, 0xa6, 0x6b, 0xd4, 0x6b, 0xe9, 0xd8, 0x18, 0x77, 0x90,
	0x32, 0xc9, 0xa5, 0x15, 0x2e, 0x8c, 0xdf, 0x81, 0x49, 0x9d, 0xdc, 0x50, 0x9b, 0xa6, 0xcb, 0xf0,
	0x24, 0x9d, 0x60, 0xe8, 0xe2, 0x5e, 0x4e, 0x51, 0x3c, 0x59, 0x57, 0xab, 0x26, 0x09, 0xdc, 0x42,
	0xca, 0x84, 0xa7, 0x8a, 0x6d, 0xe2, 0x77, 0x21, 0xa5, 0x35, 0x1d, 0xd7, 0xda, 0x08, 0x3c, 0x83,
	0x7f, 0x41, 0xf7, 0x24, 0xd7, 0xe5, 0xfb, 0xed, 0x42, 0xcc, 0x54, 0xab, 0xc4, 0x74, 0xd2, 0x22,
	0xcb, 0xac, 0xd7, 0x5e, 0x38, 0xb3, 0xe4, 0xcb, 0x0c, 0x7f, 0xa1, 0xee, 0xda, 0x9b, 0xe5, 0xff,
	0xff, 0x70, 0x07, 0x09, 0x10, 0x46, 0x21, 0x96, 0xe5, 0x1f, 0xa2, 0xb0, 0x54, 0xe8, 0x7e, 0xfa,
	0x87, 0x48, 0xec, 0x83, 0x1d, 0x14, 0x16, 0x43, 0x8a, 0x67, 0x2b, 0x73, 0x06, 0x92, 0x7d, 0x28,
	0x2c, 0x41, 0xe4, 0x16, 0xd9, 0xf4, 0xaa, 0x03, 0x1d, 0xe2, 0xfd, 0x10, 0x6d, 0xa9, 0x66, 0x93,
	0xb0, 0x9a, 0x90, 0x50, 0xf8, 0x64, 0x39, 0xfc, 0x2a, 0x5a, 0xde, 0x09, 0xdf, 0xef, 0xa0, 0x8f,
	0xc2, 0x80, 0x21, 0xf6, 0xf6, 0xd5, 0x73, 0xb9, 0x95, 0xf3, 0x19, 0xd1, 0x4f, 0x55, 0x28, 0x41,
	0x8c, 0x07, 0xf9, 0xf8, 0x69, 0x38, 0x05, 0x99, 0x81, 0xec, 0x2a, 0x26, 0x4b, 0xa6, 0x99, 0xf3,
	0x26, 0xf0, 0x7f, 0x70, 0xa0, 0x97, 0x40, 0x72, 0x6f, 0x08, 0x7f, 0x44, 0x90, 0x64, 0xbc, 0xe5,
	0x18, 0x71, 0xc7, 0x3f, 0x42, 0xf0, 0x1b, 0x04, 0xb9, 0xe1, 0xe4, 0x28, 0xa6, 0xde, 0x60, 0xf3,
	0x9c, 0x37, 0x87, 0x45, 0xc8, 0x0c, 0xc4, 0x5f, 0x66, 0xbf, 0x15, 0x97, 0x2a, 0x71, 0xf2, 0x58,
	0x8a, 0xe6, 0x53, 0x7d, 0x2b, 0xd4, 0xd9, 0x25, 0x78, 0x69, 0x30, 0xac, 0x7b, 0x43, 0x4e, 0xc0,
	0xec, 0x18, 0x88, 0xec, 0xb8, 0xaa, 0x6b, 0x68, 0xdc, 0xbe, 0x03, 0xfb, 0x21, 0xc6, 0x39, 0x5e,
	0x05, 0x3f, 0xc6, 0x52, 0xb4, 0x3c, 0x03, 0x93, 0xde, 0x69, 0xb5, 0x9b, 0x96, 0xa1, 0x11, 0xbc,
	0xef, 0x5e, 0x07, 0x45, 0x76, 0x3b, 0x28, 0xdc, 0xed, 0xa0, 0xc8, 0xc9, 0xb9, 0x57, 0x7e, 0xb1,
	0x83, 0x50, 0xb9, 0x00, 0x29, 0xcf, 0x82, 0x2f, 0x76, 0xf0, 0x5e, 0x07, 0xc5, 0x76, 0x3b, 0x28,
	0xda, 0xed, 0xa0, 0xd8, 0x57, 0xe6, 0xce, 0xcc, 0x2d, 0x2d, 0x52, 0xc9, 0x55, 0x41, 0x0c, 0x4b,
	0x91, 0x55, 0x41, 0x8c, 0x4a, 0x31, 0xfe, 0x2f, 0x90, 0xff, 0x2d, 0x82, 0x7d, 0x23, 0x6e, 0x1b,
	0xfe, 0x31, 0x1a, 0xb8, 0xb4, 0xb4, 0x90, 0x25, 0xca, 0xb5, 0xbb, 0x3b, 0x08, 0x7b, 0xf5, 0x71,
	0xa8, 0xa8, 0xc8, 0x77, 0xd0, 0x89, 0xfc, 0xac, 0x7d, 0xac, 0xf8, 0xf2, 0xf5, 0x02, 0xc7, 0x8d,
	0xad, 0x29, 0x41, 0x59, 0x15, 0xfc, 0x91, 0x88, 0xfc, 0x51, 0x1a, 0xf5, 0xdd, 0xf4, 0xe5, 0x03,
	0x1f, 0x77, 0xd0, 0x34, 0x4c, 0x01, 0x70, 0x17, 0x73, 0x2b, 0xe7, 0x1d, 0x8c, 0x96, 0xf2, 0xbf,
	0x44, 0x70, 0x60, 0xe4, 0xa5, 0xc1, 0x36, 0x4c, 0xf4, 0xf3, 0xec, 0xd5, 0x60, 0xf9, 0xf9, 0xaf,
	0x1f, 0x2b, 0xc0, 0x47, 0x82, 0x02, 0xfc, 0x09, 0x1a, 0xe9, 0x62, 0xd2, 0x0e, 0x00, 0xce, 0xf2,
	0xa1, 0x8f, 0x3b, 0xe8, 0x00, 0xec, 0x83, 0x94, 0x77, 0x51, 0x79, 0x3a, 0x32, 0x47, 0xff, 0x14,
	0x86, 0xe9, 0xa7, 0xd4, 0x63, 0x17, 0x86, 0xb2, 0xc5, 0x2b, 0xdc, 0x57, 0xbc, 0xc2, 0xfd, 0x0c,
	0x96, 0x87, 0x4b, 0xb7, 0xed, 0x56, 0xc7, 0x97, 0xee, 0x89, 0x9e, 0x97, 0x2b, 0x3a, 0xb6, 0x61,
	0x72, 0x20, 0xeb, 0xd2, 0x26, 0x0b, 0xeb, 0x1b, 0xdb, 0x3b, 0xe8, 0x70, 0x66, 0xcc, 0x8d, 0xa0,
	0x16, 0xe1, 0x0e, 0x8a, 0xe7, 0xa3, 0x76, 0xe4, 0x33, 0x14, 0xb0, 0x20, 0x15, 0x47, 0x32, 0x33,
	0xc1, 0x6d, 0xb0, 0x13, 0x3b, 0xcb, 0x97, 0xef, 0x77, 0xd0, 0x25, 0x98, 0x01, 0x69, 0x80, 0x1a,
	0x5a, 0x09, 0xa4, 0x61, 0x0e, 0x20, 0x07, 0x93, 0x6b, 0x0c, 0x9b, 0xe3, 0xe0, 0xcc, 0xd4, 0x90,
	0xc3, 0xf9, 0xdb, 0x08, 0x24, 0x85, 0x34, 0x4c, 0x55, 0x23, 0xbd, 0x16, 0xf6, 0xfa, 0x17, 0xdb,
	0xff, 0x0d, 0x77, 0x7e, 0xcb, 0x13, 0xf7, 0xcf, 0xf6, 0x1a, 0xe6, 0xfc, 0x4f, 0x22, 0x90, 0x2a,
	0x5d, 0x5b, 0x5b, 0xbf, 0x78, 0x6d, 0xcd, 0x70, 0x79, 0x34, 0xdf, 0x03, 0xc1, 0x31, 0x5c, 0xf2,
	0x82, 0x1d, 0xb4, 0xda, 0x76, 0x2a, 0xb4, 0xdd, 0xa2, 0xd0, 0x67, 0x74, 0xd0, 0x4c, 0xed, 0x7f,
	0x5f, 0xff, 0xbc, 0xfb, 0xef, 0xeb, 0x9f, 0xf3, 0xbf, 0x43, 0x70, 0x90, 0xc9, 0x9d, 0xe3, 0x20,
	0x9a, 0x40, 0x4d, 0x87, 0x85, 0xa5, 0x01, 0x07, 0x07, 0xf4, 0x55, 0x28, 0xe3, 0x2c, 0x50, 0x9c,
	0xc9, 0x33, 0x7b, 0x1d, 0xaf, 0xcf, 0x7d, 0xea, 0x41, 0x4f, 0xf5, 0xa5, 0x90, 0xb2, 0x4f, 0xeb,
	0x33, 0x5a, 0x6a, 0x3b, 0x34, 0x19, 0xca, 0x33, 0x90, 0x1e, 0xb4, 0xa8, 0x93, 0x86, 0x69, 0x6d,
	0x52, 0x0d, 0x58, 0xa4, 0xac, 0x78, 0x55, 0x18, 0x49, 0xe1, 0xfc, 0xfb, 0x08, 0x0e, 0x8f, 0xb3,
	0x81, 0xab, 0x30, 0xdd, 0x0b, 0x49, 0xc5, 0x61, 0x1b, 0x5e, 0x35, 0x3b, 0xf5, 0x02, 0x9e, 0xf7,
	0x34, 0x2a, 0x52, 0x4f, 0x1f, 0x5f, 0xcd, 0xff, 0x3c, 0xca, 0x3a, 0xd9, 0x91, 0xe2, 0xf8, 0x75,
	0x98, 0xd4, 0x6c, 0xa2, 0xd2, 0xc7, 0x65, 0x85, 0x3e, 0x84, 0xbd, 0xfc, 0xce, 0xc8, 0xfc, 0x95,
	0x2c, 0xfb, 0xaf, 0x64, 0x79, 0xdd, 0x7f, 0x25, 0x2b, 0x13, 0x3e, 0x80, 0x2e, 0xd1, 0xb6, 0x9e,
	0xbd, 0x27, 0x7a, 0xa7, 0x30, 0x74, 0xaf, 0x47, 0x98, 0xa2, 0xaf, 0x8a, 0x60, 0x7d, 0x45, 0xc7,
	0x69, 0x88, 0xf7, 0x3a, 0xcb, 0x48, 0x21, 0xa1, 0xf8, 0x53, 0x7c, 0x20, 0x68, 0x6e, 0x05, 0xaf,
	0xbd, 0x60, 0xed, 0x68, 0x0e, 0x26, 0xe8, 0xb2, 0xd5, 0xae, 0x13, 0x9b, 0x6e, 0x46, 0xf9, 0x6b,
	0xa5, 0xd5, 0xd0, 0xde, 0xa4, 0x4b, 0x2b, 0x3a, 0x6d, 0x4b, 0x28, 0x6b, 0x84, 0xf5, 0x86, 0x09,
	0x85, 0x4f, 0xf0, 0x09, 0x98, 0xee, 0x45, 0xc5, 0xa7, 0x35, 0xce, 0x24, 0xa4, 0xde, 0x06, 0xa7,
	0x01, 0xaf, 0x81, 0xe0, 0xaa, 0x35, 0xbf, 0xdd, 0x7a, 0xfd, 0x73, 0xd1, 0x2e, 0xaf, 0xab, 0x35,
	0xde, 0x3a, 0x29, 0x4c, 0x59, 0xe6, 0x34, 0x24, 0x82, 0xa5, 0x17, 0xea, 0xa6, 0x1e, 0xa3, 0xfb,
	0x1d, 0xf4, 0x08, 0xc1, 0x0c, 0x4c, 0xf6, 0x2c, 0xd1, 0x52, 0xba, 0x6f, 0x04, 0xd1, 0xb4, 0x9a,
	0x9e, 0xf3, 0xa2, 0x91, 0xa3, 0xe1, 0xa0, 0xd5, 0x74, 0x20, 0x9e, 0xb0, 0x1f, 0xe2, 0x5e, 0x8f,
	0x9e, 0x49, 0x04, 0xf4, 0x8f, 0xec, 0xd5, 0xbe, 0x0c, 0xd3, 0x74, 0x8d, 0x31, 0x9b, 0x2b, 0x69,
	0x9a, 0xd5, 0xac, 0xbb, 0x99, 0xd4, 0x60, 0x04, 0x40, 0x82, 0x28, 0x3d, 0x35, 0xc9, 0xc4, 0x3d,
	0xe2, 0xa1, 0x00, 0xd3, 0xe7, 0x03, 0x4a, 0x73, 0x9c, 0x12, 0xea, 0xec, 0x53, 0x01, 0x80, 0x14,
	0x08, 0x94, 0x93, 0x4c, 0x8c, 0x13, 0x9e, 0xff, 0xbd, 0x00, 0xa9, 0x8b, 0xa6, 0x55, 0x55, 0xcd,
	0xb5, 0x06, 0xd1, 0xbc, 0x74, 0x8c, 0xd1, 0x0b, 0x6c, 0xfb, 0xd7, 0xf7, 0xe8, 0x9e, 0x7f, 0xe9,
	0x17, 0xbc, 0xbb, 0x1a, 0x55, 0xdb, 0x8e, 0x42, 0xf0, 0xb7, 0x60, 0xa0, 0xe6, 0xb2, 0xa0, 0x27,
	0x8b, 0x27, 0xf6, 0x52, 0xd3, 0x57, 0xe9, 0x83, 0xc7, 0x35, 0x7b, 0xe1, 0xb4, 0x9d, 0xf5, 0x5a,
	0x9b, 0x6e, 0xe1, 0x4b, 0x10, 0x77, 0x48, 0x8d, 0x9e, 0x27, 0x3d, 0xf9, 0xdc, 0x45, 0x1a, 0xb6,
	0xb7, 0x7c, 0x94, 0xe2, 0x0f, 0x70, 0x09, 0xa4, 0xaa, 0x5a, 0xd7, 0xdb, 0x86, 0xee, 0xde, 0xac,
	0x9c, 0x5a, 0x5c, 0xdc, 0xa8, 0x3a, 0xde, 0xe3, 0xe4, 0x59, 0x4f, 0x9b, 0xa9, 0x40, 0x9e, 0x8b,
	0xe3, 0x32, 0x44, 0xe9, 0xf1, 0x9c, 0xf4, 0x04, 0x4b, 0xda, 0xc3, 0x43, 0xb8, 0x41, 0x27, 0x52,
	0xdb, 0x5b, 0xec, 0x4f, 0x26, 0xf8, 0x68, 0xc0, 0xa0, 0xf8, 0x3b, 0x30, 0xd5, 0x32, 0x6c, 0x97,
	0xf6, 0xd0, 0x75, 0xe2, 0xb6, 0x2d, 0xfb, 0x56, 0x3a, 0xf5, 0x1c, 0xda, 0x0e, 0x6d, 0x6f, 0x0d,
	0xe3, 0x7c, 0xc5, 0x29, 0x6f, 0xfd, 0x0a, 0x5f, 0x2e, 0x1f, 0x84, 0x28, 0x63, 0x1a, 0x4f, 0xde,
	0xeb, 0xa0, 0x30, 0xad, 0x8d, 0xdd, 0x0e, 0x42, 0xc5, 0xf2, 0x97, 0xfa, 0x09, 0xe0, 0x5f, 0xb6,
	0x98, 0x48, 0x62, 0xb7, 0x83, 0x44, 0x2a, 0x72, 0x86, 0xd7, 0xcf, 0x55, 0x41, 0x8c, 0x48, 0xc2,
	0xaa, 0x20, 0x0a, 0x52, 0x34, 0xe8, 0x68, 0xf9, 0xd7, 0x0d, 0x51, 0x4a, 0xe4, 0xff, 0x82, 0x20,
	0xc5, 0xb2, 0x9f, 0x7c, 0x71, 0xf9, 0xf3, 0xb5, 0xcf, 0x11, 0xe5, 0x20, 0xb2, 0xcb, 0xd3, 0xf7,
	0xcf, 0x0e, 0x65, 0x74, 0x19, 0xfb, 0x1c, 0x24, 0xde, 0xff, 0x07, 0xe2, 0xc3, 0xf1, 0x87, 0xcb,
	0xff, 0x15, 0xc1, 0x94, 0xd7, 0xff, 0x04, 0xe7, 0xfa, 0xc6, 0xd0, 0xb9, 0xe6, 0xc7, 0x9e, 0x6b,
	0xb8, 0x7b, 0xfa, 0x8f, 0x3a, 0xde, 0x9f, 0x11, 0x24, 0x2f, 0x12, 0xf7, 0x7f, 0x29, 0x64, 0xe5,
	0x9f, 0xa2, 0xdd, 0x87, 0xd9, 0xd0, 0x83, 0x87, 0xd9, 0xd0, 0x93, 0x87, 0x59, 0x74, 0xbb, 0x9b,
	0x45, 0xbf, 0xea, 0x66, 0xd1, 0x27, 0xdd, 0x2c, 0xda, 0xed, 0x66, 0xd1, 0x83, 0x6e, 0x16, 0x7d,
	0xda, 0xcd, 0xa2, 0xc7, 0xdd, 0x6c, 0xe8, 0x49, 0x37, 0x8b, 0x7e, 0xf6, 0x28, 0x1b, 0xba, 0xf7,
	0x28, 0x8b, 0x76, 0x1f, 0x65, 0x43, 0x0f, 0x1e, 0x65, 0x43, 0xdf, 0x7e, 0xab, 0x66, 0x35, 0x6e,
	0xd5, 0xe4, 0x96, 0x65, 0xba, 0xc4, 0xb6, 0x55, 0xb9, 0xe9, 0x2c, 0xb0, 0xc1, 0x0d, 0xcb, 0xde,
	0x98, 0x6f, 0xd8, 0x56, 0xcb, 0xd0, 0x89, 0x3d, 0xef, 0x6f, 0x2f, 0x34, 0xaa, 0x35, 0x6b, 0x81,
	0x7c, 0xcf, 0xf5, 0xbe, 0xfe, 0x8e, 0xfa, 0x7a, 0x5e, 0x8d, 0xb1, 0x3f, 0xee, 0x93, 0xff, 0x0c,
	0x00, 0x00, 0xff, 0xff, 0xba, 0x51, 0x61, 0x5a, 0x63, 0x17, 0x00, 0x00,
}

func (this *AWSREType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSREType)
	if !ok {
		that2, ok := that.(AWSREType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Region.Equal(that1.Region) {
		return false
	}
	if !this.Cred.Equal(that1.Cred) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	if !this.CloudLinks.Equal(that1.CloudLinks) {
		return false
	}
	if this.Tgw != that1.Tgw {
		return false
	}
	if len(this.Peers) != len(that1.Peers) {
		return false
	}
	for i := range this.Peers {
		if !this.Peers[i].Equal(that1.Peers[i]) {
			return false
		}
	}
	return true
}
func (this *PeerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PeerType)
	if !ok {
		that2, ok := that.(PeerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TgwAddress != that1.TgwAddress {
		return false
	}
	if this.PeerAsn != that1.PeerAsn {
		return false
	}
	if !this.Node.Equal(that1.Node) {
		return false
	}
	if this.InsideGreSubnet != that1.InsideGreSubnet {
		return false
	}
	return true
}
func (this *CloudLinkListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudLinkListType)
	if !ok {
		that2, ok := that.(CloudLinkListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CloudLink) != len(that1.CloudLink) {
		return false
	}
	for i := range this.CloudLink {
		if !this.CloudLink[i].Equal(that1.CloudLink[i]) {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentListType)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VpcList) != len(that1.VpcList) {
		return false
	}
	for i := range this.VpcList {
		if !this.VpcList[i].Equal(that1.VpcList[i]) {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	if that1.SubnetChoice == nil {
		if this.SubnetChoice != nil {
			return false
		}
	} else if this.SubnetChoice == nil {
		return false
	} else if !this.SubnetChoice.Equal(that1.SubnetChoice) {
		return false
	}
	if that1.RoutingChoice == nil {
		if this.RoutingChoice != nil {
			return false
		}
	} else if this.RoutingChoice == nil {
		return false
	} else if !this.RoutingChoice.Equal(that1.RoutingChoice) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentType_AllSubnets) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_AllSubnets)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_AllSubnets)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllSubnets.Equal(that1.AllSubnets) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_SubnetIds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_SubnetIds)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_SubnetIds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetIds.Equal(that1.SubnetIds) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_ManualRouting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_ManualRouting)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_ManualRouting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ManualRouting.Equal(that1.ManualRouting) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_DefaultRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_DefaultRoute)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_DefaultRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultRoute.Equal(that1.DefaultRoute) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_CustomRouting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_CustomRouting)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_CustomRouting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomRouting.Equal(that1.CustomRouting) {
		return false
	}
	return true
}
func (this *AWSSubnetIDListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSSubnetIDListType)
	if !ok {
		that2, ok := that.(AWSSubnetIDListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SubnetIds) != len(that1.SubnetIds) {
		return false
	}
	for i := range this.SubnetIds {
		if this.SubnetIds[i] != that1.SubnetIds[i] {
			return false
		}
	}
	return true
}
func (this *AWSRouteTableListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSRouteTableListType)
	if !ok {
		that2, ok := that.(AWSRouteTableListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RouteTables) != len(that1.RouteTables) {
		return false
	}
	for i := range this.RouteTables {
		if !this.RouteTables[i].Equal(that1.RouteTables[i]) {
			return false
		}
	}
	return true
}
func (this *AWSRouteTableType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSRouteTableType)
	if !ok {
		that2, ok := that.(AWSRouteTableType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RouteTableId != that1.RouteTableId {
		return false
	}
	if len(this.StaticRoutes) != len(that1.StaticRoutes) {
		return false
	}
	for i := range this.StaticRoutes {
		if this.StaticRoutes[i] != that1.StaticRoutes[i] {
			return false
		}
	}
	return true
}
func (this *ReplaceAWSREType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceAWSREType)
	if !ok {
		that2, ok := that.(ReplaceAWSREType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	return true
}
func (this *AWSTGWSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTGWSiteType)
	if !ok {
		that2, ok := that.(AWSTGWSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	if !this.Cred.Equal(that1.Cred) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	if !this.CloudLinks.Equal(that1.CloudLinks) {
		return false
	}
	return true
}
func (this *CloudConnectStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudConnectStatusType)
	if !ok {
		that2, ok := that.(CloudConnectStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CloudConnectDeployment == nil {
		if this.CloudConnectDeployment != nil {
			return false
		}
	} else if this.CloudConnectDeployment == nil {
		return false
	} else if !this.CloudConnectDeployment.Equal(that1.CloudConnectDeployment) {
		return false
	}
	return true
}
func (this *CloudConnectStatusType_CloudConnectAwsSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudConnectStatusType_CloudConnectAwsSite)
	if !ok {
		that2, ok := that.(CloudConnectStatusType_CloudConnectAwsSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CloudConnectAwsSite.Equal(that1.CloudConnectAwsSite) {
		return false
	}
	return true
}
func (this *AWSAttachmentsListStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSAttachmentsListStatusType)
	if !ok {
		that2, ok := that.(AWSAttachmentsListStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AttachmentStatus) != len(that1.AttachmentStatus) {
		return false
	}
	for i := range this.AttachmentStatus {
		if !this.AttachmentStatus[i].Equal(that1.AttachmentStatus[i]) {
			return false
		}
	}
	return true
}
func (this *AWSAttachmentsStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSAttachmentsStatusType)
	if !ok {
		that2, ok := that.(AWSAttachmentsStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreationTime.Equal(that1.CreationTime) {
		return false
	}
	if this.TgwAttachmentId != that1.TgwAttachmentId {
		return false
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if this.Subnets[i] != that1.Subnets[i] {
			return false
		}
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	if this.VpcOwnerId != that1.VpcOwnerId {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.DeploymentStatus != that1.DeploymentStatus {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	if that1.BandwidthOption == nil {
		if this.BandwidthOption != nil {
			return false
		}
	} else if this.BandwidthOption == nil {
		return false
	} else if !this.BandwidthOption.Equal(that1.BandwidthOption) {
		return false
	}
	if len(this.Sites) != len(that1.Sites) {
		return false
	}
	for i := range this.Sites {
		if !this.Sites[i].Equal(that1.Sites[i]) {
			return false
		}
	}
	if len(this.VirtualNetwork) != len(that1.VirtualNetwork) {
		return false
	}
	for i := range this.VirtualNetwork {
		if !this.VirtualNetwork[i].Equal(that1.VirtualNetwork[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AwsRe)
	if !ok {
		that2, ok := that.(GlobalSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AwsTgwSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AwsTgwSite)
	if !ok {
		that2, ok := that.(GlobalSpecType_AwsTgwSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsTgwSite.Equal(that1.AwsTgwSite) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Bandwidth_500Mbs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Bandwidth_500Mbs)
	if !ok {
		that2, ok := that.(GlobalSpecType_Bandwidth_500Mbs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Bandwidth_500Mbs.Equal(that1.Bandwidth_500Mbs) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	return true
}
func (this *CreateSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AwsRe)
	if !ok {
		that2, ok := that.(CreateSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AwsRe)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	return true
}
func (this *GetSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AwsRe)
	if !ok {
		that2, ok := that.(GetSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *AWSREType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud_connect.AWSREType{")
	if this.Region != nil {
		s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	}
	if this.Cred != nil {
		s = append(s, "Cred: "+fmt.Sprintf("%#v", this.Cred)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	if this.CloudLinks != nil {
		s = append(s, "CloudLinks: "+fmt.Sprintf("%#v", this.CloudLinks)+",\n")
	}
	s = append(s, "Tgw: "+fmt.Sprintf("%#v", this.Tgw)+",\n")
	if this.Peers != nil {
		s = append(s, "Peers: "+fmt.Sprintf("%#v", this.Peers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PeerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_connect.PeerType{")
	s = append(s, "TgwAddress: "+fmt.Sprintf("%#v", this.TgwAddress)+",\n")
	s = append(s, "PeerAsn: "+fmt.Sprintf("%#v", this.PeerAsn)+",\n")
	if this.Node != nil {
		s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	}
	s = append(s, "InsideGreSubnet: "+fmt.Sprintf("%#v", this.InsideGreSubnet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudLinkListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.CloudLinkListType{")
	if this.CloudLink != nil {
		s = append(s, "CloudLink: "+fmt.Sprintf("%#v", this.CloudLink)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSVPCAttachmentListType{")
	if this.VpcList != nil {
		s = append(s, "VpcList: "+fmt.Sprintf("%#v", this.VpcList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cloud_connect.AWSVPCAttachmentType{")
	s = append(s, "VpcId: "+fmt.Sprintf("%#v", this.VpcId)+",\n")
	if this.SubnetChoice != nil {
		s = append(s, "SubnetChoice: "+fmt.Sprintf("%#v", this.SubnetChoice)+",\n")
	}
	if this.RoutingChoice != nil {
		s = append(s, "RoutingChoice: "+fmt.Sprintf("%#v", this.RoutingChoice)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentType_AllSubnets) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_AllSubnets{` +
		`AllSubnets:` + fmt.Sprintf("%#v", this.AllSubnets) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_SubnetIds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_SubnetIds{` +
		`SubnetIds:` + fmt.Sprintf("%#v", this.SubnetIds) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_ManualRouting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_ManualRouting{` +
		`ManualRouting:` + fmt.Sprintf("%#v", this.ManualRouting) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_DefaultRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_DefaultRoute{` +
		`DefaultRoute:` + fmt.Sprintf("%#v", this.DefaultRoute) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_CustomRouting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_CustomRouting{` +
		`CustomRouting:` + fmt.Sprintf("%#v", this.CustomRouting) + `}`}, ", ")
	return s
}
func (this *AWSSubnetIDListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSSubnetIDListType{")
	s = append(s, "SubnetIds: "+fmt.Sprintf("%#v", this.SubnetIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSRouteTableListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSRouteTableListType{")
	if this.RouteTables != nil {
		s = append(s, "RouteTables: "+fmt.Sprintf("%#v", this.RouteTables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSRouteTableType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.AWSRouteTableType{")
	s = append(s, "RouteTableId: "+fmt.Sprintf("%#v", this.RouteTableId)+",\n")
	s = append(s, "StaticRoutes: "+fmt.Sprintf("%#v", this.StaticRoutes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceAWSREType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.ReplaceAWSREType{")
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTGWSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_connect.AWSTGWSiteType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.Cred != nil {
		s = append(s, "Cred: "+fmt.Sprintf("%#v", this.Cred)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	if this.CloudLinks != nil {
		s = append(s, "CloudLinks: "+fmt.Sprintf("%#v", this.CloudLinks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudConnectStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.CloudConnectStatusType{")
	if this.CloudConnectDeployment != nil {
		s = append(s, "CloudConnectDeployment: "+fmt.Sprintf("%#v", this.CloudConnectDeployment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudConnectStatusType_CloudConnectAwsSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CloudConnectStatusType_CloudConnectAwsSite{` +
		`CloudConnectAwsSite:` + fmt.Sprintf("%#v", this.CloudConnectAwsSite) + `}`}, ", ")
	return s
}
func (this *AWSAttachmentsListStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSAttachmentsListStatusType{")
	if this.AttachmentStatus != nil {
		s = append(s, "AttachmentStatus: "+fmt.Sprintf("%#v", this.AttachmentStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSAttachmentsStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&cloud_connect.AWSAttachmentsStatusType{")
	if this.CreationTime != nil {
		s = append(s, "CreationTime: "+fmt.Sprintf("%#v", this.CreationTime)+",\n")
	}
	s = append(s, "TgwAttachmentId: "+fmt.Sprintf("%#v", this.TgwAttachmentId)+",\n")
	s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	s = append(s, "VpcId: "+fmt.Sprintf("%#v", this.VpcId)+",\n")
	s = append(s, "VpcOwnerId: "+fmt.Sprintf("%#v", this.VpcOwnerId)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "DeploymentStatus: "+fmt.Sprintf("%#v", this.DeploymentStatus)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud_connect.GlobalSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	if this.BandwidthOption != nil {
		s = append(s, "BandwidthOption: "+fmt.Sprintf("%#v", this.BandwidthOption)+",\n")
	}
	if this.Sites != nil {
		s = append(s, "Sites: "+fmt.Sprintf("%#v", this.Sites)+",\n")
	}
	if this.VirtualNetwork != nil {
		s = append(s, "VirtualNetwork: "+fmt.Sprintf("%#v", this.VirtualNetwork)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AwsTgwSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_AwsTgwSite{` +
		`AwsTgwSite:` + fmt.Sprintf("%#v", this.AwsTgwSite) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Bandwidth_500Mbs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_Bandwidth_500Mbs{` +
		`Bandwidth_500Mbs:` + fmt.Sprintf("%#v", this.Bandwidth_500Mbs) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.CreateSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CreateSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.ReplaceSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.ReplaceSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.GetSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GetSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AWSREType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSREType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSREType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for iNdEx := len(m.Peers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Tgw) > 0 {
		i -= len(m.Tgw)
		copy(dAtA[i:], m.Tgw)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tgw)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CloudLinks != nil {
		{
			size, err := m.CloudLinks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Cred != nil {
		{
			size, err := m.Cred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PeerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InsideGreSubnet) > 0 {
		i -= len(m.InsideGreSubnet)
		copy(dAtA[i:], m.InsideGreSubnet)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideGreSubnet)))
		i--
		dAtA[i] = 0x22
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PeerAsn != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PeerAsn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TgwAddress) > 0 {
		i -= len(m.TgwAddress)
		copy(dAtA[i:], m.TgwAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TgwAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudLinkListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudLinkListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudLinkListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudLink) > 0 {
		for iNdEx := len(m.CloudLink) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudLink[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCAttachmentListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VpcList) > 0 {
		for iNdEx := len(m.VpcList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VpcList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCAttachmentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoutingChoice != nil {
		{
			size := m.RoutingChoice.Size()
			i -= size
			if _, err := m.RoutingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.SubnetChoice != nil {
		{
			size := m.SubnetChoice.Size()
			i -= size
			if _, err := m.SubnetChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.VpcId) > 0 {
		i -= len(m.VpcId)
		copy(dAtA[i:], m.VpcId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentType_AllSubnets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_AllSubnets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllSubnets != nil {
		{
			size, err := m.AllSubnets.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_SubnetIds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_SubnetIds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubnetIds != nil {
		{
			size, err := m.SubnetIds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_ManualRouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_ManualRouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ManualRouting != nil {
		{
			size, err := m.ManualRouting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_DefaultRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_DefaultRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultRoute != nil {
		{
			size, err := m.DefaultRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_CustomRouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_CustomRouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomRouting != nil {
		{
			size, err := m.CustomRouting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *AWSSubnetIDListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSSubnetIDListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSubnetIDListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubnetIds) > 0 {
		for iNdEx := len(m.SubnetIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubnetIds[iNdEx])
			copy(dAtA[i:], m.SubnetIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SubnetIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSRouteTableListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSRouteTableListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSRouteTableListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for iNdEx := len(m.RouteTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RouteTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSRouteTableType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSRouteTableType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSRouteTableType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StaticRoutes) > 0 {
		for iNdEx := len(m.StaticRoutes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StaticRoutes[iNdEx])
			copy(dAtA[i:], m.StaticRoutes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.StaticRoutes[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RouteTableId) > 0 {
		i -= len(m.RouteTableId)
		copy(dAtA[i:], m.RouteTableId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteTableId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceAWSREType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceAWSREType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceAWSREType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *AWSTGWSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTGWSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSTGWSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudLinks != nil {
		{
			size, err := m.CloudLinks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Cred != nil {
		{
			size, err := m.Cred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudConnectStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudConnectStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudConnectStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudConnectDeployment != nil {
		{
			size := m.CloudConnectDeployment.Size()
			i -= size
			if _, err := m.CloudConnectDeployment.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudConnectStatusType_CloudConnectAwsSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudConnectStatusType_CloudConnectAwsSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloudConnectAwsSite != nil {
		{
			size, err := m.CloudConnectAwsSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AWSAttachmentsListStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSAttachmentsListStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSAttachmentsListStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttachmentStatus) > 0 {
		for iNdEx := len(m.AttachmentStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AttachmentStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSAttachmentsStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSAttachmentsStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSAttachmentsStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DeploymentStatus) > 0 {
		i -= len(m.DeploymentStatus)
		copy(dAtA[i:], m.DeploymentStatus)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeploymentStatus)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.VpcOwnerId) > 0 {
		i -= len(m.VpcOwnerId)
		copy(dAtA[i:], m.VpcOwnerId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcOwnerId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.VpcId) > 0 {
		i -= len(m.VpcId)
		copy(dAtA[i:], m.VpcId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Subnets[iNdEx])
			copy(dAtA[i:], m.Subnets[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Subnets[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TgwAttachmentId) > 0 {
		i -= len(m.TgwAttachmentId)
		copy(dAtA[i:], m.TgwAttachmentId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TgwAttachmentId)))
		i--
		dAtA[i] = 0x12
	}
	if m.CreationTime != nil {
		{
			size, err := m.CreationTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VirtualNetwork) > 0 {
		for iNdEx := len(m.VirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Sites) > 0 {
		for iNdEx := len(m.Sites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.BandwidthOption != nil {
		{
			size := m.BandwidthOption.Size()
			i -= size
			if _, err := m.BandwidthOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AwsTgwSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AwsTgwSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsTgwSite != nil {
		{
			size, err := m.AwsTgwSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Bandwidth_500Mbs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Bandwidth_500Mbs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bandwidth_500Mbs != nil {
		{
			size, err := m.Bandwidth_500Mbs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AWSREType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cred != nil {
		l = m.Cred.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CloudLinks != nil {
		l = m.CloudLinks.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Tgw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PeerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TgwAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PeerAsn != 0 {
		n += 1 + sovTypes(uint64(m.PeerAsn))
	}
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InsideGreSubnet)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CloudLinkListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CloudLink) > 0 {
		for _, e := range m.CloudLink {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSVPCAttachmentListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VpcList) > 0 {
		for _, e := range m.VpcList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSVPCAttachmentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SubnetChoice != nil {
		n += m.SubnetChoice.Size()
	}
	if m.RoutingChoice != nil {
		n += m.RoutingChoice.Size()
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AWSVPCAttachmentType_AllSubnets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllSubnets != nil {
		l = m.AllSubnets.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_SubnetIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetIds != nil {
		l = m.SubnetIds.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_ManualRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManualRouting != nil {
		l = m.ManualRouting.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_DefaultRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultRoute != nil {
		l = m.DefaultRoute.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_CustomRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomRouting != nil {
		l = m.CustomRouting.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSSubnetIDListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubnetIds) > 0 {
		for _, s := range m.SubnetIds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSRouteTableListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for _, e := range m.RouteTables {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSRouteTableType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteTableId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.StaticRoutes) > 0 {
		for _, s := range m.StaticRoutes {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceAWSREType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AWSTGWSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cred != nil {
		l = m.Cred.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CloudLinks != nil {
		l = m.CloudLinks.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CloudConnectStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudConnectDeployment != nil {
		n += m.CloudConnectDeployment.Size()
	}
	return n
}

func (m *CloudConnectStatusType_CloudConnectAwsSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudConnectAwsSite != nil {
		l = m.CloudConnectAwsSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSAttachmentsListStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AttachmentStatus) > 0 {
		for _, e := range m.AttachmentStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSAttachmentsStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreationTime != nil {
		l = m.CreationTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TgwAttachmentId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Subnets) > 0 {
		for _, s := range m.Subnets {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VpcOwnerId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DeploymentStatus)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.BandwidthOption != nil {
		n += m.BandwidthOption.Size()
	}
	if len(m.Sites) > 0 {
		for _, e := range m.Sites {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.VirtualNetwork) > 0 {
		for _, e := range m.VirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AwsTgwSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsTgwSite != nil {
		l = m.AwsTgwSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Bandwidth_500Mbs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bandwidth_500Mbs != nil {
		l = m.Bandwidth_500Mbs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSREType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPeers := "[]*PeerType{"
	for _, f := range this.Peers {
		repeatedStringForPeers += strings.Replace(f.String(), "PeerType", "PeerType", 1) + ","
	}
	repeatedStringForPeers += "}"
	s := strings.Join([]string{`&AWSREType{`,
		`Region:` + strings.Replace(fmt.Sprintf("%v", this.Region), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Cred:` + strings.Replace(fmt.Sprintf("%v", this.Cred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`CloudLinks:` + strings.Replace(this.CloudLinks.String(), "CloudLinkListType", "CloudLinkListType", 1) + `,`,
		`Tgw:` + fmt.Sprintf("%v", this.Tgw) + `,`,
		`Peers:` + repeatedStringForPeers + `,`,
		`}`,
	}, "")
	return s
}
func (this *PeerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PeerType{`,
		`TgwAddress:` + fmt.Sprintf("%v", this.TgwAddress) + `,`,
		`PeerAsn:` + fmt.Sprintf("%v", this.PeerAsn) + `,`,
		`Node:` + strings.Replace(fmt.Sprintf("%v", this.Node), "NodeType", "cloud_re_region.NodeType", 1) + `,`,
		`InsideGreSubnet:` + fmt.Sprintf("%v", this.InsideGreSubnet) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudLinkListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCloudLink := "[]*ObjectRefType{"
	for _, f := range this.CloudLink {
		repeatedStringForCloudLink += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForCloudLink += "}"
	s := strings.Join([]string{`&CloudLinkListType{`,
		`CloudLink:` + repeatedStringForCloudLink + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVpcList := "[]*AWSVPCAttachmentType{"
	for _, f := range this.VpcList {
		repeatedStringForVpcList += strings.Replace(f.String(), "AWSVPCAttachmentType", "AWSVPCAttachmentType", 1) + ","
	}
	repeatedStringForVpcList += "}"
	s := strings.Join([]string{`&AWSVPCAttachmentListType{`,
		`VpcList:` + repeatedStringForVpcList + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&AWSVPCAttachmentType{`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`SubnetChoice:` + fmt.Sprintf("%v", this.SubnetChoice) + `,`,
		`RoutingChoice:` + fmt.Sprintf("%v", this.RoutingChoice) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_AllSubnets) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_AllSubnets{`,
		`AllSubnets:` + strings.Replace(fmt.Sprintf("%v", this.AllSubnets), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_SubnetIds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_SubnetIds{`,
		`SubnetIds:` + strings.Replace(fmt.Sprintf("%v", this.SubnetIds), "AWSSubnetIDListType", "AWSSubnetIDListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_ManualRouting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_ManualRouting{`,
		`ManualRouting:` + strings.Replace(fmt.Sprintf("%v", this.ManualRouting), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_DefaultRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_DefaultRoute{`,
		`DefaultRoute:` + strings.Replace(fmt.Sprintf("%v", this.DefaultRoute), "AWSRouteTableListType", "AWSRouteTableListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_CustomRouting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_CustomRouting{`,
		`CustomRouting:` + strings.Replace(fmt.Sprintf("%v", this.CustomRouting), "AWSRouteTableListType", "AWSRouteTableListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSSubnetIDListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSSubnetIDListType{`,
		`SubnetIds:` + fmt.Sprintf("%v", this.SubnetIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSRouteTableListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRouteTables := "[]*AWSRouteTableType{"
	for _, f := range this.RouteTables {
		repeatedStringForRouteTables += strings.Replace(f.String(), "AWSRouteTableType", "AWSRouteTableType", 1) + ","
	}
	repeatedStringForRouteTables += "}"
	s := strings.Join([]string{`&AWSRouteTableListType{`,
		`RouteTables:` + repeatedStringForRouteTables + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSRouteTableType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSRouteTableType{`,
		`RouteTableId:` + fmt.Sprintf("%v", this.RouteTableId) + `,`,
		`StaticRoutes:` + fmt.Sprintf("%v", this.StaticRoutes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceAWSREType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceAWSREType{`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTGWSiteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSTGWSiteType{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Cred:` + strings.Replace(fmt.Sprintf("%v", this.Cred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`CloudLinks:` + strings.Replace(this.CloudLinks.String(), "CloudLinkListType", "CloudLinkListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudConnectStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudConnectStatusType{`,
		`CloudConnectDeployment:` + fmt.Sprintf("%v", this.CloudConnectDeployment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudConnectStatusType_CloudConnectAwsSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudConnectStatusType_CloudConnectAwsSite{`,
		`CloudConnectAwsSite:` + strings.Replace(fmt.Sprintf("%v", this.CloudConnectAwsSite), "AWSAttachmentsListStatusType", "AWSAttachmentsListStatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSAttachmentsListStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAttachmentStatus := "[]*AWSAttachmentsStatusType{"
	for _, f := range this.AttachmentStatus {
		repeatedStringForAttachmentStatus += strings.Replace(f.String(), "AWSAttachmentsStatusType", "AWSAttachmentsStatusType", 1) + ","
	}
	repeatedStringForAttachmentStatus += "}"
	s := strings.Join([]string{`&AWSAttachmentsListStatusType{`,
		`AttachmentStatus:` + repeatedStringForAttachmentStatus + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSAttachmentsStatusType) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&AWSAttachmentsStatusType{`,
		`CreationTime:` + strings.Replace(fmt.Sprintf("%v", this.CreationTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`TgwAttachmentId:` + fmt.Sprintf("%v", this.TgwAttachmentId) + `,`,
		`Subnets:` + fmt.Sprintf("%v", this.Subnets) + `,`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`VpcOwnerId:` + fmt.Sprintf("%v", this.VpcOwnerId) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`DeploymentStatus:` + fmt.Sprintf("%v", this.DeploymentStatus) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSites := "[]*ObjectRefType{"
	for _, f := range this.Sites {
		repeatedStringForSites += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSites += "}"
	repeatedStringForVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.VirtualNetwork {
		repeatedStringForVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualNetwork += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`BandwidthOption:` + fmt.Sprintf("%v", this.BandwidthOption) + `,`,
		`Sites:` + repeatedStringForSites + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VirtualNetwork:` + repeatedStringForVirtualNetwork + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AwsTgwSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AwsTgwSite{`,
		`AwsTgwSite:` + strings.Replace(fmt.Sprintf("%v", this.AwsTgwSite), "AWSTGWSiteType", "AWSTGWSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Bandwidth_500Mbs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Bandwidth_500Mbs{`,
		`Bandwidth_500Mbs:` + strings.Replace(fmt.Sprintf("%v", this.Bandwidth_500Mbs), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "ReplaceAWSREType", "ReplaceAWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSREType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSREType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSREType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &views.ObjectRefType{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cred == nil {
				m.Cred = &views.ObjectRefType{}
			}
			if err := m.Cred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudLinks == nil {
				m.CloudLinks = &CloudLinkListType{}
			}
			if err := m.CloudLinks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tgw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &PeerType{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TgwAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAsn", wireType)
			}
			m.PeerAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerAsn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &cloud_re_region.NodeType{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideGreSubnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideGreSubnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudLinkListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudLinkListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudLinkListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudLink = append(m.CloudLink, &views.ObjectRefType{})
			if err := m.CloudLink[len(m.CloudLink)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCAttachmentListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCAttachmentListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCAttachmentListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcList = append(m.VpcList, &AWSVPCAttachmentType{})
			if err := m.VpcList[len(m.VpcList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCAttachmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCAttachmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCAttachmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllSubnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SubnetChoice = &AWSVPCAttachmentType_AllSubnets{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSSubnetIDListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SubnetChoice = &AWSVPCAttachmentType_SubnetIds{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualRouting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_ManualRouting{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSRouteTableListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_DefaultRoute{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomRouting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSRouteTableListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_CustomRouting{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSSubnetIDListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSSubnetIDListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSSubnetIDListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetIds = append(m.SubnetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSRouteTableListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSRouteTableListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSRouteTableListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTables = append(m.RouteTables, &AWSRouteTableType{})
			if err := m.RouteTables[len(m.RouteTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSRouteTableType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSRouteTableType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSRouteTableType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRoutes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticRoutes = append(m.StaticRoutes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceAWSREType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceAWSREType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceAWSREType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTGWSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTGWSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTGWSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Site == nil {
				m.Site = &views.ObjectRefType{}
			}
			if err := m.Site.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cred == nil {
				m.Cred = &views.ObjectRefType{}
			}
			if err := m.Cred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudLinks == nil {
				m.CloudLinks = &CloudLinkListType{}
			}
			if err := m.CloudLinks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudConnectStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudConnectStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudConnectStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudConnectAwsSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSAttachmentsListStatusType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudConnectDeployment = &CloudConnectStatusType_CloudConnectAwsSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSAttachmentsListStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSAttachmentsListStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSAttachmentsListStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachmentStatus = append(m.AttachmentStatus, &AWSAttachmentsStatusType{})
			if err := m.AttachmentStatus[len(m.AttachmentStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSAttachmentsStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSAttachmentsStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSAttachmentsStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTime == nil {
				m.CreationTime = &types.Timestamp{}
			}
			if err := m.CreationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwAttachmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TgwAttachmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcOwnerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcOwnerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GlobalSpecType_AwsRe{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsTgwSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSTGWSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GlobalSpecType_AwsTgwSite{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth_500Mbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BandwidthOption = &GlobalSpecType_Bandwidth_500Mbs{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sites = append(m.Sites, &schema.ObjectRefType{})
			if err := m.Sites[len(m.Sites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = append(m.VirtualNetwork, &schema.ObjectRefType{})
			if err := m.VirtualNetwork[len(m.VirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &CreateSpecType_AwsRe{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplaceAWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &ReplaceSpecType_AwsRe{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GetSpecType_AwsRe{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
