// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/cloud_connect/types.proto

package cloud_connect

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	cloud_re_region "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/cloud_re_region"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Cloud Connect AWS RE Type
//
// x-displayName: "AWS Type"
// Cloud Connect AWS Type
type AWSREType struct {
	// Region
	//
	// x-displayName: "Region"
	// Regions we support cloud_connects
	Region *views.ObjectRefType `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	// Cloud Credential
	//
	// x-displayName: "Credential Reference"
	// Reference to cloud credential to deploy resources
	Cred *views.ObjectRefType `protobuf:"bytes,2,opt,name=cred,proto3" json:"cred,omitempty"`
	// Spoke VPCs
	//
	// x-displayName: "Spoke VPCs"
	// Spoke VPCs to be attached to the AWS TGW Site
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
	// Cloud Links
	//
	// x-displayName: "Cloud Links"
	// Reference to cloud links
	CloudLinks *CloudLinkListType `protobuf:"bytes,4,opt,name=cloud_links,json=cloudLinks,proto3" json:"cloud_links,omitempty"`
	// TGW Name
	//
	// x-displayName: "TGW Name"
	// TGW Name of assigned
	Tgw string `protobuf:"bytes,5,opt,name=tgw,proto3" json:"tgw,omitempty"`
	// Nodes
	//
	// x-displayName: "Nodes"
	// Connected Nodes
	Nodes []*cloud_re_region.NodeType `protobuf:"bytes,6,rep,name=nodes,proto3" json:"nodes,omitempty"`
}

func (m *AWSREType) Reset()      { *m = AWSREType{} }
func (*AWSREType) ProtoMessage() {}
func (*AWSREType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{0}
}
func (m *AWSREType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSREType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSREType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSREType.Merge(m, src)
}
func (m *AWSREType) XXX_Size() int {
	return m.Size()
}
func (m *AWSREType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSREType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSREType proto.InternalMessageInfo

func (m *AWSREType) GetRegion() *views.ObjectRefType {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *AWSREType) GetCred() *views.ObjectRefType {
	if m != nil {
		return m.Cred
	}
	return nil
}

func (m *AWSREType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

func (m *AWSREType) GetCloudLinks() *CloudLinkListType {
	if m != nil {
		return m.CloudLinks
	}
	return nil
}

func (m *AWSREType) GetTgw() string {
	if m != nil {
		return m.Tgw
	}
	return ""
}

func (m *AWSREType) GetNodes() []*cloud_re_region.NodeType {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// Cloud Links
//
// x-displayName: "Cloud Links"
// List of Cloud Link references to be attached
type CloudLinkListType struct {
	// Cloud Link
	//
	// x-displayName: "Cloud Link Reference"
	// Reference to cloud link
	CloudLink []*views.ObjectRefType `protobuf:"bytes,1,rep,name=cloud_link,json=cloudLink,proto3" json:"cloud_link,omitempty"`
}

func (m *CloudLinkListType) Reset()      { *m = CloudLinkListType{} }
func (*CloudLinkListType) ProtoMessage() {}
func (*CloudLinkListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{1}
}
func (m *CloudLinkListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudLinkListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudLinkListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudLinkListType.Merge(m, src)
}
func (m *CloudLinkListType) XXX_Size() int {
	return m.Size()
}
func (m *CloudLinkListType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudLinkListType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudLinkListType proto.InternalMessageInfo

func (m *CloudLinkListType) GetCloudLink() []*views.ObjectRefType {
	if m != nil {
		return m.CloudLink
	}
	return nil
}

// Spoke VPCs
//
// x-displayName: "Spoke VPCs"
// Spoke VPCs to be attached to the AWS TGW Site
type AWSVPCAttachmentListType struct {
	// vpc_list
	//
	// x-displayName: "VPC List"
	// List of VPC attachments to transit gateway
	VpcList []*AWSVPCAttachmentType `protobuf:"bytes,1,rep,name=vpc_list,json=vpcList,proto3" json:"vpc_list,omitempty"`
}

func (m *AWSVPCAttachmentListType) Reset()      { *m = AWSVPCAttachmentListType{} }
func (*AWSVPCAttachmentListType) ProtoMessage() {}
func (*AWSVPCAttachmentListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{2}
}
func (m *AWSVPCAttachmentListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCAttachmentListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCAttachmentListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCAttachmentListType.Merge(m, src)
}
func (m *AWSVPCAttachmentListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCAttachmentListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCAttachmentListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCAttachmentListType proto.InternalMessageInfo

func (m *AWSVPCAttachmentListType) GetVpcList() []*AWSVPCAttachmentType {
	if m != nil {
		return m.VpcList
	}
	return nil
}

// AWS VPC attachment
//
// x-displayName: "VPC"
// VPC attachments to transit gateway
type AWSVPCAttachmentType struct {
	// VPC ID
	//
	// x-displayName: "VPC ID"
	// x-example: "vpc-12345678901234567"
	// x-required
	// Information about existing VPC
	VpcId string `protobuf:"bytes,1,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
	// Subnet Choice
	//
	// x-displayName: "Subnet Choice"
	// x-required
	// Subnet Choice
	//
	// Types that are valid to be assigned to SubnetChoice:
	//	*AWSVPCAttachmentType_AllSubnets
	//	*AWSVPCAttachmentType_SubnetIds
	SubnetChoice isAWSVPCAttachmentType_SubnetChoice `protobuf_oneof:"subnet_choice"`
	// Routing Choice
	//
	// x-displayName: "Routing Choice"
	// x-required
	// Routing Choice
	//
	// Types that are valid to be assigned to RoutingChoice:
	//	*AWSVPCAttachmentType_ManualRouting
	//	*AWSVPCAttachmentType_RoutingIds
	RoutingChoice isAWSVPCAttachmentType_RoutingChoice `protobuf_oneof:"routing_choice"`
	// Labels For VPC ID
	//
	// x-displayName: "Labels For VPC ID"
	// x-example: "value"
	// Add Labels for each of the VPC ID, these labels can be used in firewall policy
	// These labels used must be from known key, label defined in shared namespace and unknown key.
	Labels map[string]string `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AWSVPCAttachmentType) Reset()      { *m = AWSVPCAttachmentType{} }
func (*AWSVPCAttachmentType) ProtoMessage() {}
func (*AWSVPCAttachmentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{3}
}
func (m *AWSVPCAttachmentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCAttachmentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCAttachmentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCAttachmentType.Merge(m, src)
}
func (m *AWSVPCAttachmentType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCAttachmentType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCAttachmentType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCAttachmentType proto.InternalMessageInfo

type isAWSVPCAttachmentType_SubnetChoice interface {
	isAWSVPCAttachmentType_SubnetChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAWSVPCAttachmentType_RoutingChoice interface {
	isAWSVPCAttachmentType_RoutingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCAttachmentType_AllSubnets struct {
	AllSubnets *schema.Empty `protobuf:"bytes,3,opt,name=all_subnets,json=allSubnets,proto3,oneof" json:"all_subnets,omitempty"`
}
type AWSVPCAttachmentType_SubnetIds struct {
	SubnetIds *AWSSubnetIDListType `protobuf:"bytes,4,opt,name=subnet_ids,json=subnetIds,proto3,oneof" json:"subnet_ids,omitempty"`
}
type AWSVPCAttachmentType_ManualRouting struct {
	ManualRouting *schema.Empty `protobuf:"bytes,6,opt,name=manual_routing,json=manualRouting,proto3,oneof" json:"manual_routing,omitempty"`
}
type AWSVPCAttachmentType_RoutingIds struct {
	RoutingIds *AWSRouteTableListType `protobuf:"bytes,7,opt,name=routing_ids,json=routingIds,proto3,oneof" json:"routing_ids,omitempty"`
}

func (*AWSVPCAttachmentType_AllSubnets) isAWSVPCAttachmentType_SubnetChoice()     {}
func (*AWSVPCAttachmentType_SubnetIds) isAWSVPCAttachmentType_SubnetChoice()      {}
func (*AWSVPCAttachmentType_ManualRouting) isAWSVPCAttachmentType_RoutingChoice() {}
func (*AWSVPCAttachmentType_RoutingIds) isAWSVPCAttachmentType_RoutingChoice()    {}

func (m *AWSVPCAttachmentType) GetSubnetChoice() isAWSVPCAttachmentType_SubnetChoice {
	if m != nil {
		return m.SubnetChoice
	}
	return nil
}
func (m *AWSVPCAttachmentType) GetRoutingChoice() isAWSVPCAttachmentType_RoutingChoice {
	if m != nil {
		return m.RoutingChoice
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

func (m *AWSVPCAttachmentType) GetAllSubnets() *schema.Empty {
	if x, ok := m.GetSubnetChoice().(*AWSVPCAttachmentType_AllSubnets); ok {
		return x.AllSubnets
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetSubnetIds() *AWSSubnetIDListType {
	if x, ok := m.GetSubnetChoice().(*AWSVPCAttachmentType_SubnetIds); ok {
		return x.SubnetIds
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetManualRouting() *schema.Empty {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_ManualRouting); ok {
		return x.ManualRouting
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetRoutingIds() *AWSRouteTableListType {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_RoutingIds); ok {
		return x.RoutingIds
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSVPCAttachmentType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSVPCAttachmentType_AllSubnets)(nil),
		(*AWSVPCAttachmentType_SubnetIds)(nil),
		(*AWSVPCAttachmentType_ManualRouting)(nil),
		(*AWSVPCAttachmentType_RoutingIds)(nil),
	}
}

// AWS Subnet IDs
//
// x-displayName: "AWS Subnet IDs"
// AWS Subnet IDs
type AWSSubnetIDListType struct {
	// List of subnet IDs
	//
	// x-displayName: "List of subnet IDs"
	// x-required
	// x-example: "subnet-12345678901234567"
	// List of subnet IDs
	SubnetIds []string `protobuf:"bytes,1,rep,name=subnet_ids,json=subnetIds,proto3" json:"subnet_ids,omitempty"`
}

func (m *AWSSubnetIDListType) Reset()      { *m = AWSSubnetIDListType{} }
func (*AWSSubnetIDListType) ProtoMessage() {}
func (*AWSSubnetIDListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{4}
}
func (m *AWSSubnetIDListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSSubnetIDListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSSubnetIDListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSSubnetIDListType.Merge(m, src)
}
func (m *AWSSubnetIDListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSSubnetIDListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSSubnetIDListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSSubnetIDListType proto.InternalMessageInfo

func (m *AWSSubnetIDListType) GetSubnetIds() []string {
	if m != nil {
		return m.SubnetIds
	}
	return nil
}

// AWS Route Table List
//
// x-displayName: "AWS Route Table List"
// AWS Route Table List
type AWSRouteTableListType struct {
	// List of route tables
	//
	// x-required
	// x-displayName: "List of route tables"
	// Route Tables
	RouteTables []*AWSRouteTableType `protobuf:"bytes,1,rep,name=route_tables,json=routeTables,proto3" json:"route_tables,omitempty"`
}

func (m *AWSRouteTableListType) Reset()      { *m = AWSRouteTableListType{} }
func (*AWSRouteTableListType) ProtoMessage() {}
func (*AWSRouteTableListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{5}
}
func (m *AWSRouteTableListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSRouteTableListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSRouteTableListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSRouteTableListType.Merge(m, src)
}
func (m *AWSRouteTableListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSRouteTableListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSRouteTableListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSRouteTableListType proto.InternalMessageInfo

func (m *AWSRouteTableListType) GetRouteTables() []*AWSRouteTableType {
	if m != nil {
		return m.RouteTables
	}
	return nil
}

// AWS Route Table
//
// x-displayName: "AWS Route Table"
// AWS Route Table
type AWSRouteTableType struct {
	// Route table ID
	//
	// x-displayName: "Route table ID"
	// x-example: "rtb-12345678901234567"
	// Route table ID
	RouteTableId string `protobuf:"bytes,1,opt,name=route_table_id,json=routeTableId,proto3" json:"route_table_id,omitempty"`
	// static_routes
	//
	// x-displayName: "Static Routes"
	// x-example: "10.1.1.0/24"
	// x-required
	// List of Static Routes
	StaticRoutes []string `protobuf:"bytes,108,rep,name=static_routes,json=staticRoutes,proto3" json:"static_routes,omitempty"`
}

func (m *AWSRouteTableType) Reset()      { *m = AWSRouteTableType{} }
func (*AWSRouteTableType) ProtoMessage() {}
func (*AWSRouteTableType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{6}
}
func (m *AWSRouteTableType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSRouteTableType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSRouteTableType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSRouteTableType.Merge(m, src)
}
func (m *AWSRouteTableType) XXX_Size() int {
	return m.Size()
}
func (m *AWSRouteTableType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSRouteTableType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSRouteTableType proto.InternalMessageInfo

func (m *AWSRouteTableType) GetRouteTableId() string {
	if m != nil {
		return m.RouteTableId
	}
	return ""
}

func (m *AWSRouteTableType) GetStaticRoutes() []string {
	if m != nil {
		return m.StaticRoutes
	}
	return nil
}

// Cloud Connect ReplaceAWSREType Type
//
// x-displayName: "AWS RE Type"
// Cloud Connect AWS RE Type
type ReplaceAWSREType struct {
	// Spoke VPCs
	//
	// x-displayName: "Spoke VPCs"
	// Spoke VPCs to be attached to the AWS TGW Site
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
}

func (m *ReplaceAWSREType) Reset()      { *m = ReplaceAWSREType{} }
func (*ReplaceAWSREType) ProtoMessage() {}
func (*ReplaceAWSREType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{7}
}
func (m *ReplaceAWSREType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceAWSREType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceAWSREType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceAWSREType.Merge(m, src)
}
func (m *ReplaceAWSREType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceAWSREType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceAWSREType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceAWSREType proto.InternalMessageInfo

func (m *ReplaceAWSREType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

// Cloud Connect AWS TGW Site Type
//
// x-displayName: "AWS TGW Site Type"
// Cloud Connect AWS TGW Site Type
type AWSTGWSiteType struct {
	// AWS TGW Site Reference
	//
	// x-displayName: "AWS TGW Site Reference"
	// AWS TGW Site Reference
	Site *views.ObjectRefType `protobuf:"bytes,1,opt,name=site,proto3" json:"site,omitempty"`
	// Cloud Credential
	//
	// x-displayName: "Credential Reference"
	// Reference to cloud credential to deploy resources
	Cred *views.ObjectRefType `protobuf:"bytes,2,opt,name=cred,proto3" json:"cred,omitempty"`
	// Spoke VPCs
	//
	// x-displayName: "Spoke VPCs"
	// Spoke VPCs to be attached to the AWS TGW Site
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
	// Cloud Links
	//
	// x-displayName: "Cloud Links"
	// Reference to cloud links
	CloudLinks *CloudLinkListType `protobuf:"bytes,4,opt,name=cloud_links,json=cloudLinks,proto3" json:"cloud_links,omitempty"`
}

func (m *AWSTGWSiteType) Reset()      { *m = AWSTGWSiteType{} }
func (*AWSTGWSiteType) ProtoMessage() {}
func (*AWSTGWSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{8}
}
func (m *AWSTGWSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSTGWSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSTGWSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSTGWSiteType.Merge(m, src)
}
func (m *AWSTGWSiteType) XXX_Size() int {
	return m.Size()
}
func (m *AWSTGWSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSTGWSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSTGWSiteType proto.InternalMessageInfo

func (m *AWSTGWSiteType) GetSite() *views.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *AWSTGWSiteType) GetCred() *views.ObjectRefType {
	if m != nil {
		return m.Cred
	}
	return nil
}

func (m *AWSTGWSiteType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

func (m *AWSTGWSiteType) GetCloudLinks() *CloudLinkListType {
	if m != nil {
		return m.CloudLinks
	}
	return nil
}

// Isolated Type
//
// x-displayName: "Isolated"
// Network is isolated by default
type IsolatedType struct {
}

func (m *IsolatedType) Reset()      { *m = IsolatedType{} }
func (*IsolatedType) ProtoMessage() {}
func (*IsolatedType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{9}
}
func (m *IsolatedType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsolatedType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IsolatedType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsolatedType.Merge(m, src)
}
func (m *IsolatedType) XXX_Size() int {
	return m.Size()
}
func (m *IsolatedType) XXX_DiscardUnknown() {
	xxx_messageInfo_IsolatedType.DiscardUnknown(m)
}

var xxx_messageInfo_IsolatedType proto.InternalMessageInfo

// Enable Segment Type
//
// x-displayName: "Enable Segment Type"
// Enable Segment Type
type EnableSegmentType struct {
	// Segment
	//
	// x-displayName: "Segment"
	// Segment connected to
	Segment *views.ObjectRefType `protobuf:"bytes,1,opt,name=segment,proto3" json:"segment,omitempty"`
}

func (m *EnableSegmentType) Reset()      { *m = EnableSegmentType{} }
func (*EnableSegmentType) ProtoMessage() {}
func (*EnableSegmentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{10}
}
func (m *EnableSegmentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnableSegmentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnableSegmentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableSegmentType.Merge(m, src)
}
func (m *EnableSegmentType) XXX_Size() int {
	return m.Size()
}
func (m *EnableSegmentType) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableSegmentType.DiscardUnknown(m)
}

var xxx_messageInfo_EnableSegmentType proto.InternalMessageInfo

func (m *EnableSegmentType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

// Cloud Connect specification
//
// x-displayName: "Specification"
// Desired state for Cloud Connect
type GlobalSpecType struct {
	// Cloud Specific configuration
	//
	// x-displayName: "Cloud Specific configuration"
	// x-required
	// Cloud Specific configuration
	//
	// Types that are valid to be assigned to Cloud:
	//	*GlobalSpecType_AwsRe
	//	*GlobalSpecType_AwsTgwSite
	Cloud isGlobalSpecType_Cloud `protobuf_oneof:"cloud"`
	// Segment option
	//
	// x-displayName: "Segment Option"
	// x-required
	// Define how the cloud_connect connected to the network.
	//
	// Types that are valid to be assigned to SegmentOption:
	//	*GlobalSpecType_IsolatedSegment
	//	*GlobalSpecType_EnableSegment
	SegmentOption isGlobalSpecType_SegmentOption `protobuf_oneof:"segment_option"`
	// Bandwidth option
	//
	// x-displayName: "Bandwidth Option"
	// x-required
	// Supported bandwidth
	//
	// Types that are valid to be assigned to BandwidthOption:
	//	*GlobalSpecType_Bandwidth_500Mbs
	BandwidthOption isGlobalSpecType_BandwidthOption `protobuf_oneof:"bandwidth_option"`
	// Site Reference
	//
	// x-displayName: "Site"
	// Site
	Sites []*schema.ObjectRefType `protobuf:"bytes,12,rep,name=sites,proto3" json:"sites,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{11}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_Cloud interface {
	isGlobalSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_SegmentOption interface {
	isGlobalSpecType_SegmentOption()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_BandwidthOption interface {
	isGlobalSpecType_BandwidthOption()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type GlobalSpecType_AwsTgwSite struct {
	AwsTgwSite *AWSTGWSiteType `protobuf:"bytes,7,opt,name=aws_tgw_site,json=awsTgwSite,proto3,oneof" json:"aws_tgw_site,omitempty"`
}
type GlobalSpecType_IsolatedSegment struct {
	IsolatedSegment *IsolatedType `protobuf:"bytes,5,opt,name=isolated_segment,json=isolatedSegment,proto3,oneof" json:"isolated_segment,omitempty"`
}
type GlobalSpecType_EnableSegment struct {
	EnableSegment *EnableSegmentType `protobuf:"bytes,6,opt,name=enable_segment,json=enableSegment,proto3,oneof" json:"enable_segment,omitempty"`
}
type GlobalSpecType_Bandwidth_500Mbs struct {
	Bandwidth_500Mbs *schema.Empty `protobuf:"bytes,9,opt,name=bandwidth_500mbs,json=bandwidth500mbs,proto3,oneof" json:"bandwidth_500mbs,omitempty"`
}

func (*GlobalSpecType_AwsRe) isGlobalSpecType_Cloud()                      {}
func (*GlobalSpecType_AwsTgwSite) isGlobalSpecType_Cloud()                 {}
func (*GlobalSpecType_IsolatedSegment) isGlobalSpecType_SegmentOption()    {}
func (*GlobalSpecType_EnableSegment) isGlobalSpecType_SegmentOption()      {}
func (*GlobalSpecType_Bandwidth_500Mbs) isGlobalSpecType_BandwidthOption() {}

func (m *GlobalSpecType) GetCloud() isGlobalSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}
func (m *GlobalSpecType) GetSegmentOption() isGlobalSpecType_SegmentOption {
	if m != nil {
		return m.SegmentOption
	}
	return nil
}
func (m *GlobalSpecType) GetBandwidthOption() isGlobalSpecType_BandwidthOption {
	if m != nil {
		return m.BandwidthOption
	}
	return nil
}

func (m *GlobalSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*GlobalSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *GlobalSpecType) GetAwsTgwSite() *AWSTGWSiteType {
	if x, ok := m.GetCloud().(*GlobalSpecType_AwsTgwSite); ok {
		return x.AwsTgwSite
	}
	return nil
}

func (m *GlobalSpecType) GetIsolatedSegment() *IsolatedType {
	if x, ok := m.GetSegmentOption().(*GlobalSpecType_IsolatedSegment); ok {
		return x.IsolatedSegment
	}
	return nil
}

func (m *GlobalSpecType) GetEnableSegment() *EnableSegmentType {
	if x, ok := m.GetSegmentOption().(*GlobalSpecType_EnableSegment); ok {
		return x.EnableSegment
	}
	return nil
}

func (m *GlobalSpecType) GetBandwidth_500Mbs() *schema.Empty {
	if x, ok := m.GetBandwidthOption().(*GlobalSpecType_Bandwidth_500Mbs); ok {
		return x.Bandwidth_500Mbs
	}
	return nil
}

func (m *GlobalSpecType) GetSites() []*schema.ObjectRefType {
	if m != nil {
		return m.Sites
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_AwsRe)(nil),
		(*GlobalSpecType_AwsTgwSite)(nil),
		(*GlobalSpecType_IsolatedSegment)(nil),
		(*GlobalSpecType_EnableSegment)(nil),
		(*GlobalSpecType_Bandwidth_500Mbs)(nil),
	}
}

// Create Cloud Connect
//
// x-displayName: "Create Cloud Connect"
// Shape of the Cloud Connect specification
type CreateSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*CreateSpecType_AwsRe
	Cloud isCreateSpecType_Cloud `protobuf_oneof:"cloud"`
	// Types that are valid to be assigned to SegmentOption:
	//	*CreateSpecType_IsolatedSegment
	//	*CreateSpecType_EnableSegment
	SegmentOption isCreateSpecType_SegmentOption `protobuf_oneof:"segment_option"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{12}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_Cloud interface {
	isCreateSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_SegmentOption interface {
	isCreateSpecType_SegmentOption()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type CreateSpecType_IsolatedSegment struct {
	IsolatedSegment *IsolatedType `protobuf:"bytes,5,opt,name=isolated_segment,json=isolatedSegment,proto3,oneof" json:"isolated_segment,omitempty"`
}
type CreateSpecType_EnableSegment struct {
	EnableSegment *EnableSegmentType `protobuf:"bytes,6,opt,name=enable_segment,json=enableSegment,proto3,oneof" json:"enable_segment,omitempty"`
}

func (*CreateSpecType_AwsRe) isCreateSpecType_Cloud()                   {}
func (*CreateSpecType_IsolatedSegment) isCreateSpecType_SegmentOption() {}
func (*CreateSpecType_EnableSegment) isCreateSpecType_SegmentOption()   {}

func (m *CreateSpecType) GetCloud() isCreateSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}
func (m *CreateSpecType) GetSegmentOption() isCreateSpecType_SegmentOption {
	if m != nil {
		return m.SegmentOption
	}
	return nil
}

func (m *CreateSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*CreateSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *CreateSpecType) GetIsolatedSegment() *IsolatedType {
	if x, ok := m.GetSegmentOption().(*CreateSpecType_IsolatedSegment); ok {
		return x.IsolatedSegment
	}
	return nil
}

func (m *CreateSpecType) GetEnableSegment() *EnableSegmentType {
	if x, ok := m.GetSegmentOption().(*CreateSpecType_EnableSegment); ok {
		return x.EnableSegment
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_AwsRe)(nil),
		(*CreateSpecType_IsolatedSegment)(nil),
		(*CreateSpecType_EnableSegment)(nil),
	}
}

// Replace Cloud Connect
//
// x-displayName: "Replace Cloud Connect"
// Shape of the Cloud Connect specification
type ReplaceSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*ReplaceSpecType_AwsRe
	Cloud isReplaceSpecType_Cloud `protobuf_oneof:"cloud"`
	// Types that are valid to be assigned to SegmentOption:
	//	*ReplaceSpecType_IsolatedSegment
	//	*ReplaceSpecType_EnableSegment
	SegmentOption isReplaceSpecType_SegmentOption `protobuf_oneof:"segment_option"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{13}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_Cloud interface {
	isReplaceSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_SegmentOption interface {
	isReplaceSpecType_SegmentOption()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_AwsRe struct {
	AwsRe *ReplaceAWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type ReplaceSpecType_IsolatedSegment struct {
	IsolatedSegment *IsolatedType `protobuf:"bytes,5,opt,name=isolated_segment,json=isolatedSegment,proto3,oneof" json:"isolated_segment,omitempty"`
}
type ReplaceSpecType_EnableSegment struct {
	EnableSegment *EnableSegmentType `protobuf:"bytes,6,opt,name=enable_segment,json=enableSegment,proto3,oneof" json:"enable_segment,omitempty"`
}

func (*ReplaceSpecType_AwsRe) isReplaceSpecType_Cloud()                   {}
func (*ReplaceSpecType_IsolatedSegment) isReplaceSpecType_SegmentOption() {}
func (*ReplaceSpecType_EnableSegment) isReplaceSpecType_SegmentOption()   {}

func (m *ReplaceSpecType) GetCloud() isReplaceSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}
func (m *ReplaceSpecType) GetSegmentOption() isReplaceSpecType_SegmentOption {
	if m != nil {
		return m.SegmentOption
	}
	return nil
}

func (m *ReplaceSpecType) GetAwsRe() *ReplaceAWSREType {
	if x, ok := m.GetCloud().(*ReplaceSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *ReplaceSpecType) GetIsolatedSegment() *IsolatedType {
	if x, ok := m.GetSegmentOption().(*ReplaceSpecType_IsolatedSegment); ok {
		return x.IsolatedSegment
	}
	return nil
}

func (m *ReplaceSpecType) GetEnableSegment() *EnableSegmentType {
	if x, ok := m.GetSegmentOption().(*ReplaceSpecType_EnableSegment); ok {
		return x.EnableSegment
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_AwsRe)(nil),
		(*ReplaceSpecType_IsolatedSegment)(nil),
		(*ReplaceSpecType_EnableSegment)(nil),
	}
}

// Get Cloud Connect
//
// x-displayName: "Get Cloud Connect"
// Shape of the Cloud Connect specification
type GetSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*GetSpecType_AwsRe
	Cloud isGetSpecType_Cloud `protobuf_oneof:"cloud"`
	// Types that are valid to be assigned to SegmentOption:
	//	*GetSpecType_IsolatedSegment
	//	*GetSpecType_EnableSegment
	SegmentOption isGetSpecType_SegmentOption `protobuf_oneof:"segment_option"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{14}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_Cloud interface {
	isGetSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_SegmentOption interface {
	isGetSpecType_SegmentOption()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type GetSpecType_IsolatedSegment struct {
	IsolatedSegment *IsolatedType `protobuf:"bytes,5,opt,name=isolated_segment,json=isolatedSegment,proto3,oneof" json:"isolated_segment,omitempty"`
}
type GetSpecType_EnableSegment struct {
	EnableSegment *EnableSegmentType `protobuf:"bytes,6,opt,name=enable_segment,json=enableSegment,proto3,oneof" json:"enable_segment,omitempty"`
}

func (*GetSpecType_AwsRe) isGetSpecType_Cloud()                   {}
func (*GetSpecType_IsolatedSegment) isGetSpecType_SegmentOption() {}
func (*GetSpecType_EnableSegment) isGetSpecType_SegmentOption()   {}

func (m *GetSpecType) GetCloud() isGetSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}
func (m *GetSpecType) GetSegmentOption() isGetSpecType_SegmentOption {
	if m != nil {
		return m.SegmentOption
	}
	return nil
}

func (m *GetSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*GetSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *GetSpecType) GetIsolatedSegment() *IsolatedType {
	if x, ok := m.GetSegmentOption().(*GetSpecType_IsolatedSegment); ok {
		return x.IsolatedSegment
	}
	return nil
}

func (m *GetSpecType) GetEnableSegment() *EnableSegmentType {
	if x, ok := m.GetSegmentOption().(*GetSpecType_EnableSegment); ok {
		return x.EnableSegment
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_AwsRe)(nil),
		(*GetSpecType_IsolatedSegment)(nil),
		(*GetSpecType_EnableSegment)(nil),
	}
}

func init() {
	proto.RegisterType((*AWSREType)(nil), "ves.io.schema.cloud_connect.AWSREType")
	golang_proto.RegisterType((*AWSREType)(nil), "ves.io.schema.cloud_connect.AWSREType")
	proto.RegisterType((*CloudLinkListType)(nil), "ves.io.schema.cloud_connect.CloudLinkListType")
	golang_proto.RegisterType((*CloudLinkListType)(nil), "ves.io.schema.cloud_connect.CloudLinkListType")
	proto.RegisterType((*AWSVPCAttachmentListType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentListType")
	golang_proto.RegisterType((*AWSVPCAttachmentListType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentListType")
	proto.RegisterType((*AWSVPCAttachmentType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType")
	golang_proto.RegisterType((*AWSVPCAttachmentType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType.LabelsEntry")
	proto.RegisterType((*AWSSubnetIDListType)(nil), "ves.io.schema.cloud_connect.AWSSubnetIDListType")
	golang_proto.RegisterType((*AWSSubnetIDListType)(nil), "ves.io.schema.cloud_connect.AWSSubnetIDListType")
	proto.RegisterType((*AWSRouteTableListType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableListType")
	golang_proto.RegisterType((*AWSRouteTableListType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableListType")
	proto.RegisterType((*AWSRouteTableType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableType")
	golang_proto.RegisterType((*AWSRouteTableType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableType")
	proto.RegisterType((*ReplaceAWSREType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSREType")
	golang_proto.RegisterType((*ReplaceAWSREType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSREType")
	proto.RegisterType((*AWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.AWSTGWSiteType")
	golang_proto.RegisterType((*AWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.AWSTGWSiteType")
	proto.RegisterType((*IsolatedType)(nil), "ves.io.schema.cloud_connect.IsolatedType")
	golang_proto.RegisterType((*IsolatedType)(nil), "ves.io.schema.cloud_connect.IsolatedType")
	proto.RegisterType((*EnableSegmentType)(nil), "ves.io.schema.cloud_connect.EnableSegmentType")
	golang_proto.RegisterType((*EnableSegmentType)(nil), "ves.io.schema.cloud_connect.EnableSegmentType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cloud_connect.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cloud_connect.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cloud_connect.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cloud_connect.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cloud_connect.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cloud_connect.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cloud_connect.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cloud_connect.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/cloud_connect/types.proto", fileDescriptor_245b6fb3a531fd11)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/cloud_connect/types.proto", fileDescriptor_245b6fb3a531fd11)
}

var fileDescriptor_245b6fb3a531fd11 = []byte{
	// 1737 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x4d, 0x6c, 0x1b, 0xc7,
	0x15, 0xe6, 0x23, 0x97, 0x2b, 0xf2, 0x51, 0x22, 0x57, 0x63, 0x39, 0xa0, 0x99, 0x94, 0x61, 0x08,
	0xd9, 0xa6, 0x12, 0x93, 0x92, 0x99, 0x3a, 0x8e, 0x89, 0xc6, 0xad, 0x68, 0xcb, 0x96, 0x04, 0xe7,
	0x6f, 0xe5, 0x5a, 0xfd, 0x81, 0x4d, 0x2c, 0x77, 0x47, 0xd4, 0xd6, 0xab, 0x5d, 0x62, 0x77, 0x44,
	0x55, 0x6d, 0x09, 0x18, 0x39, 0xf8, 0xd0, 0x4b, 0x5b, 0xdf, 0x9a, 0x53, 0x4f, 0x45, 0xa1, 0x9e,
	0x7b, 0xf1, 0xea, 0x20, 0x18, 0x28, 0x10, 0x18, 0x28, 0x20, 0xf4, 0xe4, 0x4b, 0x8b, 0x98, 0xba,
	0xa4, 0xe8, 0x25, 0xc7, 0x20, 0x87, 0xa2, 0xd8, 0xd9, 0x25, 0x4d, 0x52, 0xb4, 0x6c, 0x17, 0x6d,
	0x81, 0x00, 0xbe, 0xcd, 0xec, 0xbc, 0xf7, 0xbd, 0x9f, 0xef, 0xcd, 0x9b, 0x47, 0xe2, 0xe9, 0x16,
	0x75, 0x4a, 0xba, 0x35, 0xeb, 0xa8, 0xeb, 0x74, 0x43, 0x99, 0x55, 0x0d, 0x6b, 0x53, 0xab, 0xa9,
	0x96, 0x69, 0x52, 0x95, 0xcd, 0xb2, 0xed, 0x26, 0x75, 0x4a, 0x4d, 0xdb, 0x62, 0x16, 0x79, 0xd5,
	0x17, 0x2c, 0xf9, 0x82, 0xa5, 0x01, 0xc1, 0x4c, 0xb1, 0xa1, 0xb3, 0xf5, 0xcd, 0x7a, 0x49, 0xb5,
	0x36, 0x66, 0x1b, 0x56, 0xc3, 0x9a, 0xe5, 0x3a, 0xf5, 0xcd, 0x35, 0xbe, 0xe3, 0x1b, 0xbe, 0xf2,
	0xb1, 0x32, 0x33, 0xa3, 0x8c, 0xda, 0xb4, 0x66, 0xd3, 0x86, 0x6e, 0x99, 0xfd, 0x66, 0x33, 0xaf,
	0x0e, 0x8a, 0x5a, 0x4d, 0xa6, 0x5b, 0x66, 0xf7, 0xf0, 0xc4, 0xe0, 0x61, 0xbf, 0xde, 0x6b, 0x83,
	0x47, 0x2d, 0xc5, 0xd0, 0x35, 0x85, 0xd1, 0xe0, 0x34, 0x37, 0x74, 0xaa, 0xd3, 0xad, 0xda, 0x20,
	0xf4, 0xeb, 0x87, 0x25, 0x9c, 0x7e, 0x03, 0xf9, 0x7f, 0x46, 0x30, 0x3e, 0xbf, 0xba, 0x22, 0x2f,
	0x5c, 0xdf, 0x6e, 0x52, 0xa2, 0xa1, 0xe8, 0x3b, 0x9f, 0x86, 0x1c, 0x14, 0x12, 0xe5, 0x7c, 0x69,
	0x30, 0x5d, 0x5c, 0xbf, 0xf4, 0x61, 0xfd, 0x27, 0x54, 0x65, 0x32, 0x5d, 0xf3, 0x74, 0xaa, 0x85,
	0x9d, 0x76, 0x6a, 0x28, 0xf4, 0x3b, 0xbb, 0x00, 0xf7, 0x77, 0x21, 0x19, 0x83, 0x02, 0xcc, 0x41,
	0x45, 0x54, 0x2d, 0x73, 0x4d, 0x6f, 0xc8, 0x01, 0x36, 0xb9, 0x85, 0x82, 0x6a, 0x53, 0x2d, 0x1d,
	0x7e, 0x6e, 0x1b, 0xa7, 0x76, 0xda, 0x93, 0x01, 0x55, 0x36, 0xd5, 0xa8, 0xc9, 0x74, 0xc5, 0x70,
	0x46, 0x58, 0xe0, 0xb8, 0x44, 0xc3, 0x54, 0xab, 0xa9, 0xd6, 0x14, 0xc6, 0x14, 0x75, 0x7d, 0x83,
	0x9a, 0xcc, 0x49, 0x47, 0xb8, 0xa9, 0x73, 0xa5, 0x23, 0xd8, 0x2f, 0xcd, 0xaf, 0xae, 0xdc, 0xf8,
	0xe8, 0xd2, 0x7c, 0x4f, 0xeb, 0x9a, 0xee, 0x30, 0x6e, 0x5d, 0xd8, 0x77, 0x01, 0xe4, 0x64, 0xab,
	0xa9, 0x3e, 0x39, 0x74, 0xc8, 0x87, 0x98, 0xf0, 0xf5, 0x0d, 0xdd, 0xbc, 0xed, 0xa4, 0x05, 0x6e,
	0xa1, 0x74, 0xa4, 0x85, 0x4b, 0xde, 0xee, 0x9a, 0x6e, 0xde, 0xee, 0x42, 0xcb, 0xa8, 0x76, 0x3f,
	0x39, 0xe4, 0x04, 0x46, 0x58, 0x63, 0x2b, 0x1d, 0xcd, 0x41, 0x21, 0x5e, 0x1d, 0x7b, 0xd4, 0x86,
	0x2f, 0x3c, 0xb3, 0xde, 0x37, 0x72, 0x05, 0xa3, 0xa6, 0xa5, 0x51, 0x27, 0x2d, 0xe6, 0x22, 0x85,
	0x44, 0xf9, 0xf4, 0x48, 0x2b, 0xbd, 0xf4, 0x97, 0x3e, 0xb0, 0x34, 0xca, 0x3d, 0xef, 0xa1, 0xf8,
	0xea, 0xf9, 0xdf, 0x02, 0x4e, 0x1e, 0x72, 0x82, 0x18, 0x88, 0x4f, 0x22, 0x49, 0x03, 0x37, 0xf1,
	0x3c, 0xac, 0xcc, 0xec, 0xb4, 0xfb, 0x14, 0x0f, 0xd3, 0x71, 0xff, 0x1f, 0x7b, 0x91, 0xe8, 0x3d,
	0x08, 0x4b, 0x20, 0xc7, 0x7b, 0x71, 0x56, 0x5e, 0x79, 0xe0, 0x02, 0x41, 0x09, 0x13, 0xdc, 0x91,
	0x9c, 0x1f, 0x3b, 0x9c, 0xcd, 0xff, 0x06, 0x30, 0xfd, 0x34, 0x0a, 0xc8, 0x0f, 0x31, 0xe6, 0x51,
	0x6a, 0xe8, 0x0e, 0x0b, 0x1c, 0x3c, 0xfb, 0x42, 0x5c, 0x72, 0x7f, 0x13, 0x9e, 0x43, 0xe2, 0x3d,
	0x88, 0x48, 0x77, 0x40, 0x1e, 0x6b, 0x35, 0x55, 0x0f, 0xbe, 0x92, 0x79, 0xe0, 0xc2, 0x2b, 0x38,
	0x85, 0xa9, 0x1b, 0x1f, 0x5d, 0xca, 0xf5, 0xd5, 0x8c, 0xe7, 0xd3, 0xbf, 0x44, 0x9c, 0x1a, 0x05,
	0x45, 0x28, 0x8a, 0x9e, 0x3f, 0xba, 0xc6, 0x2f, 0x4a, 0xbc, 0xfa, 0xc1, 0x57, 0x2e, 0x84, 0xee,
	0xef, 0x02, 0x09, 0x32, 0xe0, 0xe7, 0xa5, 0xa8, 0x29, 0x4c, 0xf1, 0x8c, 0x0a, 0x76, 0x38, 0xfd,
	0x3d, 0x6f, 0x71, 0xca, 0x9e, 0x2e, 0xe7, 0x6f, 0x15, 0x5a, 0x4d, 0xb5, 0x38, 0x53, 0xf8, 0xb1,
	0x52, 0xfc, 0xd9, 0x5c, 0xf1, 0xc2, 0xcd, 0x9f, 0xbf, 0xdb, 0xfe, 0x45, 0x6f, 0x7d, 0xf6, 0x7c,
	0x7b, 0x66, 0x5a, 0x8e, 0xb6, 0x9a, 0xea, 0x92, 0x46, 0xce, 0x63, 0x42, 0x31, 0x8c, 0x9a, 0xb3,
	0x59, 0x37, 0x69, 0xaf, 0x8a, 0xa7, 0x86, 0x22, 0x5f, 0xd8, 0x68, 0xb2, 0xed, 0xc5, 0x90, 0x8c,
	0x8a, 0x61, 0xac, 0xf8, 0x92, 0xe4, 0x63, 0x44, 0x5f, 0xa9, 0xa6, 0x6b, 0xdd, 0xda, 0x9c, 0x7b,
	0x56, 0xc6, 0x7c, 0xe5, 0xa5, 0xcb, 0xdd, 0xac, 0x2f, 0x86, 0xe4, 0xb8, 0x8f, 0xb2, 0xa4, 0x39,
	0xe4, 0x3d, 0x4c, 0x6e, 0x28, 0xe6, 0xa6, 0x62, 0xd4, 0x6c, 0x6b, 0x93, 0xe9, 0x66, 0x23, 0x2d,
	0x1e, 0xe1, 0x0e, 0xc8, 0x13, 0xbe, 0xb4, 0xec, 0x0b, 0x93, 0xef, 0x63, 0x22, 0xd0, 0xe3, 0x2e,
	0x8d, 0x71, 0xdd, 0xf2, 0xb3, 0x5c, 0xf2, 0xb4, 0xe9, 0x75, 0xa5, 0x6e, 0xd0, 0x9e, 0x53, 0x20,
	0x63, 0x00, 0xe4, 0x79, 0xc5, 0x50, 0x34, 0x94, 0x3a, 0x35, 0x9c, 0x74, 0x8c, 0x97, 0xc5, 0x7b,
	0x2f, 0x5c, 0x16, 0xa5, 0x6b, 0x5c, 0x7f, 0xc1, 0x64, 0xf6, 0x76, 0xf5, 0x5b, 0x9f, 0xee, 0x82,
	0x80, 0x61, 0x08, 0xf1, 0xda, 0xfd, 0x14, 0xc2, 0x52, 0xa1, 0xf3, 0xf9, 0x9f, 0x23, 0xe2, 0x2f,
	0x77, 0x21, 0x1c, 0x0b, 0xc9, 0x81, 0xad, 0xcc, 0x05, 0x4c, 0xf4, 0x69, 0x11, 0x09, 0x23, 0xb7,
	0xe9, 0xb6, 0x5f, 0x0a, 0xb2, 0xb7, 0x24, 0x53, 0x18, 0x6d, 0x29, 0xc6, 0x26, 0xe5, 0x3d, 0x2e,
	0x2e, 0xfb, 0x9b, 0x4a, 0xf8, 0x5d, 0xa8, 0xfc, 0x15, 0x1e, 0xba, 0xf0, 0x17, 0x40, 0x82, 0xa2,
	0x57, 0x70, 0x4b, 0x97, 0x33, 0xb1, 0x6e, 0x2d, 0xe1, 0x22, 0x8a, 0x3e, 0x07, 0x6f, 0x5e, 0xc4,
	0xef, 0x60, 0x66, 0x80, 0xfc, 0x72, 0x62, 0xde, 0x30, 0x72, 0xc1, 0x06, 0xb3, 0xfd, 0xfc, 0x96,
	0xa5, 0x95, 0x26, 0x55, 0xf5, 0x35, 0x9d, 0x6a, 0x81, 0x00, 0xae, 0x62, 0x82, 0xa7, 0x2e, 0xc7,
	0x73, 0xf7, 0xe6, 0x22, 0x5e, 0xc1, 0xdc, 0x30, 0x7f, 0xe5, 0xe4, 0xfb, 0x7c, 0x9f, 0x0b, 0xf6,
	0x98, 0x1f, 0xa0, 0xa8, 0x7c, 0xec, 0x7d, 0xc5, 0x54, 0x1a, 0x54, 0xe3, 0xe7, 0x34, 0xc7, 0x3c,
	0x24, 0x9c, 0x42, 0xd1, 0x8f, 0x7c, 0x19, 0xbb, 0x99, 0x97, 0xa2, 0xd5, 0x69, 0x9c, 0x08, 0xdc,
	0x51, 0xd7, 0x2d, 0x5d, 0xa5, 0xe4, 0xd8, 0x9e, 0x0b, 0x91, 0x7d, 0x17, 0xc2, 0x1d, 0x17, 0x22,
	0x6f, 0x9f, 0xf9, 0xf6, 0xef, 0x76, 0x01, 0xaa, 0x27, 0x31, 0xd9, 0xc5, 0xef, 0x13, 0x13, 0xf7,
	0x5d, 0x88, 0x7a, 0x62, 0xef, 0x9c, 0x39, 0xef, 0x89, 0x2d, 0x0b, 0xb1, 0xb0, 0x14, 0x59, 0x16,
	0x62, 0x51, 0x49, 0xcc, 0xff, 0x09, 0xf0, 0xd8, 0x88, 0xca, 0x24, 0x77, 0x61, 0xa0, 0xc0, 0xbd,
	0x96, 0x10, 0xaf, 0x36, 0x9e, 0x7e, 0x01, 0x4b, 0xf7, 0xe0, 0xad, 0xfc, 0x8c, 0x7d, 0xba, 0x7c,
	0xf2, 0x56, 0xc1, 0xd7, 0x3b, 0xf2, 0xfe, 0xf5, 0x3a, 0x97, 0xd0, 0x5d, 0xc5, 0xa0, 0xbb, 0x4a,
	0x43, 0xdf, 0xad, 0xa8, 0x1c, 0x7f, 0xe0, 0xc2, 0x24, 0xa6, 0x10, 0x7d, 0x17, 0x73, 0x4b, 0x97,
	0x79, 0xe3, 0xf8, 0x3d, 0xe0, 0xf1, 0x91, 0xe5, 0x4b, 0x6c, 0x1c, 0xe7, 0xf9, 0xac, 0xf1, 0x7c,
	0x3a, 0x41, 0x37, 0x2b, 0x3d, 0xff, 0x45, 0xe0, 0xad, 0xec, 0xf5, 0x5e, 0x2b, 0xfb, 0x0c, 0x46,
	0xba, 0xc8, 0x99, 0xf4, 0x15, 0x9c, 0xca, 0x89, 0x07, 0x2e, 0x1c, 0xc7, 0x63, 0x98, 0x0c, 0x2e,
	0xa3, 0x5f, 0x15, 0xdc, 0xd1, 0x3f, 0x86, 0x71, 0xf2, 0x10, 0x3c, 0x61, 0x3e, 0x53, 0x81, 0x93,
	0xff, 0x71, 0x9b, 0xb3, 0x59, 0xfd, 0xe8, 0x36, 0x37, 0xfe, 0xc4, 0xcb, 0x25, 0x8d, 0xc8, 0x38,
	0xe1, 0x30, 0x85, 0xe9, 0x2a, 0xaf, 0x50, 0xea, 0xa4, 0x0d, 0x4e, 0x6b, 0xd1, 0x43, 0xc4, 0x7b,
	0x30, 0x96, 0x8f, 0xda, 0x91, 0xaf, 0xa0, 0x17, 0xa5, 0x54, 0x1e, 0x19, 0xf9, 0xb8, 0x8f, 0xc1,
	0x23, 0x72, 0x2a, 0xd7, 0x1e, 0xba, 0xb0, 0x88, 0xd3, 0x28, 0x0d, 0x84, 0xee, 0x5d, 0x3b, 0x69,
	0x38, 0x46, 0xcc, 0xe1, 0xc4, 0x0a, 0xd7, 0xcd, 0xf9, 0xca, 0x99, 0xd4, 0x90, 0x43, 0xf9, 0xbb,
	0x80, 0x92, 0x4c, 0x9b, 0x86, 0xa2, 0xd2, 0xfe, 0xa1, 0xe9, 0xff, 0x30, 0x6e, 0x54, 0xc6, 0x1f,
	0x5e, 0x7c, 0x32, 0xa8, 0xe5, 0xef, 0x46, 0x30, 0x39, 0xbf, 0xba, 0x72, 0xfd, 0xea, 0xea, 0x8a,
	0xce, 0x7c, 0xce, 0x6e, 0xa2, 0xe0, 0xe8, 0x8c, 0xbe, 0xc0, 0xe4, 0x76, 0x72, 0xa7, 0x3d, 0xae,
	0x6c, 0x39, 0x35, 0xd6, 0xd8, 0xaa, 0x79, 0xaa, 0x4f, 0x19, 0xdb, 0x38, 0xec, 0xcb, 0xa1, 0x6d,
	0xe4, 0xd0, 0x96, 0x4f, 0xe2, 0xf8, 0x92, 0x63, 0x19, 0x0a, 0xa3, 0x1a, 0x27, 0xe6, 0x26, 0x4e,
	0x2e, 0x98, 0x5e, 0x41, 0xad, 0xd0, 0x46, 0x6f, 0x5a, 0x58, 0xc4, 0x31, 0xc7, 0xdf, 0xbe, 0x00,
	0x3b, 0xb8, 0xd3, 0xee, 0x6a, 0xc9, 0xdd, 0x45, 0xfe, 0x6f, 0x02, 0x26, 0xaf, 0x1a, 0x56, 0x5d,
	0x31, 0xbc, 0x96, 0xcf, 0xc1, 0xbf, 0x8b, 0xa2, 0x47, 0xa2, 0x4d, 0x03, 0x6a, 0x4e, 0x3d, 0xb3,
	0x95, 0x2c, 0x04, 0x8f, 0x7b, 0x54, 0xd9, 0x72, 0x64, 0x4a, 0x7e, 0x80, 0x03, 0x55, 0x10, 0x3c,
	0xcd, 0x6f, 0x3d, 0x0b, 0xa6, 0xaf, 0xf6, 0x7a, 0x73, 0x26, 0x9f, 0x42, 0xb6, 0x9c, 0xeb, 0x8d,
	0x2d, 0xef, 0x88, 0xdc, 0x40, 0x49, 0x0f, 0x92, 0x53, 0xeb, 0x26, 0x20, 0xca, 0xd1, 0x67, 0x8e,
	0x44, 0xef, 0xcf, 0xe8, 0x22, 0xc8, 0xa9, 0x2e, 0x48, 0x90, 0x53, 0xb2, 0x8a, 0x49, 0xca, 0x93,
	0xdc, 0x43, 0x15, 0x9f, 0x83, 0xc8, 0x43, 0xbc, 0x78, 0x43, 0x0a, 0xed, 0xff, 0x48, 0xe6, 0x51,
	0xaa, 0x2b, 0xa6, 0xb6, 0xa5, 0x6b, 0x6c, 0xbd, 0x76, 0x6e, 0x6e, 0x6e, 0xa3, 0xee, 0xa4, 0xe3,
	0x47, 0x4c, 0x39, 0x61, 0x39, 0xd5, 0x93, 0xf7, 0xc5, 0x49, 0x15, 0xa3, 0x5e, 0x16, 0x9d, 0xf4,
	0x38, 0x6f, 0xec, 0xaf, 0x0d, 0xe9, 0x0d, 0x72, 0x9c, 0xdc, 0x69, 0xf3, 0xdb, 0xd5, 0x1b, 0xd3,
	0xb9, 0x6a, 0x35, 0x83, 0x51, 0xee, 0x3a, 0x99, 0xdc, 0x73, 0x21, 0xec, 0x15, 0x72, 0xc7, 0x05,
	0x28, 0xf3, 0x47, 0xf4, 0x0d, 0x4c, 0x06, 0x41, 0x07, 0x3f, 0xf5, 0x48, 0x6a, 0xcf, 0x85, 0xe8,
	0xbe, 0x0b, 0x82, 0xf7, 0x88, 0x9e, 0x3b, 0xf3, 0x4e, 0xf5, 0x8d, 0xfe, 0x28, 0x02, 0xa1, 0x89,
	0x3d, 0x17, 0xe2, 0xfb, 0x2e, 0xc4, 0x3c, 0xa4, 0x0b, 0xcb, 0x42, 0x0c, 0xa4, 0xf0, 0xb2, 0x10,
	0x8b, 0x48, 0xc2, 0xb2, 0x10, 0x13, 0xa4, 0xe8, 0xb2, 0x10, 0x8b, 0x49, 0xf1, 0xfc, 0xe3, 0x30,
	0x26, 0x2f, 0xd9, 0x54, 0x61, 0xf4, 0xbf, 0x57, 0x5f, 0xdf, 0xb4, 0x2a, 0xa8, 0x4c, 0x3e, 0xbc,
	0x38, 0x74, 0xc9, 0xaa, 0xa4, 0xcb, 0x48, 0xfc, 0x93, 0xaf, 0xc1, 0x5f, 0x56, 0xa7, 0x0f, 0x31,
	0x41, 0x3e, 0xf9, 0x1a, 0x86, 0xbe, 0x1d, 0xce, 0x74, 0xfe, 0x20, 0x8c, 0xa9, 0xe0, 0x11, 0xe9,
	0x25, 0xf9, 0xca, 0x50, 0x92, 0x8b, 0x47, 0xc6, 0x30, 0xfc, 0x04, 0xbd, 0xcc, 0xf5, 0xa1, 0x5c,
	0xe7, 0xff, 0x1e, 0xc6, 0xc4, 0x55, 0xca, 0x5e, 0x96, 0xf1, 0xff, 0xa8, 0x8c, 0xab, 0xbf, 0x82,
	0xfd, 0xc7, 0xd9, 0xd0, 0xa3, 0xc7, 0xd9, 0xd0, 0x97, 0x8f, 0xb3, 0x70, 0xa7, 0x93, 0x85, 0x3f,
	0x74, 0xb2, 0xf0, 0x59, 0x27, 0x0b, 0xfb, 0x9d, 0x2c, 0x3c, 0xea, 0x64, 0xe1, 0xf3, 0x4e, 0x16,
	0xbe, 0xe8, 0x64, 0x43, 0x5f, 0x76, 0xb2, 0xf0, 0xeb, 0x83, 0x6c, 0x68, 0xef, 0x20, 0x0b, 0xfb,
	0x07, 0xd9, 0xd0, 0xa3, 0x83, 0x6c, 0xe8, 0x47, 0x1f, 0x37, 0xac, 0xe6, 0xed, 0x46, 0xa9, 0x65,
	0x19, 0x8c, 0xda, 0xb6, 0x52, 0xda, 0x74, 0x66, 0xf9, 0x62, 0xcd, 0xb2, 0x37, 0x8a, 0x4d, 0xdb,
	0x6a, 0xe9, 0x1a, 0xb5, 0x8b, 0xdd, 0xe3, 0xd9, 0x66, 0xbd, 0x61, 0xcd, 0xd2, 0x9f, 0xb2, 0xe0,
	0x8f, 0xac, 0x51, 0xff, 0xf3, 0xd5, 0x45, 0xfe, 0x97, 0xd6, 0xdb, 0xff, 0x0e, 0x00, 0x00, 0xff,
	0xff, 0x73, 0x07, 0x06, 0x32, 0x0d, 0x14, 0x00, 0x00,
}

func (this *AWSREType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSREType)
	if !ok {
		that2, ok := that.(AWSREType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Region.Equal(that1.Region) {
		return false
	}
	if !this.Cred.Equal(that1.Cred) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	if !this.CloudLinks.Equal(that1.CloudLinks) {
		return false
	}
	if this.Tgw != that1.Tgw {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	return true
}
func (this *CloudLinkListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudLinkListType)
	if !ok {
		that2, ok := that.(CloudLinkListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CloudLink) != len(that1.CloudLink) {
		return false
	}
	for i := range this.CloudLink {
		if !this.CloudLink[i].Equal(that1.CloudLink[i]) {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentListType)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VpcList) != len(that1.VpcList) {
		return false
	}
	for i := range this.VpcList {
		if !this.VpcList[i].Equal(that1.VpcList[i]) {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	if that1.SubnetChoice == nil {
		if this.SubnetChoice != nil {
			return false
		}
	} else if this.SubnetChoice == nil {
		return false
	} else if !this.SubnetChoice.Equal(that1.SubnetChoice) {
		return false
	}
	if that1.RoutingChoice == nil {
		if this.RoutingChoice != nil {
			return false
		}
	} else if this.RoutingChoice == nil {
		return false
	} else if !this.RoutingChoice.Equal(that1.RoutingChoice) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentType_AllSubnets) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_AllSubnets)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_AllSubnets)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllSubnets.Equal(that1.AllSubnets) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_SubnetIds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_SubnetIds)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_SubnetIds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetIds.Equal(that1.SubnetIds) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_ManualRouting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_ManualRouting)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_ManualRouting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ManualRouting.Equal(that1.ManualRouting) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_RoutingIds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_RoutingIds)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_RoutingIds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RoutingIds.Equal(that1.RoutingIds) {
		return false
	}
	return true
}
func (this *AWSSubnetIDListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSSubnetIDListType)
	if !ok {
		that2, ok := that.(AWSSubnetIDListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SubnetIds) != len(that1.SubnetIds) {
		return false
	}
	for i := range this.SubnetIds {
		if this.SubnetIds[i] != that1.SubnetIds[i] {
			return false
		}
	}
	return true
}
func (this *AWSRouteTableListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSRouteTableListType)
	if !ok {
		that2, ok := that.(AWSRouteTableListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RouteTables) != len(that1.RouteTables) {
		return false
	}
	for i := range this.RouteTables {
		if !this.RouteTables[i].Equal(that1.RouteTables[i]) {
			return false
		}
	}
	return true
}
func (this *AWSRouteTableType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSRouteTableType)
	if !ok {
		that2, ok := that.(AWSRouteTableType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RouteTableId != that1.RouteTableId {
		return false
	}
	if len(this.StaticRoutes) != len(that1.StaticRoutes) {
		return false
	}
	for i := range this.StaticRoutes {
		if this.StaticRoutes[i] != that1.StaticRoutes[i] {
			return false
		}
	}
	return true
}
func (this *ReplaceAWSREType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceAWSREType)
	if !ok {
		that2, ok := that.(ReplaceAWSREType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	return true
}
func (this *AWSTGWSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTGWSiteType)
	if !ok {
		that2, ok := that.(AWSTGWSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	if !this.Cred.Equal(that1.Cred) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	if !this.CloudLinks.Equal(that1.CloudLinks) {
		return false
	}
	return true
}
func (this *IsolatedType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IsolatedType)
	if !ok {
		that2, ok := that.(IsolatedType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *EnableSegmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EnableSegmentType)
	if !ok {
		that2, ok := that.(EnableSegmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if that1.SegmentOption == nil {
		if this.SegmentOption != nil {
			return false
		}
	} else if this.SegmentOption == nil {
		return false
	} else if !this.SegmentOption.Equal(that1.SegmentOption) {
		return false
	}
	if that1.BandwidthOption == nil {
		if this.BandwidthOption != nil {
			return false
		}
	} else if this.BandwidthOption == nil {
		return false
	} else if !this.BandwidthOption.Equal(that1.BandwidthOption) {
		return false
	}
	if len(this.Sites) != len(that1.Sites) {
		return false
	}
	for i := range this.Sites {
		if !this.Sites[i].Equal(that1.Sites[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AwsRe)
	if !ok {
		that2, ok := that.(GlobalSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AwsTgwSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AwsTgwSite)
	if !ok {
		that2, ok := that.(GlobalSpecType_AwsTgwSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsTgwSite.Equal(that1.AwsTgwSite) {
		return false
	}
	return true
}
func (this *GlobalSpecType_IsolatedSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_IsolatedSegment)
	if !ok {
		that2, ok := that.(GlobalSpecType_IsolatedSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsolatedSegment.Equal(that1.IsolatedSegment) {
		return false
	}
	return true
}
func (this *GlobalSpecType_EnableSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_EnableSegment)
	if !ok {
		that2, ok := that.(GlobalSpecType_EnableSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableSegment.Equal(that1.EnableSegment) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Bandwidth_500Mbs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Bandwidth_500Mbs)
	if !ok {
		that2, ok := that.(GlobalSpecType_Bandwidth_500Mbs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Bandwidth_500Mbs.Equal(that1.Bandwidth_500Mbs) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if that1.SegmentOption == nil {
		if this.SegmentOption != nil {
			return false
		}
	} else if this.SegmentOption == nil {
		return false
	} else if !this.SegmentOption.Equal(that1.SegmentOption) {
		return false
	}
	return true
}
func (this *CreateSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AwsRe)
	if !ok {
		that2, ok := that.(CreateSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *CreateSpecType_IsolatedSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_IsolatedSegment)
	if !ok {
		that2, ok := that.(CreateSpecType_IsolatedSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsolatedSegment.Equal(that1.IsolatedSegment) {
		return false
	}
	return true
}
func (this *CreateSpecType_EnableSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_EnableSegment)
	if !ok {
		that2, ok := that.(CreateSpecType_EnableSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableSegment.Equal(that1.EnableSegment) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if that1.SegmentOption == nil {
		if this.SegmentOption != nil {
			return false
		}
	} else if this.SegmentOption == nil {
		return false
	} else if !this.SegmentOption.Equal(that1.SegmentOption) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AwsRe)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_IsolatedSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_IsolatedSegment)
	if !ok {
		that2, ok := that.(ReplaceSpecType_IsolatedSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsolatedSegment.Equal(that1.IsolatedSegment) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_EnableSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_EnableSegment)
	if !ok {
		that2, ok := that.(ReplaceSpecType_EnableSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableSegment.Equal(that1.EnableSegment) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if that1.SegmentOption == nil {
		if this.SegmentOption != nil {
			return false
		}
	} else if this.SegmentOption == nil {
		return false
	} else if !this.SegmentOption.Equal(that1.SegmentOption) {
		return false
	}
	return true
}
func (this *GetSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AwsRe)
	if !ok {
		that2, ok := that.(GetSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *GetSpecType_IsolatedSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_IsolatedSegment)
	if !ok {
		that2, ok := that.(GetSpecType_IsolatedSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsolatedSegment.Equal(that1.IsolatedSegment) {
		return false
	}
	return true
}
func (this *GetSpecType_EnableSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_EnableSegment)
	if !ok {
		that2, ok := that.(GetSpecType_EnableSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableSegment.Equal(that1.EnableSegment) {
		return false
	}
	return true
}
func (this *AWSREType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud_connect.AWSREType{")
	if this.Region != nil {
		s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	}
	if this.Cred != nil {
		s = append(s, "Cred: "+fmt.Sprintf("%#v", this.Cred)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	if this.CloudLinks != nil {
		s = append(s, "CloudLinks: "+fmt.Sprintf("%#v", this.CloudLinks)+",\n")
	}
	s = append(s, "Tgw: "+fmt.Sprintf("%#v", this.Tgw)+",\n")
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudLinkListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.CloudLinkListType{")
	if this.CloudLink != nil {
		s = append(s, "CloudLink: "+fmt.Sprintf("%#v", this.CloudLink)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSVPCAttachmentListType{")
	if this.VpcList != nil {
		s = append(s, "VpcList: "+fmt.Sprintf("%#v", this.VpcList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud_connect.AWSVPCAttachmentType{")
	s = append(s, "VpcId: "+fmt.Sprintf("%#v", this.VpcId)+",\n")
	if this.SubnetChoice != nil {
		s = append(s, "SubnetChoice: "+fmt.Sprintf("%#v", this.SubnetChoice)+",\n")
	}
	if this.RoutingChoice != nil {
		s = append(s, "RoutingChoice: "+fmt.Sprintf("%#v", this.RoutingChoice)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentType_AllSubnets) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_AllSubnets{` +
		`AllSubnets:` + fmt.Sprintf("%#v", this.AllSubnets) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_SubnetIds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_SubnetIds{` +
		`SubnetIds:` + fmt.Sprintf("%#v", this.SubnetIds) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_ManualRouting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_ManualRouting{` +
		`ManualRouting:` + fmt.Sprintf("%#v", this.ManualRouting) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_RoutingIds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_RoutingIds{` +
		`RoutingIds:` + fmt.Sprintf("%#v", this.RoutingIds) + `}`}, ", ")
	return s
}
func (this *AWSSubnetIDListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSSubnetIDListType{")
	s = append(s, "SubnetIds: "+fmt.Sprintf("%#v", this.SubnetIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSRouteTableListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSRouteTableListType{")
	if this.RouteTables != nil {
		s = append(s, "RouteTables: "+fmt.Sprintf("%#v", this.RouteTables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSRouteTableType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.AWSRouteTableType{")
	s = append(s, "RouteTableId: "+fmt.Sprintf("%#v", this.RouteTableId)+",\n")
	s = append(s, "StaticRoutes: "+fmt.Sprintf("%#v", this.StaticRoutes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceAWSREType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.ReplaceAWSREType{")
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTGWSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_connect.AWSTGWSiteType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.Cred != nil {
		s = append(s, "Cred: "+fmt.Sprintf("%#v", this.Cred)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	if this.CloudLinks != nil {
		s = append(s, "CloudLinks: "+fmt.Sprintf("%#v", this.CloudLinks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IsolatedType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloud_connect.IsolatedType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EnableSegmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.EnableSegmentType{")
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud_connect.GlobalSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.SegmentOption != nil {
		s = append(s, "SegmentOption: "+fmt.Sprintf("%#v", this.SegmentOption)+",\n")
	}
	if this.BandwidthOption != nil {
		s = append(s, "BandwidthOption: "+fmt.Sprintf("%#v", this.BandwidthOption)+",\n")
	}
	if this.Sites != nil {
		s = append(s, "Sites: "+fmt.Sprintf("%#v", this.Sites)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AwsTgwSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_AwsTgwSite{` +
		`AwsTgwSite:` + fmt.Sprintf("%#v", this.AwsTgwSite) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_IsolatedSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_IsolatedSegment{` +
		`IsolatedSegment:` + fmt.Sprintf("%#v", this.IsolatedSegment) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_EnableSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_EnableSegment{` +
		`EnableSegment:` + fmt.Sprintf("%#v", this.EnableSegment) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Bandwidth_500Mbs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_Bandwidth_500Mbs{` +
		`Bandwidth_500Mbs:` + fmt.Sprintf("%#v", this.Bandwidth_500Mbs) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_connect.CreateSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.SegmentOption != nil {
		s = append(s, "SegmentOption: "+fmt.Sprintf("%#v", this.SegmentOption)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CreateSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_IsolatedSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CreateSpecType_IsolatedSegment{` +
		`IsolatedSegment:` + fmt.Sprintf("%#v", this.IsolatedSegment) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_EnableSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CreateSpecType_EnableSegment{` +
		`EnableSegment:` + fmt.Sprintf("%#v", this.EnableSegment) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_connect.ReplaceSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.SegmentOption != nil {
		s = append(s, "SegmentOption: "+fmt.Sprintf("%#v", this.SegmentOption)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.ReplaceSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_IsolatedSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.ReplaceSpecType_IsolatedSegment{` +
		`IsolatedSegment:` + fmt.Sprintf("%#v", this.IsolatedSegment) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_EnableSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.ReplaceSpecType_EnableSegment{` +
		`EnableSegment:` + fmt.Sprintf("%#v", this.EnableSegment) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_connect.GetSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.SegmentOption != nil {
		s = append(s, "SegmentOption: "+fmt.Sprintf("%#v", this.SegmentOption)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GetSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *GetSpecType_IsolatedSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GetSpecType_IsolatedSegment{` +
		`IsolatedSegment:` + fmt.Sprintf("%#v", this.IsolatedSegment) + `}`}, ", ")
	return s
}
func (this *GetSpecType_EnableSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GetSpecType_EnableSegment{` +
		`EnableSegment:` + fmt.Sprintf("%#v", this.EnableSegment) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AWSREType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSREType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSREType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Tgw) > 0 {
		i -= len(m.Tgw)
		copy(dAtA[i:], m.Tgw)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tgw)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CloudLinks != nil {
		{
			size, err := m.CloudLinks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Cred != nil {
		{
			size, err := m.Cred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudLinkListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudLinkListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudLinkListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudLink) > 0 {
		for iNdEx := len(m.CloudLink) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudLink[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCAttachmentListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VpcList) > 0 {
		for iNdEx := len(m.VpcList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VpcList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCAttachmentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.RoutingChoice != nil {
		{
			size := m.RoutingChoice.Size()
			i -= size
			if _, err := m.RoutingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SubnetChoice != nil {
		{
			size := m.SubnetChoice.Size()
			i -= size
			if _, err := m.SubnetChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.VpcId) > 0 {
		i -= len(m.VpcId)
		copy(dAtA[i:], m.VpcId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentType_AllSubnets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_AllSubnets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllSubnets != nil {
		{
			size, err := m.AllSubnets.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_SubnetIds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_SubnetIds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubnetIds != nil {
		{
			size, err := m.SubnetIds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_ManualRouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_ManualRouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ManualRouting != nil {
		{
			size, err := m.ManualRouting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_RoutingIds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_RoutingIds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RoutingIds != nil {
		{
			size, err := m.RoutingIds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *AWSSubnetIDListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSSubnetIDListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSubnetIDListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubnetIds) > 0 {
		for iNdEx := len(m.SubnetIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubnetIds[iNdEx])
			copy(dAtA[i:], m.SubnetIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SubnetIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSRouteTableListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSRouteTableListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSRouteTableListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for iNdEx := len(m.RouteTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RouteTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSRouteTableType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSRouteTableType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSRouteTableType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StaticRoutes) > 0 {
		for iNdEx := len(m.StaticRoutes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StaticRoutes[iNdEx])
			copy(dAtA[i:], m.StaticRoutes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.StaticRoutes[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RouteTableId) > 0 {
		i -= len(m.RouteTableId)
		copy(dAtA[i:], m.RouteTableId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteTableId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceAWSREType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceAWSREType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceAWSREType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *AWSTGWSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTGWSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSTGWSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudLinks != nil {
		{
			size, err := m.CloudLinks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Cred != nil {
		{
			size, err := m.Cred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsolatedType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsolatedType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsolatedType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EnableSegmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableSegmentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnableSegmentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sites) > 0 {
		for iNdEx := len(m.Sites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.BandwidthOption != nil {
		{
			size := m.BandwidthOption.Size()
			i -= size
			if _, err := m.BandwidthOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SegmentOption != nil {
		{
			size := m.SegmentOption.Size()
			i -= size
			if _, err := m.SegmentOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_IsolatedSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_IsolatedSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsolatedSegment != nil {
		{
			size, err := m.IsolatedSegment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_EnableSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_EnableSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableSegment != nil {
		{
			size, err := m.EnableSegment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AwsTgwSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AwsTgwSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsTgwSite != nil {
		{
			size, err := m.AwsTgwSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Bandwidth_500Mbs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Bandwidth_500Mbs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bandwidth_500Mbs != nil {
		{
			size, err := m.Bandwidth_500Mbs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SegmentOption != nil {
		{
			size := m.SegmentOption.Size()
			i -= size
			if _, err := m.SegmentOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_IsolatedSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_IsolatedSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsolatedSegment != nil {
		{
			size, err := m.IsolatedSegment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_EnableSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_EnableSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableSegment != nil {
		{
			size, err := m.EnableSegment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SegmentOption != nil {
		{
			size := m.SegmentOption.Size()
			i -= size
			if _, err := m.SegmentOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_IsolatedSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_IsolatedSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsolatedSegment != nil {
		{
			size, err := m.IsolatedSegment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_EnableSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_EnableSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableSegment != nil {
		{
			size, err := m.EnableSegment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SegmentOption != nil {
		{
			size := m.SegmentOption.Size()
			i -= size
			if _, err := m.SegmentOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_IsolatedSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_IsolatedSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsolatedSegment != nil {
		{
			size, err := m.IsolatedSegment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_EnableSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_EnableSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableSegment != nil {
		{
			size, err := m.EnableSegment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AWSREType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cred != nil {
		l = m.Cred.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CloudLinks != nil {
		l = m.CloudLinks.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Tgw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CloudLinkListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CloudLink) > 0 {
		for _, e := range m.CloudLink {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSVPCAttachmentListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VpcList) > 0 {
		for _, e := range m.VpcList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSVPCAttachmentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SubnetChoice != nil {
		n += m.SubnetChoice.Size()
	}
	if m.RoutingChoice != nil {
		n += m.RoutingChoice.Size()
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AWSVPCAttachmentType_AllSubnets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllSubnets != nil {
		l = m.AllSubnets.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_SubnetIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetIds != nil {
		l = m.SubnetIds.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_ManualRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManualRouting != nil {
		l = m.ManualRouting.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_RoutingIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoutingIds != nil {
		l = m.RoutingIds.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSSubnetIDListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubnetIds) > 0 {
		for _, s := range m.SubnetIds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSRouteTableListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for _, e := range m.RouteTables {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSRouteTableType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteTableId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.StaticRoutes) > 0 {
		for _, s := range m.StaticRoutes {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceAWSREType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AWSTGWSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cred != nil {
		l = m.Cred.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CloudLinks != nil {
		l = m.CloudLinks.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IsolatedType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EnableSegmentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.SegmentOption != nil {
		n += m.SegmentOption.Size()
	}
	if m.BandwidthOption != nil {
		n += m.BandwidthOption.Size()
	}
	if len(m.Sites) > 0 {
		for _, e := range m.Sites {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_IsolatedSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsolatedSegment != nil {
		l = m.IsolatedSegment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_EnableSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableSegment != nil {
		l = m.EnableSegment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AwsTgwSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsTgwSite != nil {
		l = m.AwsTgwSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Bandwidth_500Mbs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bandwidth_500Mbs != nil {
		l = m.Bandwidth_500Mbs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.SegmentOption != nil {
		n += m.SegmentOption.Size()
	}
	return n
}

func (m *CreateSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_IsolatedSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsolatedSegment != nil {
		l = m.IsolatedSegment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_EnableSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableSegment != nil {
		l = m.EnableSegment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.SegmentOption != nil {
		n += m.SegmentOption.Size()
	}
	return n
}

func (m *ReplaceSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_IsolatedSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsolatedSegment != nil {
		l = m.IsolatedSegment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_EnableSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableSegment != nil {
		l = m.EnableSegment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.SegmentOption != nil {
		n += m.SegmentOption.Size()
	}
	return n
}

func (m *GetSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_IsolatedSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsolatedSegment != nil {
		l = m.IsolatedSegment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_EnableSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableSegment != nil {
		l = m.EnableSegment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSREType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*NodeType{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(fmt.Sprintf("%v", f), "NodeType", "cloud_re_region.NodeType", 1) + ","
	}
	repeatedStringForNodes += "}"
	s := strings.Join([]string{`&AWSREType{`,
		`Region:` + strings.Replace(fmt.Sprintf("%v", this.Region), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Cred:` + strings.Replace(fmt.Sprintf("%v", this.Cred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`CloudLinks:` + strings.Replace(this.CloudLinks.String(), "CloudLinkListType", "CloudLinkListType", 1) + `,`,
		`Tgw:` + fmt.Sprintf("%v", this.Tgw) + `,`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudLinkListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCloudLink := "[]*ObjectRefType{"
	for _, f := range this.CloudLink {
		repeatedStringForCloudLink += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForCloudLink += "}"
	s := strings.Join([]string{`&CloudLinkListType{`,
		`CloudLink:` + repeatedStringForCloudLink + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVpcList := "[]*AWSVPCAttachmentType{"
	for _, f := range this.VpcList {
		repeatedStringForVpcList += strings.Replace(f.String(), "AWSVPCAttachmentType", "AWSVPCAttachmentType", 1) + ","
	}
	repeatedStringForVpcList += "}"
	s := strings.Join([]string{`&AWSVPCAttachmentListType{`,
		`VpcList:` + repeatedStringForVpcList + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&AWSVPCAttachmentType{`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`SubnetChoice:` + fmt.Sprintf("%v", this.SubnetChoice) + `,`,
		`RoutingChoice:` + fmt.Sprintf("%v", this.RoutingChoice) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_AllSubnets) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_AllSubnets{`,
		`AllSubnets:` + strings.Replace(fmt.Sprintf("%v", this.AllSubnets), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_SubnetIds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_SubnetIds{`,
		`SubnetIds:` + strings.Replace(fmt.Sprintf("%v", this.SubnetIds), "AWSSubnetIDListType", "AWSSubnetIDListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_ManualRouting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_ManualRouting{`,
		`ManualRouting:` + strings.Replace(fmt.Sprintf("%v", this.ManualRouting), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_RoutingIds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_RoutingIds{`,
		`RoutingIds:` + strings.Replace(fmt.Sprintf("%v", this.RoutingIds), "AWSRouteTableListType", "AWSRouteTableListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSSubnetIDListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSSubnetIDListType{`,
		`SubnetIds:` + fmt.Sprintf("%v", this.SubnetIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSRouteTableListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRouteTables := "[]*AWSRouteTableType{"
	for _, f := range this.RouteTables {
		repeatedStringForRouteTables += strings.Replace(f.String(), "AWSRouteTableType", "AWSRouteTableType", 1) + ","
	}
	repeatedStringForRouteTables += "}"
	s := strings.Join([]string{`&AWSRouteTableListType{`,
		`RouteTables:` + repeatedStringForRouteTables + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSRouteTableType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSRouteTableType{`,
		`RouteTableId:` + fmt.Sprintf("%v", this.RouteTableId) + `,`,
		`StaticRoutes:` + fmt.Sprintf("%v", this.StaticRoutes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceAWSREType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceAWSREType{`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTGWSiteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSTGWSiteType{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Cred:` + strings.Replace(fmt.Sprintf("%v", this.Cred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`CloudLinks:` + strings.Replace(this.CloudLinks.String(), "CloudLinkListType", "CloudLinkListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IsolatedType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IsolatedType{`,
		`}`,
	}, "")
	return s
}
func (this *EnableSegmentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EnableSegmentType{`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSites := "[]*ObjectRefType{"
	for _, f := range this.Sites {
		repeatedStringForSites += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSites += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`SegmentOption:` + fmt.Sprintf("%v", this.SegmentOption) + `,`,
		`BandwidthOption:` + fmt.Sprintf("%v", this.BandwidthOption) + `,`,
		`Sites:` + repeatedStringForSites + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_IsolatedSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_IsolatedSegment{`,
		`IsolatedSegment:` + strings.Replace(fmt.Sprintf("%v", this.IsolatedSegment), "IsolatedType", "IsolatedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_EnableSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_EnableSegment{`,
		`EnableSegment:` + strings.Replace(fmt.Sprintf("%v", this.EnableSegment), "EnableSegmentType", "EnableSegmentType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AwsTgwSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AwsTgwSite{`,
		`AwsTgwSite:` + strings.Replace(fmt.Sprintf("%v", this.AwsTgwSite), "AWSTGWSiteType", "AWSTGWSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Bandwidth_500Mbs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Bandwidth_500Mbs{`,
		`Bandwidth_500Mbs:` + strings.Replace(fmt.Sprintf("%v", this.Bandwidth_500Mbs), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`SegmentOption:` + fmt.Sprintf("%v", this.SegmentOption) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_IsolatedSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_IsolatedSegment{`,
		`IsolatedSegment:` + strings.Replace(fmt.Sprintf("%v", this.IsolatedSegment), "IsolatedType", "IsolatedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_EnableSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_EnableSegment{`,
		`EnableSegment:` + strings.Replace(fmt.Sprintf("%v", this.EnableSegment), "EnableSegmentType", "EnableSegmentType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`SegmentOption:` + fmt.Sprintf("%v", this.SegmentOption) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "ReplaceAWSREType", "ReplaceAWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_IsolatedSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_IsolatedSegment{`,
		`IsolatedSegment:` + strings.Replace(fmt.Sprintf("%v", this.IsolatedSegment), "IsolatedType", "IsolatedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_EnableSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_EnableSegment{`,
		`EnableSegment:` + strings.Replace(fmt.Sprintf("%v", this.EnableSegment), "EnableSegmentType", "EnableSegmentType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`SegmentOption:` + fmt.Sprintf("%v", this.SegmentOption) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_IsolatedSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_IsolatedSegment{`,
		`IsolatedSegment:` + strings.Replace(fmt.Sprintf("%v", this.IsolatedSegment), "IsolatedType", "IsolatedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_EnableSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_EnableSegment{`,
		`EnableSegment:` + strings.Replace(fmt.Sprintf("%v", this.EnableSegment), "EnableSegmentType", "EnableSegmentType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSREType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSREType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSREType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &views.ObjectRefType{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cred == nil {
				m.Cred = &views.ObjectRefType{}
			}
			if err := m.Cred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudLinks == nil {
				m.CloudLinks = &CloudLinkListType{}
			}
			if err := m.CloudLinks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tgw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &cloud_re_region.NodeType{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudLinkListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudLinkListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudLinkListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudLink = append(m.CloudLink, &views.ObjectRefType{})
			if err := m.CloudLink[len(m.CloudLink)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCAttachmentListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCAttachmentListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCAttachmentListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcList = append(m.VpcList, &AWSVPCAttachmentType{})
			if err := m.VpcList[len(m.VpcList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCAttachmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCAttachmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCAttachmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllSubnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SubnetChoice = &AWSVPCAttachmentType_AllSubnets{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSSubnetIDListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SubnetChoice = &AWSVPCAttachmentType_SubnetIds{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualRouting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_ManualRouting{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSRouteTableListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_RoutingIds{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSSubnetIDListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSSubnetIDListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSSubnetIDListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetIds = append(m.SubnetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSRouteTableListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSRouteTableListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSRouteTableListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTables = append(m.RouteTables, &AWSRouteTableType{})
			if err := m.RouteTables[len(m.RouteTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSRouteTableType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSRouteTableType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSRouteTableType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRoutes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticRoutes = append(m.StaticRoutes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceAWSREType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceAWSREType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceAWSREType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTGWSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTGWSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTGWSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Site == nil {
				m.Site = &views.ObjectRefType{}
			}
			if err := m.Site.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cred == nil {
				m.Cred = &views.ObjectRefType{}
			}
			if err := m.Cred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudLinks == nil {
				m.CloudLinks = &CloudLinkListType{}
			}
			if err := m.CloudLinks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsolatedType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsolatedType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsolatedType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableSegmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableSegmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableSegmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GlobalSpecType_AwsRe{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolatedSegment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IsolatedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegmentOption = &GlobalSpecType_IsolatedSegment{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSegment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnableSegmentType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegmentOption = &GlobalSpecType_EnableSegment{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsTgwSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSTGWSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GlobalSpecType_AwsTgwSite{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth_500Mbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BandwidthOption = &GlobalSpecType_Bandwidth_500Mbs{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sites = append(m.Sites, &schema.ObjectRefType{})
			if err := m.Sites[len(m.Sites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &CreateSpecType_AwsRe{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolatedSegment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IsolatedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegmentOption = &CreateSpecType_IsolatedSegment{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSegment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnableSegmentType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegmentOption = &CreateSpecType_EnableSegment{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplaceAWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &ReplaceSpecType_AwsRe{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolatedSegment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IsolatedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegmentOption = &ReplaceSpecType_IsolatedSegment{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSegment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnableSegmentType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegmentOption = &ReplaceSpecType_EnableSegment{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GetSpecType_AwsRe{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolatedSegment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IsolatedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegmentOption = &GetSpecType_IsolatedSegment{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSegment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnableSegmentType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegmentOption = &GetSpecType_EnableSegment{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
