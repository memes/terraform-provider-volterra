//
// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package cloud_credentials

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AWSSecretType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSSecretType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AWSSecretType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetSecretKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AWSSecretType.secret_key")
	}

	return nil
}

func (m *AWSSecretType) DeepCopy() *AWSSecretType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSSecretType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSSecretType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSSecretType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSSecretTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSSecretType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSSecretType) AccessKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for access_key")
	}

	return validatorFn, nil
}

func (v *ValidateAWSSecretType) SecretKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for secret_key")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAWSSecretType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSSecretType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSSecretType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["access_key"]; exists {

		vOpts := append(opts, db.WithValidateField("access_key"))
		if err := fv(ctx, m.GetAccessKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["secret_key"]; exists {

		vOpts := append(opts, db.WithValidateField("secret_key"))
		if err := fv(ctx, m.GetSecretKey(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSSecretTypeValidator = func() *ValidateAWSSecretType {
	v := &ValidateAWSSecretType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAccessKey := v.AccessKeyValidationRuleHandler
	rulesAccessKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFn, err = vrhAccessKey(rulesAccessKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSSecretType.access_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["access_key"] = vFn

	vrhSecretKey := v.SecretKeyValidationRuleHandler
	rulesSecretKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSecretKey(rulesSecretKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSSecretType.secret_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["secret_key"] = vFn

	return v
}()

func AWSSecretTypeValidator() db.Validator {
	return DefaultAWSSecretTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzurePfxType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzurePfxType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AzurePfxType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AzurePfxType.password")
	}

	return nil
}

func (m *AzurePfxType) DeepCopy() *AzurePfxType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzurePfxType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzurePfxType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzurePfxType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzurePfxTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzurePfxType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzurePfxType) ClientIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for client_id")
	}

	return validatorFn, nil
}

func (v *ValidateAzurePfxType) SubscriptionIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subscription_id")
	}

	return validatorFn, nil
}

func (v *ValidateAzurePfxType) TenantIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tenant_id")
	}

	return validatorFn, nil
}

func (v *ValidateAzurePfxType) CertificateUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for certificate_url")
	}

	return validatorFn, nil
}

func (v *ValidateAzurePfxType) PasswordValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for password")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAzurePfxType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzurePfxType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzurePfxType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["certificate_url"]; exists {

		vOpts := append(opts, db.WithValidateField("certificate_url"))
		if err := fv(ctx, m.GetCertificateUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_id"]; exists {

		vOpts := append(opts, db.WithValidateField("client_id"))
		if err := fv(ctx, m.GetClientId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["password"]; exists {

		vOpts := append(opts, db.WithValidateField("password"))
		if err := fv(ctx, m.GetPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subscription_id"]; exists {

		vOpts := append(opts, db.WithValidateField("subscription_id"))
		if err := fv(ctx, m.GetSubscriptionId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_id"))
		if err := fv(ctx, m.GetTenantId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzurePfxTypeValidator = func() *ValidateAzurePfxType {
	v := &ValidateAzurePfxType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClientId := v.ClientIdValidationRuleHandler
	rulesClientId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhClientId(rulesClientId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzurePfxType.client_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_id"] = vFn

	vrhSubscriptionId := v.SubscriptionIdValidationRuleHandler
	rulesSubscriptionId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhSubscriptionId(rulesSubscriptionId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzurePfxType.subscription_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subscription_id"] = vFn

	vrhTenantId := v.TenantIdValidationRuleHandler
	rulesTenantId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhTenantId(rulesTenantId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzurePfxType.tenant_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tenant_id"] = vFn

	vrhCertificateUrl := v.CertificateUrlValidationRuleHandler
	rulesCertificateUrl := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "8192",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhCertificateUrl(rulesCertificateUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzurePfxType.certificate_url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["certificate_url"] = vFn

	vrhPassword := v.PasswordValidationRuleHandler
	rulesPassword := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPassword(rulesPassword)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzurePfxType.password: %s", err)
		panic(errMsg)
	}
	v.FldValidators["password"] = vFn

	return v
}()

func AzurePfxTypeValidator() db.Validator {
	return DefaultAzurePfxTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureSecretType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureSecretType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AzureSecretType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetClientSecret().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AzureSecretType.client_secret")
	}

	return nil
}

func (m *AzureSecretType) DeepCopy() *AzureSecretType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureSecretType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureSecretType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureSecretType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureSecretTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureSecretType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureSecretType) ClientIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for client_id")
	}

	return validatorFn, nil
}

func (v *ValidateAzureSecretType) SubscriptionIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subscription_id")
	}

	return validatorFn, nil
}

func (v *ValidateAzureSecretType) TenantIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tenant_id")
	}

	return validatorFn, nil
}

func (v *ValidateAzureSecretType) ClientSecretValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for client_secret")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAzureSecretType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureSecretType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureSecretType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_id"]; exists {

		vOpts := append(opts, db.WithValidateField("client_id"))
		if err := fv(ctx, m.GetClientId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_secret"]; exists {

		vOpts := append(opts, db.WithValidateField("client_secret"))
		if err := fv(ctx, m.GetClientSecret(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subscription_id"]; exists {

		vOpts := append(opts, db.WithValidateField("subscription_id"))
		if err := fv(ctx, m.GetSubscriptionId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_id"))
		if err := fv(ctx, m.GetTenantId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureSecretTypeValidator = func() *ValidateAzureSecretType {
	v := &ValidateAzureSecretType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClientId := v.ClientIdValidationRuleHandler
	rulesClientId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhClientId(rulesClientId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureSecretType.client_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_id"] = vFn

	vrhSubscriptionId := v.SubscriptionIdValidationRuleHandler
	rulesSubscriptionId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhSubscriptionId(rulesSubscriptionId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureSecretType.subscription_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subscription_id"] = vFn

	vrhTenantId := v.TenantIdValidationRuleHandler
	rulesTenantId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhTenantId(rulesTenantId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureSecretType.tenant_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tenant_id"] = vFn

	vrhClientSecret := v.ClientSecretValidationRuleHandler
	rulesClientSecret := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhClientSecret(rulesClientSecret)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureSecretType.client_secret: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_secret"] = vFn

	return v
}()

func AzureSecretTypeValidator() db.Validator {
	return DefaultAzureSecretTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAwsSecretKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.aws_secret_key")
	}

	if err := m.GetAzurePfxCertificate().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.azure_pfx_certificate")
	}

	if err := m.GetAzureClientSecret().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.azure_client_secret")
	}

	if err := m.GetGcpCredFile().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.gcp_cred_file")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) CloudValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cloud")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cloud"]; exists {
		val := m.GetCloud()
		vOpts := append(opts,
			db.WithValidateField("cloud"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCloud().(type) {
	case *CreateSpecType_AwsSecretKey:
		if fv, exists := v.FldValidators["cloud.aws_secret_key"]; exists {
			val := m.GetCloud().(*CreateSpecType_AwsSecretKey).AwsSecretKey
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("aws_secret_key"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AzurePfxCertificate:
		if fv, exists := v.FldValidators["cloud.azure_pfx_certificate"]; exists {
			val := m.GetCloud().(*CreateSpecType_AzurePfxCertificate).AzurePfxCertificate
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("azure_pfx_certificate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AzureClientSecret:
		if fv, exists := v.FldValidators["cloud.azure_client_secret"]; exists {
			val := m.GetCloud().(*CreateSpecType_AzureClientSecret).AzureClientSecret
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("azure_client_secret"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_GcpCredFile:
		if fv, exists := v.FldValidators["cloud.gcp_cred_file"]; exists {
			val := m.GetCloud().(*CreateSpecType_GcpCredFile).GcpCredFile
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("gcp_cred_file"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCloud := v.CloudValidationRuleHandler
	rulesCloud := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCloud(rulesCloud)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.cloud: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cloud"] = vFn

	v.FldValidators["cloud.aws_secret_key"] = AWSSecretTypeValidator().Validate
	v.FldValidators["cloud.azure_pfx_certificate"] = AzurePfxTypeValidator().Validate
	v.FldValidators["cloud.azure_client_secret"] = AzureSecretTypeValidator().Validate
	v.FldValidators["cloud.gcp_cred_file"] = GCPCredFileTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPCredFileType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPCredFileType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GCPCredFileType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetCredentialFile().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GCPCredFileType.credential_file")
	}

	return nil
}

func (m *GCPCredFileType) DeepCopy() *GCPCredFileType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPCredFileType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPCredFileType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPCredFileType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPCredFileTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPCredFileType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPCredFileType) CredentialFileValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for credential_file")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGCPCredFileType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPCredFileType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPCredFileType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["credential_file"]; exists {

		vOpts := append(opts, db.WithValidateField("credential_file"))
		if err := fv(ctx, m.GetCredentialFile(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPCredFileTypeValidator = func() *ValidateGCPCredFileType {
	v := &ValidateGCPCredFileType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCredentialFile := v.CredentialFileValidationRuleHandler
	rulesCredentialFile := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCredentialFile(rulesCredentialFile)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPCredFileType.credential_file: %s", err)
		panic(errMsg)
	}
	v.FldValidators["credential_file"] = vFn

	return v
}()

func GCPCredFileTypeValidator() db.Validator {
	return DefaultGCPCredFileTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAwsSecretKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.aws_secret_key")
	}

	if err := m.GetAzurePfxCertificate().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.azure_pfx_certificate")
	}

	if err := m.GetAzureClientSecret().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.azure_client_secret")
	}

	if err := m.GetGcpCredFile().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.gcp_cred_file")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) CloudValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cloud")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cloud"]; exists {
		val := m.GetCloud()
		vOpts := append(opts,
			db.WithValidateField("cloud"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCloud().(type) {
	case *GetSpecType_AwsSecretKey:
		if fv, exists := v.FldValidators["cloud.aws_secret_key"]; exists {
			val := m.GetCloud().(*GetSpecType_AwsSecretKey).AwsSecretKey
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("aws_secret_key"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AzurePfxCertificate:
		if fv, exists := v.FldValidators["cloud.azure_pfx_certificate"]; exists {
			val := m.GetCloud().(*GetSpecType_AzurePfxCertificate).AzurePfxCertificate
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("azure_pfx_certificate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AzureClientSecret:
		if fv, exists := v.FldValidators["cloud.azure_client_secret"]; exists {
			val := m.GetCloud().(*GetSpecType_AzureClientSecret).AzureClientSecret
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("azure_client_secret"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_GcpCredFile:
		if fv, exists := v.FldValidators["cloud.gcp_cred_file"]; exists {
			val := m.GetCloud().(*GetSpecType_GcpCredFile).GcpCredFile
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("gcp_cred_file"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCloud := v.CloudValidationRuleHandler
	rulesCloud := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCloud(rulesCloud)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.cloud: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cloud"] = vFn

	v.FldValidators["cloud.aws_secret_key"] = AWSSecretTypeValidator().Validate
	v.FldValidators["cloud.azure_pfx_certificate"] = AzurePfxTypeValidator().Validate
	v.FldValidators["cloud.azure_client_secret"] = AzureSecretTypeValidator().Validate
	v.FldValidators["cloud.gcp_cred_file"] = GCPCredFileTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAwsSecretKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.aws_secret_key")
	}

	if err := m.GetAzurePfxCertificate().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.azure_pfx_certificate")
	}

	if err := m.GetAzureClientSecret().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.azure_client_secret")
	}

	if err := m.GetGcpCredFile().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.gcp_cred_file")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) CloudValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cloud")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cloud"]; exists {
		val := m.GetCloud()
		vOpts := append(opts,
			db.WithValidateField("cloud"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCloud().(type) {
	case *GlobalSpecType_AwsSecretKey:
		if fv, exists := v.FldValidators["cloud.aws_secret_key"]; exists {
			val := m.GetCloud().(*GlobalSpecType_AwsSecretKey).AwsSecretKey
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("aws_secret_key"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AzurePfxCertificate:
		if fv, exists := v.FldValidators["cloud.azure_pfx_certificate"]; exists {
			val := m.GetCloud().(*GlobalSpecType_AzurePfxCertificate).AzurePfxCertificate
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("azure_pfx_certificate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AzureClientSecret:
		if fv, exists := v.FldValidators["cloud.azure_client_secret"]; exists {
			val := m.GetCloud().(*GlobalSpecType_AzureClientSecret).AzureClientSecret
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("azure_client_secret"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_GcpCredFile:
		if fv, exists := v.FldValidators["cloud.gcp_cred_file"]; exists {
			val := m.GetCloud().(*GlobalSpecType_GcpCredFile).GcpCredFile
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("gcp_cred_file"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCloud := v.CloudValidationRuleHandler
	rulesCloud := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCloud(rulesCloud)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.cloud: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cloud"] = vFn

	v.FldValidators["cloud.aws_secret_key"] = AWSSecretTypeValidator().Validate
	v.FldValidators["cloud.azure_pfx_certificate"] = AzurePfxTypeValidator().Validate
	v.FldValidators["cloud.azure_client_secret"] = AzureSecretTypeValidator().Validate
	v.FldValidators["cloud.gcp_cred_file"] = GCPCredFileTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAwsSecretKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.aws_secret_key")
	}

	if err := m.GetAzurePfxCertificate().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.azure_pfx_certificate")
	}

	if err := m.GetAzureClientSecret().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.azure_client_secret")
	}

	if err := m.GetGcpCredFile().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.gcp_cred_file")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) CloudValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cloud")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cloud"]; exists {
		val := m.GetCloud()
		vOpts := append(opts,
			db.WithValidateField("cloud"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCloud().(type) {
	case *ReplaceSpecType_AwsSecretKey:
		if fv, exists := v.FldValidators["cloud.aws_secret_key"]; exists {
			val := m.GetCloud().(*ReplaceSpecType_AwsSecretKey).AwsSecretKey
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("aws_secret_key"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AzurePfxCertificate:
		if fv, exists := v.FldValidators["cloud.azure_pfx_certificate"]; exists {
			val := m.GetCloud().(*ReplaceSpecType_AzurePfxCertificate).AzurePfxCertificate
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("azure_pfx_certificate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AzureClientSecret:
		if fv, exists := v.FldValidators["cloud.azure_client_secret"]; exists {
			val := m.GetCloud().(*ReplaceSpecType_AzureClientSecret).AzureClientSecret
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("azure_client_secret"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_GcpCredFile:
		if fv, exists := v.FldValidators["cloud.gcp_cred_file"]; exists {
			val := m.GetCloud().(*ReplaceSpecType_GcpCredFile).GcpCredFile
			vOpts := append(opts,
				db.WithValidateField("cloud"),
				db.WithValidateField("gcp_cred_file"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCloud := v.CloudValidationRuleHandler
	rulesCloud := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCloud(rulesCloud)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.cloud: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cloud"] = vFn

	v.FldValidators["cloud.aws_secret_key"] = AWSSecretTypeValidator().Validate
	v.FldValidators["cloud.azure_pfx_certificate"] = AzurePfxTypeValidator().Validate
	v.FldValidators["cloud.azure_client_secret"] = AzureSecretTypeValidator().Validate
	v.FldValidators["cloud.gcp_cred_file"] = GCPCredFileTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetCloudToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Cloud.(type) {
	case nil:
		o.Cloud = nil

	case *CreateSpecType_AwsSecretKey:
		o.Cloud = &GlobalSpecType_AwsSecretKey{AwsSecretKey: of.AwsSecretKey}

	case *CreateSpecType_AzureClientSecret:
		o.Cloud = &GlobalSpecType_AzureClientSecret{AzureClientSecret: of.AzureClientSecret}

	case *CreateSpecType_AzurePfxCertificate:
		o.Cloud = &GlobalSpecType_AzurePfxCertificate{AzurePfxCertificate: of.AzurePfxCertificate}

	case *CreateSpecType_GcpCredFile:
		o.Cloud = &GlobalSpecType_GcpCredFile{GcpCredFile: of.GcpCredFile}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetCloudFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Cloud.(type) {
	case nil:
		r.Cloud = nil

	case *GlobalSpecType_AwsSecretKey:
		r.Cloud = &CreateSpecType_AwsSecretKey{AwsSecretKey: of.AwsSecretKey}

	case *GlobalSpecType_AzureClientSecret:
		r.Cloud = &CreateSpecType_AzureClientSecret{AzureClientSecret: of.AzureClientSecret}

	case *GlobalSpecType_AzurePfxCertificate:
		r.Cloud = &CreateSpecType_AzurePfxCertificate{AzurePfxCertificate: of.AzurePfxCertificate}

	case *GlobalSpecType_GcpCredFile:
		r.Cloud = &CreateSpecType_GcpCredFile{GcpCredFile: of.GcpCredFile}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetCloudFromGlobalSpecType(f)
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetCloudToGlobalSpecType(f)
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetCloudToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Cloud.(type) {
	case nil:
		o.Cloud = nil

	case *GetSpecType_AwsSecretKey:
		o.Cloud = &GlobalSpecType_AwsSecretKey{AwsSecretKey: of.AwsSecretKey}

	case *GetSpecType_AzureClientSecret:
		o.Cloud = &GlobalSpecType_AzureClientSecret{AzureClientSecret: of.AzureClientSecret}

	case *GetSpecType_AzurePfxCertificate:
		o.Cloud = &GlobalSpecType_AzurePfxCertificate{AzurePfxCertificate: of.AzurePfxCertificate}

	case *GetSpecType_GcpCredFile:
		o.Cloud = &GlobalSpecType_GcpCredFile{GcpCredFile: of.GcpCredFile}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetCloudFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Cloud.(type) {
	case nil:
		r.Cloud = nil

	case *GlobalSpecType_AwsSecretKey:
		r.Cloud = &GetSpecType_AwsSecretKey{AwsSecretKey: of.AwsSecretKey}

	case *GlobalSpecType_AzureClientSecret:
		r.Cloud = &GetSpecType_AzureClientSecret{AzureClientSecret: of.AzureClientSecret}

	case *GlobalSpecType_AzurePfxCertificate:
		r.Cloud = &GetSpecType_AzurePfxCertificate{AzurePfxCertificate: of.AzurePfxCertificate}

	case *GlobalSpecType_GcpCredFile:
		r.Cloud = &GetSpecType_GcpCredFile{GcpCredFile: of.GcpCredFile}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetCloudFromGlobalSpecType(f)
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetCloudToGlobalSpecType(f)
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetCloudToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Cloud.(type) {
	case nil:
		o.Cloud = nil

	case *ReplaceSpecType_AwsSecretKey:
		o.Cloud = &GlobalSpecType_AwsSecretKey{AwsSecretKey: of.AwsSecretKey}

	case *ReplaceSpecType_AzureClientSecret:
		o.Cloud = &GlobalSpecType_AzureClientSecret{AzureClientSecret: of.AzureClientSecret}

	case *ReplaceSpecType_AzurePfxCertificate:
		o.Cloud = &GlobalSpecType_AzurePfxCertificate{AzurePfxCertificate: of.AzurePfxCertificate}

	case *ReplaceSpecType_GcpCredFile:
		o.Cloud = &GlobalSpecType_GcpCredFile{GcpCredFile: of.GcpCredFile}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetCloudFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Cloud.(type) {
	case nil:
		r.Cloud = nil

	case *GlobalSpecType_AwsSecretKey:
		r.Cloud = &ReplaceSpecType_AwsSecretKey{AwsSecretKey: of.AwsSecretKey}

	case *GlobalSpecType_AzureClientSecret:
		r.Cloud = &ReplaceSpecType_AzureClientSecret{AzureClientSecret: of.AzureClientSecret}

	case *GlobalSpecType_AzurePfxCertificate:
		r.Cloud = &ReplaceSpecType_AzurePfxCertificate{AzurePfxCertificate: of.AzurePfxCertificate}

	case *GlobalSpecType_GcpCredFile:
		r.Cloud = &ReplaceSpecType_GcpCredFile{GcpCredFile: of.GcpCredFile}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetCloudFromGlobalSpecType(f)
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetCloudToGlobalSpecType(f)
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
