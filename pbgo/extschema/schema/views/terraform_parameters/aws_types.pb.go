// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/terraform_parameters/aws_types.proto

package terraform_parameters

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AWS Terraform Instance Parameters
//
// x-displayName: "AWS Terraform Instance Parameters"
// Shape of the view terraform parameters specification
type AWSInstanceType struct {
	// F5XC Node Id
	//
	// x-displayName: "F5XC Node ID"
	// F5XC Node ID will be used to refer to this node in other TF parameters
	VoltNodeId string `protobuf:"bytes,1,opt,name=volt_node_id,json=voltNodeId,proto3" json:"volt_node_id,omitempty"`
	// F5XC VPC id
	//
	// x-displayName: "F5XC VPC id"
	// VPC in which Cloud Instance is launched
	VoltVpcId string `protobuf:"bytes,3,opt,name=volt_vpc_id,json=voltVpcId,proto3" json:"volt_vpc_id,omitempty"`
	// Public Subnet
	//
	// x-displayName: "Public Subnet"
	// Public subnet will be used as site local network
	PublicSubnetId string `protobuf:"bytes,4,opt,name=public_subnet_id,json=publicSubnetId,proto3" json:"public_subnet_id,omitempty"`
	// Private Subnet
	//
	// x-displayName: "Private Subnet"
	// Private subnet will be used as site inside network, when node type has two interfaces.
	PrivateSubnetId string `protobuf:"bytes,5,opt,name=private_subnet_id,json=privateSubnetId,proto3" json:"private_subnet_id,omitempty"`
	// Cloud Instance Type
	//
	// x-displayName: "Cloud Instance Type"
	// Cloud instance type like small, medium, large etc
	InstanceType string `protobuf:"bytes,6,opt,name=instance_type,json=instanceType,proto3" json:"instance_type,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// Disk size to be used for this instance
	DiskSize string `protobuf:"bytes,7,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// AMI ID
	//
	// x-displayName: "AMI ID"
	// Amazon Machine Image ID
	AmiId string `protobuf:"bytes,8,opt,name=ami_id,json=amiId,proto3" json:"ami_id,omitempty"`
	// F5XC Node count
	//
	// x-displayName: "F5XC Node count"
	// Desired number of node count used for worker node scaling
	NodeCount int32 `protobuf:"varint,9,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// EBS Volume size
	//
	// x-displayName: "EBS Volume size"
	// Desired size of extra EBS Volume if needed. Set 0 if EBS volume is not needed.
	EbsVolumeSize uint32 `protobuf:"varint,10,opt,name=ebs_volume_size,json=ebsVolumeSize,proto3" json:"ebs_volume_size,omitempty"`
	// EBS Volume AZ
	//
	// x-displayName: "EBS Volume AZ"
	// The AZ where the EBS volume will exist.
	EbsVolumeAz string `protobuf:"bytes,11,opt,name=ebs_volume_az,json=ebsVolumeAz,proto3" json:"ebs_volume_az,omitempty"`
}

func (m *AWSInstanceType) Reset()      { *m = AWSInstanceType{} }
func (*AWSInstanceType) ProtoMessage() {}
func (*AWSInstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b038ed78730a43b7, []int{0}
}
func (m *AWSInstanceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSInstanceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSInstanceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSInstanceType.Merge(m, src)
}
func (m *AWSInstanceType) XXX_Size() int {
	return m.Size()
}
func (m *AWSInstanceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSInstanceType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSInstanceType proto.InternalMessageInfo

func (m *AWSInstanceType) GetVoltNodeId() string {
	if m != nil {
		return m.VoltNodeId
	}
	return ""
}

func (m *AWSInstanceType) GetVoltVpcId() string {
	if m != nil {
		return m.VoltVpcId
	}
	return ""
}

func (m *AWSInstanceType) GetPublicSubnetId() string {
	if m != nil {
		return m.PublicSubnetId
	}
	return ""
}

func (m *AWSInstanceType) GetPrivateSubnetId() string {
	if m != nil {
		return m.PrivateSubnetId
	}
	return ""
}

func (m *AWSInstanceType) GetInstanceType() string {
	if m != nil {
		return m.InstanceType
	}
	return ""
}

func (m *AWSInstanceType) GetDiskSize() string {
	if m != nil {
		return m.DiskSize
	}
	return ""
}

func (m *AWSInstanceType) GetAmiId() string {
	if m != nil {
		return m.AmiId
	}
	return ""
}

func (m *AWSInstanceType) GetNodeCount() int32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

func (m *AWSInstanceType) GetEbsVolumeSize() uint32 {
	if m != nil {
		return m.EbsVolumeSize
	}
	return 0
}

func (m *AWSInstanceType) GetEbsVolumeAz() string {
	if m != nil {
		return m.EbsVolumeAz
	}
	return ""
}

// Cloud Subnet
//
// x-displayName: "AWS Subnet"
// Parameters for AWS subnet
type CloudSubnetType struct {
	// New Subnet
	//
	// x-displayName: "New Subnet"
	// Parameters for creating new subnet
	SubnetParam *views.CloudSubnetParamType `protobuf:"bytes,1,opt,name=subnet_param,json=subnetParam,proto3" json:"subnet_param,omitempty"`
	// Existing Subnet
	//
	// x-displayName: "Existing Subnet"
	// Information about existing subnet
	ExistingSubnetId string `protobuf:"bytes,2,opt,name=existing_subnet_id,json=existingSubnetId,proto3" json:"existing_subnet_id,omitempty"`
}

func (m *CloudSubnetType) Reset()      { *m = CloudSubnetType{} }
func (*CloudSubnetType) ProtoMessage() {}
func (*CloudSubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b038ed78730a43b7, []int{1}
}
func (m *CloudSubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudSubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudSubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudSubnetType.Merge(m, src)
}
func (m *CloudSubnetType) XXX_Size() int {
	return m.Size()
}
func (m *CloudSubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudSubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudSubnetType proto.InternalMessageInfo

func (m *CloudSubnetType) GetSubnetParam() *views.CloudSubnetParamType {
	if m != nil {
		return m.SubnetParam
	}
	return nil
}

func (m *CloudSubnetType) GetExistingSubnetId() string {
	if m != nil {
		return m.ExistingSubnetId
	}
	return ""
}

// Terraform subnets Parameters
//
// x-displayName: "Terraform Subnet Parameters"
// Specifies subnet to be used or created in the cloud
type SubnetType struct {
	// F5XC Subnet Id
	//
	// x-displayName: "F5XC Subnet ID"
	// F5XC subnet ID will be used to refer to this subnet in other TF parameters
	VoltSubnetId string `protobuf:"bytes,1,opt,name=volt_subnet_id,json=voltSubnetId,proto3" json:"volt_subnet_id,omitempty"`
	// F5XC VPC id
	//
	// x-displayName: "F5XC VPC id"
	// VPC in which Cloud Instance is launched
	VoltVpcId string `protobuf:"bytes,2,opt,name=volt_vpc_id,json=voltVpcId,proto3" json:"volt_vpc_id,omitempty"`
	// Cloud AZ
	//
	// x-displayName: "Cloud Az"
	// Cloud AZ in which to create this subnet
	Az string `protobuf:"bytes,3,opt,name=az,proto3" json:"az,omitempty"`
	// Subnet Parameters
	//
	// x-displayName: "Subnet Parameters"
	// Subnet parameters for existing subnet or new subnet
	Subnet *CloudSubnetType `protobuf:"bytes,4,opt,name=subnet,proto3" json:"subnet,omitempty"`
	// Interface Type
	//
	// x-displayName: "Interface Type"
	// Interface Type
	InterfaceType InterfaceType `protobuf:"varint,5,opt,name=interface_type,json=interfaceType,proto3,enum=ves.io.schema.views.terraform_parameters.InterfaceType" json:"interface_type,omitempty"`
}

func (m *SubnetType) Reset()      { *m = SubnetType{} }
func (*SubnetType) ProtoMessage() {}
func (*SubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b038ed78730a43b7, []int{2}
}
func (m *SubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetType.Merge(m, src)
}
func (m *SubnetType) XXX_Size() int {
	return m.Size()
}
func (m *SubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetType proto.InternalMessageInfo

func (m *SubnetType) GetVoltSubnetId() string {
	if m != nil {
		return m.VoltSubnetId
	}
	return ""
}

func (m *SubnetType) GetVoltVpcId() string {
	if m != nil {
		return m.VoltVpcId
	}
	return ""
}

func (m *SubnetType) GetAz() string {
	if m != nil {
		return m.Az
	}
	return ""
}

func (m *SubnetType) GetSubnet() *CloudSubnetType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *SubnetType) GetInterfaceType() InterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return INTERFACE_INSIDE
}

// AWS VPC Information
//
// x-displayName: "AWS VPC Information"
// This defines AWS VPC for a view
type AWSVPCInfoType struct {
	// New VPC
	//
	// x-displayName: "New VPC Parameters"
	// Parameters for creating new VPC
	NewVpc *views.AWSVPCParamsType `protobuf:"bytes,1,opt,name=new_vpc,json=newVpc,proto3" json:"new_vpc,omitempty"`
	// Existing VPC
	//
	// x-displayName: "Existing VPC"
	// Information about existing VPC
	VpcId string `protobuf:"bytes,2,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
}

func (m *AWSVPCInfoType) Reset()      { *m = AWSVPCInfoType{} }
func (*AWSVPCInfoType) ProtoMessage() {}
func (*AWSVPCInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b038ed78730a43b7, []int{3}
}
func (m *AWSVPCInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCInfoType.Merge(m, src)
}
func (m *AWSVPCInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCInfoType proto.InternalMessageInfo

func (m *AWSVPCInfoType) GetNewVpc() *views.AWSVPCParamsType {
	if m != nil {
		return m.NewVpc
	}
	return nil
}

func (m *AWSVPCInfoType) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

// AWS TGW Information
//
// x-displayName: "AWS TGW Information"
// This defines AWS TGW for a view
type AWSTGWInfoType struct {
	// New TGW
	//
	// x-displayName: "New TGW"
	// Create new TGW
	NewTgw bool `protobuf:"varint,1,opt,name=new_tgw,json=newTgw,proto3" json:"new_tgw,omitempty"`
	// Existing TGW
	//
	// x-displayName: "Existing TGW"
	// Information about existing TGW
	TgwId string `protobuf:"bytes,2,opt,name=tgw_id,json=tgwId,proto3" json:"tgw_id,omitempty"`
	// TGW ASN
	//
	// x-displayName: "TGW ASN"
	// x-example: "64500"
	// TGW ASN.
	TgwAsn uint32 `protobuf:"varint,3,opt,name=tgw_asn,json=tgwAsn,proto3" json:"tgw_asn,omitempty"`
	// F5XC Site ASN
	//
	// x-displayName: "F5XC Site ASN"
	// x-example: "64500"
	// F5XC Site ASN.
	VolterraSiteAsn uint32 `protobuf:"varint,4,opt,name=volterra_site_asn,json=volterraSiteAsn,proto3" json:"volterra_site_asn,omitempty"`
}

func (m *AWSTGWInfoType) Reset()      { *m = AWSTGWInfoType{} }
func (*AWSTGWInfoType) ProtoMessage() {}
func (*AWSTGWInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b038ed78730a43b7, []int{4}
}
func (m *AWSTGWInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSTGWInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSTGWInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSTGWInfoType.Merge(m, src)
}
func (m *AWSTGWInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AWSTGWInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSTGWInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSTGWInfoType proto.InternalMessageInfo

func (m *AWSTGWInfoType) GetNewTgw() bool {
	if m != nil {
		return m.NewTgw
	}
	return false
}

func (m *AWSTGWInfoType) GetTgwId() string {
	if m != nil {
		return m.TgwId
	}
	return ""
}

func (m *AWSTGWInfoType) GetTgwAsn() uint32 {
	if m != nil {
		return m.TgwAsn
	}
	return 0
}

func (m *AWSTGWInfoType) GetVolterraSiteAsn() uint32 {
	if m != nil {
		return m.VolterraSiteAsn
	}
	return 0
}

// Terraform AWS VPC Site Parameters
//
// x-displayName: "Terraform Object Parameters"
// Terraform parameters to create site in AWS.
type AWSVPCType struct {
	// Site Name
	//
	// x-displayName: "Site Name"
	// Name of the site object to be created
	SiteName string `protobuf:"bytes,10,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
	// AWS Unique Name
	//
	// x-displayName: "AWS Unique Name"
	// AWS unique name which will be used to create the cloud resource objects on aws"
	AwsName string `protobuf:"bytes,15,opt,name=aws_name,json=awsName,proto3" json:"aws_name,omitempty"`
	// F5XC VPC Id
	//
	// x-displayName: "F5XC VPC ID"
	// F5XC vpc ID will be used to refer to this vpc in other TF parameters
	VoltVpcId string `protobuf:"bytes,1,opt,name=volt_vpc_id,json=voltVpcId,proto3" json:"volt_vpc_id,omitempty"`
	// Certified Hardware
	//
	// x-displayName: "Certified Hardware"
	// Certified Hardware to be used to create this site.
	CertifiedHw string `protobuf:"bytes,3,opt,name=certified_hw,json=certifiedHw,proto3" json:"certified_hw,omitempty"`
	// VPC
	//
	// x-displayName: "VPC"
	// VPC parameters to instantiate this site
	Vpc *AWSVPCInfoType `protobuf:"bytes,4,opt,name=vpc,proto3" json:"vpc,omitempty"`
	// List of Subnets
	//
	// x-displayName: "List of Subnets"
	// List of Subnets that TF script needs
	Subnets []*SubnetType `protobuf:"bytes,5,rep,name=subnets,proto3" json:"subnets,omitempty"`
	// List of Master Nodes
	//
	// x-displayName: "List of Master Nodes"
	// List of Master Nodes in this Site that TF script needs to instantiate
	MasterNodes []*AWSInstanceType `protobuf:"bytes,6,rep,name=master_nodes,json=masterNodes,proto3" json:"master_nodes,omitempty"`
	// List of Inside VIP Port Config
	//
	// x-displayName: "List of Inside VIP Port Config"
	// List of Ports which will be used to create cloud loadbalancer listener
	InsideVipPortConfig []*VIPPortConfig `protobuf:"bytes,16,rep,name=inside_vip_port_config,json=insideVipPortConfig,proto3" json:"inside_vip_port_config,omitempty"`
	// List of Outside VIP Port Config
	//
	// x-displayName: "List of Outside VIP Port Config"
	// List of Ports which will be used to create cloud loadbalancer listener
	OutsideVipPortConfig []*VIPPortConfig `protobuf:"bytes,17,rep,name=outside_vip_port_config,json=outsideVipPortConfig,proto3" json:"outside_vip_port_config,omitempty"`
	// Worker Node Scaling
	//
	// x-displayName: "Worker Node Scaling"
	// Number of Maximum Worker Nodes for Auto Scale Configuration
	WorkerNodes uint32 `protobuf:"varint,14,opt,name=worker_nodes,json=workerNodes,proto3" json:"worker_nodes,omitempty"`
	// Gateway Type
	//
	// x-displayName: "Gateway Type"
	// Gateway Type
	GatewayType CloudGatewayType `protobuf:"varint,11,opt,name=gateway_type,json=gatewayType,proto3,enum=ves.io.schema.views.terraform_parameters.CloudGatewayType" json:"gateway_type,omitempty"`
	// AWS Region
	//
	// x-displayName: "AWS Region"
	// AWS region
	AwsRegion string `protobuf:"bytes,9,opt,name=aws_region,json=awsRegion,proto3" json:"aws_region,omitempty"`
	// Public SSH key
	//
	// x-displayName: "Public SSH key"
	// Public SSH key for accessing the site.
	SshKey string `protobuf:"bytes,13,opt,name=ssh_key,json=sshKey,proto3" json:"ssh_key,omitempty"`
	// AWS Tags
	//
	// x-displayName: "AWS Tags"
	// AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources.
	Tags map[string]string `protobuf:"bytes,20,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// AWS Direct Connect Parameters
	// x-displayName: "AWS Direct Connect Parameters"
	// AWS Direct Connect Parameters
	DxConnect *DirectConnectType `protobuf:"bytes,21,opt,name=dx_connect,json=dxConnect,proto3" json:"dx_connect,omitempty"`
	// Enable Multi Node in AZ
	//
	// x-displayName: "Enable Multi Node in AZ"
	// Flag is enabled when multiple nodes are configured in single or two Availability Zones
	MultiNodeNonStdAz bool `protobuf:"varint,22,opt,name=multi_node_non_std_az,json=multiNodeNonStdAz,proto3" json:"multi_node_non_std_az,omitempty"`
	// Enable Internet VIP
	//
	// x-displayName: "Enable Internet VIP"
	// Flag is enabled when internet nlb is required for deploying PAN NFV
	InternetVip bool `protobuf:"varint,23,opt,name=internet_vip,json=internetVip,proto3" json:"internet_vip,omitempty"`
}

func (m *AWSVPCType) Reset()      { *m = AWSVPCType{} }
func (*AWSVPCType) ProtoMessage() {}
func (*AWSVPCType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b038ed78730a43b7, []int{5}
}
func (m *AWSVPCType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCType.Merge(m, src)
}
func (m *AWSVPCType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCType proto.InternalMessageInfo

func (m *AWSVPCType) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

func (m *AWSVPCType) GetAwsName() string {
	if m != nil {
		return m.AwsName
	}
	return ""
}

func (m *AWSVPCType) GetVoltVpcId() string {
	if m != nil {
		return m.VoltVpcId
	}
	return ""
}

func (m *AWSVPCType) GetCertifiedHw() string {
	if m != nil {
		return m.CertifiedHw
	}
	return ""
}

func (m *AWSVPCType) GetVpc() *AWSVPCInfoType {
	if m != nil {
		return m.Vpc
	}
	return nil
}

func (m *AWSVPCType) GetSubnets() []*SubnetType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *AWSVPCType) GetMasterNodes() []*AWSInstanceType {
	if m != nil {
		return m.MasterNodes
	}
	return nil
}

func (m *AWSVPCType) GetInsideVipPortConfig() []*VIPPortConfig {
	if m != nil {
		return m.InsideVipPortConfig
	}
	return nil
}

func (m *AWSVPCType) GetOutsideVipPortConfig() []*VIPPortConfig {
	if m != nil {
		return m.OutsideVipPortConfig
	}
	return nil
}

func (m *AWSVPCType) GetWorkerNodes() uint32 {
	if m != nil {
		return m.WorkerNodes
	}
	return 0
}

func (m *AWSVPCType) GetGatewayType() CloudGatewayType {
	if m != nil {
		return m.GatewayType
	}
	return INGRESS_GATEWAY
}

func (m *AWSVPCType) GetAwsRegion() string {
	if m != nil {
		return m.AwsRegion
	}
	return ""
}

func (m *AWSVPCType) GetSshKey() string {
	if m != nil {
		return m.SshKey
	}
	return ""
}

func (m *AWSVPCType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AWSVPCType) GetDxConnect() *DirectConnectType {
	if m != nil {
		return m.DxConnect
	}
	return nil
}

func (m *AWSVPCType) GetMultiNodeNonStdAz() bool {
	if m != nil {
		return m.MultiNodeNonStdAz
	}
	return false
}

func (m *AWSVPCType) GetInternetVip() bool {
	if m != nil {
		return m.InternetVip
	}
	return false
}

// AWSTGWTunnelInfoType
//
// x-displayName: "AWSTGWTunnelInfoType"
// AWS TGW tunnel infromation
type AWSTGWTunnelInfoType struct {
	// Node Name
	//
	// x-displayName: "Node Name"
	// x-example: "master-0"
	// Node Name
	NodeName string `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	// Tunnel 1 Inside Prefix
	//
	// x-displayName: "Tunnel 1 inside prefix"
	// x-example: "169.192.128.0/24"
	// Tunnel 1 Inside Prefix
	Tunnel1InsidePrefix string `protobuf:"bytes,2,opt,name=tunnel1_inside_prefix,json=tunnel1InsidePrefix,proto3" json:"tunnel1_inside_prefix,omitempty"`
	// Tunnel 2 Inside Prefix
	//
	// x-displayName: "Tunnel 2 inside prefix"
	// x-example: "169.192.129.0/24"
	// Tunnel 2 Inside Prefix
	Tunnel2InsidePrefix string `protobuf:"bytes,3,opt,name=tunnel2_inside_prefix,json=tunnel2InsidePrefix,proto3" json:"tunnel2_inside_prefix,omitempty"`
	// Tunnel 1 Pre Shared Key
	//
	// x-displayName: "Tunnel1 Pre Shared Key"
	// Tunnel 1 Pre Shared Key
	Tunnel1Psk *schema.SecretType `protobuf:"bytes,4,opt,name=tunnel1_psk,json=tunnel1Psk,proto3" json:"tunnel1_psk,omitempty"`
	// Tunnel 2 Pre Shared Key
	//
	// x-displayName: "Tunnel 2 Pre Shared Key"
	// Tunnel 2 Pre Shared Key
	Tunnel2Psk *schema.SecretType `protobuf:"bytes,5,opt,name=tunnel2_psk,json=tunnel2Psk,proto3" json:"tunnel2_psk,omitempty"`
}

func (m *AWSTGWTunnelInfoType) Reset()      { *m = AWSTGWTunnelInfoType{} }
func (*AWSTGWTunnelInfoType) ProtoMessage() {}
func (*AWSTGWTunnelInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b038ed78730a43b7, []int{6}
}
func (m *AWSTGWTunnelInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSTGWTunnelInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSTGWTunnelInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSTGWTunnelInfoType.Merge(m, src)
}
func (m *AWSTGWTunnelInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AWSTGWTunnelInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSTGWTunnelInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSTGWTunnelInfoType proto.InternalMessageInfo

func (m *AWSTGWTunnelInfoType) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *AWSTGWTunnelInfoType) GetTunnel1InsidePrefix() string {
	if m != nil {
		return m.Tunnel1InsidePrefix
	}
	return ""
}

func (m *AWSTGWTunnelInfoType) GetTunnel2InsidePrefix() string {
	if m != nil {
		return m.Tunnel2InsidePrefix
	}
	return ""
}

func (m *AWSTGWTunnelInfoType) GetTunnel1Psk() *schema.SecretType {
	if m != nil {
		return m.Tunnel1Psk
	}
	return nil
}

func (m *AWSTGWTunnelInfoType) GetTunnel2Psk() *schema.SecretType {
	if m != nil {
		return m.Tunnel2Psk
	}
	return nil
}

// Terraform AWS TGW Site Parameters
//
// x-displayName: "Terraform Object Parameters for AWS TGW"
// Terraform parameters to create transit gateway in AWS.
type AWSTGWType struct {
	// Site Name
	//
	// x-displayName: "Site Name"
	// Name of the site object to be created
	SiteName string `protobuf:"bytes,1,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
	// AWS Unique Name
	//
	// x-displayName: "AWS Unique Name"
	// AWS unique name which will be used to create the cloud resource objects on aws"
	AwsName string `protobuf:"bytes,15,opt,name=aws_name,json=awsName,proto3" json:"aws_name,omitempty"`
	// F5XC VPC Id
	//
	// x-displayName: "F5XC VPC ID"
	// F5XC vpc ID will be used to refer to this vpc in other TF parameters
	VoltVpcId string `protobuf:"bytes,2,opt,name=volt_vpc_id,json=voltVpcId,proto3" json:"volt_vpc_id,omitempty"`
	// Fleet Label
	//
	// x-displayName: "Fleet Label"
	// Fleet Label to identify Fleet for this site. Fleet Label is assigned to site at registration approval
	FleetLabel string `protobuf:"bytes,3,opt,name=fleet_label,json=fleetLabel,proto3" json:"fleet_label,omitempty"`
	// Certified Hardware
	//
	// x-displayName: "Certified Hardware"
	// Certified Hardware to be used to create this site.
	CertifiedHw string `protobuf:"bytes,4,opt,name=certified_hw,json=certifiedHw,proto3" json:"certified_hw,omitempty"`
	// TGW
	//
	// x-displayName: "TGW"
	// TGW parameters to instantiate this site
	Tgw *AWSTGWInfoType `protobuf:"bytes,5,opt,name=tgw,proto3" json:"tgw,omitempty"`
	// VPC
	//
	// x-displayName: "VPC"
	// VPC parameters to instantiate this site
	Vpc *AWSVPCInfoType `protobuf:"bytes,6,opt,name=vpc,proto3" json:"vpc,omitempty"`
	// List of Subnets
	//
	// x-displayName: "List of Subnets"
	// List of Subnets that TF script needs
	Subnets []*SubnetType `protobuf:"bytes,7,rep,name=subnets,proto3" json:"subnets,omitempty"`
	// List of Master Nodes
	//
	// x-displayName: "List of Master Nodes"
	// List of Master Nodes in this Site that TF script needs to instantiate
	MasterNodes []*AWSInstanceType `protobuf:"bytes,8,rep,name=master_nodes,json=masterNodes,proto3" json:"master_nodes,omitempty"`
	// Worker Node Scaling
	//
	// x-displayName: "Worker Node Scaling"
	// Number of Maximum Worker Nodes for Auto Scale Configuration
	WorkerNodes uint32 `protobuf:"varint,9,opt,name=worker_nodes,json=workerNodes,proto3" json:"worker_nodes,omitempty"`
	// AWS Region
	//
	// x-displayName: "AWS Region"
	// AWS region
	AwsRegion string `protobuf:"bytes,10,opt,name=aws_region,json=awsRegion,proto3" json:"aws_region,omitempty"`
	// Public SSH key
	//
	// x-displayName: "Public SSH key"
	// Public SSH key for accessing the site.
	SshKey string `protobuf:"bytes,11,opt,name=ssh_key,json=sshKey,proto3" json:"ssh_key,omitempty"`
	// VPC Attachments
	//
	// x-displayName: "VPC Attachments"
	// VPC Attachemnts
	VpcIds []string `protobuf:"bytes,12,rep,name=vpc_ids,json=vpcIds,proto3" json:"vpc_ids,omitempty"`
	// Hub Tunnel information
	// x-displayName: "Hub Tunnel Information"
	// Hub Tunnel information
	TunnelInformation []*AWSTGWTunnelInfoType `protobuf:"bytes,13,rep,name=tunnel_information,json=tunnelInformation,proto3" json:"tunnel_information,omitempty"`
	// Services Tunnel information
	// x-displayName: "Services Tunnel Information"
	// Services Tunnel information
	SvcsTunnelInformation []*AWSTGWTunnelInfoType `protobuf:"bytes,14,rep,name=svcs_tunnel_information,json=svcsTunnelInformation,proto3" json:"svcs_tunnel_information,omitempty"`
	// List of Inside VIP Port Config
	//
	// x-displayName: "List of Inside VIP Port Config"
	// List of Ports which will be used to create cloud loadbalancer listener
	InsideVipPortConfig []*VIPPortConfig `protobuf:"bytes,16,rep,name=inside_vip_port_config,json=insideVipPortConfig,proto3" json:"inside_vip_port_config,omitempty"`
	// List of Outside VIP Port Config
	//
	// x-displayName: "List of Outside VIP Port Config"
	// List of Ports which will be used to create cloud loadbalancer listener
	OutsideVipPortConfig []*VIPPortConfig `protobuf:"bytes,17,rep,name=outside_vip_port_config,json=outsideVipPortConfig,proto3" json:"outside_vip_port_config,omitempty"`
	// AWS Tags
	//
	// x-displayName: "AWS Tags"
	// AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources.
	Tags map[string]string `protobuf:"bytes,20,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// AWS Direct Connect Parameters
	// x-displayName: "AWS Direct Connect Parameters"
	// AWS Direct Connect Parameters
	DxConnect *DirectConnectType `protobuf:"bytes,21,opt,name=dx_connect,json=dxConnect,proto3" json:"dx_connect,omitempty"`
	// Enable Multi Node in AZ
	//
	// x-displayName: "Enable Multi Node in AZ"
	// Flag is enabled when multiple nodes are configured in single or two Availability Zones
	MultiNodeNonStdAz bool `protobuf:"varint,22,opt,name=multi_node_non_std_az,json=multiNodeNonStdAz,proto3" json:"multi_node_non_std_az,omitempty"`
	// Enable Internet VIP
	//
	// x-displayName: "Enable Internet VIP"
	// Flag is enabled when internet nlb is required for deploying PAN NFV
	InternetVip bool `protobuf:"varint,23,opt,name=internet_vip,json=internetVip,proto3" json:"internet_vip,omitempty"`
}

func (m *AWSTGWType) Reset()      { *m = AWSTGWType{} }
func (*AWSTGWType) ProtoMessage() {}
func (*AWSTGWType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b038ed78730a43b7, []int{7}
}
func (m *AWSTGWType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSTGWType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSTGWType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSTGWType.Merge(m, src)
}
func (m *AWSTGWType) XXX_Size() int {
	return m.Size()
}
func (m *AWSTGWType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSTGWType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSTGWType proto.InternalMessageInfo

func (m *AWSTGWType) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

func (m *AWSTGWType) GetAwsName() string {
	if m != nil {
		return m.AwsName
	}
	return ""
}

func (m *AWSTGWType) GetVoltVpcId() string {
	if m != nil {
		return m.VoltVpcId
	}
	return ""
}

func (m *AWSTGWType) GetFleetLabel() string {
	if m != nil {
		return m.FleetLabel
	}
	return ""
}

func (m *AWSTGWType) GetCertifiedHw() string {
	if m != nil {
		return m.CertifiedHw
	}
	return ""
}

func (m *AWSTGWType) GetTgw() *AWSTGWInfoType {
	if m != nil {
		return m.Tgw
	}
	return nil
}

func (m *AWSTGWType) GetVpc() *AWSVPCInfoType {
	if m != nil {
		return m.Vpc
	}
	return nil
}

func (m *AWSTGWType) GetSubnets() []*SubnetType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *AWSTGWType) GetMasterNodes() []*AWSInstanceType {
	if m != nil {
		return m.MasterNodes
	}
	return nil
}

func (m *AWSTGWType) GetWorkerNodes() uint32 {
	if m != nil {
		return m.WorkerNodes
	}
	return 0
}

func (m *AWSTGWType) GetAwsRegion() string {
	if m != nil {
		return m.AwsRegion
	}
	return ""
}

func (m *AWSTGWType) GetSshKey() string {
	if m != nil {
		return m.SshKey
	}
	return ""
}

func (m *AWSTGWType) GetVpcIds() []string {
	if m != nil {
		return m.VpcIds
	}
	return nil
}

func (m *AWSTGWType) GetTunnelInformation() []*AWSTGWTunnelInfoType {
	if m != nil {
		return m.TunnelInformation
	}
	return nil
}

func (m *AWSTGWType) GetSvcsTunnelInformation() []*AWSTGWTunnelInfoType {
	if m != nil {
		return m.SvcsTunnelInformation
	}
	return nil
}

func (m *AWSTGWType) GetInsideVipPortConfig() []*VIPPortConfig {
	if m != nil {
		return m.InsideVipPortConfig
	}
	return nil
}

func (m *AWSTGWType) GetOutsideVipPortConfig() []*VIPPortConfig {
	if m != nil {
		return m.OutsideVipPortConfig
	}
	return nil
}

func (m *AWSTGWType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AWSTGWType) GetDxConnect() *DirectConnectType {
	if m != nil {
		return m.DxConnect
	}
	return nil
}

func (m *AWSTGWType) GetMultiNodeNonStdAz() bool {
	if m != nil {
		return m.MultiNodeNonStdAz
	}
	return false
}

func (m *AWSTGWType) GetInternetVip() bool {
	if m != nil {
		return m.InternetVip
	}
	return false
}

// AWS Direct Connect Parameters
//
// x-displayName: "AWS Direct Connect Parameters"
// Parameters for AWS Direct Connect Parameters
type DirectConnectVifInfo struct {
	VifIds []string `protobuf:"bytes,3,rep,name=vif_ids,json=vifIds,proto3" json:"vif_ids,omitempty"`
	// Virtual Interface Ids Region
	//
	// x-displayName: "Virtual Interface Ids Region"
	// Virtual Interface Ids Region
	VifRegion string `protobuf:"bytes,2,opt,name=vif_region,json=vifRegion,proto3" json:"vif_region,omitempty"`
}

func (m *DirectConnectVifInfo) Reset()      { *m = DirectConnectVifInfo{} }
func (*DirectConnectVifInfo) ProtoMessage() {}
func (*DirectConnectVifInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b038ed78730a43b7, []int{8}
}
func (m *DirectConnectVifInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectConnectVifInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DirectConnectVifInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectConnectVifInfo.Merge(m, src)
}
func (m *DirectConnectVifInfo) XXX_Size() int {
	return m.Size()
}
func (m *DirectConnectVifInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectConnectVifInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DirectConnectVifInfo proto.InternalMessageInfo

func (m *DirectConnectVifInfo) GetVifIds() []string {
	if m != nil {
		return m.VifIds
	}
	return nil
}

func (m *DirectConnectVifInfo) GetVifRegion() string {
	if m != nil {
		return m.VifRegion
	}
	return ""
}

type DirectConnectType struct {
	// Enable Direct Connect Config
	//
	// x-displayName: "Enable Direct Connect Config"
	// Enable Direct Connect Config
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3" json:"enable,omitempty"`
	// Manage Direct Connect Gateway
	//
	// x-displayName: "Manage Direct Connect Gateway"
	// Manage Direct Connect Gateway
	ManageDxGw bool `protobuf:"varint,3,opt,name=manage_dx_gw,json=manageDxGw,proto3" json:"manage_dx_gw,omitempty"`
	// Direct Connect Gateway ASN
	//
	// x-displayName: "Direct Connect Gateway ASN"
	// x-example: "64500"
	// Direct Connect Gateway ASN, only valid if manage_dx_gw is set to true
	DxGwAsn string `protobuf:"bytes,4,opt,name=dx_gw_asn,json=dxGwAsn,proto3" json:"dx_gw_asn,omitempty"`
	// Virtual Interface Ids
	//
	// x-displayName: "Virtual Interface Ids"
	// Virtual Interface Ids
	VifIds []*DirectConnectVifInfo `protobuf:"bytes,5,rep,name=vif_ids,json=vifIds,proto3" json:"vif_ids,omitempty"`
	// Cloud Link Network Name
	//
	// x-displayName: "Cloud Link Network Name"
	// x-example: "cloud-private-ntw"
	// Cloud Link Network Name for private access connectivity to F5XC ADN.
	PrivateNetworkName string `protobuf:"bytes,6,opt,name=private_network_name,json=privateNetworkName,proto3" json:"private_network_name,omitempty"`
	// Cloud Link ADN DNS IP
	//
	// x-displayName: "Cloud Link DNS IP"
	// x-example: "10.0.0.1"
	// Cloud Link ADN DNS IP, which will be used to resolve domains
	AdnDnsIp string `protobuf:"bytes,7,opt,name=adn_dns_ip,json=adnDnsIp,proto3" json:"adn_dns_ip,omitempty"`
}

func (m *DirectConnectType) Reset()      { *m = DirectConnectType{} }
func (*DirectConnectType) ProtoMessage() {}
func (*DirectConnectType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b038ed78730a43b7, []int{9}
}
func (m *DirectConnectType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectConnectType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DirectConnectType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectConnectType.Merge(m, src)
}
func (m *DirectConnectType) XXX_Size() int {
	return m.Size()
}
func (m *DirectConnectType) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectConnectType.DiscardUnknown(m)
}

var xxx_messageInfo_DirectConnectType proto.InternalMessageInfo

func (m *DirectConnectType) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *DirectConnectType) GetManageDxGw() bool {
	if m != nil {
		return m.ManageDxGw
	}
	return false
}

func (m *DirectConnectType) GetDxGwAsn() string {
	if m != nil {
		return m.DxGwAsn
	}
	return ""
}

func (m *DirectConnectType) GetVifIds() []*DirectConnectVifInfo {
	if m != nil {
		return m.VifIds
	}
	return nil
}

func (m *DirectConnectType) GetPrivateNetworkName() string {
	if m != nil {
		return m.PrivateNetworkName
	}
	return ""
}

func (m *DirectConnectType) GetAdnDnsIp() string {
	if m != nil {
		return m.AdnDnsIp
	}
	return ""
}

func init() {
	proto.RegisterType((*AWSInstanceType)(nil), "ves.io.schema.views.terraform_parameters.AWSInstanceType")
	golang_proto.RegisterType((*AWSInstanceType)(nil), "ves.io.schema.views.terraform_parameters.AWSInstanceType")
	proto.RegisterType((*CloudSubnetType)(nil), "ves.io.schema.views.terraform_parameters.CloudSubnetType")
	golang_proto.RegisterType((*CloudSubnetType)(nil), "ves.io.schema.views.terraform_parameters.CloudSubnetType")
	proto.RegisterType((*SubnetType)(nil), "ves.io.schema.views.terraform_parameters.SubnetType")
	golang_proto.RegisterType((*SubnetType)(nil), "ves.io.schema.views.terraform_parameters.SubnetType")
	proto.RegisterType((*AWSVPCInfoType)(nil), "ves.io.schema.views.terraform_parameters.AWSVPCInfoType")
	golang_proto.RegisterType((*AWSVPCInfoType)(nil), "ves.io.schema.views.terraform_parameters.AWSVPCInfoType")
	proto.RegisterType((*AWSTGWInfoType)(nil), "ves.io.schema.views.terraform_parameters.AWSTGWInfoType")
	golang_proto.RegisterType((*AWSTGWInfoType)(nil), "ves.io.schema.views.terraform_parameters.AWSTGWInfoType")
	proto.RegisterType((*AWSVPCType)(nil), "ves.io.schema.views.terraform_parameters.AWSVPCType")
	golang_proto.RegisterType((*AWSVPCType)(nil), "ves.io.schema.views.terraform_parameters.AWSVPCType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.terraform_parameters.AWSVPCType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.terraform_parameters.AWSVPCType.TagsEntry")
	proto.RegisterType((*AWSTGWTunnelInfoType)(nil), "ves.io.schema.views.terraform_parameters.AWSTGWTunnelInfoType")
	golang_proto.RegisterType((*AWSTGWTunnelInfoType)(nil), "ves.io.schema.views.terraform_parameters.AWSTGWTunnelInfoType")
	proto.RegisterType((*AWSTGWType)(nil), "ves.io.schema.views.terraform_parameters.AWSTGWType")
	golang_proto.RegisterType((*AWSTGWType)(nil), "ves.io.schema.views.terraform_parameters.AWSTGWType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.terraform_parameters.AWSTGWType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.terraform_parameters.AWSTGWType.TagsEntry")
	proto.RegisterType((*DirectConnectVifInfo)(nil), "ves.io.schema.views.terraform_parameters.DirectConnectVifInfo")
	golang_proto.RegisterType((*DirectConnectVifInfo)(nil), "ves.io.schema.views.terraform_parameters.DirectConnectVifInfo")
	proto.RegisterType((*DirectConnectType)(nil), "ves.io.schema.views.terraform_parameters.DirectConnectType")
	golang_proto.RegisterType((*DirectConnectType)(nil), "ves.io.schema.views.terraform_parameters.DirectConnectType")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/terraform_parameters/aws_types.proto", fileDescriptor_b038ed78730a43b7)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/terraform_parameters/aws_types.proto", fileDescriptor_b038ed78730a43b7)
}

var fileDescriptor_b038ed78730a43b7 = []byte{
	// 1667 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0xcd, 0x6f, 0x23, 0x49,
	0x15, 0x4f, 0xfb, 0xb3, 0xfb, 0xf9, 0x23, 0x4e, 0x6f, 0xb2, 0xe3, 0xc9, 0xec, 0x36, 0x19, 0xb3,
	0x88, 0x30, 0x62, 0x9c, 0xc5, 0xbb, 0xd2, 0xce, 0x0e, 0xd2, 0x8a, 0x64, 0x06, 0x0d, 0x0e, 0xab,
	0x28, 0x74, 0xa2, 0x8c, 0xb4, 0x82, 0x6d, 0x95, 0xdd, 0xe5, 0x4e, 0x29, 0x76, 0x75, 0xab, 0xab,
	0x6c, 0x27, 0x39, 0xed, 0x3f, 0x80, 0x84, 0x40, 0x88, 0x0b, 0x37, 0x2e, 0xfc, 0x0d, 0x70, 0xd9,
	0x23, 0xc7, 0x39, 0x8e, 0x38, 0x31, 0xc9, 0x05, 0x4e, 0xec, 0x85, 0x33, 0xa8, 0x5e, 0xb5, 0x9d,
	0xb6, 0x63, 0x41, 0x32, 0x3b, 0x5c, 0xe0, 0xe6, 0x7a, 0x9f, 0x55, 0xaf, 0x7e, 0xef, 0xf7, 0x5c,
	0x0d, 0x8f, 0x46, 0x54, 0x34, 0x59, 0xb8, 0x25, 0xba, 0xc7, 0x74, 0x40, 0xb6, 0x46, 0x8c, 0x8e,
	0xc5, 0x96, 0xa4, 0x71, 0x4c, 0x7a, 0x61, 0x3c, 0xf0, 0x22, 0x12, 0x93, 0x01, 0x95, 0x34, 0x16,
	0x5b, 0x64, 0x2c, 0x3c, 0x79, 0x16, 0x51, 0xd1, 0x8c, 0xe2, 0x50, 0x86, 0xf6, 0xa6, 0xf6, 0x6c,
	0x6a, 0xcf, 0x26, 0x7a, 0x36, 0x17, 0x79, 0xae, 0x3f, 0x0c, 0x98, 0x3c, 0x1e, 0x76, 0x9a, 0xdd,
	0x70, 0xb0, 0x15, 0x84, 0x41, 0xb8, 0x85, 0x01, 0x3a, 0xc3, 0x1e, 0xae, 0x70, 0x81, 0xbf, 0x74,
	0xe0, 0xf5, 0x7b, 0xb3, 0x5b, 0x0a, 0x23, 0xc9, 0x42, 0x9e, 0x64, 0x5d, 0xbf, 0x3b, 0xab, 0x4c,
	0x6d, 0x68, 0xfd, 0x9d, 0xb9, 0xa3, 0x90, 0x3e, 0xf3, 0x89, 0xa4, 0x89, 0x76, 0xe3, 0xfa, 0x41,
	0xbd, 0xd9, 0xd0, 0xef, 0x2d, 0x2a, 0x85, 0x60, 0x92, 0xa6, 0x8f, 0xbd, 0xfe, 0xe1, 0x8d, 0x0b,
	0x96, 0xf2, 0x6a, 0xfc, 0x33, 0x03, 0xcb, 0xdb, 0xcf, 0x0f, 0xda, 0x5c, 0x48, 0xc2, 0xbb, 0xf4,
	0xf0, 0x2c, 0xa2, 0xf6, 0x06, 0x94, 0x47, 0x61, 0x5f, 0x7a, 0x3c, 0xf4, 0xa9, 0xc7, 0xfc, 0xba,
	0xb1, 0x61, 0x6c, 0x5a, 0x2e, 0x28, 0xd9, 0x5e, 0xe8, 0xd3, 0xb6, 0x6f, 0x3b, 0x50, 0x42, 0x8b,
	0x51, 0xd4, 0x55, 0x06, 0x59, 0x34, 0xb0, 0x94, 0xe8, 0x28, 0xea, 0xb6, 0x7d, 0x7b, 0x13, 0x6a,
	0xd1, 0xb0, 0xd3, 0x67, 0x5d, 0x4f, 0x0c, 0x3b, 0x9c, 0x4a, 0x65, 0x94, 0x43, 0xa3, 0xaa, 0x96,
	0x1f, 0xa0, 0xb8, 0xed, 0xdb, 0x0f, 0x60, 0x25, 0x8a, 0xd9, 0x88, 0x48, 0x9a, 0x32, 0xcd, 0xa3,
	0xe9, 0x72, 0xa2, 0x98, 0xda, 0x7e, 0x13, 0x2a, 0x2c, 0xd9, 0x27, 0x9e, 0xbc, 0x5e, 0x40, 0xbb,
	0x32, 0x4b, 0x6f, 0xfe, 0x1e, 0x58, 0x3e, 0x13, 0x27, 0x9e, 0x60, 0xe7, 0xb4, 0x5e, 0x44, 0x03,
	0x53, 0x09, 0x0e, 0xd8, 0x39, 0xb5, 0xd7, 0xa0, 0x40, 0x06, 0x4c, 0xa5, 0x30, 0x51, 0x93, 0x27,
	0x03, 0xd6, 0xf6, 0xed, 0x77, 0x01, 0xf0, 0xac, 0xdd, 0x70, 0xc8, 0x65, 0xdd, 0xda, 0x30, 0x36,
	0xf3, 0xae, 0xa5, 0x24, 0x4f, 0x94, 0xc0, 0x6e, 0xc1, 0x32, 0xed, 0x08, 0x6f, 0x14, 0xf6, 0x87,
	0x03, 0xaa, 0x03, 0xc3, 0x86, 0xb1, 0x59, 0xd9, 0x81, 0x3f, 0xfc, 0xed, 0xcb, 0x6c, 0xfe, 0x41,
	0xb6, 0xfe, 0x85, 0xe9, 0x56, 0x68, 0x47, 0x1c, 0xa1, 0x05, 0x66, 0x6a, 0x40, 0x25, 0xe5, 0x43,
	0xce, 0xeb, 0x25, 0x4c, 0x58, 0x9a, 0x5a, 0x6d, 0x9f, 0xef, 0xe6, 0xcc, 0x4c, 0x2d, 0xdb, 0xf8,
	0xb9, 0x01, 0xcb, 0x4f, 0xfa, 0xe1, 0xd0, 0xd7, 0xe7, 0xc4, 0x43, 0x7c, 0x0a, 0xe5, 0xa4, 0x1a,
	0x78, 0x6d, 0x78, 0x03, 0xa5, 0xd6, 0x77, 0x9a, 0x8b, 0x90, 0x9d, 0xf2, 0xdd, 0x57, 0xc6, 0x2a,
	0x80, 0x5b, 0x12, 0x57, 0x02, 0xfb, 0xbb, 0x60, 0xd3, 0x53, 0x26, 0x24, 0xe3, 0x41, 0xaa, 0xc8,
	0x19, 0xdc, 0x50, 0x6d, 0xa2, 0x99, 0x54, 0xb9, 0xf1, 0xeb, 0x0c, 0x40, 0x6a, 0x2b, 0xef, 0x41,
	0x15, 0xaf, 0xfa, 0xca, 0x51, 0xc3, 0x01, 0x21, 0x32, 0xbd, 0x9a, 0x39, 0x40, 0x64, 0xe6, 0x01,
	0x51, 0x85, 0x0c, 0x39, 0x4f, 0x70, 0x92, 0x21, 0xe7, 0xf6, 0x4f, 0xa0, 0xa0, 0x03, 0x22, 0x2c,
	0x4a, 0xad, 0x8f, 0x9b, 0x37, 0x6d, 0xda, 0xe6, 0x5c, 0xad, 0xdc, 0x24, 0x90, 0xfd, 0x39, 0x54,
	0x19, 0x97, 0x34, 0xee, 0x91, 0x09, 0x3c, 0x14, 0x8c, 0xaa, 0xad, 0x8f, 0x6e, 0x1e, 0xba, 0x3d,
	0xf1, 0xc7, 0xc0, 0x15, 0x96, 0x5e, 0x36, 0x02, 0xa8, 0x6e, 0x3f, 0x3f, 0x38, 0xda, 0x7f, 0xd2,
	0xe6, 0xbd, 0x10, 0x4b, 0xf3, 0x09, 0x14, 0x39, 0x1d, 0xab, 0x33, 0x27, 0x17, 0xf4, 0xad, 0x85,
	0xa9, 0xb4, 0x17, 0x5e, 0x85, 0xd0, 0x3b, 0xe6, 0x74, 0x7c, 0x14, 0x75, 0x15, 0x1a, 0x67, 0xea,
	0x95, 0x1f, 0xa9, 0x5a, 0x35, 0x7e, 0x63, 0x60, 0xa6, 0xc3, 0x67, 0xcf, 0xa7, 0x99, 0xee, 0xe8,
	0x4c, 0x32, 0x18, 0x63, 0x26, 0x13, 0x43, 0x1c, 0x06, 0x63, 0x15, 0x42, 0x06, 0xe3, 0x54, 0x08,
	0x19, 0x8c, 0xdb, 0xbe, 0xbd, 0x01, 0x45, 0x25, 0x26, 0x82, 0x63, 0xcd, 0x2b, 0x3b, 0x45, 0x85,
	0xd4, 0xcc, 0x83, 0x25, 0x57, 0x99, 0x6f, 0x0b, 0x6e, 0x7f, 0x00, 0x2b, 0xea, 0x76, 0x54, 0x15,
	0x3c, 0xa4, 0x12, 0x65, 0x9b, 0x9b, 0xb5, 0x5d, 0x9e, 0x58, 0x1c, 0x30, 0x49, 0xb7, 0x05, 0x6f,
	0xfc, 0xdd, 0x04, 0xd0, 0xa7, 0x99, 0xb4, 0x1a, 0xba, 0x72, 0x32, 0xd0, 0x1d, 0x61, 0xb9, 0xa6,
	0x12, 0xec, 0x91, 0x01, 0xb5, 0xef, 0x82, 0xa9, 0x88, 0x19, 0x75, 0xcb, 0xa8, 0x2b, 0x92, 0xb1,
	0x40, 0xd5, 0x1c, 0x58, 0x8c, 0x79, 0xb0, 0xdc, 0x87, 0x72, 0x97, 0xc6, 0x92, 0xf5, 0x18, 0xf5,
	0xbd, 0xe3, 0x71, 0x02, 0x9b, 0xd2, 0x54, 0xf6, 0xa3, 0xb1, 0xbd, 0x0b, 0x59, 0x55, 0x76, 0x0d,
	0x9e, 0x47, 0x37, 0xbf, 0xe1, 0xd9, 0x1b, 0x74, 0x55, 0x10, 0x7b, 0x0f, 0x8a, 0x1a, 0x42, 0xa2,
	0x9e, 0xdf, 0xc8, 0x6e, 0x96, 0x5a, 0x1f, 0xde, 0x3c, 0x5e, 0x0a, 0x87, 0x93, 0x20, 0xf6, 0x4f,
	0xa1, 0x3c, 0x20, 0x42, 0xd2, 0x18, 0x09, 0x54, 0xd4, 0x0b, 0x18, 0xf4, 0xe3, 0x5b, 0x6d, 0x32,
	0xcd, 0xc7, 0x6e, 0x49, 0x87, 0x53, 0xdc, 0x2b, 0xec, 0x3e, 0xbc, 0xcd, 0xb8, 0x60, 0x3e, 0xf5,
	0x46, 0x2c, 0xf2, 0xa2, 0x30, 0x96, 0x5e, 0x37, 0xe4, 0x3d, 0x16, 0xd4, 0x6b, 0x98, 0xe7, 0x16,
	0x70, 0x3f, 0x6a, 0xef, 0xef, 0x87, 0xb1, 0x7c, 0x82, 0xee, 0xee, 0x5b, 0x3a, 0xec, 0x11, 0x8b,
	0xae, 0x84, 0x36, 0x87, 0x3b, 0xe1, 0x50, 0x2e, 0x4c, 0xb7, 0xf2, 0xf5, 0xd2, 0xad, 0x26, 0x71,
	0x67, 0xf3, 0xdd, 0x87, 0xf2, 0x38, 0x8c, 0x4f, 0xa6, 0xb5, 0xab, 0x2a, 0x44, 0xba, 0x25, 0x2d,
	0xd3, 0x05, 0xf8, 0x19, 0x94, 0x03, 0x22, 0xe9, 0x98, 0x9c, 0xe9, 0x2e, 0x2f, 0x61, 0x97, 0x3f,
	0xbe, 0x25, 0x81, 0x3c, 0xd3, 0x21, 0x74, 0x7d, 0x83, 0xab, 0x85, 0x9a, 0x05, 0x0a, 0xb7, 0x31,
	0x0d, 0x58, 0xc8, 0x71, 0x16, 0x58, 0xae, 0x45, 0xc6, 0xc2, 0x45, 0x81, 0xea, 0x44, 0x21, 0x8e,
	0xbd, 0x13, 0x7a, 0x56, 0xaf, 0xa0, 0xae, 0x20, 0xc4, 0xf1, 0x8f, 0xe9, 0x99, 0xed, 0x42, 0x4e,
	0x92, 0x40, 0xd4, 0x57, 0xb1, 0x2c, 0x9f, 0xdc, 0x16, 0x92, 0x2a, 0x77, 0xf3, 0x90, 0x04, 0xe2,
	0x87, 0x5c, 0xc6, 0x67, 0x2e, 0xc6, 0xb2, 0x3f, 0x03, 0xf0, 0x4f, 0x55, 0xbd, 0x39, 0xed, 0xca,
	0xfa, 0x1a, 0x82, 0xfd, 0xfb, 0x37, 0x8f, 0xfc, 0x94, 0xc5, 0xb4, 0xab, 0x2a, 0xab, 0xdc, 0xf1,
	0xa4, 0x96, 0x7f, 0x9a, 0x2c, 0xed, 0xf7, 0x61, 0x6d, 0x30, 0xec, 0x4b, 0xa6, 0xa7, 0x3c, 0x0f,
	0xb9, 0x27, 0xa4, 0xaf, 0x06, 0xd5, 0xdb, 0x48, 0x30, 0x2b, 0xa8, 0x54, 0x15, 0xdf, 0x0b, 0xf9,
	0x81, 0xf4, 0xb7, 0xcf, 0xd5, 0xdd, 0x20, 0x23, 0xaa, 0x31, 0x30, 0x62, 0x51, 0xfd, 0x0e, 0x1a,
	0x96, 0x26, 0xb2, 0x23, 0x16, 0xad, 0x7f, 0x04, 0xd6, 0xf4, 0x0c, 0x76, 0x0d, 0xb2, 0xaa, 0x4c,
	0xba, 0xbd, 0xd5, 0x4f, 0x7b, 0x15, 0xf2, 0x23, 0xd2, 0x1f, 0xd2, 0x29, 0xdf, 0xa9, 0xc5, 0xe3,
	0xcc, 0x23, 0x43, 0x8f, 0xc2, 0xdd, 0x9c, 0x59, 0xac, 0x99, 0xbb, 0x39, 0xd3, 0xac, 0x59, 0xbb,
	0x39, 0xb3, 0x5c, 0xab, 0x34, 0x7e, 0x95, 0x81, 0x55, 0xcd, 0x85, 0x87, 0x43, 0xce, 0x69, 0x7f,
	0xca, 0x88, 0xf7, 0xc0, 0xd2, 0x1b, 0x57, 0xfc, 0xa2, 0x53, 0x98, 0x4a, 0x80, 0x04, 0xd3, 0x82,
	0x35, 0x89, 0xe6, 0xdf, 0xf3, 0x92, 0x5e, 0x89, 0x62, 0xda, 0x63, 0xa7, 0x49, 0xde, 0xb7, 0x12,
	0x65, 0x1b, 0x75, 0xfb, 0xa8, 0xba, 0xf2, 0x69, 0xcd, 0xf9, 0x64, 0xd3, 0x3e, 0xad, 0x19, 0x9f,
	0xc7, 0x50, 0x9a, 0xe4, 0x89, 0xc4, 0x49, 0xc2, 0x46, 0x77, 0xe7, 0x2e, 0xe8, 0x80, 0x76, 0xe3,
	0x84, 0x22, 0x20, 0xb1, 0xde, 0x17, 0x27, 0x57, 0xbe, 0x2d, 0xf4, 0xcd, 0xdf, 0xd0, 0xb7, 0xb5,
	0x2f, 0x4e, 0x1a, 0xff, 0x00, 0xe4, 0x61, 0x55, 0x95, 0x6b, 0x3c, 0x6c, 0xbc, 0x36, 0x0f, 0x5f,
	0x1b, 0xda, 0xdf, 0x80, 0x52, 0xaf, 0x4f, 0xa9, 0xf4, 0xfa, 0xa4, 0x43, 0xfb, 0x49, 0x21, 0x00,
	0x45, 0x9f, 0x2a, 0xc9, 0x35, 0xa2, 0xce, 0x2d, 0x24, 0x6a, 0x35, 0xb5, 0xf2, 0xaf, 0x41, 0xd4,
	0xa9, 0x01, 0xe8, 0xaa, 0x20, 0x13, 0xd2, 0x2f, 0xbc, 0x61, 0xd2, 0x2f, 0xfe, 0x37, 0x48, 0xdf,
	0x7c, 0xa3, 0xa4, 0x3f, 0x4f, 0x8b, 0xd6, 0x75, 0x5a, 0x9c, 0xe5, 0x2d, 0xf8, 0x37, 0xbc, 0x55,
	0x9a, 0xe1, 0xad, 0x6f, 0x43, 0x51, 0xdf, 0xbf, 0xa8, 0x97, 0x37, 0xb2, 0x9b, 0xd6, 0x4e, 0x55,
	0x8d, 0x7f, 0xeb, 0x97, 0x46, 0xa1, 0x91, 0x8b, 0x33, 0xf5, 0x1f, 0xb8, 0x05, 0xfc, 0x57, 0x22,
	0xec, 0x01, 0xd8, 0x1a, 0x82, 0x1e, 0xe3, 0x6a, 0xf3, 0x44, 0x3d, 0x51, 0xea, 0x95, 0xd7, 0xa0,
	0xbb, 0x6b, 0xdd, 0xec, 0xae, 0xc8, 0xe9, 0x3a, 0x09, 0x6c, 0x8f, 0xe0, 0x8e, 0x18, 0x75, 0x85,
	0xb7, 0x20, 0x67, 0xf5, 0x8d, 0xe4, 0x5c, 0x53, 0xe1, 0x0f, 0xaf, 0xe5, 0xfd, 0xdf, 0x9e, 0xaf,
	0x5f, 0x67, 0x4a, 0x25, 0x74, 0xf3, 0xff, 0x3b, 0xa5, 0x1a, 0x3e, 0xac, 0xce, 0xec, 0xf6, 0x88,
	0xf5, 0x14, 0x74, 0xb0, 0x87, 0x58, 0x0f, 0x7b, 0x28, 0xbb, 0xa0, 0x87, 0x5a, 0x6e, 0x61, 0xc4,
	0x7a, 0xaa, 0x87, 0xde, 0x05, 0x50, 0x86, 0x49, 0x93, 0x4e, 0x08, 0x97, 0xf5, 0x74, 0x93, 0xee,
	0xe6, 0x4c, 0xa3, 0x96, 0x69, 0xfc, 0x2e, 0x03, 0x2b, 0xd7, 0x8a, 0x62, 0xdf, 0x87, 0x02, 0xe5,
	0xa4, 0xd3, 0xd7, 0x0c, 0x6f, 0xee, 0x58, 0x7f, 0xfe, 0xa3, 0x91, 0xef, 0x91, 0xbe, 0xa0, 0x6e,
	0xa2, 0x50, 0xef, 0xf6, 0x01, 0xe1, 0x24, 0xa0, 0x9e, 0x7f, 0xea, 0x05, 0xfa, 0x7f, 0xb3, 0xe9,
	0x82, 0x96, 0x3d, 0x3d, 0x7d, 0x36, 0xb6, 0xd7, 0xc1, 0x42, 0xd5, 0xf4, 0xdf, 0xbe, 0xe5, 0x16,
	0xfd, 0xd3, 0x67, 0xf8, 0x22, 0x78, 0x7e, 0x75, 0x88, 0xfc, 0x6d, 0xd1, 0xb1, 0xa8, 0x2a, 0xd3,
	0x43, 0xbf, 0x0f, 0xab, 0x93, 0x27, 0x3e, 0xa7, 0x52, 0x71, 0x96, 0x9e, 0x46, 0xfa, 0xf5, 0x6e,
	0x27, 0xba, 0x3d, 0xad, 0xc2, 0xc1, 0xf4, 0x0e, 0x00, 0xf1, 0xb9, 0xe7, 0x73, 0xe1, 0xb1, 0x68,
	0xf2, 0x88, 0x27, 0x3e, 0x7f, 0xca, 0x45, 0x3b, 0xd2, 0xff, 0x15, 0x76, 0x7e, 0x6b, 0xbc, 0x78,
	0xe5, 0x2c, 0xbd, 0x7c, 0xe5, 0x2c, 0x7d, 0xf5, 0xca, 0x31, 0xbe, 0xb8, 0x70, 0x8c, 0xdf, 0x5f,
	0x38, 0xc6, 0x9f, 0x2e, 0x1c, 0xe3, 0xc5, 0x85, 0x63, 0xbc, 0xbc, 0x70, 0x8c, 0xbf, 0x5c, 0x38,
	0xc6, 0x5f, 0x2f, 0x9c, 0xa5, 0xaf, 0x2e, 0x1c, 0xe3, 0x17, 0x97, 0xce, 0xd2, 0x97, 0x97, 0x8e,
	0xf1, 0xe2, 0xd2, 0x59, 0x7a, 0x79, 0xe9, 0x2c, 0x7d, 0xf6, 0x79, 0x10, 0x46, 0x27, 0x41, 0x73,
	0xf2, 0xc2, 0x69, 0x0e, 0x53, 0xdf, 0x4a, 0x1e, 0x46, 0x71, 0x38, 0x62, 0x3e, 0x8d, 0x1f, 0x4e,
	0xd4, 0x5b, 0x51, 0x27, 0x08, 0xb7, 0xe8, 0xa9, 0x4c, 0x3e, 0xae, 0xfc, 0xc7, 0x6f, 0x2c, 0x9d,
	0x02, 0x7e, 0x5e, 0xf9, 0xe0, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xca, 0x57, 0xd6, 0xfe, 0xc7,
	0x12, 0x00, 0x00,
}

func (this *AWSInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSInstanceType)
	if !ok {
		that2, ok := that.(AWSInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VoltNodeId != that1.VoltNodeId {
		return false
	}
	if this.VoltVpcId != that1.VoltVpcId {
		return false
	}
	if this.PublicSubnetId != that1.PublicSubnetId {
		return false
	}
	if this.PrivateSubnetId != that1.PrivateSubnetId {
		return false
	}
	if this.InstanceType != that1.InstanceType {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	if this.AmiId != that1.AmiId {
		return false
	}
	if this.NodeCount != that1.NodeCount {
		return false
	}
	if this.EbsVolumeSize != that1.EbsVolumeSize {
		return false
	}
	if this.EbsVolumeAz != that1.EbsVolumeAz {
		return false
	}
	return true
}
func (this *CloudSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetType)
	if !ok {
		that2, ok := that.(CloudSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	if this.ExistingSubnetId != that1.ExistingSubnetId {
		return false
	}
	return true
}
func (this *SubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubnetType)
	if !ok {
		that2, ok := that.(SubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VoltSubnetId != that1.VoltSubnetId {
		return false
	}
	if this.VoltVpcId != that1.VoltVpcId {
		return false
	}
	if this.Az != that1.Az {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	return true
}
func (this *AWSVPCInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCInfoType)
	if !ok {
		that2, ok := that.(AWSVPCInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVpc.Equal(that1.NewVpc) {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	return true
}
func (this *AWSTGWInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTGWInfoType)
	if !ok {
		that2, ok := that.(AWSTGWInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NewTgw != that1.NewTgw {
		return false
	}
	if this.TgwId != that1.TgwId {
		return false
	}
	if this.TgwAsn != that1.TgwAsn {
		return false
	}
	if this.VolterraSiteAsn != that1.VolterraSiteAsn {
		return false
	}
	return true
}
func (this *AWSVPCType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCType)
	if !ok {
		that2, ok := that.(AWSVPCType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteName != that1.SiteName {
		return false
	}
	if this.AwsName != that1.AwsName {
		return false
	}
	if this.VoltVpcId != that1.VoltVpcId {
		return false
	}
	if this.CertifiedHw != that1.CertifiedHw {
		return false
	}
	if !this.Vpc.Equal(that1.Vpc) {
		return false
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if len(this.MasterNodes) != len(that1.MasterNodes) {
		return false
	}
	for i := range this.MasterNodes {
		if !this.MasterNodes[i].Equal(that1.MasterNodes[i]) {
			return false
		}
	}
	if len(this.InsideVipPortConfig) != len(that1.InsideVipPortConfig) {
		return false
	}
	for i := range this.InsideVipPortConfig {
		if !this.InsideVipPortConfig[i].Equal(that1.InsideVipPortConfig[i]) {
			return false
		}
	}
	if len(this.OutsideVipPortConfig) != len(that1.OutsideVipPortConfig) {
		return false
	}
	for i := range this.OutsideVipPortConfig {
		if !this.OutsideVipPortConfig[i].Equal(that1.OutsideVipPortConfig[i]) {
			return false
		}
	}
	if this.WorkerNodes != that1.WorkerNodes {
		return false
	}
	if this.GatewayType != that1.GatewayType {
		return false
	}
	if this.AwsRegion != that1.AwsRegion {
		return false
	}
	if this.SshKey != that1.SshKey {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !this.DxConnect.Equal(that1.DxConnect) {
		return false
	}
	if this.MultiNodeNonStdAz != that1.MultiNodeNonStdAz {
		return false
	}
	if this.InternetVip != that1.InternetVip {
		return false
	}
	return true
}
func (this *AWSTGWTunnelInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTGWTunnelInfoType)
	if !ok {
		that2, ok := that.(AWSTGWTunnelInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeName != that1.NodeName {
		return false
	}
	if this.Tunnel1InsidePrefix != that1.Tunnel1InsidePrefix {
		return false
	}
	if this.Tunnel2InsidePrefix != that1.Tunnel2InsidePrefix {
		return false
	}
	if !this.Tunnel1Psk.Equal(that1.Tunnel1Psk) {
		return false
	}
	if !this.Tunnel2Psk.Equal(that1.Tunnel2Psk) {
		return false
	}
	return true
}
func (this *AWSTGWType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTGWType)
	if !ok {
		that2, ok := that.(AWSTGWType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteName != that1.SiteName {
		return false
	}
	if this.AwsName != that1.AwsName {
		return false
	}
	if this.VoltVpcId != that1.VoltVpcId {
		return false
	}
	if this.FleetLabel != that1.FleetLabel {
		return false
	}
	if this.CertifiedHw != that1.CertifiedHw {
		return false
	}
	if !this.Tgw.Equal(that1.Tgw) {
		return false
	}
	if !this.Vpc.Equal(that1.Vpc) {
		return false
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if len(this.MasterNodes) != len(that1.MasterNodes) {
		return false
	}
	for i := range this.MasterNodes {
		if !this.MasterNodes[i].Equal(that1.MasterNodes[i]) {
			return false
		}
	}
	if this.WorkerNodes != that1.WorkerNodes {
		return false
	}
	if this.AwsRegion != that1.AwsRegion {
		return false
	}
	if this.SshKey != that1.SshKey {
		return false
	}
	if len(this.VpcIds) != len(that1.VpcIds) {
		return false
	}
	for i := range this.VpcIds {
		if this.VpcIds[i] != that1.VpcIds[i] {
			return false
		}
	}
	if len(this.TunnelInformation) != len(that1.TunnelInformation) {
		return false
	}
	for i := range this.TunnelInformation {
		if !this.TunnelInformation[i].Equal(that1.TunnelInformation[i]) {
			return false
		}
	}
	if len(this.SvcsTunnelInformation) != len(that1.SvcsTunnelInformation) {
		return false
	}
	for i := range this.SvcsTunnelInformation {
		if !this.SvcsTunnelInformation[i].Equal(that1.SvcsTunnelInformation[i]) {
			return false
		}
	}
	if len(this.InsideVipPortConfig) != len(that1.InsideVipPortConfig) {
		return false
	}
	for i := range this.InsideVipPortConfig {
		if !this.InsideVipPortConfig[i].Equal(that1.InsideVipPortConfig[i]) {
			return false
		}
	}
	if len(this.OutsideVipPortConfig) != len(that1.OutsideVipPortConfig) {
		return false
	}
	for i := range this.OutsideVipPortConfig {
		if !this.OutsideVipPortConfig[i].Equal(that1.OutsideVipPortConfig[i]) {
			return false
		}
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !this.DxConnect.Equal(that1.DxConnect) {
		return false
	}
	if this.MultiNodeNonStdAz != that1.MultiNodeNonStdAz {
		return false
	}
	if this.InternetVip != that1.InternetVip {
		return false
	}
	return true
}
func (this *DirectConnectVifInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectVifInfo)
	if !ok {
		that2, ok := that.(DirectConnectVifInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VifIds) != len(that1.VifIds) {
		return false
	}
	for i := range this.VifIds {
		if this.VifIds[i] != that1.VifIds[i] {
			return false
		}
	}
	if this.VifRegion != that1.VifRegion {
		return false
	}
	return true
}
func (this *DirectConnectType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectType)
	if !ok {
		that2, ok := that.(DirectConnectType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enable != that1.Enable {
		return false
	}
	if this.ManageDxGw != that1.ManageDxGw {
		return false
	}
	if this.DxGwAsn != that1.DxGwAsn {
		return false
	}
	if len(this.VifIds) != len(that1.VifIds) {
		return false
	}
	for i := range this.VifIds {
		if !this.VifIds[i].Equal(that1.VifIds[i]) {
			return false
		}
	}
	if this.PrivateNetworkName != that1.PrivateNetworkName {
		return false
	}
	if this.AdnDnsIp != that1.AdnDnsIp {
		return false
	}
	return true
}
func (this *AWSInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&terraform_parameters.AWSInstanceType{")
	s = append(s, "VoltNodeId: "+fmt.Sprintf("%#v", this.VoltNodeId)+",\n")
	s = append(s, "VoltVpcId: "+fmt.Sprintf("%#v", this.VoltVpcId)+",\n")
	s = append(s, "PublicSubnetId: "+fmt.Sprintf("%#v", this.PublicSubnetId)+",\n")
	s = append(s, "PrivateSubnetId: "+fmt.Sprintf("%#v", this.PrivateSubnetId)+",\n")
	s = append(s, "InstanceType: "+fmt.Sprintf("%#v", this.InstanceType)+",\n")
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "AmiId: "+fmt.Sprintf("%#v", this.AmiId)+",\n")
	s = append(s, "NodeCount: "+fmt.Sprintf("%#v", this.NodeCount)+",\n")
	s = append(s, "EbsVolumeSize: "+fmt.Sprintf("%#v", this.EbsVolumeSize)+",\n")
	s = append(s, "EbsVolumeAz: "+fmt.Sprintf("%#v", this.EbsVolumeAz)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&terraform_parameters.CloudSubnetType{")
	if this.SubnetParam != nil {
		s = append(s, "SubnetParam: "+fmt.Sprintf("%#v", this.SubnetParam)+",\n")
	}
	s = append(s, "ExistingSubnetId: "+fmt.Sprintf("%#v", this.ExistingSubnetId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&terraform_parameters.SubnetType{")
	s = append(s, "VoltSubnetId: "+fmt.Sprintf("%#v", this.VoltSubnetId)+",\n")
	s = append(s, "VoltVpcId: "+fmt.Sprintf("%#v", this.VoltVpcId)+",\n")
	s = append(s, "Az: "+fmt.Sprintf("%#v", this.Az)+",\n")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&terraform_parameters.AWSVPCInfoType{")
	if this.NewVpc != nil {
		s = append(s, "NewVpc: "+fmt.Sprintf("%#v", this.NewVpc)+",\n")
	}
	s = append(s, "VpcId: "+fmt.Sprintf("%#v", this.VpcId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTGWInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&terraform_parameters.AWSTGWInfoType{")
	s = append(s, "NewTgw: "+fmt.Sprintf("%#v", this.NewTgw)+",\n")
	s = append(s, "TgwId: "+fmt.Sprintf("%#v", this.TgwId)+",\n")
	s = append(s, "TgwAsn: "+fmt.Sprintf("%#v", this.TgwAsn)+",\n")
	s = append(s, "VolterraSiteAsn: "+fmt.Sprintf("%#v", this.VolterraSiteAsn)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&terraform_parameters.AWSVPCType{")
	s = append(s, "SiteName: "+fmt.Sprintf("%#v", this.SiteName)+",\n")
	s = append(s, "AwsName: "+fmt.Sprintf("%#v", this.AwsName)+",\n")
	s = append(s, "VoltVpcId: "+fmt.Sprintf("%#v", this.VoltVpcId)+",\n")
	s = append(s, "CertifiedHw: "+fmt.Sprintf("%#v", this.CertifiedHw)+",\n")
	if this.Vpc != nil {
		s = append(s, "Vpc: "+fmt.Sprintf("%#v", this.Vpc)+",\n")
	}
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.MasterNodes != nil {
		s = append(s, "MasterNodes: "+fmt.Sprintf("%#v", this.MasterNodes)+",\n")
	}
	if this.InsideVipPortConfig != nil {
		s = append(s, "InsideVipPortConfig: "+fmt.Sprintf("%#v", this.InsideVipPortConfig)+",\n")
	}
	if this.OutsideVipPortConfig != nil {
		s = append(s, "OutsideVipPortConfig: "+fmt.Sprintf("%#v", this.OutsideVipPortConfig)+",\n")
	}
	s = append(s, "WorkerNodes: "+fmt.Sprintf("%#v", this.WorkerNodes)+",\n")
	s = append(s, "GatewayType: "+fmt.Sprintf("%#v", this.GatewayType)+",\n")
	s = append(s, "AwsRegion: "+fmt.Sprintf("%#v", this.AwsRegion)+",\n")
	s = append(s, "SshKey: "+fmt.Sprintf("%#v", this.SshKey)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.DxConnect != nil {
		s = append(s, "DxConnect: "+fmt.Sprintf("%#v", this.DxConnect)+",\n")
	}
	s = append(s, "MultiNodeNonStdAz: "+fmt.Sprintf("%#v", this.MultiNodeNonStdAz)+",\n")
	s = append(s, "InternetVip: "+fmt.Sprintf("%#v", this.InternetVip)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTGWTunnelInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&terraform_parameters.AWSTGWTunnelInfoType{")
	s = append(s, "NodeName: "+fmt.Sprintf("%#v", this.NodeName)+",\n")
	s = append(s, "Tunnel1InsidePrefix: "+fmt.Sprintf("%#v", this.Tunnel1InsidePrefix)+",\n")
	s = append(s, "Tunnel2InsidePrefix: "+fmt.Sprintf("%#v", this.Tunnel2InsidePrefix)+",\n")
	if this.Tunnel1Psk != nil {
		s = append(s, "Tunnel1Psk: "+fmt.Sprintf("%#v", this.Tunnel1Psk)+",\n")
	}
	if this.Tunnel2Psk != nil {
		s = append(s, "Tunnel2Psk: "+fmt.Sprintf("%#v", this.Tunnel2Psk)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTGWType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 25)
	s = append(s, "&terraform_parameters.AWSTGWType{")
	s = append(s, "SiteName: "+fmt.Sprintf("%#v", this.SiteName)+",\n")
	s = append(s, "AwsName: "+fmt.Sprintf("%#v", this.AwsName)+",\n")
	s = append(s, "VoltVpcId: "+fmt.Sprintf("%#v", this.VoltVpcId)+",\n")
	s = append(s, "FleetLabel: "+fmt.Sprintf("%#v", this.FleetLabel)+",\n")
	s = append(s, "CertifiedHw: "+fmt.Sprintf("%#v", this.CertifiedHw)+",\n")
	if this.Tgw != nil {
		s = append(s, "Tgw: "+fmt.Sprintf("%#v", this.Tgw)+",\n")
	}
	if this.Vpc != nil {
		s = append(s, "Vpc: "+fmt.Sprintf("%#v", this.Vpc)+",\n")
	}
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.MasterNodes != nil {
		s = append(s, "MasterNodes: "+fmt.Sprintf("%#v", this.MasterNodes)+",\n")
	}
	s = append(s, "WorkerNodes: "+fmt.Sprintf("%#v", this.WorkerNodes)+",\n")
	s = append(s, "AwsRegion: "+fmt.Sprintf("%#v", this.AwsRegion)+",\n")
	s = append(s, "SshKey: "+fmt.Sprintf("%#v", this.SshKey)+",\n")
	s = append(s, "VpcIds: "+fmt.Sprintf("%#v", this.VpcIds)+",\n")
	if this.TunnelInformation != nil {
		s = append(s, "TunnelInformation: "+fmt.Sprintf("%#v", this.TunnelInformation)+",\n")
	}
	if this.SvcsTunnelInformation != nil {
		s = append(s, "SvcsTunnelInformation: "+fmt.Sprintf("%#v", this.SvcsTunnelInformation)+",\n")
	}
	if this.InsideVipPortConfig != nil {
		s = append(s, "InsideVipPortConfig: "+fmt.Sprintf("%#v", this.InsideVipPortConfig)+",\n")
	}
	if this.OutsideVipPortConfig != nil {
		s = append(s, "OutsideVipPortConfig: "+fmt.Sprintf("%#v", this.OutsideVipPortConfig)+",\n")
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.DxConnect != nil {
		s = append(s, "DxConnect: "+fmt.Sprintf("%#v", this.DxConnect)+",\n")
	}
	s = append(s, "MultiNodeNonStdAz: "+fmt.Sprintf("%#v", this.MultiNodeNonStdAz)+",\n")
	s = append(s, "InternetVip: "+fmt.Sprintf("%#v", this.InternetVip)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DirectConnectVifInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&terraform_parameters.DirectConnectVifInfo{")
	s = append(s, "VifIds: "+fmt.Sprintf("%#v", this.VifIds)+",\n")
	s = append(s, "VifRegion: "+fmt.Sprintf("%#v", this.VifRegion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DirectConnectType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&terraform_parameters.DirectConnectType{")
	s = append(s, "Enable: "+fmt.Sprintf("%#v", this.Enable)+",\n")
	s = append(s, "ManageDxGw: "+fmt.Sprintf("%#v", this.ManageDxGw)+",\n")
	s = append(s, "DxGwAsn: "+fmt.Sprintf("%#v", this.DxGwAsn)+",\n")
	if this.VifIds != nil {
		s = append(s, "VifIds: "+fmt.Sprintf("%#v", this.VifIds)+",\n")
	}
	s = append(s, "PrivateNetworkName: "+fmt.Sprintf("%#v", this.PrivateNetworkName)+",\n")
	s = append(s, "AdnDnsIp: "+fmt.Sprintf("%#v", this.AdnDnsIp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAwsTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AWSInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSInstanceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSInstanceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EbsVolumeAz) > 0 {
		i -= len(m.EbsVolumeAz)
		copy(dAtA[i:], m.EbsVolumeAz)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.EbsVolumeAz)))
		i--
		dAtA[i] = 0x5a
	}
	if m.EbsVolumeSize != 0 {
		i = encodeVarintAwsTypes(dAtA, i, uint64(m.EbsVolumeSize))
		i--
		dAtA[i] = 0x50
	}
	if m.NodeCount != 0 {
		i = encodeVarintAwsTypes(dAtA, i, uint64(m.NodeCount))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AmiId) > 0 {
		i -= len(m.AmiId)
		copy(dAtA[i:], m.AmiId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.AmiId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DiskSize) > 0 {
		i -= len(m.DiskSize)
		copy(dAtA[i:], m.DiskSize)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.DiskSize)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.InstanceType) > 0 {
		i -= len(m.InstanceType)
		copy(dAtA[i:], m.InstanceType)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.InstanceType)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PrivateSubnetId) > 0 {
		i -= len(m.PrivateSubnetId)
		copy(dAtA[i:], m.PrivateSubnetId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.PrivateSubnetId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicSubnetId) > 0 {
		i -= len(m.PublicSubnetId)
		copy(dAtA[i:], m.PublicSubnetId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.PublicSubnetId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VoltVpcId) > 0 {
		i -= len(m.VoltVpcId)
		copy(dAtA[i:], m.VoltVpcId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VoltVpcId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VoltNodeId) > 0 {
		i -= len(m.VoltNodeId)
		copy(dAtA[i:], m.VoltNodeId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VoltNodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudSubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudSubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExistingSubnetId) > 0 {
		i -= len(m.ExistingSubnetId)
		copy(dAtA[i:], m.ExistingSubnetId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.ExistingSubnetId)))
		i--
		dAtA[i] = 0x12
	}
	if m.SubnetParam != nil {
		{
			size, err := m.SubnetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceType != 0 {
		i = encodeVarintAwsTypes(dAtA, i, uint64(m.InterfaceType))
		i--
		dAtA[i] = 0x28
	}
	if m.Subnet != nil {
		{
			size, err := m.Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Az) > 0 {
		i -= len(m.Az)
		copy(dAtA[i:], m.Az)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.Az)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VoltVpcId) > 0 {
		i -= len(m.VoltVpcId)
		copy(dAtA[i:], m.VoltVpcId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VoltVpcId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VoltSubnetId) > 0 {
		i -= len(m.VoltSubnetId)
		copy(dAtA[i:], m.VoltSubnetId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VoltSubnetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VpcId) > 0 {
		i -= len(m.VpcId)
		copy(dAtA[i:], m.VpcId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VpcId)))
		i--
		dAtA[i] = 0x12
	}
	if m.NewVpc != nil {
		{
			size, err := m.NewVpc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSTGWInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTGWInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSTGWInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VolterraSiteAsn != 0 {
		i = encodeVarintAwsTypes(dAtA, i, uint64(m.VolterraSiteAsn))
		i--
		dAtA[i] = 0x20
	}
	if m.TgwAsn != 0 {
		i = encodeVarintAwsTypes(dAtA, i, uint64(m.TgwAsn))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TgwId) > 0 {
		i -= len(m.TgwId)
		copy(dAtA[i:], m.TgwId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.TgwId)))
		i--
		dAtA[i] = 0x12
	}
	if m.NewTgw {
		i--
		if m.NewTgw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InternetVip {
		i--
		if m.InternetVip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.MultiNodeNonStdAz {
		i--
		if m.MultiNodeNonStdAz {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.DxConnect != nil {
		{
			size, err := m.DxConnect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAwsTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintAwsTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAwsTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.OutsideVipPortConfig) > 0 {
		for iNdEx := len(m.OutsideVipPortConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutsideVipPortConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.InsideVipPortConfig) > 0 {
		for iNdEx := len(m.InsideVipPortConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InsideVipPortConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.AwsName) > 0 {
		i -= len(m.AwsName)
		copy(dAtA[i:], m.AwsName)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.AwsName)))
		i--
		dAtA[i] = 0x7a
	}
	if m.WorkerNodes != 0 {
		i = encodeVarintAwsTypes(dAtA, i, uint64(m.WorkerNodes))
		i--
		dAtA[i] = 0x70
	}
	if len(m.SshKey) > 0 {
		i -= len(m.SshKey)
		copy(dAtA[i:], m.SshKey)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.SshKey)))
		i--
		dAtA[i] = 0x6a
	}
	if m.GatewayType != 0 {
		i = encodeVarintAwsTypes(dAtA, i, uint64(m.GatewayType))
		i--
		dAtA[i] = 0x58
	}
	if len(m.SiteName) > 0 {
		i -= len(m.SiteName)
		copy(dAtA[i:], m.SiteName)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.SiteName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.AwsRegion) > 0 {
		i -= len(m.AwsRegion)
		copy(dAtA[i:], m.AwsRegion)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.AwsRegion)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MasterNodes) > 0 {
		for iNdEx := len(m.MasterNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MasterNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Vpc != nil {
		{
			size, err := m.Vpc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CertifiedHw) > 0 {
		i -= len(m.CertifiedHw)
		copy(dAtA[i:], m.CertifiedHw)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.CertifiedHw)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VoltVpcId) > 0 {
		i -= len(m.VoltVpcId)
		copy(dAtA[i:], m.VoltVpcId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VoltVpcId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSTGWTunnelInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTGWTunnelInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSTGWTunnelInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tunnel2Psk != nil {
		{
			size, err := m.Tunnel2Psk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Tunnel1Psk != nil {
		{
			size, err := m.Tunnel1Psk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tunnel2InsidePrefix) > 0 {
		i -= len(m.Tunnel2InsidePrefix)
		copy(dAtA[i:], m.Tunnel2InsidePrefix)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.Tunnel2InsidePrefix)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tunnel1InsidePrefix) > 0 {
		i -= len(m.Tunnel1InsidePrefix)
		copy(dAtA[i:], m.Tunnel1InsidePrefix)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.Tunnel1InsidePrefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSTGWType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTGWType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSTGWType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InternetVip {
		i--
		if m.InternetVip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.MultiNodeNonStdAz {
		i--
		if m.MultiNodeNonStdAz {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.DxConnect != nil {
		{
			size, err := m.DxConnect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAwsTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintAwsTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAwsTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.OutsideVipPortConfig) > 0 {
		for iNdEx := len(m.OutsideVipPortConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutsideVipPortConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.InsideVipPortConfig) > 0 {
		for iNdEx := len(m.InsideVipPortConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InsideVipPortConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.AwsName) > 0 {
		i -= len(m.AwsName)
		copy(dAtA[i:], m.AwsName)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.AwsName)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.SvcsTunnelInformation) > 0 {
		for iNdEx := len(m.SvcsTunnelInformation) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SvcsTunnelInformation[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.TunnelInformation) > 0 {
		for iNdEx := len(m.TunnelInformation) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TunnelInformation[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.VpcIds) > 0 {
		for iNdEx := len(m.VpcIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VpcIds[iNdEx])
			copy(dAtA[i:], m.VpcIds[iNdEx])
			i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VpcIds[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.SshKey) > 0 {
		i -= len(m.SshKey)
		copy(dAtA[i:], m.SshKey)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.SshKey)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.AwsRegion) > 0 {
		i -= len(m.AwsRegion)
		copy(dAtA[i:], m.AwsRegion)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.AwsRegion)))
		i--
		dAtA[i] = 0x52
	}
	if m.WorkerNodes != 0 {
		i = encodeVarintAwsTypes(dAtA, i, uint64(m.WorkerNodes))
		i--
		dAtA[i] = 0x48
	}
	if len(m.MasterNodes) > 0 {
		for iNdEx := len(m.MasterNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MasterNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Vpc != nil {
		{
			size, err := m.Vpc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Tgw != nil {
		{
			size, err := m.Tgw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CertifiedHw) > 0 {
		i -= len(m.CertifiedHw)
		copy(dAtA[i:], m.CertifiedHw)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.CertifiedHw)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FleetLabel) > 0 {
		i -= len(m.FleetLabel)
		copy(dAtA[i:], m.FleetLabel)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.FleetLabel)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VoltVpcId) > 0 {
		i -= len(m.VoltVpcId)
		copy(dAtA[i:], m.VoltVpcId)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VoltVpcId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SiteName) > 0 {
		i -= len(m.SiteName)
		copy(dAtA[i:], m.SiteName)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.SiteName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DirectConnectVifInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectConnectVifInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectVifInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VifIds) > 0 {
		for iNdEx := len(m.VifIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VifIds[iNdEx])
			copy(dAtA[i:], m.VifIds[iNdEx])
			i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VifIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.VifRegion) > 0 {
		i -= len(m.VifRegion)
		copy(dAtA[i:], m.VifRegion)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VifRegion)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DirectConnectType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectConnectType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AdnDnsIp) > 0 {
		i -= len(m.AdnDnsIp)
		copy(dAtA[i:], m.AdnDnsIp)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.AdnDnsIp)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PrivateNetworkName) > 0 {
		i -= len(m.PrivateNetworkName)
		copy(dAtA[i:], m.PrivateNetworkName)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.PrivateNetworkName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.VifIds) > 0 {
		for iNdEx := len(m.VifIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VifIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DxGwAsn) > 0 {
		i -= len(m.DxGwAsn)
		copy(dAtA[i:], m.DxGwAsn)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.DxGwAsn)))
		i--
		dAtA[i] = 0x22
	}
	if m.ManageDxGw {
		i--
		if m.ManageDxGw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAwsTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovAwsTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AWSInstanceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VoltNodeId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.VoltVpcId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.PublicSubnetId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.PrivateSubnetId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.InstanceType)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.DiskSize)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.AmiId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.NodeCount != 0 {
		n += 1 + sovAwsTypes(uint64(m.NodeCount))
	}
	if m.EbsVolumeSize != 0 {
		n += 1 + sovAwsTypes(uint64(m.EbsVolumeSize))
	}
	l = len(m.EbsVolumeAz)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}

func (m *CloudSubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.ExistingSubnetId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}

func (m *SubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VoltSubnetId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.VoltVpcId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.Az)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.InterfaceType != 0 {
		n += 1 + sovAwsTypes(uint64(m.InterfaceType))
	}
	return n
}

func (m *AWSVPCInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewVpc != nil {
		l = m.NewVpc.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}

func (m *AWSTGWInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewTgw {
		n += 2
	}
	l = len(m.TgwId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.TgwAsn != 0 {
		n += 1 + sovAwsTypes(uint64(m.TgwAsn))
	}
	if m.VolterraSiteAsn != 0 {
		n += 1 + sovAwsTypes(uint64(m.VolterraSiteAsn))
	}
	return n
}

func (m *AWSVPCType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VoltVpcId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.CertifiedHw)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.Vpc != nil {
		l = m.Vpc.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	if len(m.MasterNodes) > 0 {
		for _, e := range m.MasterNodes {
			l = e.Size()
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	l = len(m.AwsRegion)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.SiteName)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.GatewayType != 0 {
		n += 1 + sovAwsTypes(uint64(m.GatewayType))
	}
	l = len(m.SshKey)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.WorkerNodes != 0 {
		n += 1 + sovAwsTypes(uint64(m.WorkerNodes))
	}
	l = len(m.AwsName)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if len(m.InsideVipPortConfig) > 0 {
		for _, e := range m.InsideVipPortConfig {
			l = e.Size()
			n += 2 + l + sovAwsTypes(uint64(l))
		}
	}
	if len(m.OutsideVipPortConfig) > 0 {
		for _, e := range m.OutsideVipPortConfig {
			l = e.Size()
			n += 2 + l + sovAwsTypes(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAwsTypes(uint64(len(k))) + 1 + len(v) + sovAwsTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovAwsTypes(uint64(mapEntrySize))
		}
	}
	if m.DxConnect != nil {
		l = m.DxConnect.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	if m.MultiNodeNonStdAz {
		n += 3
	}
	if m.InternetVip {
		n += 3
	}
	return n
}

func (m *AWSTGWTunnelInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.Tunnel1InsidePrefix)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.Tunnel2InsidePrefix)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.Tunnel1Psk != nil {
		l = m.Tunnel1Psk.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.Tunnel2Psk != nil {
		l = m.Tunnel2Psk.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}

func (m *AWSTGWType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SiteName)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.VoltVpcId)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.FleetLabel)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.CertifiedHw)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.Tgw != nil {
		l = m.Tgw.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.Vpc != nil {
		l = m.Vpc.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	if len(m.MasterNodes) > 0 {
		for _, e := range m.MasterNodes {
			l = e.Size()
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	if m.WorkerNodes != 0 {
		n += 1 + sovAwsTypes(uint64(m.WorkerNodes))
	}
	l = len(m.AwsRegion)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.SshKey)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if len(m.VpcIds) > 0 {
		for _, s := range m.VpcIds {
			l = len(s)
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	if len(m.TunnelInformation) > 0 {
		for _, e := range m.TunnelInformation {
			l = e.Size()
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	if len(m.SvcsTunnelInformation) > 0 {
		for _, e := range m.SvcsTunnelInformation {
			l = e.Size()
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	l = len(m.AwsName)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if len(m.InsideVipPortConfig) > 0 {
		for _, e := range m.InsideVipPortConfig {
			l = e.Size()
			n += 2 + l + sovAwsTypes(uint64(l))
		}
	}
	if len(m.OutsideVipPortConfig) > 0 {
		for _, e := range m.OutsideVipPortConfig {
			l = e.Size()
			n += 2 + l + sovAwsTypes(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAwsTypes(uint64(len(k))) + 1 + len(v) + sovAwsTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovAwsTypes(uint64(mapEntrySize))
		}
	}
	if m.DxConnect != nil {
		l = m.DxConnect.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	if m.MultiNodeNonStdAz {
		n += 3
	}
	if m.InternetVip {
		n += 3
	}
	return n
}

func (m *DirectConnectVifInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VifRegion)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if len(m.VifIds) > 0 {
		for _, s := range m.VifIds {
			l = len(s)
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	return n
}

func (m *DirectConnectType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	if m.ManageDxGw {
		n += 2
	}
	l = len(m.DxGwAsn)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if len(m.VifIds) > 0 {
		for _, e := range m.VifIds {
			l = e.Size()
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	l = len(m.PrivateNetworkName)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.AdnDnsIp)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}

func sovAwsTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAwsTypes(x uint64) (n int) {
	return sovAwsTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSInstanceType{`,
		`VoltNodeId:` + fmt.Sprintf("%v", this.VoltNodeId) + `,`,
		`VoltVpcId:` + fmt.Sprintf("%v", this.VoltVpcId) + `,`,
		`PublicSubnetId:` + fmt.Sprintf("%v", this.PublicSubnetId) + `,`,
		`PrivateSubnetId:` + fmt.Sprintf("%v", this.PrivateSubnetId) + `,`,
		`InstanceType:` + fmt.Sprintf("%v", this.InstanceType) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`AmiId:` + fmt.Sprintf("%v", this.AmiId) + `,`,
		`NodeCount:` + fmt.Sprintf("%v", this.NodeCount) + `,`,
		`EbsVolumeSize:` + fmt.Sprintf("%v", this.EbsVolumeSize) + `,`,
		`EbsVolumeAz:` + fmt.Sprintf("%v", this.EbsVolumeAz) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetType{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "CloudSubnetParamType", "views.CloudSubnetParamType", 1) + `,`,
		`ExistingSubnetId:` + fmt.Sprintf("%v", this.ExistingSubnetId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubnetType{`,
		`VoltSubnetId:` + fmt.Sprintf("%v", this.VoltSubnetId) + `,`,
		`VoltVpcId:` + fmt.Sprintf("%v", this.VoltVpcId) + `,`,
		`Az:` + fmt.Sprintf("%v", this.Az) + `,`,
		`Subnet:` + strings.Replace(this.Subnet.String(), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCInfoType{`,
		`NewVpc:` + strings.Replace(fmt.Sprintf("%v", this.NewVpc), "AWSVPCParamsType", "views.AWSVPCParamsType", 1) + `,`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTGWInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSTGWInfoType{`,
		`NewTgw:` + fmt.Sprintf("%v", this.NewTgw) + `,`,
		`TgwId:` + fmt.Sprintf("%v", this.TgwId) + `,`,
		`TgwAsn:` + fmt.Sprintf("%v", this.TgwAsn) + `,`,
		`VolterraSiteAsn:` + fmt.Sprintf("%v", this.VolterraSiteAsn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnets := "[]*SubnetType{"
	for _, f := range this.Subnets {
		repeatedStringForSubnets += strings.Replace(f.String(), "SubnetType", "SubnetType", 1) + ","
	}
	repeatedStringForSubnets += "}"
	repeatedStringForMasterNodes := "[]*AWSInstanceType{"
	for _, f := range this.MasterNodes {
		repeatedStringForMasterNodes += strings.Replace(f.String(), "AWSInstanceType", "AWSInstanceType", 1) + ","
	}
	repeatedStringForMasterNodes += "}"
	repeatedStringForInsideVipPortConfig := "[]*VIPPortConfig{"
	for _, f := range this.InsideVipPortConfig {
		repeatedStringForInsideVipPortConfig += strings.Replace(fmt.Sprintf("%v", f), "VIPPortConfig", "VIPPortConfig", 1) + ","
	}
	repeatedStringForInsideVipPortConfig += "}"
	repeatedStringForOutsideVipPortConfig := "[]*VIPPortConfig{"
	for _, f := range this.OutsideVipPortConfig {
		repeatedStringForOutsideVipPortConfig += strings.Replace(fmt.Sprintf("%v", f), "VIPPortConfig", "VIPPortConfig", 1) + ","
	}
	repeatedStringForOutsideVipPortConfig += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&AWSVPCType{`,
		`VoltVpcId:` + fmt.Sprintf("%v", this.VoltVpcId) + `,`,
		`CertifiedHw:` + fmt.Sprintf("%v", this.CertifiedHw) + `,`,
		`Vpc:` + strings.Replace(this.Vpc.String(), "AWSVPCInfoType", "AWSVPCInfoType", 1) + `,`,
		`Subnets:` + repeatedStringForSubnets + `,`,
		`MasterNodes:` + repeatedStringForMasterNodes + `,`,
		`AwsRegion:` + fmt.Sprintf("%v", this.AwsRegion) + `,`,
		`SiteName:` + fmt.Sprintf("%v", this.SiteName) + `,`,
		`GatewayType:` + fmt.Sprintf("%v", this.GatewayType) + `,`,
		`SshKey:` + fmt.Sprintf("%v", this.SshKey) + `,`,
		`WorkerNodes:` + fmt.Sprintf("%v", this.WorkerNodes) + `,`,
		`AwsName:` + fmt.Sprintf("%v", this.AwsName) + `,`,
		`InsideVipPortConfig:` + repeatedStringForInsideVipPortConfig + `,`,
		`OutsideVipPortConfig:` + repeatedStringForOutsideVipPortConfig + `,`,
		`Tags:` + mapStringForTags + `,`,
		`DxConnect:` + strings.Replace(this.DxConnect.String(), "DirectConnectType", "DirectConnectType", 1) + `,`,
		`MultiNodeNonStdAz:` + fmt.Sprintf("%v", this.MultiNodeNonStdAz) + `,`,
		`InternetVip:` + fmt.Sprintf("%v", this.InternetVip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTGWTunnelInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSTGWTunnelInfoType{`,
		`NodeName:` + fmt.Sprintf("%v", this.NodeName) + `,`,
		`Tunnel1InsidePrefix:` + fmt.Sprintf("%v", this.Tunnel1InsidePrefix) + `,`,
		`Tunnel2InsidePrefix:` + fmt.Sprintf("%v", this.Tunnel2InsidePrefix) + `,`,
		`Tunnel1Psk:` + strings.Replace(fmt.Sprintf("%v", this.Tunnel1Psk), "SecretType", "schema.SecretType", 1) + `,`,
		`Tunnel2Psk:` + strings.Replace(fmt.Sprintf("%v", this.Tunnel2Psk), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTGWType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnets := "[]*SubnetType{"
	for _, f := range this.Subnets {
		repeatedStringForSubnets += strings.Replace(f.String(), "SubnetType", "SubnetType", 1) + ","
	}
	repeatedStringForSubnets += "}"
	repeatedStringForMasterNodes := "[]*AWSInstanceType{"
	for _, f := range this.MasterNodes {
		repeatedStringForMasterNodes += strings.Replace(f.String(), "AWSInstanceType", "AWSInstanceType", 1) + ","
	}
	repeatedStringForMasterNodes += "}"
	repeatedStringForTunnelInformation := "[]*AWSTGWTunnelInfoType{"
	for _, f := range this.TunnelInformation {
		repeatedStringForTunnelInformation += strings.Replace(f.String(), "AWSTGWTunnelInfoType", "AWSTGWTunnelInfoType", 1) + ","
	}
	repeatedStringForTunnelInformation += "}"
	repeatedStringForSvcsTunnelInformation := "[]*AWSTGWTunnelInfoType{"
	for _, f := range this.SvcsTunnelInformation {
		repeatedStringForSvcsTunnelInformation += strings.Replace(f.String(), "AWSTGWTunnelInfoType", "AWSTGWTunnelInfoType", 1) + ","
	}
	repeatedStringForSvcsTunnelInformation += "}"
	repeatedStringForInsideVipPortConfig := "[]*VIPPortConfig{"
	for _, f := range this.InsideVipPortConfig {
		repeatedStringForInsideVipPortConfig += strings.Replace(fmt.Sprintf("%v", f), "VIPPortConfig", "VIPPortConfig", 1) + ","
	}
	repeatedStringForInsideVipPortConfig += "}"
	repeatedStringForOutsideVipPortConfig := "[]*VIPPortConfig{"
	for _, f := range this.OutsideVipPortConfig {
		repeatedStringForOutsideVipPortConfig += strings.Replace(fmt.Sprintf("%v", f), "VIPPortConfig", "VIPPortConfig", 1) + ","
	}
	repeatedStringForOutsideVipPortConfig += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&AWSTGWType{`,
		`SiteName:` + fmt.Sprintf("%v", this.SiteName) + `,`,
		`VoltVpcId:` + fmt.Sprintf("%v", this.VoltVpcId) + `,`,
		`FleetLabel:` + fmt.Sprintf("%v", this.FleetLabel) + `,`,
		`CertifiedHw:` + fmt.Sprintf("%v", this.CertifiedHw) + `,`,
		`Tgw:` + strings.Replace(this.Tgw.String(), "AWSTGWInfoType", "AWSTGWInfoType", 1) + `,`,
		`Vpc:` + strings.Replace(this.Vpc.String(), "AWSVPCInfoType", "AWSVPCInfoType", 1) + `,`,
		`Subnets:` + repeatedStringForSubnets + `,`,
		`MasterNodes:` + repeatedStringForMasterNodes + `,`,
		`WorkerNodes:` + fmt.Sprintf("%v", this.WorkerNodes) + `,`,
		`AwsRegion:` + fmt.Sprintf("%v", this.AwsRegion) + `,`,
		`SshKey:` + fmt.Sprintf("%v", this.SshKey) + `,`,
		`VpcIds:` + fmt.Sprintf("%v", this.VpcIds) + `,`,
		`TunnelInformation:` + repeatedStringForTunnelInformation + `,`,
		`SvcsTunnelInformation:` + repeatedStringForSvcsTunnelInformation + `,`,
		`AwsName:` + fmt.Sprintf("%v", this.AwsName) + `,`,
		`InsideVipPortConfig:` + repeatedStringForInsideVipPortConfig + `,`,
		`OutsideVipPortConfig:` + repeatedStringForOutsideVipPortConfig + `,`,
		`Tags:` + mapStringForTags + `,`,
		`DxConnect:` + strings.Replace(this.DxConnect.String(), "DirectConnectType", "DirectConnectType", 1) + `,`,
		`MultiNodeNonStdAz:` + fmt.Sprintf("%v", this.MultiNodeNonStdAz) + `,`,
		`InternetVip:` + fmt.Sprintf("%v", this.InternetVip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectVifInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectConnectVifInfo{`,
		`VifRegion:` + fmt.Sprintf("%v", this.VifRegion) + `,`,
		`VifIds:` + fmt.Sprintf("%v", this.VifIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVifIds := "[]*DirectConnectVifInfo{"
	for _, f := range this.VifIds {
		repeatedStringForVifIds += strings.Replace(f.String(), "DirectConnectVifInfo", "DirectConnectVifInfo", 1) + ","
	}
	repeatedStringForVifIds += "}"
	s := strings.Join([]string{`&DirectConnectType{`,
		`Enable:` + fmt.Sprintf("%v", this.Enable) + `,`,
		`ManageDxGw:` + fmt.Sprintf("%v", this.ManageDxGw) + `,`,
		`DxGwAsn:` + fmt.Sprintf("%v", this.DxGwAsn) + `,`,
		`VifIds:` + repeatedStringForVifIds + `,`,
		`PrivateNetworkName:` + fmt.Sprintf("%v", this.PrivateNetworkName) + `,`,
		`AdnDnsIp:` + fmt.Sprintf("%v", this.AdnDnsIp) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAwsTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltNodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltNodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltVpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltVpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmiId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmiId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EbsVolumeSize", wireType)
			}
			m.EbsVolumeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EbsVolumeSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EbsVolumeAz", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EbsVolumeAz = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetParam == nil {
				m.SubnetParam = &views.CloudSubnetParamType{}
			}
			if err := m.SubnetParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExistingSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltVpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltVpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Az", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Az = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &CloudSubnetType{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			m.InterfaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceType |= InterfaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewVpc == nil {
				m.NewVpc = &views.AWSVPCParamsType{}
			}
			if err := m.NewVpc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTGWInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTGWInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTGWInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTgw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewTgw = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TgwId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwAsn", wireType)
			}
			m.TgwAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TgwAsn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSiteAsn", wireType)
			}
			m.VolterraSiteAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSiteAsn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltVpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltVpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertifiedHw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vpc == nil {
				m.Vpc = &AWSVPCInfoType{}
			}
			if err := m.Vpc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &SubnetType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterNodes = append(m.MasterNodes, &AWSInstanceType{})
			if err := m.MasterNodes[len(m.MasterNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayType", wireType)
			}
			m.GatewayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayType |= CloudGatewayType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerNodes", wireType)
			}
			m.WorkerNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerNodes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVipPortConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVipPortConfig = append(m.InsideVipPortConfig, &VIPPortConfig{})
			if err := m.InsideVipPortConfig[len(m.InsideVipPortConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVipPortConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVipPortConfig = append(m.OutsideVipPortConfig, &VIPPortConfig{})
			if err := m.OutsideVipPortConfig[len(m.OutsideVipPortConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAwsTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAwsTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAwsTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAwsTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAwsTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAwsTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAwsTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAwsTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAwsTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DxConnect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DxConnect == nil {
				m.DxConnect = &DirectConnectType{}
			}
			if err := m.DxConnect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiNodeNonStdAz", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiNodeNonStdAz = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternetVip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternetVip = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTGWTunnelInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTGWTunnelInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTGWTunnelInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel1InsidePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tunnel1InsidePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel2InsidePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tunnel2InsidePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel1Psk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tunnel1Psk == nil {
				m.Tunnel1Psk = &schema.SecretType{}
			}
			if err := m.Tunnel1Psk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel2Psk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tunnel2Psk == nil {
				m.Tunnel2Psk = &schema.SecretType{}
			}
			if err := m.Tunnel2Psk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTGWType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTGWType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTGWType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltVpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltVpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FleetLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertifiedHw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tgw == nil {
				m.Tgw = &AWSTGWInfoType{}
			}
			if err := m.Tgw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vpc == nil {
				m.Vpc = &AWSVPCInfoType{}
			}
			if err := m.Vpc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &SubnetType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterNodes = append(m.MasterNodes, &AWSInstanceType{})
			if err := m.MasterNodes[len(m.MasterNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerNodes", wireType)
			}
			m.WorkerNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerNodes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcIds = append(m.VpcIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelInformation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TunnelInformation = append(m.TunnelInformation, &AWSTGWTunnelInfoType{})
			if err := m.TunnelInformation[len(m.TunnelInformation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcsTunnelInformation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SvcsTunnelInformation = append(m.SvcsTunnelInformation, &AWSTGWTunnelInfoType{})
			if err := m.SvcsTunnelInformation[len(m.SvcsTunnelInformation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVipPortConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVipPortConfig = append(m.InsideVipPortConfig, &VIPPortConfig{})
			if err := m.InsideVipPortConfig[len(m.InsideVipPortConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVipPortConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVipPortConfig = append(m.OutsideVipPortConfig, &VIPPortConfig{})
			if err := m.OutsideVipPortConfig[len(m.OutsideVipPortConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAwsTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAwsTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAwsTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAwsTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAwsTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAwsTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAwsTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAwsTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAwsTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DxConnect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DxConnect == nil {
				m.DxConnect = &DirectConnectType{}
			}
			if err := m.DxConnect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiNodeNonStdAz", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiNodeNonStdAz = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternetVip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternetVip = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectConnectVifInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectConnectVifInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectConnectVifInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VifRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VifRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VifIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VifIds = append(m.VifIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectConnectType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectConnectType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectConnectType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManageDxGw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ManageDxGw = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DxGwAsn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DxGwAsn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VifIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VifIds = append(m.VifIds, &DirectConnectVifInfo{})
			if err := m.VifIds[len(m.VifIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateNetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateNetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdnDnsIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdnDnsIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAwsTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAwsTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAwsTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAwsTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAwsTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAwsTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAwsTypes = fmt.Errorf("proto: unexpected end of group")
)
