// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package views

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AdvertiseCustom) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseCustom) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AdvertiseCustom) DeepCopy() *AdvertiseCustom {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseCustom{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseCustom) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseCustom) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseCustomValidator().Validate(ctx, m, opts...)
}

func (m *AdvertiseCustom) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseWhereDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AdvertiseCustom) GetAdvertiseWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseWhere() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetAdvertiseWhere() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseWhere() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("advertise_where[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateAdvertiseCustom struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseCustom) AdvertiseWhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for advertise_where")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*WhereType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := WhereTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for advertise_where")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*WhereType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*WhereType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated advertise_where")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items advertise_where")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertiseCustom) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseCustom)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseCustom got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_where"]; exists {
		vOpts := append(opts, db.WithValidateField("advertise_where"))
		if err := fv(ctx, m.GetAdvertiseWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseCustomValidator = func() *ValidateAdvertiseCustom {
	v := &ValidateAdvertiseCustom{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseWhere := v.AdvertiseWhereValidationRuleHandler
	rulesAdvertiseWhere := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAdvertiseWhere(rulesAdvertiseWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseCustom.advertise_where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_where"] = vFn

	return v
}()

func AdvertiseCustomValidator() db.Validator {
	return DefaultAdvertiseCustomValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertisePublic) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertisePublic) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AdvertisePublic) DeepCopy() *AdvertisePublic {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertisePublic{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertisePublic) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertisePublic) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertisePublicValidator().Validate(ctx, m, opts...)
}

func (m *AdvertisePublic) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPublicIpDRefInfo()

}

func (m *AdvertisePublic) GetPublicIpDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetPublicIp()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("public_ip.Object")
	dri := db.DRefInfo{
		RefdType:   "public_ip.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "public_ip",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetPublicIpDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AdvertisePublic) GetPublicIpDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "public_ip.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: public_ip")
	}

	vref := m.GetPublicIp()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "public_ip.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateAdvertisePublic struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertisePublic) PublicIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for public_ip")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertisePublic) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertisePublic)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertisePublic got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["public_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("public_ip"))
		if err := fv(ctx, m.GetPublicIp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertisePublicValidator = func() *ValidateAdvertisePublic {
	v := &ValidateAdvertisePublic{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPublicIp := v.PublicIpValidationRuleHandler
	rulesPublicIp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPublicIp(rulesPublicIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertisePublic.public_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_ip"] = vFn

	return v
}()

func AdvertisePublicValidator() db.Validator {
	return DefaultAdvertisePublicValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertiseSiteVsite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseSiteVsite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AdvertiseSiteVsite) DeepCopy() *AdvertiseSiteVsite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseSiteVsite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseSiteVsite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseSiteVsite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseSiteVsiteValidator().Validate(ctx, m, opts...)
}

func (m *AdvertiseSiteVsite) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseWhereDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AdvertiseSiteVsite) GetAdvertiseWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseWhere() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetAdvertiseWhere() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseWhere() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("advertise_where[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateAdvertiseSiteVsite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseSiteVsite) AdvertiseWhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for advertise_where")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*WhereTypeSiteVsite, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := WhereTypeSiteVsiteValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for advertise_where")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*WhereTypeSiteVsite)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*WhereTypeSiteVsite, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated advertise_where")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items advertise_where")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertiseSiteVsite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseSiteVsite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseSiteVsite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_where"]; exists {
		vOpts := append(opts, db.WithValidateField("advertise_where"))
		if err := fv(ctx, m.GetAdvertiseWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseSiteVsiteValidator = func() *ValidateAdvertiseSiteVsite {
	v := &ValidateAdvertiseSiteVsite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseWhere := v.AdvertiseWhereValidationRuleHandler
	rulesAdvertiseWhere := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAdvertiseWhere(rulesAdvertiseWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseSiteVsite.advertise_where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_where"] = vFn

	return v
}()

func AdvertiseSiteVsiteValidator() db.Validator {
	return DefaultAdvertiseSiteVsiteValidator
}

// augmented methods on protoc/std generated struct

func (m *CustomCiphers) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomCiphers) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CustomCiphers) DeepCopy() *CustomCiphers {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomCiphers{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomCiphers) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomCiphers) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomCiphersValidator().Validate(ctx, m, opts...)
}

type ValidateCustomCiphers struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomCiphers) CipherSuitesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for cipher_suites")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cipher_suites")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cipher_suites")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cipher_suites")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCustomCiphers) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomCiphers)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomCiphers got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cipher_suites"]; exists {
		vOpts := append(opts, db.WithValidateField("cipher_suites"))
		if err := fv(ctx, m.GetCipherSuites(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_version"]; exists {

		vOpts := append(opts, db.WithValidateField("max_version"))
		if err := fv(ctx, m.GetMaxVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_version"]; exists {

		vOpts := append(opts, db.WithValidateField("min_version"))
		if err := fv(ctx, m.GetMinVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomCiphersValidator = func() *ValidateCustomCiphers {
	v := &ValidateCustomCiphers{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCipherSuites := v.CipherSuitesValidationRuleHandler
	rulesCipherSuites := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.repeated.items.string.in": "[\"TLS_AES_128_GCM_SHA256\",\"TLS_AES_256_GCM_SHA384\",\"TLS_CHACHA20_POLY1305_SHA256\",\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\",\"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\",\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\",\"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\",\"TLS_RSA_WITH_AES_128_CBC_SHA\",\"TLS_RSA_WITH_AES_128_GCM_SHA256\",\"TLS_RSA_WITH_AES_256_CBC_SHA\",\"TLS_RSA_WITH_AES_256_GCM_SHA384\"]",
		"ves.io.schema.rules.repeated.unique":          "true",
	}
	vFn, err = vrhCipherSuites(rulesCipherSuites)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomCiphers.cipher_suites: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cipher_suites"] = vFn

	return v
}()

func CustomCiphersValidator() db.Validator {
	return DefaultCustomCiphersValidator
}

// augmented methods on protoc/std generated struct

func (m *DownstreamTlsParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DownstreamTlsParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *DownstreamTlsParamsType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetTlsCertificates() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting DownstreamTlsParamsType.tls_certificates idx %v", idx)
		}
	}

	return nil
}

func (m *DownstreamTlsParamsType) DeepCopy() *DownstreamTlsParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DownstreamTlsParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DownstreamTlsParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DownstreamTlsParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DownstreamTlsParamsTypeValidator().Validate(ctx, m, opts...)
}

func (m *DownstreamTlsParamsType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetMtlsChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *DownstreamTlsParamsType) GetMtlsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetMtlsChoice() == nil {
		return nil, nil
	}
	switch m.GetMtlsChoice().(type) {
	case *DownstreamTlsParamsType_NoMtls:

		return nil, nil

	case *DownstreamTlsParamsType_UseMtls:
		drInfos, err := m.GetUseMtls().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetUseMtls().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "use_mtls." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateDownstreamTlsParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDownstreamTlsParamsType) MtlsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtls_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDownstreamTlsParamsType) TlsCertificatesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for tls_certificates")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.TlsCertificateType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.TlsCertificateTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tls_certificates")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.TlsCertificateType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.TlsCertificateType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tls_certificates")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tls_certificates")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDownstreamTlsParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DownstreamTlsParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DownstreamTlsParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mtls_choice"]; exists {
		val := m.GetMtlsChoice()
		vOpts := append(opts,
			db.WithValidateField("mtls_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMtlsChoice().(type) {
	case *DownstreamTlsParamsType_NoMtls:
		if fv, exists := v.FldValidators["mtls_choice.no_mtls"]; exists {
			val := m.GetMtlsChoice().(*DownstreamTlsParamsType_NoMtls).NoMtls
			vOpts := append(opts,
				db.WithValidateField("mtls_choice"),
				db.WithValidateField("no_mtls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DownstreamTlsParamsType_UseMtls:
		if fv, exists := v.FldValidators["mtls_choice.use_mtls"]; exists {
			val := m.GetMtlsChoice().(*DownstreamTlsParamsType_UseMtls).UseMtls
			vOpts := append(opts,
				db.WithValidateField("mtls_choice"),
				db.WithValidateField("use_mtls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_certificates"]; exists {
		vOpts := append(opts, db.WithValidateField("tls_certificates"))
		if err := fv(ctx, m.GetTlsCertificates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_config"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_config"))
		if err := fv(ctx, m.GetTlsConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDownstreamTlsParamsTypeValidator = func() *ValidateDownstreamTlsParamsType {
	v := &ValidateDownstreamTlsParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMtlsChoice := v.MtlsChoiceValidationRuleHandler
	rulesMtlsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMtlsChoice(rulesMtlsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DownstreamTlsParamsType.mtls_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtls_choice"] = vFn

	vrhTlsCertificates := v.TlsCertificatesValidationRuleHandler
	rulesTlsCertificates := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhTlsCertificates(rulesTlsCertificates)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DownstreamTlsParamsType.tls_certificates: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_certificates"] = vFn

	v.FldValidators["mtls_choice.use_mtls"] = DownstreamTlsValidationContextValidator().Validate

	v.FldValidators["tls_config"] = TlsConfigValidator().Validate

	return v
}()

func DownstreamTlsParamsTypeValidator() db.Validator {
	return DefaultDownstreamTlsParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DownstreamTlsValidationContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DownstreamTlsValidationContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DownstreamTlsValidationContext) DeepCopy() *DownstreamTlsValidationContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DownstreamTlsValidationContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DownstreamTlsValidationContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DownstreamTlsValidationContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DownstreamTlsValidationContextValidator().Validate(ctx, m, opts...)
}

func (m *DownstreamTlsValidationContext) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCrlChoiceDRefInfo()

}

func (m *DownstreamTlsValidationContext) GetCrlChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetCrlChoice().(type) {
	case *DownstreamTlsValidationContext_NoCrl:

		return nil, nil

	case *DownstreamTlsValidationContext_Crl:

		vref := m.GetCrl()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("crl.Object")
		dri := db.DRefInfo{
			RefdType:   "crl.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "crl",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetCrlChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DownstreamTlsValidationContext) GetCrlChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetCrlChoice().(type) {
	case *DownstreamTlsValidationContext_NoCrl:

	case *DownstreamTlsValidationContext_Crl:
		refdType, err := d.TypeForEntryKind("", "", "crl.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: crl")
		}

		vref := m.GetCrl()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "crl.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateDownstreamTlsValidationContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDownstreamTlsValidationContext) TrustedCaUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_url")
	}

	return validatorFn, nil
}

func (v *ValidateDownstreamTlsValidationContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DownstreamTlsValidationContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DownstreamTlsValidationContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetCrlChoice().(type) {
	case *DownstreamTlsValidationContext_NoCrl:
		if fv, exists := v.FldValidators["crl_choice.no_crl"]; exists {
			val := m.GetCrlChoice().(*DownstreamTlsValidationContext_NoCrl).NoCrl
			vOpts := append(opts,
				db.WithValidateField("crl_choice"),
				db.WithValidateField("no_crl"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DownstreamTlsValidationContext_Crl:
		if fv, exists := v.FldValidators["crl_choice.crl"]; exists {
			val := m.GetCrlChoice().(*DownstreamTlsValidationContext_Crl).Crl
			vOpts := append(opts,
				db.WithValidateField("crl_choice"),
				db.WithValidateField("crl"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["trusted_ca_url"]; exists {

		vOpts := append(opts, db.WithValidateField("trusted_ca_url"))
		if err := fv(ctx, m.GetTrustedCaUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDownstreamTlsValidationContextValidator = func() *ValidateDownstreamTlsValidationContext {
	v := &ValidateDownstreamTlsValidationContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTrustedCaUrl := v.TrustedCaUrlValidationRuleHandler
	rulesTrustedCaUrl := map[string]string{
		"ves.io.schema.rules.message.required":      "true",
		"ves.io.schema.rules.string.max_bytes":      "131072",
		"ves.io.schema.rules.string.min_bytes":      "1",
		"ves.io.schema.rules.string.truststore_url": "true",
	}
	vFn, err = vrhTrustedCaUrl(rulesTrustedCaUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DownstreamTlsValidationContext.trusted_ca_url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_ca_url"] = vFn

	v.FldValidators["crl_choice.crl"] = ObjectRefTypeValidator().Validate

	return v
}()

func DownstreamTlsValidationContextValidator() db.Validator {
	return DefaultDownstreamTlsValidationContextValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalConnectorType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalConnectorType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalConnectorType) DeepCopy() *GlobalConnectorType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalConnectorType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalConnectorType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalConnectorType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalConnectorTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalConnectorType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetGlobalVnDRefInfo()

}

func (m *GlobalConnectorType) GetGlobalVnDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetGlobalVn()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_network.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_network.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "global_vn",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetGlobalVnDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalConnectorType) GetGlobalVnDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}

	vref := m.GetGlobalVn()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_network.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateGlobalConnectorType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalConnectorType) GlobalVnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for global_vn")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalConnectorType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalConnectorType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalConnectorType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["global_vn"]; exists {

		vOpts := append(opts, db.WithValidateField("global_vn"))
		if err := fv(ctx, m.GetGlobalVn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalConnectorTypeValidator = func() *ValidateGlobalConnectorType {
	v := &ValidateGlobalConnectorType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhGlobalVn := v.GlobalVnValidationRuleHandler
	rulesGlobalVn := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhGlobalVn(rulesGlobalVn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalConnectorType.global_vn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["global_vn"] = vFn

	return v
}()

func GlobalConnectorTypeValidator() db.Validator {
	return DefaultGlobalConnectorTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InternetVIPInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InternetVIPInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InternetVIPInfo) DeepCopy() *InternetVIPInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InternetVIPInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InternetVIPInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InternetVIPInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InternetVIPInfoValidator().Validate(ctx, m, opts...)
}

type ValidateInternetVIPInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInternetVIPInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InternetVIPInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InternetVIPInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site_name"]; exists {

		vOpts := append(opts, db.WithValidateField("site_name"))
		if err := fv(ctx, m.GetSiteName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_network_type"))
		if err := fv(ctx, m.GetSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInternetVIPInfoValidator = func() *ValidateInternetVIPInfo {
	v := &ValidateInternetVIPInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InternetVIPInfoValidator() db.Validator {
	return DefaultInternetVIPInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *InternetVIPListenerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InternetVIPListenerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InternetVIPListenerStatusType) DeepCopy() *InternetVIPListenerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InternetVIPListenerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InternetVIPListenerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InternetVIPListenerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InternetVIPListenerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateInternetVIPListenerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInternetVIPListenerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InternetVIPListenerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InternetVIPListenerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["arn"]; exists {

		vOpts := append(opts, db.WithValidateField("arn"))
		if err := fv(ctx, m.GetArn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol"))
		if err := fv(ctx, m.GetProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reason"]; exists {

		vOpts := append(opts, db.WithValidateField("reason"))
		if err := fv(ctx, m.GetReason(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInternetVIPListenerStatusTypeValidator = func() *ValidateInternetVIPListenerStatusType {
	v := &ValidateInternetVIPListenerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InternetVIPListenerStatusTypeValidator() db.Validator {
	return DefaultInternetVIPListenerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InternetVIPStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InternetVIPStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InternetVIPStatus) DeepCopy() *InternetVIPStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InternetVIPStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InternetVIPStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InternetVIPStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InternetVIPStatusValidator().Validate(ctx, m, opts...)
}

type ValidateInternetVIPStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInternetVIPStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InternetVIPStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InternetVIPStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["arn"]; exists {

		vOpts := append(opts, db.WithValidateField("arn"))
		if err := fv(ctx, m.GetArn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nlb_cname"]; exists {

		vOpts := append(opts, db.WithValidateField("nlb_cname"))
		if err := fv(ctx, m.GetNlbCname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nlb_status"]; exists {

		vOpts := append(opts, db.WithValidateField("nlb_status"))
		if err := fv(ctx, m.GetNlbStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reason"]; exists {

		vOpts := append(opts, db.WithValidateField("reason"))
		if err := fv(ctx, m.GetReason(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["target_group_status"]; exists {

		vOpts := append(opts, db.WithValidateField("target_group_status"))
		for idx, item := range m.GetTargetGroupStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInternetVIPStatusValidator = func() *ValidateInternetVIPStatus {
	v := &ValidateInternetVIPStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InternetVIPStatusValidator() db.Validator {
	return DefaultInternetVIPStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *InternetVIPTargetGroupStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InternetVIPTargetGroupStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InternetVIPTargetGroupStatusType) DeepCopy() *InternetVIPTargetGroupStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InternetVIPTargetGroupStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InternetVIPTargetGroupStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InternetVIPTargetGroupStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InternetVIPTargetGroupStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateInternetVIPTargetGroupStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInternetVIPTargetGroupStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InternetVIPTargetGroupStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InternetVIPTargetGroupStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["arn"]; exists {

		vOpts := append(opts, db.WithValidateField("arn"))
		if err := fv(ctx, m.GetArn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["listener_status"]; exists {

		vOpts := append(opts, db.WithValidateField("listener_status"))
		for idx, item := range m.GetListenerStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol"))
		if err := fv(ctx, m.GetProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reason"]; exists {

		vOpts := append(opts, db.WithValidateField("reason"))
		if err := fv(ctx, m.GetReason(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInternetVIPTargetGroupStatusTypeValidator = func() *ValidateInternetVIPTargetGroupStatusType {
	v := &ValidateInternetVIPTargetGroupStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InternetVIPTargetGroupStatusTypeValidator() db.Validator {
	return DefaultInternetVIPTargetGroupStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LinkRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LinkRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LinkRefType) DeepCopy() *LinkRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LinkRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LinkRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LinkRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LinkRefTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLinkRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLinkRefType) HrefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for href")
	}

	return validatorFn, nil
}

func (v *ValidateLinkRefType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateLinkRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LinkRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LinkRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["href"]; exists {

		vOpts := append(opts, db.WithValidateField("href"))
		if err := fv(ctx, m.GetHref(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLinkRefTypeValidator = func() *ValidateLinkRefType {
	v := &ValidateLinkRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHref := v.HrefValidationRuleHandler
	rulesHref := map[string]string{
		"ves.io.schema.rules.string.max_len": "512",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhHref(rulesHref)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LinkRefType.href: %s", err)
		panic(errMsg)
	}
	v.FldValidators["href"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LinkRefType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func LinkRefTypeValidator() db.Validator {
	return DefaultLinkRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ObjectRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ObjectRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ObjectRefType) DeepCopy() *ObjectRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ObjectRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ObjectRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ObjectRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ObjectRefTypeValidator().Validate(ctx, m, opts...)
}

// SetName sets the field
func (m *ObjectRefType) SetName(in string) {
	m.Name = in
}

// SetNamespace sets the field
func (m *ObjectRefType) SetNamespace(in string) {
	m.Namespace = in
}

// SetTenant sets the field
func (m *ObjectRefType) SetTenant(in string) {
	m.Tenant = in
}

type ValidateObjectRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateObjectRefType) TenantValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tenant")
	}

	return validatorFn, nil
}

func (v *ValidateObjectRefType) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateObjectRefType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateObjectRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ObjectRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ObjectRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultObjectRefTypeValidator = func() *ValidateObjectRefType {
	v := &ValidateObjectRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTenant := v.TenantValidationRuleHandler
	rulesTenant := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
	}
	vFn, err = vrhTenant(rulesTenant)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectRefType.tenant: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tenant"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectRefType.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectRefType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func ObjectRefTypeValidator() db.Validator {
	return DefaultObjectRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OperatingSystemType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OperatingSystemType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OperatingSystemType) DeepCopy() *OperatingSystemType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OperatingSystemType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OperatingSystemType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OperatingSystemType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OperatingSystemTypeValidator().Validate(ctx, m, opts...)
}

type ValidateOperatingSystemType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOperatingSystemType) OperatingSystemVersionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOperatingSystemType) OperatingSystemVersionChoiceOperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_OperatingSystemVersion, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}
	return oValidatorFn_OperatingSystemVersion, nil
}

func (v *ValidateOperatingSystemType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OperatingSystemType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OperatingSystemType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["operating_system_version_choice"]; exists {
		val := m.GetOperatingSystemVersionChoice()
		vOpts := append(opts,
			db.WithValidateField("operating_system_version_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetOperatingSystemVersionChoice().(type) {
	case *OperatingSystemType_DefaultOsVersion:
		if fv, exists := v.FldValidators["operating_system_version_choice.default_os_version"]; exists {
			val := m.GetOperatingSystemVersionChoice().(*OperatingSystemType_DefaultOsVersion).DefaultOsVersion
			vOpts := append(opts,
				db.WithValidateField("operating_system_version_choice"),
				db.WithValidateField("default_os_version"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OperatingSystemType_OperatingSystemVersion:
		if fv, exists := v.FldValidators["operating_system_version_choice.operating_system_version"]; exists {
			val := m.GetOperatingSystemVersionChoice().(*OperatingSystemType_OperatingSystemVersion).OperatingSystemVersion
			vOpts := append(opts,
				db.WithValidateField("operating_system_version_choice"),
				db.WithValidateField("operating_system_version"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOperatingSystemTypeValidator = func() *ValidateOperatingSystemType {
	v := &ValidateOperatingSystemType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOperatingSystemVersionChoice := v.OperatingSystemVersionChoiceValidationRuleHandler
	rulesOperatingSystemVersionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhOperatingSystemVersionChoice(rulesOperatingSystemVersionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OperatingSystemType.operating_system_version_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version_choice"] = vFn

	vrhOperatingSystemVersionChoiceOperatingSystemVersion := v.OperatingSystemVersionChoiceOperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersionChoiceOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "20",
	}
	vFnMap["operating_system_version_choice.operating_system_version"], err = vrhOperatingSystemVersionChoiceOperatingSystemVersion(rulesOperatingSystemVersionChoiceOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OperatingSystemType.operating_system_version_choice_operating_system_version: %s", err)
		panic(errMsg)
	}

	v.FldValidators["operating_system_version_choice.operating_system_version"] = vFnMap["operating_system_version_choice.operating_system_version"]

	return v
}()

func OperatingSystemTypeValidator() db.Validator {
	return DefaultOperatingSystemTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginPoolListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginPoolListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginPoolListType) DeepCopy() *OriginPoolListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginPoolListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginPoolListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginPoolListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginPoolListTypeValidator().Validate(ctx, m, opts...)
}

func (m *OriginPoolListType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPoolsDRefInfo()

}

// GetDRefInfo for the field's type
func (m *OriginPoolListType) GetPoolsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetPools() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetPools() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPools() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("pools[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateOriginPoolListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginPoolListType) PoolsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for pools")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*OriginPoolWithWeight, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := OriginPoolWithWeightValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for pools")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*OriginPoolWithWeight)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*OriginPoolWithWeight, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated pools")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items pools")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginPoolListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginPoolListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginPoolListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["pools"]; exists {
		vOpts := append(opts, db.WithValidateField("pools"))
		if err := fv(ctx, m.GetPools(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginPoolListTypeValidator = func() *ValidateOriginPoolListType {
	v := &ValidateOriginPoolListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPools := v.PoolsValidationRuleHandler
	rulesPools := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhPools(rulesPools)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolListType.pools: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pools"] = vFn

	return v
}()

func OriginPoolListTypeValidator() db.Validator {
	return DefaultOriginPoolListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginPoolWithWeight) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginPoolWithWeight) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginPoolWithWeight) DeepCopy() *OriginPoolWithWeight {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginPoolWithWeight{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginPoolWithWeight) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginPoolWithWeight) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginPoolWithWeightValidator().Validate(ctx, m, opts...)
}

func (m *OriginPoolWithWeight) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPoolChoiceDRefInfo()

}

func (m *OriginPoolWithWeight) GetPoolChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetPoolChoice().(type) {
	case *OriginPoolWithWeight_Pool:

		vref := m.GetPool()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("origin_pool.Object")
		dri := db.DRefInfo{
			RefdType:   "origin_pool.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "pool",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *OriginPoolWithWeight_Cluster:

		vref := m.GetCluster()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("cluster.Object")
		dri := db.DRefInfo{
			RefdType:   "cluster.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "cluster",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetPoolChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *OriginPoolWithWeight) GetPoolChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetPoolChoice().(type) {
	case *OriginPoolWithWeight_Pool:
		refdType, err := d.TypeForEntryKind("", "", "origin_pool.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: origin_pool")
		}

		vref := m.GetPool()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "origin_pool.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *OriginPoolWithWeight_Cluster:
		refdType, err := d.TypeForEntryKind("", "", "cluster.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: cluster")
		}

		vref := m.GetCluster()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "cluster.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateOriginPoolWithWeight struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginPoolWithWeight) PoolChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pool_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginPoolWithWeight) PoolChoicePoolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return ObjectRefTypeValidator().Validate, nil
}
func (v *ValidateOriginPoolWithWeight) PoolChoiceClusterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return ObjectRefTypeValidator().Validate, nil
}

func (v *ValidateOriginPoolWithWeight) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for endpoint_subsets")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginPoolWithWeight) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateOriginPoolWithWeight) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginPoolWithWeight)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginPoolWithWeight got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pool_choice"]; exists {
		val := m.GetPoolChoice()
		vOpts := append(opts,
			db.WithValidateField("pool_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPoolChoice().(type) {
	case *OriginPoolWithWeight_Pool:
		if fv, exists := v.FldValidators["pool_choice.pool"]; exists {
			val := m.GetPoolChoice().(*OriginPoolWithWeight_Pool).Pool
			vOpts := append(opts,
				db.WithValidateField("pool_choice"),
				db.WithValidateField("pool"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolWithWeight_Cluster:
		if fv, exists := v.FldValidators["pool_choice.cluster"]; exists {
			val := m.GetPoolChoice().(*OriginPoolWithWeight_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("pool_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["weight"]; exists {

		vOpts := append(opts, db.WithValidateField("weight"))
		if err := fv(ctx, m.GetWeight(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginPoolWithWeightValidator = func() *ValidateOriginPoolWithWeight {
	v := &ValidateOriginPoolWithWeight{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPoolChoice := v.PoolChoiceValidationRuleHandler
	rulesPoolChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPoolChoice(rulesPoolChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolWithWeight.pool_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pool_choice"] = vFn

	vrhPoolChoicePool := v.PoolChoicePoolValidationRuleHandler
	rulesPoolChoicePool := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["pool_choice.pool"], err = vrhPoolChoicePool(rulesPoolChoicePool)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginPoolWithWeight.pool_choice_pool: %s", err)
		panic(errMsg)
	}
	vrhPoolChoiceCluster := v.PoolChoiceClusterValidationRuleHandler
	rulesPoolChoiceCluster := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["pool_choice.cluster"], err = vrhPoolChoiceCluster(rulesPoolChoiceCluster)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginPoolWithWeight.pool_choice_cluster: %s", err)
		panic(errMsg)
	}

	v.FldValidators["pool_choice.pool"] = vFnMap["pool_choice.pool"]
	v.FldValidators["pool_choice.cluster"] = vFnMap["pool_choice.cluster"]

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "16",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolWithWeight.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.lte": "32",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolWithWeight.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	return v
}()

func OriginPoolWithWeightValidator() db.Validator {
	return DefaultOriginPoolWithWeightValidator
}

// augmented methods on protoc/std generated struct

func (m *PerformanceEnhancementModeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PerformanceEnhancementModeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PerformanceEnhancementModeType) DeepCopy() *PerformanceEnhancementModeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PerformanceEnhancementModeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PerformanceEnhancementModeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PerformanceEnhancementModeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PerformanceEnhancementModeTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePerformanceEnhancementModeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePerformanceEnhancementModeType) PerfModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for perf_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePerformanceEnhancementModeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PerformanceEnhancementModeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PerformanceEnhancementModeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["perf_mode_choice"]; exists {
		val := m.GetPerfModeChoice()
		vOpts := append(opts,
			db.WithValidateField("perf_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPerfModeChoice().(type) {
	case *PerformanceEnhancementModeType_PerfModeL7Enhanced:
		if fv, exists := v.FldValidators["perf_mode_choice.perf_mode_l7_enhanced"]; exists {
			val := m.GetPerfModeChoice().(*PerformanceEnhancementModeType_PerfModeL7Enhanced).PerfModeL7Enhanced
			vOpts := append(opts,
				db.WithValidateField("perf_mode_choice"),
				db.WithValidateField("perf_mode_l7_enhanced"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PerformanceEnhancementModeType_PerfModeL3Enhanced:
		if fv, exists := v.FldValidators["perf_mode_choice.perf_mode_l3_enhanced"]; exists {
			val := m.GetPerfModeChoice().(*PerformanceEnhancementModeType_PerfModeL3Enhanced).PerfModeL3Enhanced
			vOpts := append(opts,
				db.WithValidateField("perf_mode_choice"),
				db.WithValidateField("perf_mode_l3_enhanced"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPerformanceEnhancementModeTypeValidator = func() *ValidatePerformanceEnhancementModeType {
	v := &ValidatePerformanceEnhancementModeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPerfModeChoice := v.PerfModeChoiceValidationRuleHandler
	rulesPerfModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPerfModeChoice(rulesPerfModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PerformanceEnhancementModeType.perf_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["perf_mode_choice"] = vFn

	return v
}()

func PerformanceEnhancementModeTypeValidator() db.Validator {
	return DefaultPerformanceEnhancementModeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PrefixStringListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PrefixStringListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PrefixStringListType) DeepCopy() *PrefixStringListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PrefixStringListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PrefixStringListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PrefixStringListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PrefixStringListTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePrefixStringListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePrefixStringListType) PrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePrefixStringListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PrefixStringListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PrefixStringListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("prefixes"))
		if err := fv(ctx, m.GetPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPrefixStringListTypeValidator = func() *ValidatePrefixStringListType {
	v := &ValidatePrefixStringListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixes := v.PrefixesValidationRuleHandler
	rulesPrefixes := map[string]string{
		"ves.io.schema.rules.message.required":                  "true",
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "128",
		"ves.io.schema.rules.repeated.min_items":                "1",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhPrefixes(rulesPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PrefixStringListType.prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefixes"] = vFn

	return v
}()

func PrefixStringListTypeValidator() db.Validator {
	return DefaultPrefixStringListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteLocator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteLocator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteLocator) DeepCopy() *SiteLocator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteLocator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteLocator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteLocator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteLocatorValidator().Validate(ctx, m, opts...)
}

func (m *SiteLocator) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

func (m *SiteLocator) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetChoice().(type) {
	case *SiteLocator_Site:

		vref := m.GetSite()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("site.Object")
		dri := db.DRefInfo{
			RefdType:   "site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "site",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *SiteLocator_VirtualSite:

		vref := m.GetVirtualSite()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_site.Object")
		dri := db.DRefInfo{
			RefdType:   "virtual_site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "virtual_site",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteLocator) GetChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetChoice().(type) {
	case *SiteLocator_Site:
		refdType, err := d.TypeForEntryKind("", "", "site.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: site")
		}

		vref := m.GetSite()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *SiteLocator_VirtualSite:
		refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
		}

		vref := m.GetVirtualSite()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateSiteLocator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteLocator) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateSiteLocator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteLocator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteLocator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *SiteLocator_Site:
		if fv, exists := v.FldValidators["choice.site"]; exists {
			val := m.GetChoice().(*SiteLocator_Site).Site
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteLocator_VirtualSite:
		if fv, exists := v.FldValidators["choice.virtual_site"]; exists {
			val := m.GetChoice().(*SiteLocator_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteLocatorValidator = func() *ValidateSiteLocator {
	v := &ValidateSiteLocator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteLocator.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.site"] = ObjectRefTypeValidator().Validate
	v.FldValidators["choice.virtual_site"] = ObjectRefTypeValidator().Validate

	return v
}()

func SiteLocatorValidator() db.Validator {
	return DefaultSiteLocatorValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TlsConfig) DeepCopy() *TlsConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsConfigValidator().Validate(ctx, m, opts...)
}

type ValidateTlsConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsConfig) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateTlsConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *TlsConfig_DefaultSecurity:
		if fv, exists := v.FldValidators["choice.default_security"]; exists {
			val := m.GetChoice().(*TlsConfig_DefaultSecurity).DefaultSecurity
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("default_security"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsConfig_MediumSecurity:
		if fv, exists := v.FldValidators["choice.medium_security"]; exists {
			val := m.GetChoice().(*TlsConfig_MediumSecurity).MediumSecurity
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("medium_security"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsConfig_LowSecurity:
		if fv, exists := v.FldValidators["choice.low_security"]; exists {
			val := m.GetChoice().(*TlsConfig_LowSecurity).LowSecurity
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("low_security"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsConfig_CustomSecurity:
		if fv, exists := v.FldValidators["choice.custom_security"]; exists {
			val := m.GetChoice().(*TlsConfig_CustomSecurity).CustomSecurity
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("custom_security"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsConfigValidator = func() *ValidateTlsConfig {
	v := &ValidateTlsConfig{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsConfig.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.custom_security"] = CustomCiphersValidator().Validate

	return v
}()

func TlsConfigValidator() db.Validator {
	return DefaultTlsConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *VolterraSoftwareType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolterraSoftwareType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VolterraSoftwareType) DeepCopy() *VolterraSoftwareType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolterraSoftwareType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolterraSoftwareType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolterraSoftwareType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolterraSoftwareTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVolterraSoftwareType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolterraSoftwareType) VolterraSwVersionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_sw_version_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVolterraSoftwareType) VolterraSwVersionChoiceVolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_VolterraSoftwareVersion, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}
	return oValidatorFn_VolterraSoftwareVersion, nil
}

func (v *ValidateVolterraSoftwareType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolterraSoftwareType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolterraSoftwareType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["volterra_sw_version_choice"]; exists {
		val := m.GetVolterraSwVersionChoice()
		vOpts := append(opts,
			db.WithValidateField("volterra_sw_version_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVolterraSwVersionChoice().(type) {
	case *VolterraSoftwareType_DefaultSwVersion:
		if fv, exists := v.FldValidators["volterra_sw_version_choice.default_sw_version"]; exists {
			val := m.GetVolterraSwVersionChoice().(*VolterraSoftwareType_DefaultSwVersion).DefaultSwVersion
			vOpts := append(opts,
				db.WithValidateField("volterra_sw_version_choice"),
				db.WithValidateField("default_sw_version"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VolterraSoftwareType_VolterraSoftwareVersion:
		if fv, exists := v.FldValidators["volterra_sw_version_choice.volterra_software_version"]; exists {
			val := m.GetVolterraSwVersionChoice().(*VolterraSoftwareType_VolterraSoftwareVersion).VolterraSoftwareVersion
			vOpts := append(opts,
				db.WithValidateField("volterra_sw_version_choice"),
				db.WithValidateField("volterra_software_version"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolterraSoftwareTypeValidator = func() *ValidateVolterraSoftwareType {
	v := &ValidateVolterraSoftwareType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVolterraSwVersionChoice := v.VolterraSwVersionChoiceValidationRuleHandler
	rulesVolterraSwVersionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVolterraSwVersionChoice(rulesVolterraSwVersionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VolterraSoftwareType.volterra_sw_version_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_sw_version_choice"] = vFn

	vrhVolterraSwVersionChoiceVolterraSoftwareVersion := v.VolterraSwVersionChoiceVolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSwVersionChoiceVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "20",
	}
	vFnMap["volterra_sw_version_choice.volterra_software_version"], err = vrhVolterraSwVersionChoiceVolterraSoftwareVersion(rulesVolterraSwVersionChoiceVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field VolterraSoftwareType.volterra_sw_version_choice_volterra_software_version: %s", err)
		panic(errMsg)
	}

	v.FldValidators["volterra_sw_version_choice.volterra_software_version"] = vFnMap["volterra_sw_version_choice.volterra_software_version"]

	return v
}()

func VolterraSoftwareTypeValidator() db.Validator {
	return DefaultVolterraSoftwareTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereSite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereSite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereSite) DeepCopy() *WhereSite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereSite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereSite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereSite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereSiteValidator().Validate(ctx, m, opts...)
}

func (m *WhereSite) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSiteDRefInfo()

}

func (m *WhereSite) GetSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("site.Object")
	dri := db.DRefInfo{
		RefdType:   "site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereSite) GetSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}

	vref := m.GetSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereSite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereSite) NetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteNetwork)
		return int32(i)
	}
	// SiteNetwork_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteNetwork_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network")
	}

	return validatorFn, nil
}

func (v *ValidateWhereSite) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereSite) IpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}

	return validatorFn, nil
}

func (v *ValidateWhereSite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereSite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereSite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		if err := fv(ctx, m.GetNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereSiteValidator = func() *ValidateWhereSite {
	v := &ValidateWhereSite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetwork := v.NetworkValidationRuleHandler
	rulesNetwork := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetwork(rulesNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSite.network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network"] = vFn

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSite.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	vrhIp := v.IpValidationRuleHandler
	rulesIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhIp(rulesIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSite.ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip"] = vFn

	return v
}()

func WhereSiteValidator() db.Validator {
	return DefaultWhereSiteValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereType) DeepCopy() *WhereType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereTypeValidator().Validate(ctx, m, opts...)
}

func (m *WhereType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *WhereType) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetChoice() == nil {
		return nil, nil
	}
	switch m.GetChoice().(type) {
	case *WhereType_Site:
		drInfos, err := m.GetSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site." + dri.DRField
		}
		return drInfos, err

	case *WhereType_VirtualSite:
		drInfos, err := m.GetVirtualSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site." + dri.DRField
		}
		return drInfos, err

	case *WhereType_Vk8SService:
		drInfos, err := m.GetVk8SService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVk8SService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "vk8s_service." + dri.DRField
		}
		return drInfos, err

	case *WhereType_VirtualNetwork:
		drInfos, err := m.GetVirtualNetwork().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualNetwork().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_network." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateWhereType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateWhereType) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateWhereType) PortChoicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Port, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}
	return oValidatorFn_Port, nil
}

func (v *ValidateWhereType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *WhereType_Site:
		if fv, exists := v.FldValidators["choice.site"]; exists {
			val := m.GetChoice().(*WhereType_Site).Site
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_VirtualSite:
		if fv, exists := v.FldValidators["choice.virtual_site"]; exists {
			val := m.GetChoice().(*WhereType_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_Vk8SService:
		if fv, exists := v.FldValidators["choice.vk8s_service"]; exists {
			val := m.GetChoice().(*WhereType_Vk8SService).Vk8SService
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("vk8s_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_VirtualNetwork:
		if fv, exists := v.FldValidators["choice.virtual_network"]; exists {
			val := m.GetChoice().(*WhereType_VirtualNetwork).VirtualNetwork
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *WhereType_UseDefaultPort:
		if fv, exists := v.FldValidators["port_choice.use_default_port"]; exists {
			val := m.GetPortChoice().(*WhereType_UseDefaultPort).UseDefaultPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("use_default_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_Port:
		if fv, exists := v.FldValidators["port_choice.port"]; exists {
			val := m.GetPortChoice().(*WhereType_Port).Port
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereTypeValidator = func() *ValidateWhereType {
	v := &ValidateWhereType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereType.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	vrhPortChoicePort := v.PortChoicePortValidationRuleHandler
	rulesPortChoicePort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.port"], err = vrhPortChoicePort(rulesPortChoicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field WhereType.port_choice_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.port"] = vFnMap["port_choice.port"]

	v.FldValidators["choice.site"] = WhereSiteValidator().Validate
	v.FldValidators["choice.virtual_site"] = WhereVirtualSiteValidator().Validate
	v.FldValidators["choice.vk8s_service"] = WhereVK8SServiceValidator().Validate
	v.FldValidators["choice.virtual_network"] = WhereVirtualNetworkValidator().Validate

	return v
}()

func WhereTypeValidator() db.Validator {
	return DefaultWhereTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereTypeSiteVsite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereTypeSiteVsite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereTypeSiteVsite) DeepCopy() *WhereTypeSiteVsite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereTypeSiteVsite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereTypeSiteVsite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereTypeSiteVsite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereTypeSiteVsiteValidator().Validate(ctx, m, opts...)
}

func (m *WhereTypeSiteVsite) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *WhereTypeSiteVsite) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetChoice() == nil {
		return nil, nil
	}
	switch m.GetChoice().(type) {
	case *WhereTypeSiteVsite_Site:
		drInfos, err := m.GetSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site." + dri.DRField
		}
		return drInfos, err

	case *WhereTypeSiteVsite_VirtualSite:
		drInfos, err := m.GetVirtualSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateWhereTypeSiteVsite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereTypeSiteVsite) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateWhereTypeSiteVsite) PortChoicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Port, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}
	return oValidatorFn_Port, nil
}

func (v *ValidateWhereTypeSiteVsite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereTypeSiteVsite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereTypeSiteVsite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *WhereTypeSiteVsite_Site:
		if fv, exists := v.FldValidators["choice.site"]; exists {
			val := m.GetChoice().(*WhereTypeSiteVsite_Site).Site
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereTypeSiteVsite_VirtualSite:
		if fv, exists := v.FldValidators["choice.virtual_site"]; exists {
			val := m.GetChoice().(*WhereTypeSiteVsite_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetPortChoice().(type) {
	case *WhereTypeSiteVsite_UseDefaultPort:
		if fv, exists := v.FldValidators["port_choice.use_default_port"]; exists {
			val := m.GetPortChoice().(*WhereTypeSiteVsite_UseDefaultPort).UseDefaultPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("use_default_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereTypeSiteVsite_Port:
		if fv, exists := v.FldValidators["port_choice.port"]; exists {
			val := m.GetPortChoice().(*WhereTypeSiteVsite_Port).Port
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereTypeSiteVsiteValidator = func() *ValidateWhereTypeSiteVsite {
	v := &ValidateWhereTypeSiteVsite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereTypeSiteVsite.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhPortChoicePort := v.PortChoicePortValidationRuleHandler
	rulesPortChoicePort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.port"], err = vrhPortChoicePort(rulesPortChoicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field WhereTypeSiteVsite.port_choice_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.port"] = vFnMap["port_choice.port"]

	v.FldValidators["choice.site"] = WhereSiteValidator().Validate
	v.FldValidators["choice.virtual_site"] = WhereVirtualSiteValidator().Validate

	return v
}()

func WhereTypeSiteVsiteValidator() db.Validator {
	return DefaultWhereTypeSiteVsiteValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereVK8SService) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereVK8SService) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereVK8SService) DeepCopy() *WhereVK8SService {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereVK8SService{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereVK8SService) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereVK8SService) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereVK8SServiceValidator().Validate(ctx, m, opts...)
}

func (m *WhereVK8SService) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

func (m *WhereVK8SService) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetChoice().(type) {
	case *WhereVK8SService_Site:

		vref := m.GetSite()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("site.Object")
		dri := db.DRefInfo{
			RefdType:   "site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "site",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *WhereVK8SService_VirtualSite:

		vref := m.GetVirtualSite()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_site.Object")
		dri := db.DRefInfo{
			RefdType:   "virtual_site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "virtual_site",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereVK8SService) GetChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetChoice().(type) {
	case *WhereVK8SService_Site:
		refdType, err := d.TypeForEntryKind("", "", "site.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: site")
		}

		vref := m.GetSite()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *WhereVK8SService_VirtualSite:
		refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
		}

		vref := m.GetVirtualSite()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateWhereVK8SService struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereVK8SService) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateWhereVK8SService) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereVK8SService)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereVK8SService got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *WhereVK8SService_Site:
		if fv, exists := v.FldValidators["choice.site"]; exists {
			val := m.GetChoice().(*WhereVK8SService_Site).Site
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereVK8SService_VirtualSite:
		if fv, exists := v.FldValidators["choice.virtual_site"]; exists {
			val := m.GetChoice().(*WhereVK8SService_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereVK8SServiceValidator = func() *ValidateWhereVK8SService {
	v := &ValidateWhereVK8SService{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVK8SService.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.site"] = ObjectRefTypeValidator().Validate
	v.FldValidators["choice.virtual_site"] = ObjectRefTypeValidator().Validate

	return v
}()

func WhereVK8SServiceValidator() db.Validator {
	return DefaultWhereVK8SServiceValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereVirtualNetwork) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereVirtualNetwork) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereVirtualNetwork) DeepCopy() *WhereVirtualNetwork {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereVirtualNetwork{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereVirtualNetwork) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereVirtualNetwork) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereVirtualNetworkValidator().Validate(ctx, m, opts...)
}

func (m *WhereVirtualNetwork) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualNetworkDRefInfo()

}

func (m *WhereVirtualNetwork) GetVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetVirtualNetwork()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_network.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_network.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "virtual_network",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereVirtualNetwork) GetVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}

	vref := m.GetVirtualNetwork()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_network.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereVirtualNetwork struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereVirtualNetwork) VipChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateWhereVirtualNetwork) VipChoiceSpecificVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SpecificVip, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for specific_vip")
	}
	return oValidatorFn_SpecificVip, nil
}

func (v *ValidateWhereVirtualNetwork) VirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for virtual_network")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualNetwork) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereVirtualNetwork)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereVirtualNetwork got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["vip_choice"]; exists {
		val := m.GetVipChoice()
		vOpts := append(opts,
			db.WithValidateField("vip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVipChoice().(type) {
	case *WhereVirtualNetwork_DefaultVip:
		if fv, exists := v.FldValidators["vip_choice.default_vip"]; exists {
			val := m.GetVipChoice().(*WhereVirtualNetwork_DefaultVip).DefaultVip
			vOpts := append(opts,
				db.WithValidateField("vip_choice"),
				db.WithValidateField("default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereVirtualNetwork_SpecificVip:
		if fv, exists := v.FldValidators["vip_choice.specific_vip"]; exists {
			val := m.GetVipChoice().(*WhereVirtualNetwork_SpecificVip).SpecificVip
			vOpts := append(opts,
				db.WithValidateField("vip_choice"),
				db.WithValidateField("specific_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["virtual_network"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_network"))
		if err := fv(ctx, m.GetVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereVirtualNetworkValidator = func() *ValidateWhereVirtualNetwork {
	v := &ValidateWhereVirtualNetwork{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVipChoice := v.VipChoiceValidationRuleHandler
	rulesVipChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVipChoice(rulesVipChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualNetwork.vip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vip_choice"] = vFn

	vrhVipChoiceSpecificVip := v.VipChoiceSpecificVipValidationRuleHandler
	rulesVipChoiceSpecificVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFnMap["vip_choice.specific_vip"], err = vrhVipChoiceSpecificVip(rulesVipChoiceSpecificVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field WhereVirtualNetwork.vip_choice_specific_vip: %s", err)
		panic(errMsg)
	}

	v.FldValidators["vip_choice.specific_vip"] = vFnMap["vip_choice.specific_vip"]

	vrhVirtualNetwork := v.VirtualNetworkValidationRuleHandler
	rulesVirtualNetwork := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhVirtualNetwork(rulesVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualNetwork.virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_network"] = vFn

	return v
}()

func WhereVirtualNetworkValidator() db.Validator {
	return DefaultWhereVirtualNetworkValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereVirtualSite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereVirtualSite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereVirtualSite) DeepCopy() *WhereVirtualSite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereVirtualSite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereVirtualSite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereVirtualSite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereVirtualSiteValidator().Validate(ctx, m, opts...)
}

func (m *WhereVirtualSite) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualSiteDRefInfo()

}

func (m *WhereVirtualSite) GetVirtualSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetVirtualSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_site.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "virtual_site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetVirtualSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereVirtualSite) GetVirtualSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
	}

	vref := m.GetVirtualSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereVirtualSite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereVirtualSite) NetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteNetwork)
		return int32(i)
	}
	// SiteNetwork_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteNetwork_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network")
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSite) VirtualSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for virtual_site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereVirtualSite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereVirtualSite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		if err := fv(ctx, m.GetNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_site"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_site"))
		if err := fv(ctx, m.GetVirtualSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereVirtualSiteValidator = func() *ValidateWhereVirtualSite {
	v := &ValidateWhereVirtualSite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetwork := v.NetworkValidationRuleHandler
	rulesNetwork := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetwork(rulesNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSite.network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network"] = vFn

	vrhVirtualSite := v.VirtualSiteValidationRuleHandler
	rulesVirtualSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhVirtualSite(rulesVirtualSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSite.virtual_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_site"] = vFn

	return v
}()

func WhereVirtualSiteValidator() db.Validator {
	return DefaultWhereVirtualSiteValidator
}
