// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package api_inventory

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create ConfigCustomAPI GRPC Client satisfying server.CustomClient
type ConfigCustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient ConfigCustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *ConfigCustomAPIGrpcClient) doRPCGetApiGroup(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetApiGroupReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.api_inventory.GetApiGroupReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetApiGroup(ctx, req, opts...)
	return rsp, err
}

func (c *ConfigCustomAPIGrpcClient) doRPCListApiGroups(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &ListApiGroupsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.api_inventory.ListApiGroupsReq", yamlReq)
	}
	rsp, err := c.grpcClient.ListApiGroups(ctx, req, opts...)
	return rsp, err
}

func (c *ConfigCustomAPIGrpcClient) doRPCUpdateApiGroup(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &UpdateApiGroupReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.api_inventory.UpdateApiGroupReq", yamlReq)
	}
	rsp, err := c.grpcClient.UpdateApiGroup(ctx, req, opts...)
	return rsp, err
}

func (c *ConfigCustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewConfigCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &ConfigCustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewConfigCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["GetApiGroup"] = ccl.doRPCGetApiGroup

	rpcFns["ListApiGroups"] = ccl.doRPCListApiGroups

	rpcFns["UpdateApiGroup"] = ccl.doRPCUpdateApiGroup

	ccl.rpcFns = rpcFns

	return ccl
}

// Create ConfigCustomAPI REST Client satisfying server.CustomClient
type ConfigCustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *ConfigCustomAPIRestClient) doRPCGetApiGroup(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetApiGroupReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.api_inventory.GetApiGroupReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("group_name", fmt.Sprintf("%v", req.GroupName))
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetApiGroupRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.api_inventory.GetApiGroupRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *ConfigCustomAPIRestClient) doRPCListApiGroups(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &ListApiGroupsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.api_inventory.ListApiGroupsReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("with_contents", fmt.Sprintf("%v", req.WithContents))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &ListApiGroupsRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.api_inventory.ListApiGroupsRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *ConfigCustomAPIRestClient) doRPCUpdateApiGroup(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &UpdateApiGroupReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.api_inventory.UpdateApiGroupReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("api_group", fmt.Sprintf("%v", req.ApiGroup))
		q.Add("group_name", fmt.Sprintf("%v", req.GroupName))
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &UpdateApiGroupRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.api_inventory.UpdateApiGroupRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *ConfigCustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewConfigCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &ConfigCustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["GetApiGroup"] = ccl.doRPCGetApiGroup

	rpcFns["ListApiGroups"] = ccl.doRPCListApiGroups

	rpcFns["UpdateApiGroup"] = ccl.doRPCUpdateApiGroup

	ccl.rpcFns = rpcFns

	return ccl
}

// Create configCustomAPIInprocClient

// INPROC Client (satisfying ConfigCustomAPIClient interface)
type configCustomAPIInprocClient struct {
	ConfigCustomAPIServer
}

func (c *configCustomAPIInprocClient) GetApiGroup(ctx context.Context, in *GetApiGroupReq, opts ...grpc.CallOption) (*GetApiGroupRsp, error) {
	return c.ConfigCustomAPIServer.GetApiGroup(ctx, in)
}
func (c *configCustomAPIInprocClient) ListApiGroups(ctx context.Context, in *ListApiGroupsReq, opts ...grpc.CallOption) (*ListApiGroupsRsp, error) {
	return c.ConfigCustomAPIServer.ListApiGroups(ctx, in)
}
func (c *configCustomAPIInprocClient) UpdateApiGroup(ctx context.Context, in *UpdateApiGroupReq, opts ...grpc.CallOption) (*UpdateApiGroupRsp, error) {
	return c.ConfigCustomAPIServer.UpdateApiGroup(ctx, in)
}

func NewConfigCustomAPIInprocClient(svc svcfw.Service) ConfigCustomAPIClient {
	return &configCustomAPIInprocClient{ConfigCustomAPIServer: NewConfigCustomAPIServer(svc)}
}

// RegisterGwConfigCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwConfigCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterConfigCustomAPIHandlerClient(ctx, mux, NewConfigCustomAPIInprocClient(s))
}

// Create configCustomAPISrv

// SERVER (satisfying ConfigCustomAPIServer interface)
type configCustomAPISrv struct {
	svc svcfw.Service
}

func (s *configCustomAPISrv) GetApiGroup(ctx context.Context, in *GetApiGroupReq) (*GetApiGroupRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.api_inventory.ConfigCustomAPI")
	cah, ok := ah.(ConfigCustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *ConfigCustomAPIServer", ah)
	}

	var (
		rsp *GetApiGroupRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.api_inventory.GetApiGroupReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'ConfigCustomAPI.GetApiGroup' operation on 'api_inventory'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.api_inventory.ConfigCustomAPI.GetApiGroup"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetApiGroup(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.api_inventory.GetApiGroupRsp", rsp)...)

	return rsp, nil
}
func (s *configCustomAPISrv) ListApiGroups(ctx context.Context, in *ListApiGroupsReq) (*ListApiGroupsRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.api_inventory.ConfigCustomAPI")
	cah, ok := ah.(ConfigCustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *ConfigCustomAPIServer", ah)
	}

	var (
		rsp *ListApiGroupsRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.api_inventory.ListApiGroupsReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'ConfigCustomAPI.ListApiGroups' operation on 'api_inventory'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.api_inventory.ConfigCustomAPI.ListApiGroups"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.ListApiGroups(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.api_inventory.ListApiGroupsRsp", rsp)...)

	return rsp, nil
}
func (s *configCustomAPISrv) UpdateApiGroup(ctx context.Context, in *UpdateApiGroupReq) (*UpdateApiGroupRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.api_inventory.ConfigCustomAPI")
	cah, ok := ah.(ConfigCustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *ConfigCustomAPIServer", ah)
	}

	var (
		rsp *UpdateApiGroupRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.api_inventory.UpdateApiGroupReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'ConfigCustomAPI.UpdateApiGroup' operation on 'api_inventory'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()
	if err := s.svc.CustomAPIProcessDRef(ctx, in); err != nil {
		return nil, err
	}

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.api_inventory.ConfigCustomAPI.UpdateApiGroup"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.UpdateApiGroup(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.api_inventory.UpdateApiGroupRsp", rsp)...)

	return rsp, nil
}

func NewConfigCustomAPIServer(svc svcfw.Service) ConfigCustomAPIServer {
	return &configCustomAPISrv{svc: svc}
}

var ConfigCustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "api inventory object",
        "description": "The API Inventory manages an approved set of endpoints of an application per HTTP Load Balancer,\nand it's actually an internal object of the HTTP Load Balancer with custom API defined to reflect this.\nThe endpoints are stored in a swagger file and manipulated by the asterix service,\nthus operations on the inventory are proxied to the asterix service.\nInventory's content is automatically synced with API Definition specified for HTTP Load Balancer.\nIn addition, API Inventory maintains custom API groups as child objects, and provides methods to\nevaluate a custom group builder without updating groups. Custom api groups are defined by\napi group builders which contain selection expressions, explicit include list, and explicit exclude list.\n\n The view creates the following child objects:\n * app_api_group",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/{namespace}/http_loadbalancers/{name}/api_inventory/api_groups": {
            "get": {
                "summary": "List API Groups of the API Inventory",
                "description": "List the API Groups and the API Group Builder objects from the API Inventory object.",
                "operationId": "ves.io.schema.views.api_inventory.ConfigCustomAPI.ListApiGroups",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/api_inventoryListApiGroupsRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the Http LoadBalancer for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Http LoadBalancer Name\n\nx-example: \"blogging-app\"\nHttp LoadBalancer for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Http LoadBalancer Name"
                    },
                    {
                        "name": "with_contents",
                        "description": "Optional query parameter.\nWhen set, the response will include full contents of the Custom API Groups and not only names.",
                        "in": "query",
                        "required": false,
                        "type": "boolean",
                        "format": "boolean",
                        "x-displayname": "With Contents"
                    }
                ],
                "tags": [
                    "ConfigCustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-api_inventory-configcustomapi-listapigroups"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.api_inventory.ConfigCustomAPI.ListApiGroups"
            },
            "x-displayname": "API Inventory Custom APIs",
            "x-ves-proto-service": "ves.io.schema.views.api_inventory.ConfigCustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/http_loadbalancers/{name}/api_inventory/api_groups/{group_name}": {
            "get": {
                "summary": "Get API Group",
                "description": "Get the API Group and the API Group Builder object from the API Inventory object.",
                "operationId": "ves.io.schema.views.api_inventory.ConfigCustomAPI.GetApiGroup",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/api_inventoryGetApiGroupRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the Http LoadBalancer for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Http LoadBalancer Name\n\nx-example: \"blogging-app\"\nAPI Inventory for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Http LoadBalancer Name"
                    },
                    {
                        "name": "group_name",
                        "description": "API Group Name\n\nx-example: \"sensitive\"\nAPI Group name for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "API Group Name"
                    }
                ],
                "tags": [
                    "ConfigCustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-api_inventory-configcustomapi-getapigroup"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.api_inventory.ConfigCustomAPI.GetApiGroup"
            },
            "put": {
                "summary": "Update Api Group",
                "description": "Update the API Group and the Api Group Builder object in the API Inventory.",
                "operationId": "ves.io.schema.views.api_inventory.ConfigCustomAPI.UpdateApiGroup",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/api_inventoryUpdateApiGroupRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the Http LoadBalancer for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Http LoadBalancer Name\n\nx-example: \"blogging-app\"\nHttp LoadBalancer for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Http LoadBalancer Name"
                    },
                    {
                        "name": "group_name",
                        "description": "API Group Name\n\nx-example: \"sensitive\"\nAPI Group name for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "API Group Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/api_inventoryUpdateApiGroupReq"
                        }
                    }
                ],
                "tags": [
                    "ConfigCustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-api_inventory-configcustomapi-updateapigroup"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.api_inventory.ConfigCustomAPI.UpdateApiGroup"
            },
            "x-displayname": "API Inventory Custom APIs",
            "x-ves-proto-service": "ves.io.schema.views.api_inventory.ConfigCustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "api_definitionApiGroupBuilder": {
            "type": "object",
            "description": "Define a group of application operations using path matching and label filtering.",
            "title": "ApiGroupBuilder",
            "x-displayname": "API Group Builder",
            "x-ves-proto-message": "ves.io.schema.views.api_definition.ApiGroupBuilder",
            "properties": {
                "excluded_operations": {
                    "type": "array",
                    "description": " List of operations matched by the filters to be excluded from a group.\n The list should only include operations matched by the filters.\n The paths appear here with parameters as defined in OpenAPI spec file.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 100\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "excluded_operations",
                    "maxItems": 100,
                    "items": {
                        "$ref": "#/definitions/api_definitionApiOperation"
                    },
                    "x-displayname": "Excluded Operations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "100",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "included_operations": {
                    "type": "array",
                    "description": " List of operations not matched by the filters to be included in a group.\n The list should not include operations matched by the filters.\n The paths appear here with parameters as defined in OpenAPI spec file.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 100\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "included_operations",
                    "maxItems": 100,
                    "items": {
                        "$ref": "#/definitions/api_definitionApiOperation"
                    },
                    "x-displayname": "Included Operations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "100",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "label_filter": {
                    "description": " A group builder should include only labels selected by expression.\n In the current context a label is a property of an OpenAPI operation or path.\n\nExample: - \"method in (POST, DELETE), tag in (web, db)\"-",
                    "title": "label_filter",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Label Filter",
                    "x-ves-example": "method in (POST, DELETE), tag in (web, db)"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path_filter": {
                    "type": "string",
                    "description": " Regular expression to match the input request API path against.\n The match is considered to succeed if the input request API path matches the specified path regex.\n\nExample: - \"/api/config/.*/path[123]/$\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "path_filter",
                    "maxLength": 1024,
                    "x-displayname": "Path Filter",
                    "x-ves-example": "/api/config/.*/path[123]/$",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                }
            }
        },
        "api_definitionApiOperation": {
            "type": "object",
            "description": "API operation according to OpenAPI specification.",
            "title": "ApiOperation",
            "x-displayname": "API Operation",
            "x-ves-proto-message": "ves.io.schema.views.api_definition.ApiOperation",
            "properties": {
                "method": {
                    "description": " Method to match the input request API method against.\n\nExample: - 'POST'-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "method",
                    "$ref": "#/definitions/schemaHttpMethod",
                    "x-displayname": "HTTP Method",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "type": "string",
                    "description": " An endpoint path, as specified in OpenAPI, including parameters.\n The path should comply with RFC 3986 and may have parameters according to OpenAPI specification\n\nExample: - \"/api/users/{userid}\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 1024\n  ves.io.schema.rules.string.min_bytes: 1\n  ves.io.schema.rules.string.pattern: ^/[\\\\w/{}\\\\-._~%!$\u0026'()*+,;=:]*$\n",
                    "title": "path",
                    "minLength": 1,
                    "maxLength": 1024,
                    "x-displayname": "Path",
                    "x-ves-example": "/api/users/{userid}",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "1024",
                        "ves.io.schema.rules.string.min_bytes": "1",
                        "ves.io.schema.rules.string.pattern": "^/[\\\\w/{}\\\\-._~%!$\u0026'()*+,;=:]*$"
                    }
                }
            }
        },
        "api_inventoryCustomApiGroup": {
            "type": "object",
            "description": "The Custom API Group holds an API Group together with a builder\nwhich defines how the group is derived from the API Inventory.",
            "title": "Custom API Group",
            "x-displayname": "Custom API Group",
            "x-ves-proto-message": "ves.io.schema.views.api_inventory.CustomApiGroup",
            "properties": {
                "api_group": {
                    "description": " An API Group defined by the API Group Builder",
                    "title": "Api Group",
                    "$ref": "#/definitions/viewsapp_api_groupGlobalSpecType",
                    "x-displayname": "Api Group"
                },
                "api_group_builder": {
                    "description": " An Api Group Builder of the API Inventory",
                    "title": "API Group Builder",
                    "$ref": "#/definitions/api_definitionApiGroupBuilder",
                    "x-displayname": "API Group Builder"
                }
            }
        },
        "api_inventoryGetApiGroupRsp": {
            "type": "object",
            "description": "Response shape for Get API Group request",
            "title": "Get API Group Response",
            "x-displayname": "Get API Group Response",
            "x-ves-proto-message": "ves.io.schema.views.api_inventory.GetApiGroupRsp",
            "properties": {
                "api_group": {
                    "description": " A Custom API Group which includes API Group Builder",
                    "title": "Custom Api Group",
                    "$ref": "#/definitions/api_inventoryCustomApiGroup",
                    "x-displayname": "Custom Api Group"
                }
            }
        },
        "api_inventoryListApiGroupsRsp": {
            "type": "object",
            "description": "Response shape for List API Group Builders request",
            "title": "List API Groups Response",
            "x-displayname": "List API Group Builders Response",
            "x-ves-proto-message": "ves.io.schema.views.api_inventory.ListApiGroupsRsp",
            "properties": {
                "api_groups_contents": {
                    "type": "array",
                    "description": " Contents of the Custom API Groups in the API Inventory\n OPTIONAL",
                    "title": "api_groups_contents",
                    "items": {
                        "$ref": "#/definitions/api_inventoryCustomApiGroup"
                    },
                    "x-displayname": "Custom API Groups Contents"
                },
                "api_groups_names": {
                    "type": "array",
                    "description": " Contents of the Custom API Groups in the API Inventory",
                    "title": "api_groups_names",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Custom API Groups Contents"
                }
            }
        },
        "api_inventoryUpdateApiGroupReq": {
            "type": "object",
            "description": "Request shape for Apply API Group",
            "title": "Update API Group Request",
            "x-displayname": "Update API Group Request",
            "x-ves-proto-message": "ves.io.schema.views.api_inventory.UpdateApiGroupReq",
            "properties": {
                "api_group": {
                    "description": " A Custom API Group which includes API Group Builder",
                    "title": "Custom Api Group",
                    "$ref": "#/definitions/api_inventoryCustomApiGroup",
                    "x-displayname": "Custom Api Group"
                },
                "group_name": {
                    "type": "string",
                    "description": " API Group name for the current request\n\nExample: - \"sensitive\"-",
                    "title": "API Group Name",
                    "x-displayname": "API Group Name",
                    "x-ves-example": "sensitive"
                },
                "name": {
                    "type": "string",
                    "description": " Http LoadBalancer for the current request\n\nExample: - \"blogging-app\"-",
                    "title": "Http LoadBalancer Name",
                    "x-displayname": "Http LoadBalancer Name",
                    "x-ves-example": "blogging-app"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the Http LoadBalancer for the current request\n\nExample: - \"shared\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared"
                }
            }
        },
        "api_inventoryUpdateApiGroupRsp": {
            "type": "object",
            "description": "Response shape for Update API Group request;\nempty because the only returned information is error message.",
            "title": "Update API Group Response",
            "x-displayname": "Update API Group Response",
            "x-ves-proto-message": "ves.io.schema.views.api_inventory.UpdateApiGroupRsp"
        },
        "schemaHttpMethod": {
            "type": "string",
            "description": "Specifies the HTTP method used to access a resource.\n\nAny HTTP Method",
            "title": "HttpMethod",
            "enum": [
                "ANY",
                "GET",
                "HEAD",
                "POST",
                "PUT",
                "DELETE",
                "CONNECT",
                "OPTIONS",
                "TRACE",
                "PATCH"
            ],
            "default": "ANY",
            "x-displayname": "HTTP Method",
            "x-ves-proto-enum": "ves.io.schema.HttpMethod"
        },
        "schemaLabelSelectorType": {
            "type": "object",
            "description": "This type can be used to establish a 'selector reference' from one object(called selector) to\na set of other objects(called selectees) based on the value of expresssions.\nA label selector is a label query over a set of resources. An empty label selector matches all objects.\nA null label selector matches no objects. Label selector is immutable.\nexpressions is a list of strings of label selection expression.\nEach string has \",\" separated values which are \"AND\" and all strings are logically \"OR\".\nBNF for expression string\n\u003cselector-syntax\u003e         ::= \u003crequirement\u003e | \u003crequirement\u003e \",\" \u003cselector-syntax\u003e\n\u003crequirement\u003e             ::= [!] KEY [ \u003cset-based-restriction\u003e | \u003cexact-match-restriction\u003e ]\n\u003cset-based-restriction\u003e   ::= \"\" | \u003cinclusion-exclusion\u003e \u003cvalue-set\u003e\n\u003cinclusion-exclusion\u003e     ::= \u003cinclusion\u003e | \u003cexclusion\u003e\n\u003cexclusion\u003e               ::= \"notin\"\n\u003cinclusion\u003e               ::= \"in\"\n\u003cvalue-set\u003e               ::= \"(\" \u003cvalues\u003e \")\"\n\u003cvalues\u003e                  ::= VALUE | VALUE \",\" \u003cvalues\u003e\n\u003cexact-match-restriction\u003e ::= [\"=\"|\"==\"|\"!=\"] VALUE",
            "title": "LabelSelectorType",
            "x-displayname": "Label Selector",
            "x-ves-proto-message": "ves.io.schema.LabelSelectorType",
            "properties": {
                "expressions": {
                    "type": "array",
                    "description": " expressions contains the kubernetes style label expression for selections.\n\nExample: - \"region in (us-west1, us-west2),tier in (staging)\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.k8s_label_selector: true\n  ves.io.schema.rules.repeated.items.string.max_len: 4096\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.max_items: 1\n",
                    "title": "expressions",
                    "maxItems": 1,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 4096
                    },
                    "x-displayname": "Selector Expression",
                    "x-ves-example": "region in (us-west1, us-west2),tier in (staging)",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.k8s_label_selector": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "4096",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.max_items": "1"
                    }
                }
            }
        },
        "schemaMessageMetaType": {
            "type": "object",
            "description": "MessageMetaType is metadata (common attributes) of a message that only certain messages\nhave. This information is propagated to the metadata of a child object that gets created\nfrom the containing message during view processing.\nThe information in this type can be specified by user during create and replace APIs.",
            "title": "MessageMetaType",
            "x-displayname": "Message Metadata",
            "x-ves-proto-message": "ves.io.schema.MessageMetaType",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " Human readable description.\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "description",
                    "maxLength": 256,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of the message.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.min_len: 1\n  ves.io.schema.rules.string.ves_object_name: true\n",
                    "title": "name",
                    "minLength": 1,
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.min_len": "1",
                        "ves.io.schema.rules.string.ves_object_name": "true"
                    }
                }
            }
        },
        "schemaapi_group_elementGlobalSpecType": {
            "type": "object",
            "description": "Shape of api_group_element in the storage backend.",
            "title": "GlobalSpecType",
            "x-displayname": "Specification",
            "x-ves-proto-message": "ves.io.schema.api_group_element.GlobalSpecType",
            "properties": {
                "methods": {
                    "type": "array",
                    "description": " List of method values to match the input request API method against.\n The match is considered to succeed if the input request API method is a member of the list.\n\nExample: - \"['PUT', 'POST', 'DELETE']\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.not_in: 0\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "methods",
                    "minItems": 1,
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "HTTP Methods",
                    "x-ves-example": "['PUT', 'POST', 'DELETE']",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.not_in": "0",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "path_regex": {
                    "type": "string",
                    "description": " Regular expression to match the input request API path against.\n The match is considered to succeed if the input request API path matches the specified path regex.\n\nExample: - \"/api/config/.*/path[123]/$\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 1024\n  ves.io.schema.rules.string.min_bytes: 1\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "path regex",
                    "minLength": 1,
                    "maxLength": 1024,
                    "x-displayname": "Path Regex",
                    "x-ves-example": "/api/config/.*/path[123]/$",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "1024",
                        "ves.io.schema.rules.string.min_bytes": "1",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                }
            }
        },
        "schemaviewsObjectRefType": {
            "type": "object",
            "description": "x-displayName: \"Object reference\"\nThis type establishes a direct reference from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name",
            "title": "ObjectRefType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Name\"\nx-example: \"contacts-route\"\nx-required\nWhen a configuration object(e.g. virtual_host) refers to another(e.g route)\nthen name will hold the referred object's(e.g. route's) name.",
                    "title": "name"
                },
                "namespace": {
                    "type": "string",
                    "description": "x-displayName: \"Namespace\"\nx-example: \"ns1\"\nWhen a configuration object(e.g. virtual_host) refers to another(e.g route)\nthen namespace will hold the referred object's(e.g. route's) namespace.",
                    "title": "namespace"
                },
                "tenant": {
                    "type": "string",
                    "description": "x-displayName: \"Tenant\"\nx-example: \"acmecorp\"\nWhen a configuration object(e.g. virtual_host) refers to another(e.g route)\nthen tenant will hold the referred object's(e.g. route's) tenant.",
                    "title": "tenant"
                }
            }
        },
        "viewsapp_api_groupGlobalSpecType": {
            "type": "object",
            "description": "Shape of app_api_group in the storage backend.",
            "title": "GlobalSpecType",
            "x-displayname": "Specification",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.GlobalSpecType",
            "properties": {
                "elements": {
                    "type": "array",
                    "description": " List of API group elements with methods and path regex for matching requests.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 1000\n",
                    "title": "elements",
                    "maxItems": 1000,
                    "items": {
                        "$ref": "#/definitions/schemaapi_group_elementGlobalSpecType"
                    },
                    "x-displayname": "API Group Elements",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "1000"
                    }
                }
            }
        }
    },
    "x-displayname": "API Inventory",
    "x-ves-proto-file": "ves.io/schema/views/api_inventory/public_config_customapi.proto"
}`
