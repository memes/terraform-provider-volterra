// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/cdn_loadbalancer/types.proto

package cdn_loadbalancer

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/rate_limiter"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/route"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/service_policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/service_policy_rule"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/cdn_loadbalancer/access_log"
	http_loadbalancer "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/http_loadbalancer"
	origin_pool "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/origin_pool"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/rate_limiter_policy"
	virtual_host "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host"
	virtual_host_dns_info "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host_dns_info"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Metrics Field Selector options
//
// x-displayName: "Metrics Field Selector"
// CDN Metric fields. Naming convention is <field>_<aggregation>
type LilacCDNMetricsFieldSelector int32

const (
	// x-displayName: " REQUEST_TOTAL_SUM"
	// REQUEST_SUCCESS computed from REQUEST_TOTAL - REQUEST_FAILED
	REQUEST_TOTAL_SUM LilacCDNMetricsFieldSelector = 0
	// x-displayName: " REQUEST_FAILED_SUM"
	REQUEST_FAILED_SUM LilacCDNMetricsFieldSelector = 1
	// x-displayName: " REQUEST_1XX_SUM"
	REQUEST_1XX_SUM LilacCDNMetricsFieldSelector = 2
	// x-displayName: " REQUEST_2XX_SUM"
	REQUEST_2XX_SUM LilacCDNMetricsFieldSelector = 3
	// x-displayName: " REQUEST_3XX_SUM"
	REQUEST_3XX_SUM LilacCDNMetricsFieldSelector = 4
	// x-displayName: " REQUEST_4XX_SUM"
	REQUEST_4XX_SUM LilacCDNMetricsFieldSelector = 5
	// x-displayName: " REQUEST_5XX_SUM"
	REQUEST_5XX_SUM LilacCDNMetricsFieldSelector = 6
	// x-displayName: " DATA_OUT_SUM"
	// Bandwidth computed from DATA_OUT
	DATA_OUT_SUM LilacCDNMetricsFieldSelector = 7
	// x-displayName: " LATENCY_MEAN"
	LATENCY_MEAN LilacCDNMetricsFieldSelector = 8
)

var LilacCDNMetricsFieldSelector_name = map[int32]string{
	0: "REQUEST_TOTAL_SUM",
	1: "REQUEST_FAILED_SUM",
	2: "REQUEST_1XX_SUM",
	3: "REQUEST_2XX_SUM",
	4: "REQUEST_3XX_SUM",
	5: "REQUEST_4XX_SUM",
	6: "REQUEST_5XX_SUM",
	7: "DATA_OUT_SUM",
	8: "LATENCY_MEAN",
}

var LilacCDNMetricsFieldSelector_value = map[string]int32{
	"REQUEST_TOTAL_SUM":  0,
	"REQUEST_FAILED_SUM": 1,
	"REQUEST_1XX_SUM":    2,
	"REQUEST_2XX_SUM":    3,
	"REQUEST_3XX_SUM":    4,
	"REQUEST_4XX_SUM":    5,
	"REQUEST_5XX_SUM":    6,
	"DATA_OUT_SUM":       7,
	"LATENCY_MEAN":       8,
}

func (LilacCDNMetricsFieldSelector) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{0}
}

// Metrics Tag options
//
// x-displayName: "Tags"
// Tags on which CDN metrics can be filtered or grouped by
type LilacCDNMetricsTag int32

const (
	// x-displayName: " CDN_DISTRIBUTION_NAME"
	CDN_DISTRIBUTION_NAME LilacCDNMetricsTag = 0
	// x-displayName: " CACHE_HIT_TYPE"
	// HIT|MISS
	CACHE_HIT_TYPE LilacCDNMetricsTag = 1
	// x-displayName: "Request originating country"
	// Two letter country code
	REQUEST_COUNTRY LilacCDNMetricsTag = 2
	// x-displayName: "HTTP Protocol Version"
	// http_1_1|http_2_0 etc
	HTTP_VERSION LilacCDNMetricsTag = 3
	// x-displayName: "TLS Protocol Version"
	// tlsv1_0|tlsv1_1|tlsv1_2 etc
	TLS_VERSION LilacCDNMetricsTag = 4
	// x-displayName: " Region of the PoP"
	POP_REGION LilacCDNMetricsTag = 5
	// x-displayName: "PoP"
	POP LilacCDNMetricsTag = 6
)

var LilacCDNMetricsTag_name = map[int32]string{
	0: "CDN_DISTRIBUTION_NAME",
	1: "CACHE_HIT_TYPE",
	2: "REQUEST_COUNTRY",
	3: "HTTP_VERSION",
	4: "TLS_VERSION",
	5: "POP_REGION",
	6: "POP",
}

var LilacCDNMetricsTag_value = map[string]int32{
	"CDN_DISTRIBUTION_NAME": 0,
	"CACHE_HIT_TYPE":        1,
	"REQUEST_COUNTRY":       2,
	"HTTP_VERSION":          3,
	"TLS_VERSION":           4,
	"POP_REGION":            5,
	"POP":                   6,
}

func (LilacCDNMetricsTag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{1}
}

// Metrics Operator Types
//
// x-displayName: "Metrics Operator Types"
// Operators possible in filtering
type LilacCDNMetricsOperatorType int32

const (
	// x-displayName: " IN Operator"
	OPERATOR_TYPE_IN LilacCDNMetricsOperatorType = 0
	// x-displayName: " Not-IN Operator"
	OPERATOR_TYPE_NOT_IN LilacCDNMetricsOperatorType = 1
)

var LilacCDNMetricsOperatorType_name = map[int32]string{
	0: "OPERATOR_TYPE_IN",
	1: "OPERATOR_TYPE_NOT_IN",
}

var LilacCDNMetricsOperatorType_value = map[string]int32{
	"OPERATOR_TYPE_IN":     0,
	"OPERATOR_TYPE_NOT_IN": 1,
}

func (LilacCDNMetricsOperatorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{2}
}

// Metric Unit
//
// x-displayName: "Metric Unit"
// Metric Unit
type LilacCDNMetricUnit int32

const (
	// x-displayName: "Count"
	COUNT LilacCDNMetricUnit = 0
	// x-displayName: "Bytes"
	BYTES LilacCDNMetricUnit = 1
	// x-displayName: "Milliseconds"
	MILLISECONDS LilacCDNMetricUnit = 2
)

var LilacCDNMetricUnit_name = map[int32]string{
	0: "COUNT",
	1: "BYTES",
	2: "MILLISECONDS",
}

var LilacCDNMetricUnit_value = map[string]int32{
	"COUNT":        0,
	"BYTES":        1,
	"MILLISECONDS": 2,
}

func (LilacCDNMetricUnit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{3}
}

// HTTPS with Auto Certs Choice
//
// x-displayName: "HTTPS with Auto Certs Choice"
// Choice for selecting HTTP proxy with bring your own certificates
type ProxyTypeHttpsAutoCerts struct {
	// HTTP Redirect
	//
	// x-displayName: "HTTP Redirect to HTTPS"
	// Redirect HTTP traffic to corresponding HTTPS
	HttpRedirect bool `protobuf:"varint,1,opt,name=http_redirect,json=httpRedirect,proto3" json:"http_redirect,omitempty"`
	// Add HSTS
	//
	// x-displayName: "Add HSTS Header"
	// Add HTTP Strict-Transport-Security response header
	AddHsts bool `protobuf:"varint,2,opt,name=add_hsts,json=addHsts,proto3" json:"add_hsts,omitempty"`
	// TLS Config
	//
	// x-displayName: "TLS Config"
	// Configuration for TLS parameters such as min/max TLS version and ciphers
	TlsConfig *views.TlsConfig `protobuf:"bytes,3,opt,name=tls_config,json=tlsConfig,proto3" json:"tls_config,omitempty"`
	// Server Header configuration
	//
	// x-displayName: "Server Header value to be used in response"
	// x-required
	// Specify Server Header value to be used in responses
	//
	// Types that are valid to be assigned to ServerHeaderChoice:
	//	*ProxyTypeHttpsAutoCerts_DefaultHeader
	//	*ProxyTypeHttpsAutoCerts_ServerName
	//	*ProxyTypeHttpsAutoCerts_AppendServerName
	//	*ProxyTypeHttpsAutoCerts_PassThrough
	ServerHeaderChoice isProxyTypeHttpsAutoCerts_ServerHeaderChoice `protobuf_oneof:"server_header_choice"`
}

func (m *ProxyTypeHttpsAutoCerts) Reset()      { *m = ProxyTypeHttpsAutoCerts{} }
func (*ProxyTypeHttpsAutoCerts) ProtoMessage() {}
func (*ProxyTypeHttpsAutoCerts) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{0}
}
func (m *ProxyTypeHttpsAutoCerts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyTypeHttpsAutoCerts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProxyTypeHttpsAutoCerts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyTypeHttpsAutoCerts.Merge(m, src)
}
func (m *ProxyTypeHttpsAutoCerts) XXX_Size() int {
	return m.Size()
}
func (m *ProxyTypeHttpsAutoCerts) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyTypeHttpsAutoCerts.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyTypeHttpsAutoCerts proto.InternalMessageInfo

type isProxyTypeHttpsAutoCerts_ServerHeaderChoice interface {
	isProxyTypeHttpsAutoCerts_ServerHeaderChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProxyTypeHttpsAutoCerts_DefaultHeader struct {
	DefaultHeader *schema.Empty `protobuf:"bytes,5,opt,name=default_header,json=defaultHeader,proto3,oneof" json:"default_header,omitempty"`
}
type ProxyTypeHttpsAutoCerts_ServerName struct {
	ServerName string `protobuf:"bytes,6,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type ProxyTypeHttpsAutoCerts_AppendServerName struct {
	AppendServerName string `protobuf:"bytes,7,opt,name=append_server_name,json=appendServerName,proto3,oneof" json:"append_server_name,omitempty"`
}
type ProxyTypeHttpsAutoCerts_PassThrough struct {
	PassThrough *schema.Empty `protobuf:"bytes,8,opt,name=pass_through,json=passThrough,proto3,oneof" json:"pass_through,omitempty"`
}

func (*ProxyTypeHttpsAutoCerts_DefaultHeader) isProxyTypeHttpsAutoCerts_ServerHeaderChoice()    {}
func (*ProxyTypeHttpsAutoCerts_ServerName) isProxyTypeHttpsAutoCerts_ServerHeaderChoice()       {}
func (*ProxyTypeHttpsAutoCerts_AppendServerName) isProxyTypeHttpsAutoCerts_ServerHeaderChoice() {}
func (*ProxyTypeHttpsAutoCerts_PassThrough) isProxyTypeHttpsAutoCerts_ServerHeaderChoice()      {}

func (m *ProxyTypeHttpsAutoCerts) GetServerHeaderChoice() isProxyTypeHttpsAutoCerts_ServerHeaderChoice {
	if m != nil {
		return m.ServerHeaderChoice
	}
	return nil
}

func (m *ProxyTypeHttpsAutoCerts) GetHttpRedirect() bool {
	if m != nil {
		return m.HttpRedirect
	}
	return false
}

func (m *ProxyTypeHttpsAutoCerts) GetAddHsts() bool {
	if m != nil {
		return m.AddHsts
	}
	return false
}

func (m *ProxyTypeHttpsAutoCerts) GetTlsConfig() *views.TlsConfig {
	if m != nil {
		return m.TlsConfig
	}
	return nil
}

func (m *ProxyTypeHttpsAutoCerts) GetDefaultHeader() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_DefaultHeader); ok {
		return x.DefaultHeader
	}
	return nil
}

func (m *ProxyTypeHttpsAutoCerts) GetServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *ProxyTypeHttpsAutoCerts) GetAppendServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_AppendServerName); ok {
		return x.AppendServerName
	}
	return ""
}

func (m *ProxyTypeHttpsAutoCerts) GetPassThrough() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_PassThrough); ok {
		return x.PassThrough
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProxyTypeHttpsAutoCerts) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProxyTypeHttpsAutoCerts_DefaultHeader)(nil),
		(*ProxyTypeHttpsAutoCerts_ServerName)(nil),
		(*ProxyTypeHttpsAutoCerts_AppendServerName)(nil),
		(*ProxyTypeHttpsAutoCerts_PassThrough)(nil),
	}
}

// Header Control
//
// x-displayName: "Header Control"
// This defines various options related to request/response headers
type HeaderControlType struct {
	// Headers to add in request
	//
	// x-displayName: "Add Origin Request Headers"
	// Headers are key-value pairs to be added to HTTP request being routed towards upstream.
	// Headers specified at this level are applied after headers from matched Route are applied
	RequestHeadersToAdd []*schema.HeaderManipulationOptionType `protobuf:"bytes,1,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	// Header to be removed from request
	//
	// x-displayName: "Remove Origin Request Headers"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP request being sent towards upstream.
	RequestHeadersToRemove []string `protobuf:"bytes,2,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	// Headers to add in response
	//
	// x-displayName: "Add Response Headers"
	// Headers are key-value pairs to be added to HTTP response being sent towards downstream.
	// Headers specified at this level are applied after headers from matched Route are applied
	ResponseHeadersToAdd []*schema.HeaderManipulationOptionType `protobuf:"bytes,3,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	// Header to be removed from response
	//
	// x-displayName: "Remove Response Headers"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP response being sent towards downstream.
	ResponseHeadersToRemove []string `protobuf:"bytes,4,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
}

func (m *HeaderControlType) Reset()      { *m = HeaderControlType{} }
func (*HeaderControlType) ProtoMessage() {}
func (*HeaderControlType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{1}
}
func (m *HeaderControlType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderControlType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderControlType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderControlType.Merge(m, src)
}
func (m *HeaderControlType) XXX_Size() int {
	return m.Size()
}
func (m *HeaderControlType) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderControlType.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderControlType proto.InternalMessageInfo

func (m *HeaderControlType) GetRequestHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *HeaderControlType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *HeaderControlType) GetResponseHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *HeaderControlType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

// Security options
//
// x-displayName: "Security Options"
// This defines various options related to security
type SecurityOptionsType struct {
	// ip_filtering
	//
	// x-displayName: "Client IP filtering Options"
	// IP filtering options
	IpFiltering *IpFilteringOptions `protobuf:"bytes,5,opt,name=ip_filtering,json=ipFiltering,proto3" json:"ip_filtering,omitempty"`
	// geo_filtering
	//
	// x-displayName: "Client Geo filtering Options"
	// Geo filtering options
	GeoFiltering *GeoFilteringOptions `protobuf:"bytes,6,opt,name=geo_filtering,json=geoFiltering,proto3" json:"geo_filtering,omitempty"`
	// authentication
	//
	// x-displayName: "Authentication Options"
	// Authentication Options
	AuthOptions *AuthenticationOptions `protobuf:"bytes,9,opt,name=auth_options,json=authOptions,proto3" json:"auth_options,omitempty"`
}

func (m *SecurityOptionsType) Reset()      { *m = SecurityOptionsType{} }
func (*SecurityOptionsType) ProtoMessage() {}
func (*SecurityOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{2}
}
func (m *SecurityOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecurityOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityOptionsType.Merge(m, src)
}
func (m *SecurityOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *SecurityOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityOptionsType proto.InternalMessageInfo

func (m *SecurityOptionsType) GetIpFiltering() *IpFilteringOptions {
	if m != nil {
		return m.IpFiltering
	}
	return nil
}

func (m *SecurityOptionsType) GetGeoFiltering() *GeoFilteringOptions {
	if m != nil {
		return m.GeoFiltering
	}
	return nil
}

func (m *SecurityOptionsType) GetAuthOptions() *AuthenticationOptions {
	if m != nil {
		return m.AuthOptions
	}
	return nil
}

// Logging options
//
// x-displayName: "Logging Options"
// This defines various options related to logging
type LoggingOptionsType struct {
	// client_log_options
	//
	// x-displayName: "Client Request Headers to Log"
	// Client request headers to log
	ClientLogOptions *LogHeaderOptions `protobuf:"bytes,7,opt,name=client_log_options,json=clientLogOptions,proto3" json:"client_log_options,omitempty"`
	// origin_log_options
	//
	// x-displayName: "Origin Response Headers to Log"
	// Origin response headers to log
	OriginLogOptions *LogHeaderOptions `protobuf:"bytes,8,opt,name=origin_log_options,json=originLogOptions,proto3" json:"origin_log_options,omitempty"`
}

func (m *LoggingOptionsType) Reset()      { *m = LoggingOptionsType{} }
func (*LoggingOptionsType) ProtoMessage() {}
func (*LoggingOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{3}
}
func (m *LoggingOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggingOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LoggingOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggingOptionsType.Merge(m, src)
}
func (m *LoggingOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *LoggingOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggingOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_LoggingOptionsType proto.InternalMessageInfo

func (m *LoggingOptionsType) GetClientLogOptions() *LogHeaderOptions {
	if m != nil {
		return m.ClientLogOptions
	}
	return nil
}

func (m *LoggingOptionsType) GetOriginLogOptions() *LogHeaderOptions {
	if m != nil {
		return m.OriginLogOptions
	}
	return nil
}

// Cache options
//
// x-displayName: "Cache Options"
// This defines the options related to content caching
type CacheTTLOptionsType struct {
	// Cache Options
	//
	// x-displayName: "Cache Settings"
	// Configure the Cache Settings
	//
	// Types that are valid to be assigned to TtlOptions:
	//	*CacheTTLOptionsType_CacheTtlDefault
	//	*CacheTTLOptionsType_CacheTtlOverride
	//	*CacheTTLOptionsType_CacheDisabled
	TtlOptions isCacheTTLOptionsType_TtlOptions `protobuf_oneof:"ttl_options"`
}

func (m *CacheTTLOptionsType) Reset()      { *m = CacheTTLOptionsType{} }
func (*CacheTTLOptionsType) ProtoMessage() {}
func (*CacheTTLOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{4}
}
func (m *CacheTTLOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheTTLOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheTTLOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheTTLOptionsType.Merge(m, src)
}
func (m *CacheTTLOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *CacheTTLOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheTTLOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_CacheTTLOptionsType proto.InternalMessageInfo

type isCacheTTLOptionsType_TtlOptions interface {
	isCacheTTLOptionsType_TtlOptions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CacheTTLOptionsType_CacheTtlDefault struct {
	CacheTtlDefault string `protobuf:"bytes,2,opt,name=cache_ttl_default,json=cacheTtlDefault,proto3,oneof" json:"cache_ttl_default,omitempty"`
}
type CacheTTLOptionsType_CacheTtlOverride struct {
	CacheTtlOverride string `protobuf:"bytes,3,opt,name=cache_ttl_override,json=cacheTtlOverride,proto3,oneof" json:"cache_ttl_override,omitempty"`
}
type CacheTTLOptionsType_CacheDisabled struct {
	CacheDisabled *schema.Empty `protobuf:"bytes,4,opt,name=cache_disabled,json=cacheDisabled,proto3,oneof" json:"cache_disabled,omitempty"`
}

func (*CacheTTLOptionsType_CacheTtlDefault) isCacheTTLOptionsType_TtlOptions()  {}
func (*CacheTTLOptionsType_CacheTtlOverride) isCacheTTLOptionsType_TtlOptions() {}
func (*CacheTTLOptionsType_CacheDisabled) isCacheTTLOptionsType_TtlOptions()    {}

func (m *CacheTTLOptionsType) GetTtlOptions() isCacheTTLOptionsType_TtlOptions {
	if m != nil {
		return m.TtlOptions
	}
	return nil
}

func (m *CacheTTLOptionsType) GetCacheTtlDefault() string {
	if x, ok := m.GetTtlOptions().(*CacheTTLOptionsType_CacheTtlDefault); ok {
		return x.CacheTtlDefault
	}
	return ""
}

func (m *CacheTTLOptionsType) GetCacheTtlOverride() string {
	if x, ok := m.GetTtlOptions().(*CacheTTLOptionsType_CacheTtlOverride); ok {
		return x.CacheTtlOverride
	}
	return ""
}

func (m *CacheTTLOptionsType) GetCacheDisabled() *schema.Empty {
	if x, ok := m.GetTtlOptions().(*CacheTTLOptionsType_CacheDisabled); ok {
		return x.CacheDisabled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CacheTTLOptionsType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CacheTTLOptionsType_CacheTtlDefault)(nil),
		(*CacheTTLOptionsType_CacheTtlOverride)(nil),
		(*CacheTTLOptionsType_CacheDisabled)(nil),
	}
}

// Advanced options
//
// x-displayName: "Advanced Options"
// This defines various options to define a route
type AdvancedOptionsType struct {
	// Header Control
	//
	// x-displayName: "Header Control"
	// Request/Response header related options
	HeaderOptions *HeaderControlType `protobuf:"bytes,16,opt,name=header_options,json=headerOptions,proto3" json:"header_options,omitempty"`
	// Security Options
	//
	// x-displayName: "Security Options"
	// Security related options
	SecurityOptions *SecurityOptionsType `protobuf:"bytes,17,opt,name=security_options,json=securityOptions,proto3" json:"security_options,omitempty"`
	// Logging Options
	//
	// x-displayName: "Logging Options"
	// Logging related options
	LoggingOptions *LoggingOptionsType `protobuf:"bytes,18,opt,name=logging_options,json=loggingOptions,proto3" json:"logging_options,omitempty"`
	// Cache Options
	//
	// x-displayName: "Cache Options"
	// Cache Options
	CacheTtlOptions *CacheTTLOptionsType `protobuf:"bytes,19,opt,name=cache_ttl_options,json=cacheTtlOptions,proto3" json:"cache_ttl_options,omitempty"`
}

func (m *AdvancedOptionsType) Reset()      { *m = AdvancedOptionsType{} }
func (*AdvancedOptionsType) ProtoMessage() {}
func (*AdvancedOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{5}
}
func (m *AdvancedOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvancedOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvancedOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvancedOptionsType.Merge(m, src)
}
func (m *AdvancedOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *AdvancedOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvancedOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvancedOptionsType proto.InternalMessageInfo

func (m *AdvancedOptionsType) GetHeaderOptions() *HeaderControlType {
	if m != nil {
		return m.HeaderOptions
	}
	return nil
}

func (m *AdvancedOptionsType) GetSecurityOptions() *SecurityOptionsType {
	if m != nil {
		return m.SecurityOptions
	}
	return nil
}

func (m *AdvancedOptionsType) GetLoggingOptions() *LoggingOptionsType {
	if m != nil {
		return m.LoggingOptions
	}
	return nil
}

func (m *AdvancedOptionsType) GetCacheTtlOptions() *CacheTTLOptionsType {
	if m != nil {
		return m.CacheTtlOptions
	}
	return nil
}

// CDNTLSConfig
//
// x-displayName: "TLS Config"
// This defines various options to configure TLS configuration parameters
type CDNTLSConfig struct {
	// TLS Security Level
	//
	// x-displayName: "TLS Security Level"
	// x-required
	// The security level for TLS handshake between client/server and the platform.
	//
	// Types that are valid to be assigned to Choice:
	//	*CDNTLSConfig_Tls_12Plus
	//	*CDNTLSConfig_Tls_11Plus
	Choice isCDNTLSConfig_Choice `protobuf_oneof:"choice"`
}

func (m *CDNTLSConfig) Reset()      { *m = CDNTLSConfig{} }
func (*CDNTLSConfig) ProtoMessage() {}
func (*CDNTLSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{6}
}
func (m *CDNTLSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNTLSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNTLSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNTLSConfig.Merge(m, src)
}
func (m *CDNTLSConfig) XXX_Size() int {
	return m.Size()
}
func (m *CDNTLSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNTLSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CDNTLSConfig proto.InternalMessageInfo

type isCDNTLSConfig_Choice interface {
	isCDNTLSConfig_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CDNTLSConfig_Tls_12Plus struct {
	Tls_12Plus *schema.Empty `protobuf:"bytes,1,opt,name=tls_12_plus,json=tls12Plus,proto3,oneof" json:"tls_12_plus,omitempty"`
}
type CDNTLSConfig_Tls_11Plus struct {
	Tls_11Plus *schema.Empty `protobuf:"bytes,2,opt,name=tls_11_plus,json=tls11Plus,proto3,oneof" json:"tls_11_plus,omitempty"`
}

func (*CDNTLSConfig_Tls_12Plus) isCDNTLSConfig_Choice() {}
func (*CDNTLSConfig_Tls_11Plus) isCDNTLSConfig_Choice() {}

func (m *CDNTLSConfig) GetChoice() isCDNTLSConfig_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *CDNTLSConfig) GetTls_12Plus() *schema.Empty {
	if x, ok := m.GetChoice().(*CDNTLSConfig_Tls_12Plus); ok {
		return x.Tls_12Plus
	}
	return nil
}

func (m *CDNTLSConfig) GetTls_11Plus() *schema.Empty {
	if x, ok := m.GetChoice().(*CDNTLSConfig_Tls_11Plus); ok {
		return x.Tls_11Plus
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CDNTLSConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CDNTLSConfig_Tls_12Plus)(nil),
		(*CDNTLSConfig_Tls_11Plus)(nil),
	}
}

// HTTPS with Automatic Certificate
//
// x-displayName: "HTTPS with Automatic Certificate"
// Choice for selecting HTTPS CDN distribution with bring your own certificates
type CDNHTTPSAutoCertsType struct {
	// HTTP Redirect
	//
	// x-displayName: "HTTP Redirect to HTTPS"
	// Redirect HTTP traffic to HTTPS
	HttpRedirect bool `protobuf:"varint,1,opt,name=http_redirect,json=httpRedirect,proto3" json:"http_redirect,omitempty"`
	// Add HSTS
	//
	// x-displayName: "Add HSTS Header"
	// Add HTTP Strict-Transport-Security response header
	AddHsts bool `protobuf:"varint,2,opt,name=add_hsts,json=addHsts,proto3" json:"add_hsts,omitempty"`
	// TLS Config
	//
	// x-displayName: "TLS"
	// TLS Configuration Parameters
	TlsConfig *CDNTLSConfig `protobuf:"bytes,3,opt,name=tls_config,json=tlsConfig,proto3" json:"tls_config,omitempty"`
}

func (m *CDNHTTPSAutoCertsType) Reset()      { *m = CDNHTTPSAutoCertsType{} }
func (*CDNHTTPSAutoCertsType) ProtoMessage() {}
func (*CDNHTTPSAutoCertsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{7}
}
func (m *CDNHTTPSAutoCertsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNHTTPSAutoCertsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNHTTPSAutoCertsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNHTTPSAutoCertsType.Merge(m, src)
}
func (m *CDNHTTPSAutoCertsType) XXX_Size() int {
	return m.Size()
}
func (m *CDNHTTPSAutoCertsType) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNHTTPSAutoCertsType.DiscardUnknown(m)
}

var xxx_messageInfo_CDNHTTPSAutoCertsType proto.InternalMessageInfo

func (m *CDNHTTPSAutoCertsType) GetHttpRedirect() bool {
	if m != nil {
		return m.HttpRedirect
	}
	return false
}

func (m *CDNHTTPSAutoCertsType) GetAddHsts() bool {
	if m != nil {
		return m.AddHsts
	}
	return false
}

func (m *CDNHTTPSAutoCertsType) GetTlsConfig() *CDNTLSConfig {
	if m != nil {
		return m.TlsConfig
	}
	return nil
}

// CDNDownstreamTlsParamsType
//
// x-displayName: "TLS Parameters"
// TLS parameters for CDN distribution
type CDNDownstreamTlsParamsType struct {
	// TLS Config
	//
	// x-displayName: "TLS"
	// TLS Configuration Parameters
	TlsConfig *CDNTLSConfig `protobuf:"bytes,1,opt,name=tls_config,json=tlsConfig,proto3" json:"tls_config,omitempty"`
	// tls_certificates
	//
	// x-displayName: "TLS Certificates"
	// x-required
	// Users can add one or more certificates that share the same set of domains.
	// for example, domain.com and *.domain.com - but use different signature algorithms
	TlsCertificates []*schema.TlsCertificateType `protobuf:"bytes,2,rep,name=tls_certificates,json=tlsCertificates,proto3" json:"tls_certificates,omitempty"`
}

func (m *CDNDownstreamTlsParamsType) Reset()      { *m = CDNDownstreamTlsParamsType{} }
func (*CDNDownstreamTlsParamsType) ProtoMessage() {}
func (*CDNDownstreamTlsParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{8}
}
func (m *CDNDownstreamTlsParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNDownstreamTlsParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNDownstreamTlsParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNDownstreamTlsParamsType.Merge(m, src)
}
func (m *CDNDownstreamTlsParamsType) XXX_Size() int {
	return m.Size()
}
func (m *CDNDownstreamTlsParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNDownstreamTlsParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_CDNDownstreamTlsParamsType proto.InternalMessageInfo

func (m *CDNDownstreamTlsParamsType) GetTlsConfig() *CDNTLSConfig {
	if m != nil {
		return m.TlsConfig
	}
	return nil
}

func (m *CDNDownstreamTlsParamsType) GetTlsCertificates() []*schema.TlsCertificateType {
	if m != nil {
		return m.TlsCertificates
	}
	return nil
}

// BYOC for the CDN distribution
//
// x-displayName: "BYOC HTTPS Choice"
// Choice for selecting CDN Distribution with bring your own certificates
type CDNHTTPSCustomCertsType struct {
	// HTTP Redirect
	//
	// x-displayName: "HTTP Redirect to HTTPS"
	// Redirect HTTP traffic to HTTPS
	HttpRedirect bool `protobuf:"varint,1,opt,name=http_redirect,json=httpRedirect,proto3" json:"http_redirect,omitempty"`
	// Add HSTS
	//
	// x-displayName: "Add HSTS Header"
	// Add HTTP Strict-Transport-Security response header
	AddHsts bool `protobuf:"varint,2,opt,name=add_hsts,json=addHsts,proto3" json:"add_hsts,omitempty"`
	// TLS parameters.
	//
	// x-displayName: "TLS Parameters"
	// TLS parameters for the downstream connections.
	TlsParameters *CDNDownstreamTlsParamsType `protobuf:"bytes,3,opt,name=tls_parameters,json=tlsParameters,proto3" json:"tls_parameters,omitempty"`
}

func (m *CDNHTTPSCustomCertsType) Reset()      { *m = CDNHTTPSCustomCertsType{} }
func (*CDNHTTPSCustomCertsType) ProtoMessage() {}
func (*CDNHTTPSCustomCertsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{9}
}
func (m *CDNHTTPSCustomCertsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNHTTPSCustomCertsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNHTTPSCustomCertsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNHTTPSCustomCertsType.Merge(m, src)
}
func (m *CDNHTTPSCustomCertsType) XXX_Size() int {
	return m.Size()
}
func (m *CDNHTTPSCustomCertsType) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNHTTPSCustomCertsType.DiscardUnknown(m)
}

var xxx_messageInfo_CDNHTTPSCustomCertsType proto.InternalMessageInfo

func (m *CDNHTTPSCustomCertsType) GetHttpRedirect() bool {
	if m != nil {
		return m.HttpRedirect
	}
	return false
}

func (m *CDNHTTPSCustomCertsType) GetAddHsts() bool {
	if m != nil {
		return m.AddHsts
	}
	return false
}

func (m *CDNHTTPSCustomCertsType) GetTlsParameters() *CDNDownstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Global Specification"
// Shape of the CDN loadbalancer specification
type GlobalSpecType struct {
	// Domains
	//
	// x-displayName: "Domains"
	// x-example: "www.foo.com"
	// x-required
	// A list of fully qualified domain names.
	// The CDN Distribution will be setup for these FQDN name(s).
	// [This can be a domain or a sub-domain]
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// Proxy choice
	//
	// x-displayName: "Select Type of CDN Distribution"
	// x-required
	// CDN Distribution type can be "http" or "https"
	//
	// Types that are valid to be assigned to LoadbalancerType:
	//	*GlobalSpecType_Http
	//	*GlobalSpecType_HttpsAutoCert
	//	*GlobalSpecType_Https
	LoadbalancerType isGlobalSpecType_LoadbalancerType `protobuf_oneof:"loadbalancer_type"`
	// Add Site information
	//
	// x-displayName: "Add Location"
	// x-example: "true"
	// x-example: true
	// Appends header x-volterra-location = <re-site-name> in responses.
	AddLocation bool `protobuf:"varint,11,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	// More Options
	//
	// x-displayName: "More Options"
	// More options like header manipulation, compression etc.
	MoreOption *AdvancedOptionsType `protobuf:"bytes,13,opt,name=more_option,json=moreOption,proto3" json:"more_option,omitempty"`
	// Origin Pool
	//
	// x-displayName: "CDN Origin Pool"
	// x-required
	OriginPool *CdnOriginPoolType `protobuf:"bytes,16,opt,name=origin_pool,json=originPool,proto3" json:"origin_pool,omitempty"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal,proto3" json:"view_internal,omitempty"`
	// host name
	//
	// x-displayName: "Host Name"
	// x-example: "ves-io-cf8684b9-a18f-4843-a24f-1f9ee8ea2776.ac.vh.ves.io"
	// Internally generated host name to be used for the virtual host
	HostName string `protobuf:"bytes,1001,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// DNS information
	//
	// x-displayName: "DNS Information"
	// DNS information for this virtual host
	DnsInfo []*virtual_host_dns_info.DnsInfo `protobuf:"bytes,1002,rep,name=dns_info,json=dnsInfo,proto3" json:"dns_info,omitempty"`
	// Virtual Host state
	//
	// x-displayName: "Virtual Host State"
	// State of the virtual host
	State virtual_host.VirtualHostState `protobuf:"varint,1003,opt,name=state,proto3,enum=ves.io.schema.virtual_host.VirtualHostState" json:"state,omitempty"`
	// Auto Cert State
	//
	// x-displayName: "Auto Cert State"
	// State of auto certificate generation.
	AutoCertState virtual_host.CertificationState `protobuf:"varint,1004,opt,name=auto_cert_state,json=autoCertState,proto3,enum=ves.io.schema.virtual_host.CertificationState" json:"auto_cert_state,omitempty"` // Deprecated: Do not use.
	// Auto Cert Information
	//
	// x-displayName: "Auto Cert Information"
	// Auto certificate related information
	AutoCertInfo *virtual_host.AutoCertInfoType `protobuf:"bytes,1010,opt,name=auto_cert_info,json=autoCertInfo,proto3" json:"auto_cert_info,omitempty"`
	// Service Domains
	//
	// x-displayName: "Service Domains"
	// CNAME provided from service per domain
	ServiceDomains []*virtual_host.ServiceDomain `protobuf:"bytes,1011,rep,name=service_domains,json=serviceDomains,proto3" json:"service_domains,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{10}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_LoadbalancerType interface {
	isGlobalSpecType_LoadbalancerType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_Http struct {
	Http *http_loadbalancer.ProxyTypeHttp `protobuf:"bytes,3,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type GlobalSpecType_HttpsAutoCert struct {
	HttpsAutoCert *CDNHTTPSAutoCertsType `protobuf:"bytes,18,opt,name=https_auto_cert,json=httpsAutoCert,proto3,oneof" json:"https_auto_cert,omitempty"`
}
type GlobalSpecType_Https struct {
	Https *CDNHTTPSCustomCertsType `protobuf:"bytes,19,opt,name=https,proto3,oneof" json:"https,omitempty"`
}

func (*GlobalSpecType_Http) isGlobalSpecType_LoadbalancerType()          {}
func (*GlobalSpecType_HttpsAutoCert) isGlobalSpecType_LoadbalancerType() {}
func (*GlobalSpecType_Https) isGlobalSpecType_LoadbalancerType()         {}

func (m *GlobalSpecType) GetLoadbalancerType() isGlobalSpecType_LoadbalancerType {
	if m != nil {
		return m.LoadbalancerType
	}
	return nil
}

func (m *GlobalSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *GlobalSpecType) GetHttp() *http_loadbalancer.ProxyTypeHttp {
	if x, ok := m.GetLoadbalancerType().(*GlobalSpecType_Http); ok {
		return x.Http
	}
	return nil
}

func (m *GlobalSpecType) GetHttpsAutoCert() *CDNHTTPSAutoCertsType {
	if x, ok := m.GetLoadbalancerType().(*GlobalSpecType_HttpsAutoCert); ok {
		return x.HttpsAutoCert
	}
	return nil
}

func (m *GlobalSpecType) GetHttps() *CDNHTTPSCustomCertsType {
	if x, ok := m.GetLoadbalancerType().(*GlobalSpecType_Https); ok {
		return x.Https
	}
	return nil
}

func (m *GlobalSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *GlobalSpecType) GetMoreOption() *AdvancedOptionsType {
	if m != nil {
		return m.MoreOption
	}
	return nil
}

func (m *GlobalSpecType) GetOriginPool() *CdnOriginPoolType {
	if m != nil {
		return m.OriginPool
	}
	return nil
}

func (m *GlobalSpecType) GetViewInternal() *views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

func (m *GlobalSpecType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *GlobalSpecType) GetDnsInfo() []*virtual_host_dns_info.DnsInfo {
	if m != nil {
		return m.DnsInfo
	}
	return nil
}

func (m *GlobalSpecType) GetState() virtual_host.VirtualHostState {
	if m != nil {
		return m.State
	}
	return virtual_host.VIRTUAL_HOST_READY
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetAutoCertState() virtual_host.CertificationState {
	if m != nil {
		return m.AutoCertState
	}
	return virtual_host.AutoCertDisabled
}

func (m *GlobalSpecType) GetAutoCertInfo() *virtual_host.AutoCertInfoType {
	if m != nil {
		return m.AutoCertInfo
	}
	return nil
}

func (m *GlobalSpecType) GetServiceDomains() []*virtual_host.ServiceDomain {
	if m != nil {
		return m.ServiceDomains
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_Http)(nil),
		(*GlobalSpecType_HttpsAutoCert)(nil),
		(*GlobalSpecType_Https)(nil),
	}
}

// IpFilteringOptions
//
// x-displayName: "IP Filtering Options"
// Options to filter based on IP prefix
type IpFilteringOptions struct {
	// ip_filtering_type
	//
	// x-displayName: "Ip Filtering Type"
	// Type of IP filtering (Allow vs Block)
	//
	// Types that are valid to be assigned to IpFilteringType:
	//	*IpFilteringOptions_AllowList
	//	*IpFilteringOptions_BlockList
	IpFilteringType isIpFilteringOptions_IpFilteringType `protobuf_oneof:"ip_filtering_type"`
}

func (m *IpFilteringOptions) Reset()      { *m = IpFilteringOptions{} }
func (*IpFilteringOptions) ProtoMessage() {}
func (*IpFilteringOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{11}
}
func (m *IpFilteringOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpFilteringOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpFilteringOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpFilteringOptions.Merge(m, src)
}
func (m *IpFilteringOptions) XXX_Size() int {
	return m.Size()
}
func (m *IpFilteringOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_IpFilteringOptions.DiscardUnknown(m)
}

var xxx_messageInfo_IpFilteringOptions proto.InternalMessageInfo

type isIpFilteringOptions_IpFilteringType interface {
	isIpFilteringOptions_IpFilteringType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IpFilteringOptions_AllowList struct {
	AllowList *policy.PrefixMatchList `protobuf:"bytes,2,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type IpFilteringOptions_BlockList struct {
	BlockList *policy.PrefixMatchList `protobuf:"bytes,3,opt,name=block_list,json=blockList,proto3,oneof" json:"block_list,omitempty"`
}

func (*IpFilteringOptions_AllowList) isIpFilteringOptions_IpFilteringType() {}
func (*IpFilteringOptions_BlockList) isIpFilteringOptions_IpFilteringType() {}

func (m *IpFilteringOptions) GetIpFilteringType() isIpFilteringOptions_IpFilteringType {
	if m != nil {
		return m.IpFilteringType
	}
	return nil
}

func (m *IpFilteringOptions) GetAllowList() *policy.PrefixMatchList {
	if x, ok := m.GetIpFilteringType().(*IpFilteringOptions_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *IpFilteringOptions) GetBlockList() *policy.PrefixMatchList {
	if x, ok := m.GetIpFilteringType().(*IpFilteringOptions_BlockList); ok {
		return x.BlockList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IpFilteringOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IpFilteringOptions_AllowList)(nil),
		(*IpFilteringOptions_BlockList)(nil),
	}
}

// GeoFilteringOptions
//
// x-displayName: "Geo Filtering Options"
// Options to filter based on Geo prefix
type GeoFilteringOptions struct {
	// geo_filtering_type
	//
	// x-displayName: "Geo Filtering Type"
	// Type of Geo filtering (Allow vs Block)
	//
	// Types that are valid to be assigned to GeoFilteringType:
	//	*GeoFilteringOptions_AllowList
	//	*GeoFilteringOptions_BlockList
	GeoFilteringType isGeoFilteringOptions_GeoFilteringType `protobuf_oneof:"geo_filtering_type"`
}

func (m *GeoFilteringOptions) Reset()      { *m = GeoFilteringOptions{} }
func (*GeoFilteringOptions) ProtoMessage() {}
func (*GeoFilteringOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{12}
}
func (m *GeoFilteringOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoFilteringOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GeoFilteringOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoFilteringOptions.Merge(m, src)
}
func (m *GeoFilteringOptions) XXX_Size() int {
	return m.Size()
}
func (m *GeoFilteringOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoFilteringOptions.DiscardUnknown(m)
}

var xxx_messageInfo_GeoFilteringOptions proto.InternalMessageInfo

type isGeoFilteringOptions_GeoFilteringType interface {
	isGeoFilteringOptions_GeoFilteringType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GeoFilteringOptions_AllowList struct {
	AllowList *policy.CountryCodeList `protobuf:"bytes,2,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type GeoFilteringOptions_BlockList struct {
	BlockList *policy.CountryCodeList `protobuf:"bytes,3,opt,name=block_list,json=blockList,proto3,oneof" json:"block_list,omitempty"`
}

func (*GeoFilteringOptions_AllowList) isGeoFilteringOptions_GeoFilteringType() {}
func (*GeoFilteringOptions_BlockList) isGeoFilteringOptions_GeoFilteringType() {}

func (m *GeoFilteringOptions) GetGeoFilteringType() isGeoFilteringOptions_GeoFilteringType {
	if m != nil {
		return m.GeoFilteringType
	}
	return nil
}

func (m *GeoFilteringOptions) GetAllowList() *policy.CountryCodeList {
	if x, ok := m.GetGeoFilteringType().(*GeoFilteringOptions_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *GeoFilteringOptions) GetBlockList() *policy.CountryCodeList {
	if x, ok := m.GetGeoFilteringType().(*GeoFilteringOptions_BlockList); ok {
		return x.BlockList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GeoFilteringOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GeoFilteringOptions_AllowList)(nil),
		(*GeoFilteringOptions_BlockList)(nil),
	}
}

// LogHeaderOptions
//
// x-displayName: "Headers to Log"
// List of headers to Log
type LogHeaderOptions struct {
	// List of Headers
	//
	// x-displayName: "Headers"
	// x-example: "x-custom-length"
	// List of headers
	HeaderList []string `protobuf:"bytes,1,rep,name=header_list,json=headerList,proto3" json:"header_list,omitempty"`
}

func (m *LogHeaderOptions) Reset()      { *m = LogHeaderOptions{} }
func (*LogHeaderOptions) ProtoMessage() {}
func (*LogHeaderOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{13}
}
func (m *LogHeaderOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogHeaderOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogHeaderOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogHeaderOptions.Merge(m, src)
}
func (m *LogHeaderOptions) XXX_Size() int {
	return m.Size()
}
func (m *LogHeaderOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_LogHeaderOptions.DiscardUnknown(m)
}

var xxx_messageInfo_LogHeaderOptions proto.InternalMessageInfo

func (m *LogHeaderOptions) GetHeaderList() []string {
	if m != nil {
		return m.HeaderList
	}
	return nil
}

// CDNCustomAuthentication
//
// x-displayName: "Custom Authentication"
// Custom  Authentication
type CDNCustomAuthentication struct {
	// custom_auth_config
	//
	// x-displayName: "Custom Auth Config"
	// x-example: ""
	// Custom Authentication Configuration
	CustomAuthConfig string `protobuf:"bytes,1,opt,name=custom_auth_config,json=customAuthConfig,proto3" json:"custom_auth_config,omitempty"`
}

func (m *CDNCustomAuthentication) Reset()      { *m = CDNCustomAuthentication{} }
func (*CDNCustomAuthentication) ProtoMessage() {}
func (*CDNCustomAuthentication) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{14}
}
func (m *CDNCustomAuthentication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNCustomAuthentication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNCustomAuthentication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNCustomAuthentication.Merge(m, src)
}
func (m *CDNCustomAuthentication) XXX_Size() int {
	return m.Size()
}
func (m *CDNCustomAuthentication) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNCustomAuthentication.DiscardUnknown(m)
}

var xxx_messageInfo_CDNCustomAuthentication proto.InternalMessageInfo

func (m *CDNCustomAuthentication) GetCustomAuthConfig() string {
	if m != nil {
		return m.CustomAuthConfig
	}
	return ""
}

// AuthenticationOptions
//
// x-displayName: "Authentication Options"
// Options to authenticate incoming client requests
type AuthenticationOptions struct {
	// Authentication Options
	//
	// x-displayName: "Authentication Type"
	// Type of Authentication
	//
	// Types that are valid to be assigned to AuthOptions:
	//	*AuthenticationOptions_DisableAuth
	//	*AuthenticationOptions_Jwt
	//	*AuthenticationOptions_Custom
	AuthOptions isAuthenticationOptions_AuthOptions `protobuf_oneof:"auth_options"`
}

func (m *AuthenticationOptions) Reset()      { *m = AuthenticationOptions{} }
func (*AuthenticationOptions) ProtoMessage() {}
func (*AuthenticationOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{15}
}
func (m *AuthenticationOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticationOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AuthenticationOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticationOptions.Merge(m, src)
}
func (m *AuthenticationOptions) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticationOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticationOptions.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticationOptions proto.InternalMessageInfo

type isAuthenticationOptions_AuthOptions interface {
	isAuthenticationOptions_AuthOptions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AuthenticationOptions_DisableAuth struct {
	DisableAuth *schema.Empty `protobuf:"bytes,2,opt,name=disable_auth,json=disableAuth,proto3,oneof" json:"disable_auth,omitempty"`
}
type AuthenticationOptions_Jwt struct {
	Jwt *policy.JwtTokenAuthOptions `protobuf:"bytes,3,opt,name=jwt,proto3,oneof" json:"jwt,omitempty"`
}
type AuthenticationOptions_Custom struct {
	Custom *CDNCustomAuthentication `protobuf:"bytes,4,opt,name=custom,proto3,oneof" json:"custom,omitempty"`
}

func (*AuthenticationOptions_DisableAuth) isAuthenticationOptions_AuthOptions() {}
func (*AuthenticationOptions_Jwt) isAuthenticationOptions_AuthOptions()         {}
func (*AuthenticationOptions_Custom) isAuthenticationOptions_AuthOptions()      {}

func (m *AuthenticationOptions) GetAuthOptions() isAuthenticationOptions_AuthOptions {
	if m != nil {
		return m.AuthOptions
	}
	return nil
}

func (m *AuthenticationOptions) GetDisableAuth() *schema.Empty {
	if x, ok := m.GetAuthOptions().(*AuthenticationOptions_DisableAuth); ok {
		return x.DisableAuth
	}
	return nil
}

func (m *AuthenticationOptions) GetJwt() *policy.JwtTokenAuthOptions {
	if x, ok := m.GetAuthOptions().(*AuthenticationOptions_Jwt); ok {
		return x.Jwt
	}
	return nil
}

func (m *AuthenticationOptions) GetCustom() *CDNCustomAuthentication {
	if x, ok := m.GetAuthOptions().(*AuthenticationOptions_Custom); ok {
		return x.Custom
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AuthenticationOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AuthenticationOptions_DisableAuth)(nil),
		(*AuthenticationOptions_Jwt)(nil),
		(*AuthenticationOptions_Custom)(nil),
	}
}

// CDNOriginServerType
//
// x-displayName: "Origin Server"
// Various options to specify origin server
type CDNOriginServerType struct {
	// Origin Server Type
	//
	// x-displayName: "Select Type of Origin Server"
	// x-required
	// Various options to specify origin server
	//
	// Types that are valid to be assigned to Choice:
	//	*CDNOriginServerType_PublicIp
	//	*CDNOriginServerType_PublicName
	Choice isCDNOriginServerType_Choice `protobuf_oneof:"choice"`
}

func (m *CDNOriginServerType) Reset()      { *m = CDNOriginServerType{} }
func (*CDNOriginServerType) ProtoMessage() {}
func (*CDNOriginServerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{16}
}
func (m *CDNOriginServerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNOriginServerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNOriginServerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNOriginServerType.Merge(m, src)
}
func (m *CDNOriginServerType) XXX_Size() int {
	return m.Size()
}
func (m *CDNOriginServerType) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNOriginServerType.DiscardUnknown(m)
}

var xxx_messageInfo_CDNOriginServerType proto.InternalMessageInfo

type isCDNOriginServerType_Choice interface {
	isCDNOriginServerType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CDNOriginServerType_PublicIp struct {
	PublicIp *origin_pool.OriginServerPublicIP `protobuf:"bytes,2,opt,name=public_ip,json=publicIp,proto3,oneof" json:"public_ip,omitempty"`
}
type CDNOriginServerType_PublicName struct {
	PublicName *origin_pool.OriginServerPublicName `protobuf:"bytes,3,opt,name=public_name,json=publicName,proto3,oneof" json:"public_name,omitempty"`
}

func (*CDNOriginServerType_PublicIp) isCDNOriginServerType_Choice()   {}
func (*CDNOriginServerType_PublicName) isCDNOriginServerType_Choice() {}

func (m *CDNOriginServerType) GetChoice() isCDNOriginServerType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *CDNOriginServerType) GetPublicIp() *origin_pool.OriginServerPublicIP {
	if x, ok := m.GetChoice().(*CDNOriginServerType_PublicIp); ok {
		return x.PublicIp
	}
	return nil
}

func (m *CDNOriginServerType) GetPublicName() *origin_pool.OriginServerPublicName {
	if x, ok := m.GetChoice().(*CDNOriginServerType_PublicName); ok {
		return x.PublicName
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CDNOriginServerType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CDNOriginServerType_PublicIp)(nil),
		(*CDNOriginServerType_PublicName)(nil),
	}
}

// CdnOriginPoolType
//
// x-displayName: "CDN Origin Pool"
// Origin Pool for the CDN distribution
type CdnOriginPoolType struct {
	// OriginServerPublicName
	//
	// x-required
	// x-displayName: "Origin Host Header"
	// The DNS name to be used as the host header for the request to the origin server
	PublicName *origin_pool.OriginServerPublicName `protobuf:"bytes,1,opt,name=public_name,json=publicName,proto3" json:"public_name,omitempty"`
	// Enable TLS
	//
	// x-displayName: "Enable TLS for Origin Servers"
	// x-required
	// Choice to enable TLS for origin servers
	//
	// Types that are valid to be assigned to TlsChoice:
	//	*CdnOriginPoolType_NoTls
	//	*CdnOriginPoolType_UseTls
	TlsChoice isCdnOriginPoolType_TlsChoice `protobuf_oneof:"tls_choice"`
	// List of Origin Servers
	//
	// x-displayName: "List Of Origin Servers"
	// x-required
	// List of original servers
	OriginServers []*CDNOriginServerType `protobuf:"bytes,5,rep,name=origin_servers,json=originServers,proto3" json:"origin_servers,omitempty"`
	// Follow Origin Redirect
	//
	// x-displayName: "Follow Origin Redirect"
	// x-example: "true"
	// x-example: true
	// Instructs the CDN to follow redirects from the origin server(s)
	FollowOriginRedirect bool `protobuf:"varint,6,opt,name=follow_origin_redirect,json=followOriginRedirect,proto3" json:"follow_origin_redirect,omitempty"`
	// Origin Request Timeout
	//
	// x-displayName: "Origin Request Timeout Duration"
	// x-example: "100s"
	// Configures the time after which a request to the origin will time out waiting for a response
	OriginRequestTimeout string `protobuf:"bytes,7,opt,name=origin_request_timeout,json=originRequestTimeout,proto3" json:"origin_request_timeout,omitempty"`
}

func (m *CdnOriginPoolType) Reset()      { *m = CdnOriginPoolType{} }
func (*CdnOriginPoolType) ProtoMessage() {}
func (*CdnOriginPoolType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{17}
}
func (m *CdnOriginPoolType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CdnOriginPoolType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CdnOriginPoolType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CdnOriginPoolType.Merge(m, src)
}
func (m *CdnOriginPoolType) XXX_Size() int {
	return m.Size()
}
func (m *CdnOriginPoolType) XXX_DiscardUnknown() {
	xxx_messageInfo_CdnOriginPoolType.DiscardUnknown(m)
}

var xxx_messageInfo_CdnOriginPoolType proto.InternalMessageInfo

type isCdnOriginPoolType_TlsChoice interface {
	isCdnOriginPoolType_TlsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CdnOriginPoolType_NoTls struct {
	NoTls *schema.Empty `protobuf:"bytes,3,opt,name=no_tls,json=noTls,proto3,oneof" json:"no_tls,omitempty"`
}
type CdnOriginPoolType_UseTls struct {
	UseTls *origin_pool.UpstreamTlsParameters `protobuf:"bytes,4,opt,name=use_tls,json=useTls,proto3,oneof" json:"use_tls,omitempty"`
}

func (*CdnOriginPoolType_NoTls) isCdnOriginPoolType_TlsChoice()  {}
func (*CdnOriginPoolType_UseTls) isCdnOriginPoolType_TlsChoice() {}

func (m *CdnOriginPoolType) GetTlsChoice() isCdnOriginPoolType_TlsChoice {
	if m != nil {
		return m.TlsChoice
	}
	return nil
}

func (m *CdnOriginPoolType) GetPublicName() *origin_pool.OriginServerPublicName {
	if m != nil {
		return m.PublicName
	}
	return nil
}

func (m *CdnOriginPoolType) GetNoTls() *schema.Empty {
	if x, ok := m.GetTlsChoice().(*CdnOriginPoolType_NoTls); ok {
		return x.NoTls
	}
	return nil
}

func (m *CdnOriginPoolType) GetUseTls() *origin_pool.UpstreamTlsParameters {
	if x, ok := m.GetTlsChoice().(*CdnOriginPoolType_UseTls); ok {
		return x.UseTls
	}
	return nil
}

func (m *CdnOriginPoolType) GetOriginServers() []*CDNOriginServerType {
	if m != nil {
		return m.OriginServers
	}
	return nil
}

func (m *CdnOriginPoolType) GetFollowOriginRedirect() bool {
	if m != nil {
		return m.FollowOriginRedirect
	}
	return false
}

func (m *CdnOriginPoolType) GetOriginRequestTimeout() string {
	if m != nil {
		return m.OriginRequestTimeout
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CdnOriginPoolType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CdnOriginPoolType_NoTls)(nil),
		(*CdnOriginPoolType_UseTls)(nil),
	}
}

// CreateSpecType
//
// x-displayName: "Create CDN Loadbalancer"
// Shape of the CDN loadbalancer specification
type CreateSpecType struct {
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// Types that are valid to be assigned to LoadbalancerType:
	//	*CreateSpecType_Http
	//	*CreateSpecType_HttpsAutoCert
	//	*CreateSpecType_Https
	LoadbalancerType isCreateSpecType_LoadbalancerType `protobuf_oneof:"loadbalancer_type"`
	AddLocation      bool                              `protobuf:"varint,11,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	MoreOption       *AdvancedOptionsType              `protobuf:"bytes,13,opt,name=more_option,json=moreOption,proto3" json:"more_option,omitempty"`
	// Origin Pool
	//
	// x-displayName: "CDN Origin Pool"
	// x-required
	OriginPool *CdnOriginPoolType `protobuf:"bytes,16,opt,name=origin_pool,json=originPool,proto3" json:"origin_pool,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{18}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_LoadbalancerType interface {
	isCreateSpecType_LoadbalancerType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_Http struct {
	Http *http_loadbalancer.ProxyTypeHttp `protobuf:"bytes,3,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type CreateSpecType_HttpsAutoCert struct {
	HttpsAutoCert *CDNHTTPSAutoCertsType `protobuf:"bytes,18,opt,name=https_auto_cert,json=httpsAutoCert,proto3,oneof" json:"https_auto_cert,omitempty"`
}
type CreateSpecType_Https struct {
	Https *CDNHTTPSCustomCertsType `protobuf:"bytes,19,opt,name=https,proto3,oneof" json:"https,omitempty"`
}

func (*CreateSpecType_Http) isCreateSpecType_LoadbalancerType()          {}
func (*CreateSpecType_HttpsAutoCert) isCreateSpecType_LoadbalancerType() {}
func (*CreateSpecType_Https) isCreateSpecType_LoadbalancerType()         {}

func (m *CreateSpecType) GetLoadbalancerType() isCreateSpecType_LoadbalancerType {
	if m != nil {
		return m.LoadbalancerType
	}
	return nil
}

func (m *CreateSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *CreateSpecType) GetHttp() *http_loadbalancer.ProxyTypeHttp {
	if x, ok := m.GetLoadbalancerType().(*CreateSpecType_Http); ok {
		return x.Http
	}
	return nil
}

func (m *CreateSpecType) GetHttpsAutoCert() *CDNHTTPSAutoCertsType {
	if x, ok := m.GetLoadbalancerType().(*CreateSpecType_HttpsAutoCert); ok {
		return x.HttpsAutoCert
	}
	return nil
}

func (m *CreateSpecType) GetHttps() *CDNHTTPSCustomCertsType {
	if x, ok := m.GetLoadbalancerType().(*CreateSpecType_Https); ok {
		return x.Https
	}
	return nil
}

func (m *CreateSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *CreateSpecType) GetMoreOption() *AdvancedOptionsType {
	if m != nil {
		return m.MoreOption
	}
	return nil
}

func (m *CreateSpecType) GetOriginPool() *CdnOriginPoolType {
	if m != nil {
		return m.OriginPool
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_Http)(nil),
		(*CreateSpecType_HttpsAutoCert)(nil),
		(*CreateSpecType_Https)(nil),
	}
}

// ReplaceSpecType
//
// x-displayName: "Replace CDN Loadbalancer"
// Shape of the CDN loadbalancer specification
type ReplaceSpecType struct {
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// Types that are valid to be assigned to LoadbalancerType:
	//	*ReplaceSpecType_Http
	//	*ReplaceSpecType_HttpsAutoCert
	//	*ReplaceSpecType_Https
	LoadbalancerType isReplaceSpecType_LoadbalancerType `protobuf_oneof:"loadbalancer_type"`
	AddLocation      bool                               `protobuf:"varint,11,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	MoreOption       *AdvancedOptionsType               `protobuf:"bytes,13,opt,name=more_option,json=moreOption,proto3" json:"more_option,omitempty"`
	// Origin Pool
	//
	// x-displayName: "CDN Origin Pool"
	// x-required
	OriginPool *CdnOriginPoolType `protobuf:"bytes,16,opt,name=origin_pool,json=originPool,proto3" json:"origin_pool,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{19}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_LoadbalancerType interface {
	isReplaceSpecType_LoadbalancerType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_Http struct {
	Http *http_loadbalancer.ProxyTypeHttp `protobuf:"bytes,3,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type ReplaceSpecType_HttpsAutoCert struct {
	HttpsAutoCert *CDNHTTPSAutoCertsType `protobuf:"bytes,18,opt,name=https_auto_cert,json=httpsAutoCert,proto3,oneof" json:"https_auto_cert,omitempty"`
}
type ReplaceSpecType_Https struct {
	Https *CDNHTTPSCustomCertsType `protobuf:"bytes,19,opt,name=https,proto3,oneof" json:"https,omitempty"`
}

func (*ReplaceSpecType_Http) isReplaceSpecType_LoadbalancerType()          {}
func (*ReplaceSpecType_HttpsAutoCert) isReplaceSpecType_LoadbalancerType() {}
func (*ReplaceSpecType_Https) isReplaceSpecType_LoadbalancerType()         {}

func (m *ReplaceSpecType) GetLoadbalancerType() isReplaceSpecType_LoadbalancerType {
	if m != nil {
		return m.LoadbalancerType
	}
	return nil
}

func (m *ReplaceSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *ReplaceSpecType) GetHttp() *http_loadbalancer.ProxyTypeHttp {
	if x, ok := m.GetLoadbalancerType().(*ReplaceSpecType_Http); ok {
		return x.Http
	}
	return nil
}

func (m *ReplaceSpecType) GetHttpsAutoCert() *CDNHTTPSAutoCertsType {
	if x, ok := m.GetLoadbalancerType().(*ReplaceSpecType_HttpsAutoCert); ok {
		return x.HttpsAutoCert
	}
	return nil
}

func (m *ReplaceSpecType) GetHttps() *CDNHTTPSCustomCertsType {
	if x, ok := m.GetLoadbalancerType().(*ReplaceSpecType_Https); ok {
		return x.Https
	}
	return nil
}

func (m *ReplaceSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *ReplaceSpecType) GetMoreOption() *AdvancedOptionsType {
	if m != nil {
		return m.MoreOption
	}
	return nil
}

func (m *ReplaceSpecType) GetOriginPool() *CdnOriginPoolType {
	if m != nil {
		return m.OriginPool
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_Http)(nil),
		(*ReplaceSpecType_HttpsAutoCert)(nil),
		(*ReplaceSpecType_Https)(nil),
	}
}

// GetSpecType
//
// x-displayName: "Get CDN Loadbalancer"
// Shape of the CDN loadbalancer specification
type GetSpecType struct {
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// Types that are valid to be assigned to LoadbalancerType:
	//	*GetSpecType_Http
	//	*GetSpecType_HttpsAutoCert
	//	*GetSpecType_Https
	LoadbalancerType isGetSpecType_LoadbalancerType   `protobuf_oneof:"loadbalancer_type"`
	AddLocation      bool                             `protobuf:"varint,11,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	MoreOption       *AdvancedOptionsType             `protobuf:"bytes,13,opt,name=more_option,json=moreOption,proto3" json:"more_option,omitempty"`
	OriginPool       *CdnOriginPoolType               `protobuf:"bytes,16,opt,name=origin_pool,json=originPool,proto3" json:"origin_pool,omitempty"`
	HostName         string                           `protobuf:"bytes,1001,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	DnsInfo          []*virtual_host_dns_info.DnsInfo `protobuf:"bytes,1002,rep,name=dns_info,json=dnsInfo,proto3" json:"dns_info,omitempty"`
	State            virtual_host.VirtualHostState    `protobuf:"varint,1003,opt,name=state,proto3,enum=ves.io.schema.virtual_host.VirtualHostState" json:"state,omitempty"`
	AutoCertInfo     *virtual_host.AutoCertInfoType   `protobuf:"bytes,1010,opt,name=auto_cert_info,json=autoCertInfo,proto3" json:"auto_cert_info,omitempty"`
	ServiceDomains   []*virtual_host.ServiceDomain    `protobuf:"bytes,1011,rep,name=service_domains,json=serviceDomains,proto3" json:"service_domains,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{20}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_LoadbalancerType interface {
	isGetSpecType_LoadbalancerType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_Http struct {
	Http *http_loadbalancer.ProxyTypeHttp `protobuf:"bytes,3,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type GetSpecType_HttpsAutoCert struct {
	HttpsAutoCert *CDNHTTPSAutoCertsType `protobuf:"bytes,18,opt,name=https_auto_cert,json=httpsAutoCert,proto3,oneof" json:"https_auto_cert,omitempty"`
}
type GetSpecType_Https struct {
	Https *CDNHTTPSCustomCertsType `protobuf:"bytes,19,opt,name=https,proto3,oneof" json:"https,omitempty"`
}

func (*GetSpecType_Http) isGetSpecType_LoadbalancerType()          {}
func (*GetSpecType_HttpsAutoCert) isGetSpecType_LoadbalancerType() {}
func (*GetSpecType_Https) isGetSpecType_LoadbalancerType()         {}

func (m *GetSpecType) GetLoadbalancerType() isGetSpecType_LoadbalancerType {
	if m != nil {
		return m.LoadbalancerType
	}
	return nil
}

func (m *GetSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *GetSpecType) GetHttp() *http_loadbalancer.ProxyTypeHttp {
	if x, ok := m.GetLoadbalancerType().(*GetSpecType_Http); ok {
		return x.Http
	}
	return nil
}

func (m *GetSpecType) GetHttpsAutoCert() *CDNHTTPSAutoCertsType {
	if x, ok := m.GetLoadbalancerType().(*GetSpecType_HttpsAutoCert); ok {
		return x.HttpsAutoCert
	}
	return nil
}

func (m *GetSpecType) GetHttps() *CDNHTTPSCustomCertsType {
	if x, ok := m.GetLoadbalancerType().(*GetSpecType_Https); ok {
		return x.Https
	}
	return nil
}

func (m *GetSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *GetSpecType) GetMoreOption() *AdvancedOptionsType {
	if m != nil {
		return m.MoreOption
	}
	return nil
}

func (m *GetSpecType) GetOriginPool() *CdnOriginPoolType {
	if m != nil {
		return m.OriginPool
	}
	return nil
}

func (m *GetSpecType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *GetSpecType) GetDnsInfo() []*virtual_host_dns_info.DnsInfo {
	if m != nil {
		return m.DnsInfo
	}
	return nil
}

func (m *GetSpecType) GetState() virtual_host.VirtualHostState {
	if m != nil {
		return m.State
	}
	return virtual_host.VIRTUAL_HOST_READY
}

func (m *GetSpecType) GetAutoCertInfo() *virtual_host.AutoCertInfoType {
	if m != nil {
		return m.AutoCertInfo
	}
	return nil
}

func (m *GetSpecType) GetServiceDomains() []*virtual_host.ServiceDomain {
	if m != nil {
		return m.ServiceDomains
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_Http)(nil),
		(*GetSpecType_HttpsAutoCert)(nil),
		(*GetSpecType_Https)(nil),
	}
}

// Metrics Filter options
//
// x-displayName: "Metrics Filter"
// CDN Metrics filter options
type LilacCDNMetricsFilter struct {
	// Metrics Filter Tag options
	//
	// x-displayName: "Filter Tags"
	// x-required
	// Tags on which CDN metrics can be filtered by
	Tag LilacCDNMetricsTag `protobuf:"varint,1,opt,name=tag,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsTag" json:"tag,omitempty"`
	// Filter values
	//
	// x-displayName: "Filter values"
	// x-example: "[IN, US]"
	// x-required
	// Filter values
	Values []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	// Metrics Operator Types
	//
	// x-displayName: "Metrics Operator Types"
	// x-required
	// Operators possible in filtering
	Operator LilacCDNMetricsOperatorType `protobuf:"varint,3,opt,name=operator,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsOperatorType" json:"operator,omitempty"`
}

func (m *LilacCDNMetricsFilter) Reset()      { *m = LilacCDNMetricsFilter{} }
func (*LilacCDNMetricsFilter) ProtoMessage() {}
func (*LilacCDNMetricsFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{21}
}
func (m *LilacCDNMetricsFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LilacCDNMetricsFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsFilter.Merge(m, src)
}
func (m *LilacCDNMetricsFilter) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsFilter.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsFilter proto.InternalMessageInfo

func (m *LilacCDNMetricsFilter) GetTag() LilacCDNMetricsTag {
	if m != nil {
		return m.Tag
	}
	return CDN_DISTRIBUTION_NAME
}

func (m *LilacCDNMetricsFilter) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *LilacCDNMetricsFilter) GetOperator() LilacCDNMetricsOperatorType {
	if m != nil {
		return m.Operator
	}
	return OPERATOR_TYPE_IN
}

// Metrics group by options
//
// x-displayName: "Metrics Group By"
// CDN Metrics group by options
type LilacCDNMetricsResponseGroupBy struct {
	// Metric Group-By Tags
	//
	// x-displayName: "Group By Tags"
	// Tag on which CDN metric was requested to be grouped in request
	Name LilacCDNMetricsTag `protobuf:"varint,1,opt,name=name,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsTag" json:"name,omitempty"`
	// Group-By tag Value
	//
	// x-displayName: "Group By Tag Value"
	// Group-By tag Value
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *LilacCDNMetricsResponseGroupBy) Reset()      { *m = LilacCDNMetricsResponseGroupBy{} }
func (*LilacCDNMetricsResponseGroupBy) ProtoMessage() {}
func (*LilacCDNMetricsResponseGroupBy) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{22}
}
func (m *LilacCDNMetricsResponseGroupBy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsResponseGroupBy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LilacCDNMetricsResponseGroupBy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsResponseGroupBy.Merge(m, src)
}
func (m *LilacCDNMetricsResponseGroupBy) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsResponseGroupBy) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsResponseGroupBy.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsResponseGroupBy proto.InternalMessageInfo

func (m *LilacCDNMetricsResponseGroupBy) GetName() LilacCDNMetricsTag {
	if m != nil {
		return m.Name
	}
	return CDN_DISTRIBUTION_NAME
}

func (m *LilacCDNMetricsResponseGroupBy) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Metrics Response Value
//
// x-displayName: "Metrics Response Value"
// CDN Metrics response value
type LilacCDNMetricsResponseValue struct {
	// Metric Timestamp
	//
	// x-displayName: "Metric Timestamp"
	// Metric Timestamp in unix_timestamp
	Timestamp string `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Metric Value
	//
	// x-displayName: "Metric Value"
	// Metric Value
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *LilacCDNMetricsResponseValue) Reset()      { *m = LilacCDNMetricsResponseValue{} }
func (*LilacCDNMetricsResponseValue) ProtoMessage() {}
func (*LilacCDNMetricsResponseValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{23}
}
func (m *LilacCDNMetricsResponseValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsResponseValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LilacCDNMetricsResponseValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsResponseValue.Merge(m, src)
}
func (m *LilacCDNMetricsResponseValue) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsResponseValue) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsResponseValue.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsResponseValue proto.InternalMessageInfo

func (m *LilacCDNMetricsResponseValue) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *LilacCDNMetricsResponseValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Metrics Series
//
// x-displayName: "Metrics Response Series"
// CDN Metrics response series.
// Each series instance has data for a combination of group-by tag values.
type LilacCDNMetricsResponseSeries struct {
	// Metrics group by options
	//
	// x-displayName: "Metrics Group By"
	// CDN Metrics group-by tag combination.
	GroupBy []*LilacCDNMetricsResponseGroupBy `protobuf:"bytes,1,rep,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	// Metrics Response Value
	//
	// x-displayName: "Metrics Response Value"
	// CDN Metrics data for the series.
	Value []*LilacCDNMetricsResponseValue `protobuf:"bytes,2,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *LilacCDNMetricsResponseSeries) Reset()      { *m = LilacCDNMetricsResponseSeries{} }
func (*LilacCDNMetricsResponseSeries) ProtoMessage() {}
func (*LilacCDNMetricsResponseSeries) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{24}
}
func (m *LilacCDNMetricsResponseSeries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsResponseSeries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LilacCDNMetricsResponseSeries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsResponseSeries.Merge(m, src)
}
func (m *LilacCDNMetricsResponseSeries) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsResponseSeries) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsResponseSeries.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsResponseSeries proto.InternalMessageInfo

func (m *LilacCDNMetricsResponseSeries) GetGroupBy() []*LilacCDNMetricsResponseGroupBy {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *LilacCDNMetricsResponseSeries) GetValue() []*LilacCDNMetricsResponseValue {
	if m != nil {
		return m.Value
	}
	return nil
}

// Metrics Response Data
//
// x-displayName: "Metrics Response Data"
// CDN Metrics response data. This is specific to a metric field.
type LilacCDNMetricsResponseData struct {
	// Metrics Field Selector options
	//
	// x-displayName: "Metrics Field Selector"
	// Metrics field for this response message
	Type LilacCDNMetricsFieldSelector `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFieldSelector" json:"type,omitempty"`
	// Metric Unit
	//
	// x-displayName: "Metric Unit"
	// Metric Unit of the field in this message
	Unit LilacCDNMetricUnit `protobuf:"varint,2,opt,name=unit,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricUnit" json:"unit,omitempty"`
	// Metrics Series
	//
	// x-displayName: "Metrics Response Series"
	// CDN Metrics response series for the field in this message
	Series []*LilacCDNMetricsResponseSeries `protobuf:"bytes,3,rep,name=series,proto3" json:"series,omitempty"`
}

func (m *LilacCDNMetricsResponseData) Reset()      { *m = LilacCDNMetricsResponseData{} }
func (*LilacCDNMetricsResponseData) ProtoMessage() {}
func (*LilacCDNMetricsResponseData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{25}
}
func (m *LilacCDNMetricsResponseData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsResponseData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LilacCDNMetricsResponseData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsResponseData.Merge(m, src)
}
func (m *LilacCDNMetricsResponseData) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsResponseData) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsResponseData.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsResponseData proto.InternalMessageInfo

func (m *LilacCDNMetricsResponseData) GetType() LilacCDNMetricsFieldSelector {
	if m != nil {
		return m.Type
	}
	return REQUEST_TOTAL_SUM
}

func (m *LilacCDNMetricsResponseData) GetUnit() LilacCDNMetricUnit {
	if m != nil {
		return m.Unit
	}
	return COUNT
}

func (m *LilacCDNMetricsResponseData) GetSeries() []*LilacCDNMetricsResponseSeries {
	if m != nil {
		return m.Series
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFieldSelector", LilacCDNMetricsFieldSelector_name, LilacCDNMetricsFieldSelector_value)
	golang_proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFieldSelector", LilacCDNMetricsFieldSelector_name, LilacCDNMetricsFieldSelector_value)
	proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsTag", LilacCDNMetricsTag_name, LilacCDNMetricsTag_value)
	golang_proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsTag", LilacCDNMetricsTag_name, LilacCDNMetricsTag_value)
	proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsOperatorType", LilacCDNMetricsOperatorType_name, LilacCDNMetricsOperatorType_value)
	golang_proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsOperatorType", LilacCDNMetricsOperatorType_name, LilacCDNMetricsOperatorType_value)
	proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricUnit", LilacCDNMetricUnit_name, LilacCDNMetricUnit_value)
	golang_proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricUnit", LilacCDNMetricUnit_name, LilacCDNMetricUnit_value)
	proto.RegisterType((*ProxyTypeHttpsAutoCerts)(nil), "ves.io.schema.views.cdn_loadbalancer.ProxyTypeHttpsAutoCerts")
	golang_proto.RegisterType((*ProxyTypeHttpsAutoCerts)(nil), "ves.io.schema.views.cdn_loadbalancer.ProxyTypeHttpsAutoCerts")
	proto.RegisterType((*HeaderControlType)(nil), "ves.io.schema.views.cdn_loadbalancer.HeaderControlType")
	golang_proto.RegisterType((*HeaderControlType)(nil), "ves.io.schema.views.cdn_loadbalancer.HeaderControlType")
	proto.RegisterType((*SecurityOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.SecurityOptionsType")
	golang_proto.RegisterType((*SecurityOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.SecurityOptionsType")
	proto.RegisterType((*LoggingOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.LoggingOptionsType")
	golang_proto.RegisterType((*LoggingOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.LoggingOptionsType")
	proto.RegisterType((*CacheTTLOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheTTLOptionsType")
	golang_proto.RegisterType((*CacheTTLOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheTTLOptionsType")
	proto.RegisterType((*AdvancedOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.AdvancedOptionsType")
	golang_proto.RegisterType((*AdvancedOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.AdvancedOptionsType")
	proto.RegisterType((*CDNTLSConfig)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNTLSConfig")
	golang_proto.RegisterType((*CDNTLSConfig)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNTLSConfig")
	proto.RegisterType((*CDNHTTPSAutoCertsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNHTTPSAutoCertsType")
	golang_proto.RegisterType((*CDNHTTPSAutoCertsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNHTTPSAutoCertsType")
	proto.RegisterType((*CDNDownstreamTlsParamsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNDownstreamTlsParamsType")
	golang_proto.RegisterType((*CDNDownstreamTlsParamsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNDownstreamTlsParamsType")
	proto.RegisterType((*CDNHTTPSCustomCertsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNHTTPSCustomCertsType")
	golang_proto.RegisterType((*CDNHTTPSCustomCertsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNHTTPSCustomCertsType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.GlobalSpecType")
	proto.RegisterType((*IpFilteringOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.IpFilteringOptions")
	golang_proto.RegisterType((*IpFilteringOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.IpFilteringOptions")
	proto.RegisterType((*GeoFilteringOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.GeoFilteringOptions")
	golang_proto.RegisterType((*GeoFilteringOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.GeoFilteringOptions")
	proto.RegisterType((*LogHeaderOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.LogHeaderOptions")
	golang_proto.RegisterType((*LogHeaderOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.LogHeaderOptions")
	proto.RegisterType((*CDNCustomAuthentication)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNCustomAuthentication")
	golang_proto.RegisterType((*CDNCustomAuthentication)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNCustomAuthentication")
	proto.RegisterType((*AuthenticationOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.AuthenticationOptions")
	golang_proto.RegisterType((*AuthenticationOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.AuthenticationOptions")
	proto.RegisterType((*CDNOriginServerType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNOriginServerType")
	golang_proto.RegisterType((*CDNOriginServerType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNOriginServerType")
	proto.RegisterType((*CdnOriginPoolType)(nil), "ves.io.schema.views.cdn_loadbalancer.CdnOriginPoolType")
	golang_proto.RegisterType((*CdnOriginPoolType)(nil), "ves.io.schema.views.cdn_loadbalancer.CdnOriginPoolType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.GetSpecType")
	proto.RegisterType((*LilacCDNMetricsFilter)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFilter")
	golang_proto.RegisterType((*LilacCDNMetricsFilter)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFilter")
	proto.RegisterType((*LilacCDNMetricsResponseGroupBy)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseGroupBy")
	golang_proto.RegisterType((*LilacCDNMetricsResponseGroupBy)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseGroupBy")
	proto.RegisterType((*LilacCDNMetricsResponseValue)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseValue")
	golang_proto.RegisterType((*LilacCDNMetricsResponseValue)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseValue")
	proto.RegisterType((*LilacCDNMetricsResponseSeries)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseSeries")
	golang_proto.RegisterType((*LilacCDNMetricsResponseSeries)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseSeries")
	proto.RegisterType((*LilacCDNMetricsResponseData)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseData")
	golang_proto.RegisterType((*LilacCDNMetricsResponseData)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseData")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/cdn_loadbalancer/types.proto", fileDescriptor_0a2659efdd085843)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/cdn_loadbalancer/types.proto", fileDescriptor_0a2659efdd085843)
}

var fileDescriptor_0a2659efdd085843 = []byte{
	// 3340 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xdd, 0x6f, 0x1b, 0x57,
	0x76, 0xe7, 0xe5, 0xb7, 0x8e, 0x24, 0x6a, 0x7c, 0x25, 0x59, 0xb4, 0xe2, 0xd0, 0x5a, 0x22, 0x5b,
	0x38, 0xb6, 0x44, 0x59, 0x72, 0xec, 0x8d, 0x95, 0x8d, 0xbb, 0x22, 0x29, 0x5b, 0x14, 0x64, 0x8a,
	0x3b, 0xa4, 0x12, 0xc7, 0xde, 0x64, 0x3a, 0x22, 0xaf, 0xc8, 0x89, 0x87, 0x73, 0xd9, 0x99, 0x4b,
	0x39, 0x5a, 0x74, 0xd1, 0xa0, 0x68, 0x1f, 0x0b, 0xb4, 0x46, 0x1f, 0xfa, 0xd8, 0x97, 0x02, 0x45,
	0xff, 0x80, 0x3e, 0x94, 0x2f, 0x46, 0x50, 0xb4, 0x8b, 0x3c, 0xf9, 0xd1, 0xc8, 0x43, 0xd1, 0x28,
	0x40, 0x91, 0xec, 0xa6, 0x40, 0x36, 0x2d, 0x8a, 0xa0, 0x68, 0x81, 0xe2, 0xde, 0x3b, 0x24, 0x67,
	0x28, 0x4a, 0x91, 0x62, 0xef, 0x02, 0x01, 0xfc, 0xa4, 0x99, 0x73, 0xcf, 0xf9, 0x9d, 0x8f, 0x7b,
	0xee, 0x3d, 0xe7, 0x8c, 0x08, 0x57, 0xf6, 0x88, 0x93, 0x31, 0xe8, 0xa2, 0x53, 0x6d, 0x90, 0xa6,
	0xbe, 0xb8, 0x67, 0x90, 0x87, 0xce, 0x62, 0xb5, 0x66, 0x69, 0x26, 0xd5, 0x6b, 0x3b, 0xba, 0xa9,
	0x5b, 0x55, 0x62, 0x2f, 0xb2, 0xfd, 0x16, 0x71, 0x32, 0x2d, 0x9b, 0x32, 0x8a, 0x5f, 0x91, 0x12,
	0x19, 0x29, 0x91, 0x11, 0x12, 0x99, 0x41, 0x89, 0xd9, 0x85, 0xba, 0xc1, 0x1a, 0xed, 0x9d, 0x4c,
	0x95, 0x36, 0x17, 0xeb, 0xb4, 0x4e, 0x17, 0x85, 0xf0, 0x4e, 0x7b, 0x57, 0xbc, 0x89, 0x17, 0xf1,
	0x24, 0x41, 0x67, 0x2f, 0xd4, 0x29, 0xad, 0x9b, 0xa4, 0xcf, 0xc5, 0x8c, 0x26, 0x71, 0x98, 0xde,
	0x6c, 0xb9, 0x0c, 0x2f, 0xf9, 0xed, 0xa4, 0x2d, 0x66, 0x50, 0xcb, 0x35, 0x69, 0x76, 0xce, 0xbf,
	0xd8, 0xa2, 0xa6, 0x51, 0xdd, 0xf7, 0x1a, 0x3d, 0xfb, 0x7b, 0x7e, 0x0e, 0x5b, 0x67, 0x44, 0x33,
	0x8d, 0xa6, 0xc1, 0xfc, 0xce, 0xcd, 0x5e, 0x18, 0xe0, 0xa3, 0x6d, 0x46, 0x7c, 0x0c, 0x17, 0xfd,
	0x0c, 0x0e, 0xb1, 0xf7, 0x8c, 0x2a, 0xd1, 0x86, 0xa8, 0x5c, 0x38, 0x8e, 0x53, 0xb3, 0xdb, 0xa6,
	0x1f, 0xf8, 0x9c, 0x9f, 0xdd, 0xbb, 0x74, 0x7e, 0x60, 0x8f, 0x74, 0xd3, 0xa8, 0xe9, 0x8c, 0x0c,
	0x77, 0x9e, 0xef, 0x87, 0xe6, 0x0f, 0xcf, 0x1b, 0x27, 0xda, 0x63, 0xbd, 0x5a, 0x25, 0x8e, 0xa3,
	0x99, 0xb4, 0xee, 0x53, 0xbe, 0x34, 0x4c, 0xb8, 0xc1, 0x58, 0xeb, 0xc8, 0x0c, 0x99, 0xbd, 0x3c,
	0x4c, 0x84, 0xda, 0x46, 0xdd, 0xb0, 0xb4, 0x16, 0xa5, 0xa6, 0x8f, 0xf9, 0xea, 0x30, 0x66, 0xef,
	0xfe, 0x0c, 0x8b, 0xed, 0x85, 0x61, 0x42, 0xc7, 0xec, 0xf7, 0x9e, 0x61, 0xb3, 0xb6, 0x6e, 0x6a,
	0x0d, 0xea, 0x30, 0x1f, 0xdf, 0x95, 0xa3, 0xf9, 0xb4, 0x9a, 0xe5, 0x68, 0x86, 0xb5, 0x4b, 0x17,
	0xe9, 0xce, 0xfb, 0xa4, 0xca, 0xa4, 0x44, 0xfa, 0xdf, 0x43, 0x30, 0x53, 0xb2, 0xe9, 0x07, 0xfb,
	0x95, 0xfd, 0x16, 0x59, 0x67, 0xac, 0xe5, 0xac, 0xb6, 0x19, 0xcd, 0x11, 0x9b, 0x39, 0xf8, 0x55,
	0x18, 0x17, 0x91, 0xb1, 0x49, 0xcd, 0xb0, 0x49, 0x95, 0x25, 0xd1, 0x1c, 0xba, 0x18, 0xcf, 0x86,
	0xbf, 0xe9, 0xa0, 0x80, 0x3a, 0xc6, 0x97, 0x54, 0x77, 0x05, 0x5f, 0x80, 0xb8, 0x5e, 0xab, 0x69,
	0x0d, 0x87, 0x39, 0xc9, 0xa0, 0x87, 0x2b, 0xa6, 0xd7, 0x6a, 0xeb, 0x0e, 0x73, 0x70, 0x0e, 0x80,
	0x99, 0x8e, 0x56, 0xa5, 0xd6, 0xae, 0x51, 0x4f, 0x86, 0xe6, 0xd0, 0xc5, 0xd1, 0xe5, 0x54, 0x66,
	0xd8, 0xd9, 0xab, 0x98, 0x4e, 0x4e, 0x70, 0x65, 0xc3, 0x5f, 0x75, 0x10, 0x52, 0x47, 0x58, 0x97,
	0x80, 0x73, 0x90, 0xa8, 0x91, 0x5d, 0xbd, 0x6d, 0x32, 0xad, 0x41, 0xf4, 0x1a, 0xb1, 0x93, 0x11,
	0x01, 0x34, 0x35, 0x00, 0xb4, 0xd6, 0x6c, 0xb1, 0xfd, 0x6c, 0xf8, 0x71, 0x07, 0xa1, 0xf5, 0x80,
	0x3a, 0xee, 0xca, 0xac, 0x0b, 0x11, 0xbc, 0x04, 0xa3, 0x3c, 0x79, 0x89, 0xad, 0x59, 0x7a, 0x93,
	0x24, 0xa3, 0x73, 0xe8, 0xe2, 0x48, 0x36, 0xc1, 0x79, 0xff, 0xf1, 0x8b, 0xc7, 0xa1, 0x88, 0x1d,
	0x7a, 0x1a, 0xe4, 0x52, 0x20, 0x99, 0x8a, 0x7a, 0x93, 0xe0, 0x9b, 0x80, 0xf5, 0x56, 0x8b, 0x58,
	0x35, 0xcd, 0x2b, 0x19, 0x3b, 0x42, 0x52, 0x91, 0xbc, 0xe5, 0xbe, 0xfc, 0xef, 0xc3, 0x58, 0x4b,
	0x77, 0x1c, 0x8d, 0x35, 0x6c, 0xda, 0xae, 0x37, 0x92, 0xf1, 0x13, 0x58, 0x3d, 0xca, 0x25, 0x2a,
	0x52, 0x60, 0x05, 0xbe, 0xbe, 0x19, 0x5b, 0x9a, 0x5f, 0x9e, 0xbf, 0x3a, 0xff, 0x5a, 0x76, 0x11,
	0xa6, 0x5c, 0x2b, 0x64, 0x0c, 0xb4, 0x6a, 0x83, 0x1a, 0x55, 0x82, 0x67, 0x1e, 0x77, 0x50, 0xe4,
	0x97, 0x1d, 0x84, 0x9e, 0x74, 0x50, 0xf8, 0xa0, 0x83, 0x62, 0xd7, 0xe6, 0xaf, 0xcf, 0xff, 0x68,
	0xfe, 0xf5, 0x8d, 0x70, 0x3c, 0xac, 0x44, 0xd2, 0x7f, 0x1e, 0x86, 0x33, 0x32, 0x02, 0x39, 0x6a,
	0x31, 0x9b, 0x9a, 0x7c, 0xc3, 0xf1, 0xcf, 0xe1, 0xac, 0x4d, 0xfe, 0xb0, 0x4d, 0x9c, 0x6e, 0x44,
	0x1d, 0x8d, 0x51, 0x4d, 0xaf, 0xd5, 0x92, 0x68, 0x2e, 0x74, 0x71, 0x74, 0xf9, 0xf2, 0x80, 0x8d,
	0x12, 0xe1, 0x8e, 0x6e, 0x19, 0xad, 0xb6, 0xa9, 0xf3, 0x53, 0xb9, 0x25, 0xce, 0x26, 0x07, 0xcb,
	0x26, 0x9f, 0x74, 0x43, 0xf1, 0x08, 0x05, 0x95, 0xb9, 0xee, 0x53, 0x12, 0xa9, 0x93, 0xae, 0x12,
	0x29, 0xee, 0x54, 0xe8, 0x6a, 0xad, 0x86, 0xff, 0x0c, 0xc1, 0xb9, 0x21, 0xca, 0x6d, 0xd2, 0xa4,
	0x7b, 0x24, 0x19, 0x9c, 0x0b, 0x5d, 0x1c, 0xc9, 0x6e, 0x74, 0x21, 0xc7, 0x1e, 0xa1, 0x91, 0x74,
	0xcc, 0xe6, 0xfb, 0xfd, 0x61, 0x90, 0x13, 0xce, 0x3f, 0x42, 0xe7, 0xd2, 0x33, 0xf6, 0xf4, 0xf2,
	0xe4, 0x7b, 0xf7, 0xaf, 0x2c, 0xdc, 0x58, 0x5d, 0xb8, 0xa7, 0x2f, 0xfc, 0x5c, 0xfb, 0xd9, 0xc2,
	0xcf, 0x32, 0xef, 0x5e, 0x7e, 0x65, 0xa8, 0x11, 0x67, 0x07, 0x8d, 0x50, 0x85, 0x26, 0xfc, 0x47,
	0x30, 0x63, 0x13, 0xa7, 0x45, 0x2d, 0x87, 0x0c, 0x06, 0x21, 0xf4, 0x3c, 0x83, 0x30, 0xd5, 0xd5,
	0xe2, 0x8b, 0xc2, 0x1e, 0xcc, 0x0e, 0xd3, 0xee, 0x46, 0x21, 0x2c, 0xa2, 0x70, 0xa3, 0x8b, 0x79,
	0x7a, 0xa7, 0x67, 0x0e, 0x29, 0x95, 0x5e, 0xa7, 0xff, 0x29, 0x08, 0x93, 0x65, 0x52, 0x6d, 0xdb,
	0x06, 0xdb, 0x97, 0xe6, 0x3b, 0x22, 0x23, 0x74, 0x18, 0x33, 0x5a, 0xda, 0xae, 0x61, 0x32, 0x62,
	0x1b, 0x56, 0xdd, 0x3d, 0x61, 0xaf, 0x67, 0x4e, 0x52, 0x26, 0x33, 0x85, 0xd6, 0xad, 0xae, 0xa0,
	0x8b, 0x99, 0x0d, 0x73, 0xdb, 0xd5, 0x51, 0xa3, 0xbf, 0x82, 0x6b, 0x30, 0x5e, 0x27, 0xd4, 0xa3,
	0x23, 0x2a, 0x74, 0xdc, 0x38, 0x99, 0x8e, 0xdb, 0x84, 0x1e, 0xa1, 0x64, 0xac, 0xee, 0x59, 0xc2,
	0x35, 0x18, 0xd3, 0xdb, 0xac, 0xd1, 0x2d, 0x1e, 0xc9, 0x11, 0xa1, 0xe4, 0x8d, 0x93, 0x29, 0x59,
	0x6d, 0xb3, 0x06, 0xb1, 0x98, 0x51, 0xf5, 0x6c, 0x6f, 0xcf, 0x17, 0x0e, 0xeb, 0x92, 0xd2, 0x5f,
	0x22, 0xc0, 0x9b, 0xb4, 0x5e, 0xef, 0x1b, 0x23, 0xa2, 0xf8, 0x3e, 0xe0, 0xaa, 0x69, 0x10, 0x8b,
	0xf1, 0x02, 0xd4, 0x33, 0x21, 0x26, 0x4c, 0xb8, 0x7e, 0x32, 0x13, 0x36, 0x69, 0x5d, 0xee, 0x99,
	0x5f, 0xbb, 0x22, 0x71, 0x37, 0x69, 0x57, 0x1f, 0xd7, 0xe5, 0x56, 0x23, 0xaf, 0xae, 0xf8, 0xf3,
	0xd0, 0x25, 0x71, 0xfb, 0xba, 0xd2, 0x5f, 0x20, 0x98, 0xcc, 0xe9, 0xd5, 0x06, 0xa9, 0x54, 0x36,
	0xbd, 0xfe, 0xbe, 0x0e, 0x67, 0xaa, 0x9c, 0xac, 0x31, 0x66, 0x6a, 0xee, 0x7d, 0x2b, 0x0a, 0xc1,
	0x48, 0x16, 0xdc, 0xcb, 0xf1, 0x2b, 0x71, 0x39, 0x4e, 0x08, 0xb6, 0x0a, 0x33, 0xf3, 0x92, 0x09,
	0xaf, 0x00, 0xee, 0x4b, 0xd2, 0x3d, 0x62, 0xdb, 0x46, 0x8d, 0x88, 0x02, 0x31, 0x28, 0xaa, 0x74,
	0x45, 0xb7, 0x5c, 0x2e, 0xfc, 0x26, 0x24, 0xa4, 0x6c, 0xcd, 0x70, 0xf4, 0x1d, 0x93, 0xd4, 0x92,
	0xe1, 0xa3, 0x6f, 0x56, 0x5e, 0x09, 0x04, 0x77, 0xde, 0x65, 0xce, 0xce, 0xc0, 0xa8, 0x50, 0xea,
	0xc6, 0x31, 0xfe, 0xb8, 0x83, 0x82, 0xdc, 0xef, 0x8d, 0x70, 0x1c, 0x29, 0xc1, 0xf4, 0x6f, 0x42,
	0x30, 0xb9, 0x5a, 0xdb, 0xe3, 0x11, 0xaa, 0x79, 0x7d, 0x6d, 0x40, 0xc2, 0xbd, 0x79, 0xbb, 0xb1,
	0x56, 0x84, 0xd6, 0x1f, 0x9d, 0x2c, 0xd6, 0x87, 0x2e, 0xe1, 0x2c, 0x57, 0x8c, 0x44, 0xc0, 0xc7,
	0x1b, 0xde, 0x5d, 0xc0, 0x16, 0x28, 0x8e, 0x7b, 0x44, 0x7b, 0xba, 0xce, 0x9c, 0xe6, 0xac, 0x0c,
	0x39, 0xe0, 0x1e, 0x6d, 0x13, 0x8e, 0x7f, 0x19, 0x3f, 0x80, 0x09, 0x53, 0xe6, 0x72, 0x4f, 0x1d,
	0x3e, 0xcd, 0xf1, 0x3f, 0x7c, 0x10, 0x3c, 0xda, 0x12, 0xa6, 0x6f, 0x15, 0x53, 0x6f, 0xca, 0x74,
	0xd5, 0x4d, 0x9e, 0xc6, 0xbb, 0x21, 0x89, 0xe8, 0xf5, 0xae, 0x97, 0x2e, 0x72, 0x59, 0xee, 0xea,
	0x46, 0x38, 0x1e, 0x54, 0x42, 0x1b, 0xe1, 0x78, 0x48, 0x09, 0xcb, 0xca, 0xb8, 0x11, 0x8e, 0x27,
	0x94, 0x89, 0x8d, 0x70, 0x7c, 0x42, 0x51, 0xd2, 0x7f, 0x8b, 0x60, 0x2c, 0x97, 0x2f, 0x56, 0x36,
	0xcb, 0x6e, 0xcb, 0x71, 0x1d, 0x46, 0x79, 0xdf, 0xb2, 0xb4, 0xac, 0xb5, 0xcc, 0xb6, 0x23, 0x3a,
	0xa0, 0xa3, 0xf3, 0x8b, 0xb7, 0x2a, 0x4b, 0xcb, 0x25, 0xb3, 0xed, 0xf4, 0xe4, 0x96, 0xa4, 0x5c,
	0xf0, 0xdb, 0xe5, 0x96, 0xb8, 0xdc, 0x4a, 0xf8, 0xeb, 0x9b, 0xe8, 0x5a, 0xf6, 0x1c, 0x44, 0xdd,
	0xaa, 0x3e, 0xe1, 0xfa, 0x13, 0x39, 0xe8, 0xa0, 0xd0, 0xd2, 0xfc, 0xf2, 0x46, 0x38, 0x1e, 0x51,
	0xa2, 0xe9, 0x7f, 0x46, 0x30, 0x9d, 0xcb, 0x17, 0xd7, 0x2b, 0x95, 0x52, 0xb9, 0xd7, 0xb0, 0x89,
	0xec, 0x7c, 0x9e, 0x4d, 0xdb, 0xdb, 0x43, 0x9a, 0xb6, 0xe5, 0x13, 0xee, 0x8d, 0x27, 0x88, 0x87,
	0x1a, 0xb9, 0x95, 0xf8, 0xd7, 0x37, 0x23, 0xa2, 0x9f, 0x49, 0xff, 0x37, 0x82, 0xd9, 0x5c, 0xbe,
	0x98, 0xa7, 0x0f, 0x2d, 0x87, 0xd9, 0x44, 0x6f, 0x56, 0x4c, 0xa7, 0xa4, 0xdb, 0x7a, 0x53, 0x7a,
	0xe3, 0xb7, 0x00, 0x3d, 0x37, 0x0b, 0xf0, 0x0e, 0x28, 0x02, 0x98, 0xd8, 0xcc, 0xd8, 0xe5, 0xd7,
	0x3c, 0x71, 0x44, 0xcb, 0x31, 0xba, 0xfc, 0x83, 0x01, 0x78, 0xde, 0x8f, 0xf6, 0xb9, 0x44, 0x92,
	0x4d, 0xf5, 0x4a, 0xad, 0xd2, 0x7d, 0x8a, 0x23, 0x75, 0x82, 0xf9, 0x38, 0x9d, 0x95, 0x97, 0x3e,
	0xea, 0xa0, 0x19, 0x98, 0x86, 0x44, 0x65, 0xb3, 0x3c, 0x27, 0x9c, 0x22, 0x8c, 0xd8, 0x0e, 0xe6,
	0xfb, 0x98, 0xfe, 0x57, 0x04, 0x33, 0xdd, 0x1d, 0xcc, 0xb5, 0x1d, 0x46, 0x9b, 0xbf, 0x9d, 0x3d,
	0x6c, 0x42, 0x82, 0x3b, 0xda, 0xea, 0xa9, 0x77, 0xf7, 0xf1, 0x27, 0x27, 0x8e, 0xe2, 0x11, 0x7b,
	0xe3, 0xd6, 0x88, 0x71, 0xe6, 0x12, 0x05, 0xb8, 0x67, 0x67, 0xff, 0x05, 0x20, 0x71, 0xdb, 0xa4,
	0x3b, 0xba, 0x59, 0x6e, 0x91, 0xaa, 0xf0, 0xeb, 0x8f, 0x21, 0x56, 0xa3, 0x4d, 0xdd, 0xb0, 0x1c,
	0xd1, 0x5e, 0x8e, 0x64, 0x09, 0x0f, 0xdf, 0xc8, 0x23, 0x14, 0x4d, 0x87, 0xed, 0x60, 0x43, 0xb4,
	0x38, 0xf0, 0x08, 0xc5, 0xd2, 0x11, 0x3b, 0x94, 0x94, 0x6d, 0x5e, 0x77, 0x51, 0x11, 0x8b, 0x33,
	0x8f, 0xd0, 0x54, 0x1a, 0xdb, 0xca, 0x72, 0xe2, 0x3e, 0x6f, 0x79, 0xee, 0xcb, 0x06, 0xe8, 0xdd,
	0xcb, 0x87, 0x5b, 0x9f, 0x38, 0xf2, 0x34, 0x41, 0x5d, 0xad, 0x78, 0x03, 0xc2, 0x3c, 0x7a, 0x6e,
	0x08, 0x5e, 0x1b, 0x1a, 0x82, 0x43, 0xc3, 0x60, 0xc6, 0x37, 0x1f, 0xad, 0x07, 0x54, 0x81, 0x81,
	0x09, 0x4c, 0xf0, 0xbf, 0x8e, 0xa6, 0xb7, 0x19, 0x15, 0x89, 0xe4, 0x5e, 0x96, 0x6f, 0x9c, 0x38,
	0xb2, 0x87, 0x8f, 0x2f, 0x2f, 0x52, 0x0d, 0xef, 0x14, 0x86, 0xb7, 0x21, 0x22, 0x08, 0xee, 0xd5,
	0xf8, 0xe6, 0xe9, 0xc0, 0x07, 0x32, 0x6b, 0x3d, 0xa0, 0x4a, 0x34, 0x7c, 0x19, 0xc6, 0x78, 0xde,
	0x98, 0x54, 0x76, 0x38, 0xc9, 0x51, 0x91, 0x3b, 0xe2, 0xf6, 0x14, 0xf9, 0x33, 0xaa, 0xd7, 0x6a,
	0x9b, 0xee, 0x22, 0xfe, 0x03, 0x18, 0x6d, 0x52, 0x9b, 0xb8, 0xb7, 0x74, 0x72, 0xfc, 0x34, 0x97,
	0xf4, 0x90, 0x0a, 0x2a, 0x67, 0x1c, 0x15, 0x38, 0xa6, 0x24, 0xe3, 0xf7, 0x60, 0xd4, 0x33, 0x51,
	0x9f, 0xae, 0xa0, 0xe6, 0x6a, 0xd6, 0x96, 0x90, 0x2d, 0x51, 0xb7, 0xa0, 0xca, 0xcc, 0x04, 0xda,
	0xa3, 0xe2, 0xf7, 0x60, 0x5c, 0x7c, 0x49, 0x30, 0x2c, 0x46, 0x6c, 0x4b, 0x37, 0x93, 0x9f, 0xcb,
	0x5e, 0x2c, 0x3d, 0x54, 0xc5, 0x96, 0x98, 0x90, 0x55, 0xb2, 0x2b, 0x4f, 0xfb, 0xdf, 0xff, 0xc2,
	0x2f, 0xfc, 0xb9, 0x68, 0x36, 0x39, 0xa9, 0xe0, 0x52, 0xf0, 0x79, 0x18, 0x11, 0x43, 0xb6, 0x18,
	0x0c, 0xbf, 0x10, 0x93, 0xa1, 0x1a, 0xe7, 0x14, 0x31, 0xff, 0xad, 0x43, 0xbc, 0x3b, 0x7d, 0x27,
	0x7f, 0x15, 0x13, 0xb7, 0xcc, 0xfc, 0x21, 0xc5, 0x43, 0x46, 0xf5, 0x4c, 0xde, 0x72, 0x0a, 0xd6,
	0x2e, 0x55, 0x63, 0x35, 0xf9, 0x80, 0x73, 0x10, 0x71, 0x98, 0xce, 0x48, 0xf2, 0xd7, 0x5c, 0x47,
	0xe2, 0x58, 0x98, 0xcc, 0x5b, 0xf2, 0x65, 0x9d, 0x3a, 0xac, 0xcc, 0x85, 0x54, 0x29, 0x8b, 0xef,
	0xc3, 0x44, 0x2f, 0x67, 0x35, 0x09, 0xf7, 0xa5, 0x84, 0xcb, 0x1c, 0x07, 0xd7, 0xbf, 0xdb, 0x0c,
	0x6a, 0x09, 0xc0, 0x2c, 0x3f, 0x5c, 0xe3, 0xba, 0x9b, 0xaa, 0x82, 0x84, 0xcb, 0x90, 0xe8, 0x83,
	0x0b, 0x8f, 0xbf, 0x96, 0xa1, 0x3e, 0xd6, 0xd4, 0x6e, 0xba, 0x73, 0x27, 0x79, 0xd0, 0xd5, 0x31,
	0xdd, 0x43, 0xc1, 0x65, 0x98, 0xe8, 0x7e, 0x70, 0xea, 0x5e, 0x20, 0xff, 0x29, 0xe3, 0xf8, 0xea,
	0x71, 0xa8, 0x65, 0x29, 0x93, 0x17, 0x22, 0x6a, 0xc2, 0xf1, 0xbe, 0x3a, 0x2b, 0x77, 0x3f, 0xea,
	0xa0, 0x0a, 0xcc, 0xc2, 0x64, 0x56, 0x77, 0x8c, 0xea, 0x9c, 0x2c, 0x0c, 0x6d, 0x5b, 0xa6, 0x3c,
	0xbf, 0xa3, 0x61, 0x1a, 0x26, 0x72, 0xf9, 0xe2, 0x9c, 0xcc, 0xae, 0x39, 0x91, 0x48, 0xc1, 0xa5,
	0xeb, 0x70, 0x01, 0xce, 0x76, 0xb3, 0x7a, 0x40, 0x2a, 0xb2, 0xb4, 0x34, 0xbf, 0x74, 0x35, 0xfb,
	0x32, 0x9c, 0xf1, 0x66, 0xa8, 0xc6, 0xf8, 0xe5, 0xc7, 0xcf, 0x16, 0x7e, 0xd2, 0x41, 0xfd, 0x16,
	0x44, 0x36, 0x1f, 0x11, 0x25, 0xba, 0x11, 0x8e, 0x47, 0x95, 0xd8, 0x46, 0x38, 0x1e, 0x53, 0xe2,
	0x1b, 0xe1, 0xf8, 0x98, 0x32, 0xee, 0x6b, 0x4a, 0x7e, 0x83, 0x00, 0x1f, 0x9e, 0xac, 0xf0, 0x2d,
	0x00, 0xdd, 0x34, 0xe9, 0x43, 0xcd, 0x34, 0x1c, 0xe6, 0x76, 0x18, 0x3f, 0x1c, 0x08, 0x87, 0xfc,
	0xd8, 0x94, 0x29, 0xd9, 0x64, 0xd7, 0xf8, 0xe0, 0x8e, 0xce, 0xaa, 0x8d, 0x4d, 0xc3, 0x61, 0xbc,
	0xe5, 0x10, 0xa2, 0xfc, 0x85, 0xe3, 0xec, 0x98, 0xb4, 0xfa, 0x40, 0xe2, 0x84, 0x4e, 0x89, 0x23,
	0x44, 0xf9, 0xcb, 0xca, 0x85, 0x8f, 0x3a, 0xe8, 0x25, 0x38, 0x07, 0x53, 0x85, 0xd2, 0x5c, 0xcf,
	0xd8, 0xb9, 0xae, 0xb5, 0x68, 0x29, 0xfb, 0x0a, 0x9c, 0xf1, 0x8e, 0x96, 0x32, 0x2c, 0x13, 0xdd,
	0xae, 0x9b, 0x37, 0x38, 0xcb, 0xf3, 0x57, 0xdd, 0xe6, 0xfb, 0xbf, 0x10, 0x4c, 0x0e, 0x99, 0xf4,
	0x4e, 0xe3, 0x74, 0x8e, 0xb6, 0x2d, 0x66, 0xef, 0xe7, 0x68, 0x8d, 0x3c, 0x93, 0xd3, 0x43, 0x70,
	0xfa, 0x4e, 0xcf, 0x7d, 0xd4, 0x41, 0xe7, 0x61, 0x16, 0xa6, 0x6f, 0x13, 0x3a, 0xdc, 0xeb, 0x1f,
	0x02, 0xf6, 0x4d, 0xbb, 0xc7, 0xba, 0x5d, 0x00, 0x65, 0x70, 0x16, 0xc3, 0xd7, 0x60, 0xd4, 0x9d,
	0x37, 0x84, 0xad, 0xb2, 0x72, 0xf6, 0x5b, 0x90, 0x9f, 0x78, 0x0a, 0x1d, 0x48, 0x46, 0x6e, 0x59,
	0xfa, 0x6d, 0xd1, 0x5f, 0xc8, 0x02, 0xe0, 0x1f, 0x67, 0xf1, 0x8f, 0x01, 0x57, 0x05, 0x5d, 0x13,
	0x13, 0xb2, 0xa7, 0xbb, 0x1a, 0xc9, 0x26, 0xbe, 0xe9, 0xa0, 0x90, 0x3b, 0x77, 0x25, 0x3f, 0x9c,
	0x53, 0x95, 0x6a, 0x0f, 0x41, 0xe6, 0x7a, 0xfa, 0x2f, 0x83, 0x30, 0x3d, 0x74, 0x3e, 0xc6, 0x37,
	0x60, 0xcc, 0x9d, 0xc4, 0x04, 0xf0, 0xb7, 0x74, 0xbd, 0xa3, 0x2e, 0x2f, 0xc7, 0xc2, 0x6f, 0x42,
	0xe8, 0xfd, 0x87, 0xdd, 0x8d, 0x78, 0x75, 0xf8, 0x46, 0x6c, 0x3c, 0x64, 0x15, 0xfa, 0x80, 0x58,
	0xab, 0xfd, 0xf9, 0x7b, 0x3d, 0xa0, 0x72, 0x39, 0xfc, 0x36, 0x44, 0xa5, 0x9d, 0xee, 0x04, 0x78,
	0xf2, 0x32, 0x39, 0x2c, 0x40, 0xeb, 0x01, 0xd5, 0x85, 0xcb, 0x5e, 0xf0, 0x7f, 0x45, 0x38, 0x6a,
	0xdf, 0x7e, 0x1d, 0x84, 0xc9, 0x5c, 0xbe, 0x28, 0x6f, 0x0a, 0xf9, 0xe5, 0x4f, 0x74, 0x3c, 0x15,
	0x18, 0x69, 0xb5, 0x77, 0x4c, 0xa3, 0xaa, 0x19, 0x2d, 0x37, 0x1c, 0xd7, 0x86, 0x9a, 0xe6, 0xa9,
	0x7e, 0x19, 0x2f, 0x4a, 0x49, 0x48, 0x17, 0x4a, 0xeb, 0x01, 0x35, 0x2e, 0x91, 0x0a, 0x2d, 0x7c,
	0x0f, 0x46, 0x5d, 0x54, 0x51, 0x6f, 0x42, 0xc7, 0x54, 0xcb, 0xe3, 0x71, 0x79, 0x75, 0x5a, 0x0f,
	0xa8, 0xd0, 0xea, 0xbd, 0xad, 0xfc, 0xe2, 0xe3, 0x0e, 0xda, 0x87, 0x5b, 0x10, 0xe6, 0xf6, 0x5f,
	0xba, 0x09, 0x57, 0xe1, 0xac, 0xc7, 0x87, 0xe5, 0x11, 0x29, 0x38, 0x57, 0x28, 0xc1, 0x39, 0x9f,
	0x15, 0xcb, 0xe0, 0xae, 0xe4, 0x8b, 0x65, 0x1c, 0xdb, 0xb6, 0x1e, 0x58, 0xf4, 0xa1, 0x05, 0x8b,
	0x10, 0xe3, 0xa8, 0x8b, 0x85, 0xd2, 0xf2, 0x2b, 0x30, 0xd6, 0x83, 0xc9, 0x18, 0x2d, 0x98, 0xf2,
	0x08, 0x67, 0x78, 0xc5, 0xe3, 0x0f, 0xd9, 0x97, 0x7b, 0x93, 0xcf, 0xe4, 0xe3, 0x0e, 0x0a, 0x79,
	0x22, 0xfd, 0x4d, 0x7f, 0x32, 0xff, 0x87, 0x30, 0x9c, 0x39, 0x54, 0xf5, 0xf1, 0x5d, 0x7f, 0x54,
	0xd0, 0x33, 0x45, 0xc5, 0x1b, 0x13, 0xbc, 0x00, 0x51, 0x8b, 0x6a, 0xcc, 0xec, 0xf6, 0xce, 0x47,
	0x65, 0x74, 0xc4, 0xa2, 0x15, 0xd3, 0xc1, 0x3f, 0x85, 0x58, 0xdb, 0x21, 0x82, 0x3f, 0x7c, 0xcc,
	0x57, 0x18, 0xaf, 0x11, 0xdb, 0x2d, 0x7f, 0x87, 0x2d, 0x9a, 0x69, 0x9e, 0x86, 0x6d, 0x87, 0x70,
	0xc8, 0x0f, 0x11, 0x24, 0x5c, 0x7e, 0xf9, 0xf1, 0xd7, 0x49, 0x46, 0x44, 0xfd, 0xbb, 0x71, 0xe2,
	0x44, 0x1f, 0xcc, 0xcd, 0x6c, 0xea, 0x5b, 0xba, 0xe6, 0x71, 0xea, 0x91, 0x70, 0xf0, 0x0a, 0x9c,
	0xdd, 0xa5, 0xe2, 0xea, 0x75, 0x0d, 0xe9, 0x4d, 0x27, 0x51, 0x39, 0x77, 0x88, 0xb6, 0x68, 0x4a,
	0xf2, 0x48, 0x65, 0xbd, 0x29, 0x45, 0x87, 0xb3, 0x3d, 0x21, 0xf9, 0xc1, 0x97, 0x19, 0x4d, 0x42,
	0xdb, 0xcc, 0xfd, 0x88, 0x7e, 0xf9, 0x93, 0x0e, 0x0a, 0x5d, 0xbf, 0xe2, 0x70, 0xed, 0x71, 0x3b,
	0xfa, 0xab, 0x50, 0x68, 0xe9, 0x4a, 0xd3, 0x7d, 0x39, 0xe0, 0x2f, 0x4e, 0xff, 0x4b, 0x90, 0x3a,
	0x45, 0x5d, 0x70, 0x81, 0x54, 0x91, 0x40, 0xd9, 0x97, 0xdd, 0x49, 0xb1, 0x3f, 0x36, 0xf3, 0x2e,
	0x30, 0xc8, 0x93, 0xe7, 0xea, 0xfc, 0x6b, 0xb2, 0xe6, 0xa6, 0xff, 0x37, 0x0c, 0x89, 0x9c, 0x4d,
	0x74, 0x46, 0x7a, 0x33, 0x49, 0x72, 0x60, 0x26, 0x79, 0x31, 0x2c, 0x1c, 0x1e, 0x16, 0x7e, 0x30,
	0x6c, 0x58, 0xf0, 0x8f, 0x08, 0xf7, 0x9e, 0xef, 0x88, 0xe0, 0x1b, 0x0e, 0xee, 0x3e, 0xcf, 0xe1,
	0xc0, 0x3b, 0x16, 0xac, 0x9c, 0xf9, 0xf8, 0xe6, 0xc0, 0x8c, 0x9a, 0xbd, 0x34, 0xac, 0x77, 0x9b,
	0xfe, 0x93, 0xff, 0x41, 0x87, 0xc9, 0xa7, 0x6e, 0xe4, 0xfe, 0x2f, 0x0c, 0x13, 0x2a, 0x69, 0x99,
	0x7a, 0xf5, 0x45, 0xfe, 0xbd, 0xc8, 0xbf, 0xdf, 0x7d, 0xfe, 0x3d, 0x8d, 0xc1, 0xe8, 0x6d, 0xc2,
	0x5e, 0xe4, 0xde, 0x8b, 0xdc, 0xfb, 0x9e, 0x7d, 0xb2, 0xf8, 0xfe, 0x7c, 0x55, 0xf8, 0xdd, 0x1e,
	0xe9, 0x8d, 0x68, 0xfc, 0xcb, 0x98, 0xf2, 0x1f, 0xb1, 0xf4, 0x01, 0x82, 0xe9, 0x4d, 0xc3, 0xd4,
	0xab, 0xb9, 0x7c, 0xf1, 0x0e, 0x61, 0xb6, 0x51, 0x75, 0xe4, 0x34, 0x8a, 0x37, 0x20, 0xc4, 0x74,
	0x39, 0xdd, 0x25, 0x4e, 0xfc, 0x8f, 0x1c, 0x3f, 0x52, 0x45, 0xaf, 0xab, 0x1c, 0x04, 0x9f, 0x85,
	0xe8, 0x9e, 0x6e, 0xb6, 0xdd, 0x6f, 0xe5, 0x23, 0xaa, 0xfb, 0x86, 0xdf, 0x85, 0x38, 0x6d, 0x11,
	0x5b, 0x67, 0xd4, 0x16, 0x57, 0x46, 0x62, 0x79, 0xf5, 0x3b, 0x29, 0xda, 0x72, 0x41, 0xc4, 0x66,
	0xf5, 0x20, 0x57, 0xa2, 0x1f, 0x77, 0x50, 0x50, 0x41, 0xe9, 0x3f, 0x45, 0x90, 0x1a, 0x90, 0x50,
	0xdd, 0x7f, 0x6f, 0xdf, 0xb6, 0x69, 0xbb, 0x95, 0xdd, 0xc7, 0x9b, 0x10, 0xee, 0x75, 0xff, 0xcf,
	0xe2, 0xae, 0x40, 0xc1, 0x53, 0x10, 0x11, 0x1e, 0xca, 0x7f, 0x65, 0xaa, 0xf2, 0x25, 0xad, 0xc2,
	0xf9, 0x23, 0xac, 0x78, 0x8b, 0xaf, 0xf3, 0x93, 0xd5, 0xfb, 0xbd, 0x97, 0x9c, 0xaa, 0xd5, 0x3e,
	0xe1, 0x08, 0xcc, 0x4f, 0x10, 0xbc, 0x7c, 0x04, 0x68, 0x99, 0xd8, 0x06, 0x71, 0xb0, 0x06, 0xf1,
	0x3a, 0x77, 0x52, 0xdb, 0xd9, 0x77, 0x7f, 0x9c, 0x91, 0xff, 0x4e, 0xde, 0x0d, 0x44, 0x4c, 0x8d,
	0xd5, 0xdd, 0xd0, 0xdd, 0xed, 0x1b, 0xc6, 0xd1, 0xb3, 0xcf, 0x84, 0x2e, 0x22, 0xd1, 0x75, 0xee,
	0x6f, 0x82, 0xf0, 0xd2, 0x11, 0x7c, 0x79, 0x9d, 0xe9, 0xf8, 0x2d, 0x08, 0xf3, 0xe4, 0x77, 0x37,
	0xed, 0xbb, 0x29, 0xbe, 0x65, 0x10, 0xb3, 0x56, 0x26, 0x26, 0xa9, 0x32, 0x6a, 0xab, 0x02, 0x8f,
	0x27, 0x43, 0xdb, 0x32, 0xe4, 0x67, 0xa2, 0xef, 0x98, 0x0c, 0xdb, 0x96, 0xc1, 0x54, 0x81, 0x82,
	0xef, 0x43, 0xd4, 0x11, 0x5b, 0xe1, 0xfe, 0x2c, 0x24, 0xf7, 0x4c, 0x01, 0x92, 0xbb, 0xaa, 0xba,
	0x90, 0x97, 0x3e, 0x41, 0x87, 0x92, 0xca, 0xe7, 0x11, 0x9e, 0x86, 0x33, 0xea, 0xda, 0x4f, 0xb7,
	0xd7, 0xca, 0x15, 0xad, 0xb2, 0x55, 0x59, 0xdd, 0xd4, 0xca, 0xdb, 0x77, 0x94, 0x00, 0x3e, 0x0b,
	0xb8, 0x4b, 0xbe, 0xb5, 0x5a, 0xd8, 0x5c, 0xcb, 0x0b, 0x3a, 0xc2, 0x93, 0x30, 0xd1, 0xa5, 0x2f,
	0xdd, 0xbd, 0x2b, 0x88, 0x41, 0x2f, 0x71, 0xd9, 0x25, 0x86, 0xbc, 0xc4, 0xab, 0x2e, 0x31, 0xec,
	0x25, 0xbe, 0xe6, 0x12, 0x23, 0x5e, 0xe2, 0x35, 0x97, 0x18, 0xc5, 0x0a, 0x8c, 0xe5, 0x57, 0x2b,
	0xab, 0xda, 0xd6, 0x76, 0x45, 0x50, 0x62, 0x9c, 0xb2, 0xb9, 0x5a, 0x59, 0x2b, 0xe6, 0xde, 0xd1,
	0xee, 0xac, 0xad, 0x16, 0x95, 0xf8, 0xa5, 0xbf, 0x42, 0x80, 0x0f, 0x9f, 0x31, 0x7c, 0x4e, 0xfc,
	0x0f, 0x53, 0xcb, 0x17, 0xca, 0x15, 0xb5, 0x90, 0xdd, 0xae, 0x14, 0xb6, 0x8a, 0x5a, 0x71, 0xf5,
	0xce, 0x9a, 0x12, 0xc0, 0x18, 0x12, 0xb9, 0xd5, 0xdc, 0xfa, 0x9a, 0xb6, 0x5e, 0xa8, 0x68, 0x95,
	0x77, 0x4a, 0x6b, 0x7e, 0x97, 0x72, 0x5b, 0xdb, 0xc5, 0x8a, 0xfa, 0x8e, 0x12, 0xe4, 0xca, 0x78,
	0xfd, 0xd6, 0xde, 0x5a, 0x53, 0xcb, 0x85, 0xad, 0xa2, 0x12, 0xc2, 0x13, 0x30, 0x5a, 0xd9, 0x2c,
	0xf7, 0x08, 0x61, 0x9c, 0x00, 0x28, 0x6d, 0x95, 0x34, 0x75, 0xed, 0x36, 0x7f, 0x8f, 0xe0, 0x18,
	0x84, 0x4a, 0x5b, 0x25, 0x25, 0x7a, 0xe9, 0xce, 0xa1, 0xac, 0xf4, 0xde, 0x3f, 0x78, 0x0a, 0x94,
	0xad, 0xd2, 0x9a, 0xba, 0x5a, 0xd9, 0x52, 0x85, 0x09, 0x5a, 0xa1, 0xa8, 0x04, 0x70, 0x12, 0xa6,
	0xfc, 0xd4, 0xe2, 0x56, 0x85, 0xaf, 0xa0, 0x4b, 0x3f, 0x1e, 0x74, 0x92, 0xe7, 0x0e, 0x1e, 0x81,
	0x88, 0xb0, 0x56, 0x09, 0xf0, 0xc7, 0xec, 0x3b, 0x95, 0xb5, 0xb2, 0x82, 0xb8, 0xd9, 0x77, 0x0a,
	0x9b, 0x9b, 0x85, 0xf2, 0x5a, 0x6e, 0xab, 0x98, 0x2f, 0x2b, 0xc1, 0xec, 0x5f, 0xa3, 0x27, 0x9f,
	0xa6, 0x02, 0x4f, 0x3f, 0x4d, 0x05, 0xbe, 0xfa, 0x34, 0x85, 0x3e, 0x3c, 0x48, 0xa1, 0xbf, 0x3b,
	0x48, 0xa1, 0x5f, 0x1e, 0xa4, 0xd0, 0x93, 0x83, 0x14, 0x7a, 0x7a, 0x90, 0x42, 0xff, 0x76, 0x90,
	0x42, 0x9f, 0x1f, 0xa4, 0x02, 0x5f, 0x1d, 0xa4, 0xd0, 0x5f, 0x7c, 0x96, 0x0a, 0x3c, 0xfe, 0x2c,
	0x85, 0x9e, 0x7c, 0x96, 0x0a, 0x3c, 0xfd, 0x2c, 0x15, 0xb8, 0x77, 0xaf, 0x4e, 0x5b, 0x0f, 0xea,
	0x99, 0x3d, 0xca, 0xef, 0x7c, 0x5b, 0xcf, 0xb4, 0x9d, 0x45, 0xf1, 0xb0, 0x4b, 0xed, 0xe6, 0x42,
	0xcb, 0xa6, 0x7b, 0x46, 0x8d, 0xd8, 0x0b, 0xdd, 0xe5, 0xc5, 0xd6, 0x4e, 0x9d, 0x2e, 0x92, 0x0f,
	0x58, 0xf7, 0xd7, 0x9c, 0xc7, 0xfd, 0x94, 0x72, 0x27, 0x2a, 0x7e, 0x2a, 0x78, 0xf5, 0xff, 0x03,
	0x00, 0x00, 0xff, 0xff, 0xae, 0x79, 0x32, 0xff, 0x5d, 0x2b, 0x00, 0x00,
}

func (x LilacCDNMetricsFieldSelector) String() string {
	s, ok := LilacCDNMetricsFieldSelector_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LilacCDNMetricsTag) String() string {
	s, ok := LilacCDNMetricsTag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LilacCDNMetricsOperatorType) String() string {
	s, ok := LilacCDNMetricsOperatorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LilacCDNMetricUnit) String() string {
	s, ok := LilacCDNMetricUnit_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ProxyTypeHttpsAutoCerts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyTypeHttpsAutoCerts)
	if !ok {
		that2, ok := that.(ProxyTypeHttpsAutoCerts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HttpRedirect != that1.HttpRedirect {
		return false
	}
	if this.AddHsts != that1.AddHsts {
		return false
	}
	if !this.TlsConfig.Equal(that1.TlsConfig) {
		return false
	}
	if that1.ServerHeaderChoice == nil {
		if this.ServerHeaderChoice != nil {
			return false
		}
	} else if this.ServerHeaderChoice == nil {
		return false
	} else if !this.ServerHeaderChoice.Equal(that1.ServerHeaderChoice) {
		return false
	}
	return true
}
func (this *ProxyTypeHttpsAutoCerts_DefaultHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyTypeHttpsAutoCerts_DefaultHeader)
	if !ok {
		that2, ok := that.(ProxyTypeHttpsAutoCerts_DefaultHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultHeader.Equal(that1.DefaultHeader) {
		return false
	}
	return true
}
func (this *ProxyTypeHttpsAutoCerts_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyTypeHttpsAutoCerts_ServerName)
	if !ok {
		that2, ok := that.(ProxyTypeHttpsAutoCerts_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *ProxyTypeHttpsAutoCerts_AppendServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyTypeHttpsAutoCerts_AppendServerName)
	if !ok {
		that2, ok := that.(ProxyTypeHttpsAutoCerts_AppendServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppendServerName != that1.AppendServerName {
		return false
	}
	return true
}
func (this *ProxyTypeHttpsAutoCerts_PassThrough) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyTypeHttpsAutoCerts_PassThrough)
	if !ok {
		that2, ok := that.(ProxyTypeHttpsAutoCerts_PassThrough)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PassThrough.Equal(that1.PassThrough) {
		return false
	}
	return true
}
func (this *HeaderControlType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderControlType)
	if !ok {
		that2, ok := that.(HeaderControlType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	return true
}
func (this *SecurityOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityOptionsType)
	if !ok {
		that2, ok := that.(SecurityOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpFiltering.Equal(that1.IpFiltering) {
		return false
	}
	if !this.GeoFiltering.Equal(that1.GeoFiltering) {
		return false
	}
	if !this.AuthOptions.Equal(that1.AuthOptions) {
		return false
	}
	return true
}
func (this *LoggingOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoggingOptionsType)
	if !ok {
		that2, ok := that.(LoggingOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientLogOptions.Equal(that1.ClientLogOptions) {
		return false
	}
	if !this.OriginLogOptions.Equal(that1.OriginLogOptions) {
		return false
	}
	return true
}
func (this *CacheTTLOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheTTLOptionsType)
	if !ok {
		that2, ok := that.(CacheTTLOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.TtlOptions == nil {
		if this.TtlOptions != nil {
			return false
		}
	} else if this.TtlOptions == nil {
		return false
	} else if !this.TtlOptions.Equal(that1.TtlOptions) {
		return false
	}
	return true
}
func (this *CacheTTLOptionsType_CacheTtlDefault) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheTTLOptionsType_CacheTtlDefault)
	if !ok {
		that2, ok := that.(CacheTTLOptionsType_CacheTtlDefault)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CacheTtlDefault != that1.CacheTtlDefault {
		return false
	}
	return true
}
func (this *CacheTTLOptionsType_CacheTtlOverride) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheTTLOptionsType_CacheTtlOverride)
	if !ok {
		that2, ok := that.(CacheTTLOptionsType_CacheTtlOverride)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CacheTtlOverride != that1.CacheTtlOverride {
		return false
	}
	return true
}
func (this *CacheTTLOptionsType_CacheDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheTTLOptionsType_CacheDisabled)
	if !ok {
		that2, ok := that.(CacheTTLOptionsType_CacheDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CacheDisabled.Equal(that1.CacheDisabled) {
		return false
	}
	return true
}
func (this *AdvancedOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvancedOptionsType)
	if !ok {
		that2, ok := that.(AdvancedOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HeaderOptions.Equal(that1.HeaderOptions) {
		return false
	}
	if !this.SecurityOptions.Equal(that1.SecurityOptions) {
		return false
	}
	if !this.LoggingOptions.Equal(that1.LoggingOptions) {
		return false
	}
	if !this.CacheTtlOptions.Equal(that1.CacheTtlOptions) {
		return false
	}
	return true
}
func (this *CDNTLSConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNTLSConfig)
	if !ok {
		that2, ok := that.(CDNTLSConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *CDNTLSConfig_Tls_12Plus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNTLSConfig_Tls_12Plus)
	if !ok {
		that2, ok := that.(CDNTLSConfig_Tls_12Plus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Tls_12Plus.Equal(that1.Tls_12Plus) {
		return false
	}
	return true
}
func (this *CDNTLSConfig_Tls_11Plus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNTLSConfig_Tls_11Plus)
	if !ok {
		that2, ok := that.(CDNTLSConfig_Tls_11Plus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Tls_11Plus.Equal(that1.Tls_11Plus) {
		return false
	}
	return true
}
func (this *CDNHTTPSAutoCertsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNHTTPSAutoCertsType)
	if !ok {
		that2, ok := that.(CDNHTTPSAutoCertsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HttpRedirect != that1.HttpRedirect {
		return false
	}
	if this.AddHsts != that1.AddHsts {
		return false
	}
	if !this.TlsConfig.Equal(that1.TlsConfig) {
		return false
	}
	return true
}
func (this *CDNDownstreamTlsParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNDownstreamTlsParamsType)
	if !ok {
		that2, ok := that.(CDNDownstreamTlsParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TlsConfig.Equal(that1.TlsConfig) {
		return false
	}
	if len(this.TlsCertificates) != len(that1.TlsCertificates) {
		return false
	}
	for i := range this.TlsCertificates {
		if !this.TlsCertificates[i].Equal(that1.TlsCertificates[i]) {
			return false
		}
	}
	return true
}
func (this *CDNHTTPSCustomCertsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNHTTPSCustomCertsType)
	if !ok {
		that2, ok := that.(CDNHTTPSCustomCertsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HttpRedirect != that1.HttpRedirect {
		return false
	}
	if this.AddHsts != that1.AddHsts {
		return false
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if that1.LoadbalancerType == nil {
		if this.LoadbalancerType != nil {
			return false
		}
	} else if this.LoadbalancerType == nil {
		return false
	} else if !this.LoadbalancerType.Equal(that1.LoadbalancerType) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.MoreOption.Equal(that1.MoreOption) {
		return false
	}
	if !this.OriginPool.Equal(that1.OriginPool) {
		return false
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if len(this.DnsInfo) != len(that1.DnsInfo) {
		return false
	}
	for i := range this.DnsInfo {
		if !this.DnsInfo[i].Equal(that1.DnsInfo[i]) {
			return false
		}
	}
	if this.State != that1.State {
		return false
	}
	if this.AutoCertState != that1.AutoCertState {
		return false
	}
	if !this.AutoCertInfo.Equal(that1.AutoCertInfo) {
		return false
	}
	if len(this.ServiceDomains) != len(that1.ServiceDomains) {
		return false
	}
	for i := range this.ServiceDomains {
		if !this.ServiceDomains[i].Equal(that1.ServiceDomains[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Http)
	if !ok {
		that2, ok := that.(GlobalSpecType_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *GlobalSpecType_HttpsAutoCert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_HttpsAutoCert)
	if !ok {
		that2, ok := that.(GlobalSpecType_HttpsAutoCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpsAutoCert.Equal(that1.HttpsAutoCert) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Https) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Https)
	if !ok {
		that2, ok := that.(GlobalSpecType_Https)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Https.Equal(that1.Https) {
		return false
	}
	return true
}
func (this *IpFilteringOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpFilteringOptions)
	if !ok {
		that2, ok := that.(IpFilteringOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.IpFilteringType == nil {
		if this.IpFilteringType != nil {
			return false
		}
	} else if this.IpFilteringType == nil {
		return false
	} else if !this.IpFilteringType.Equal(that1.IpFilteringType) {
		return false
	}
	return true
}
func (this *IpFilteringOptions_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpFilteringOptions_AllowList)
	if !ok {
		that2, ok := that.(IpFilteringOptions_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *IpFilteringOptions_BlockList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpFilteringOptions_BlockList)
	if !ok {
		that2, ok := that.(IpFilteringOptions_BlockList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlockList.Equal(that1.BlockList) {
		return false
	}
	return true
}
func (this *GeoFilteringOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoFilteringOptions)
	if !ok {
		that2, ok := that.(GeoFilteringOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.GeoFilteringType == nil {
		if this.GeoFilteringType != nil {
			return false
		}
	} else if this.GeoFilteringType == nil {
		return false
	} else if !this.GeoFilteringType.Equal(that1.GeoFilteringType) {
		return false
	}
	return true
}
func (this *GeoFilteringOptions_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoFilteringOptions_AllowList)
	if !ok {
		that2, ok := that.(GeoFilteringOptions_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *GeoFilteringOptions_BlockList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoFilteringOptions_BlockList)
	if !ok {
		that2, ok := that.(GeoFilteringOptions_BlockList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlockList.Equal(that1.BlockList) {
		return false
	}
	return true
}
func (this *LogHeaderOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogHeaderOptions)
	if !ok {
		that2, ok := that.(LogHeaderOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.HeaderList) != len(that1.HeaderList) {
		return false
	}
	for i := range this.HeaderList {
		if this.HeaderList[i] != that1.HeaderList[i] {
			return false
		}
	}
	return true
}
func (this *CDNCustomAuthentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCustomAuthentication)
	if !ok {
		that2, ok := that.(CDNCustomAuthentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomAuthConfig != that1.CustomAuthConfig {
		return false
	}
	return true
}
func (this *AuthenticationOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationOptions)
	if !ok {
		that2, ok := that.(AuthenticationOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthOptions == nil {
		if this.AuthOptions != nil {
			return false
		}
	} else if this.AuthOptions == nil {
		return false
	} else if !this.AuthOptions.Equal(that1.AuthOptions) {
		return false
	}
	return true
}
func (this *AuthenticationOptions_DisableAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationOptions_DisableAuth)
	if !ok {
		that2, ok := that.(AuthenticationOptions_DisableAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableAuth.Equal(that1.DisableAuth) {
		return false
	}
	return true
}
func (this *AuthenticationOptions_Jwt) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationOptions_Jwt)
	if !ok {
		that2, ok := that.(AuthenticationOptions_Jwt)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Jwt.Equal(that1.Jwt) {
		return false
	}
	return true
}
func (this *AuthenticationOptions_Custom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationOptions_Custom)
	if !ok {
		that2, ok := that.(AuthenticationOptions_Custom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Custom.Equal(that1.Custom) {
		return false
	}
	return true
}
func (this *CDNOriginServerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNOriginServerType)
	if !ok {
		that2, ok := that.(CDNOriginServerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *CDNOriginServerType_PublicIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNOriginServerType_PublicIp)
	if !ok {
		that2, ok := that.(CDNOriginServerType_PublicIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PublicIp.Equal(that1.PublicIp) {
		return false
	}
	return true
}
func (this *CDNOriginServerType_PublicName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNOriginServerType_PublicName)
	if !ok {
		that2, ok := that.(CDNOriginServerType_PublicName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PublicName.Equal(that1.PublicName) {
		return false
	}
	return true
}
func (this *CdnOriginPoolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CdnOriginPoolType)
	if !ok {
		that2, ok := that.(CdnOriginPoolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PublicName.Equal(that1.PublicName) {
		return false
	}
	if that1.TlsChoice == nil {
		if this.TlsChoice != nil {
			return false
		}
	} else if this.TlsChoice == nil {
		return false
	} else if !this.TlsChoice.Equal(that1.TlsChoice) {
		return false
	}
	if len(this.OriginServers) != len(that1.OriginServers) {
		return false
	}
	for i := range this.OriginServers {
		if !this.OriginServers[i].Equal(that1.OriginServers[i]) {
			return false
		}
	}
	if this.FollowOriginRedirect != that1.FollowOriginRedirect {
		return false
	}
	if this.OriginRequestTimeout != that1.OriginRequestTimeout {
		return false
	}
	return true
}
func (this *CdnOriginPoolType_NoTls) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CdnOriginPoolType_NoTls)
	if !ok {
		that2, ok := that.(CdnOriginPoolType_NoTls)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoTls.Equal(that1.NoTls) {
		return false
	}
	return true
}
func (this *CdnOriginPoolType_UseTls) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CdnOriginPoolType_UseTls)
	if !ok {
		that2, ok := that.(CdnOriginPoolType_UseTls)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseTls.Equal(that1.UseTls) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if that1.LoadbalancerType == nil {
		if this.LoadbalancerType != nil {
			return false
		}
	} else if this.LoadbalancerType == nil {
		return false
	} else if !this.LoadbalancerType.Equal(that1.LoadbalancerType) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.MoreOption.Equal(that1.MoreOption) {
		return false
	}
	if !this.OriginPool.Equal(that1.OriginPool) {
		return false
	}
	return true
}
func (this *CreateSpecType_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Http)
	if !ok {
		that2, ok := that.(CreateSpecType_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *CreateSpecType_HttpsAutoCert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_HttpsAutoCert)
	if !ok {
		that2, ok := that.(CreateSpecType_HttpsAutoCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpsAutoCert.Equal(that1.HttpsAutoCert) {
		return false
	}
	return true
}
func (this *CreateSpecType_Https) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Https)
	if !ok {
		that2, ok := that.(CreateSpecType_Https)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Https.Equal(that1.Https) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if that1.LoadbalancerType == nil {
		if this.LoadbalancerType != nil {
			return false
		}
	} else if this.LoadbalancerType == nil {
		return false
	} else if !this.LoadbalancerType.Equal(that1.LoadbalancerType) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.MoreOption.Equal(that1.MoreOption) {
		return false
	}
	if !this.OriginPool.Equal(that1.OriginPool) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Http)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_HttpsAutoCert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_HttpsAutoCert)
	if !ok {
		that2, ok := that.(ReplaceSpecType_HttpsAutoCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpsAutoCert.Equal(that1.HttpsAutoCert) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Https) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Https)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Https)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Https.Equal(that1.Https) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if that1.LoadbalancerType == nil {
		if this.LoadbalancerType != nil {
			return false
		}
	} else if this.LoadbalancerType == nil {
		return false
	} else if !this.LoadbalancerType.Equal(that1.LoadbalancerType) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.MoreOption.Equal(that1.MoreOption) {
		return false
	}
	if !this.OriginPool.Equal(that1.OriginPool) {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if len(this.DnsInfo) != len(that1.DnsInfo) {
		return false
	}
	for i := range this.DnsInfo {
		if !this.DnsInfo[i].Equal(that1.DnsInfo[i]) {
			return false
		}
	}
	if this.State != that1.State {
		return false
	}
	if !this.AutoCertInfo.Equal(that1.AutoCertInfo) {
		return false
	}
	if len(this.ServiceDomains) != len(that1.ServiceDomains) {
		return false
	}
	for i := range this.ServiceDomains {
		if !this.ServiceDomains[i].Equal(that1.ServiceDomains[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Http)
	if !ok {
		that2, ok := that.(GetSpecType_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *GetSpecType_HttpsAutoCert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_HttpsAutoCert)
	if !ok {
		that2, ok := that.(GetSpecType_HttpsAutoCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpsAutoCert.Equal(that1.HttpsAutoCert) {
		return false
	}
	return true
}
func (this *GetSpecType_Https) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Https)
	if !ok {
		that2, ok := that.(GetSpecType_Https)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Https.Equal(that1.Https) {
		return false
	}
	return true
}
func (this *LilacCDNMetricsFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsFilter)
	if !ok {
		that2, ok := that.(LilacCDNMetricsFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tag != that1.Tag {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	if this.Operator != that1.Operator {
		return false
	}
	return true
}
func (this *LilacCDNMetricsResponseGroupBy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsResponseGroupBy)
	if !ok {
		that2, ok := that.(LilacCDNMetricsResponseGroupBy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *LilacCDNMetricsResponseValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsResponseValue)
	if !ok {
		that2, ok := that.(LilacCDNMetricsResponseValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *LilacCDNMetricsResponseSeries) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsResponseSeries)
	if !ok {
		that2, ok := that.(LilacCDNMetricsResponseSeries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.GroupBy) != len(that1.GroupBy) {
		return false
	}
	for i := range this.GroupBy {
		if !this.GroupBy[i].Equal(that1.GroupBy[i]) {
			return false
		}
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if !this.Value[i].Equal(that1.Value[i]) {
			return false
		}
	}
	return true
}
func (this *LilacCDNMetricsResponseData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsResponseData)
	if !ok {
		that2, ok := that.(LilacCDNMetricsResponseData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	if len(this.Series) != len(that1.Series) {
		return false
	}
	for i := range this.Series {
		if !this.Series[i].Equal(that1.Series[i]) {
			return false
		}
	}
	return true
}
func (this *ProxyTypeHttpsAutoCerts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cdn_loadbalancer.ProxyTypeHttpsAutoCerts{")
	s = append(s, "HttpRedirect: "+fmt.Sprintf("%#v", this.HttpRedirect)+",\n")
	s = append(s, "AddHsts: "+fmt.Sprintf("%#v", this.AddHsts)+",\n")
	if this.TlsConfig != nil {
		s = append(s, "TlsConfig: "+fmt.Sprintf("%#v", this.TlsConfig)+",\n")
	}
	if this.ServerHeaderChoice != nil {
		s = append(s, "ServerHeaderChoice: "+fmt.Sprintf("%#v", this.ServerHeaderChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProxyTypeHttpsAutoCerts_DefaultHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ProxyTypeHttpsAutoCerts_DefaultHeader{` +
		`DefaultHeader:` + fmt.Sprintf("%#v", this.DefaultHeader) + `}`}, ", ")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ProxyTypeHttpsAutoCerts_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_AppendServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ProxyTypeHttpsAutoCerts_AppendServerName{` +
		`AppendServerName:` + fmt.Sprintf("%#v", this.AppendServerName) + `}`}, ", ")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_PassThrough) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ProxyTypeHttpsAutoCerts_PassThrough{` +
		`PassThrough:` + fmt.Sprintf("%#v", this.PassThrough) + `}`}, ", ")
	return s
}
func (this *HeaderControlType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cdn_loadbalancer.HeaderControlType{")
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.SecurityOptionsType{")
	if this.IpFiltering != nil {
		s = append(s, "IpFiltering: "+fmt.Sprintf("%#v", this.IpFiltering)+",\n")
	}
	if this.GeoFiltering != nil {
		s = append(s, "GeoFiltering: "+fmt.Sprintf("%#v", this.GeoFiltering)+",\n")
	}
	if this.AuthOptions != nil {
		s = append(s, "AuthOptions: "+fmt.Sprintf("%#v", this.AuthOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoggingOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.LoggingOptionsType{")
	if this.ClientLogOptions != nil {
		s = append(s, "ClientLogOptions: "+fmt.Sprintf("%#v", this.ClientLogOptions)+",\n")
	}
	if this.OriginLogOptions != nil {
		s = append(s, "OriginLogOptions: "+fmt.Sprintf("%#v", this.OriginLogOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheTTLOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CacheTTLOptionsType{")
	if this.TtlOptions != nil {
		s = append(s, "TtlOptions: "+fmt.Sprintf("%#v", this.TtlOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheTTLOptionsType_CacheTtlDefault) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheTTLOptionsType_CacheTtlDefault{` +
		`CacheTtlDefault:` + fmt.Sprintf("%#v", this.CacheTtlDefault) + `}`}, ", ")
	return s
}
func (this *CacheTTLOptionsType_CacheTtlOverride) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheTTLOptionsType_CacheTtlOverride{` +
		`CacheTtlOverride:` + fmt.Sprintf("%#v", this.CacheTtlOverride) + `}`}, ", ")
	return s
}
func (this *CacheTTLOptionsType_CacheDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheTTLOptionsType_CacheDisabled{` +
		`CacheDisabled:` + fmt.Sprintf("%#v", this.CacheDisabled) + `}`}, ", ")
	return s
}
func (this *AdvancedOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cdn_loadbalancer.AdvancedOptionsType{")
	if this.HeaderOptions != nil {
		s = append(s, "HeaderOptions: "+fmt.Sprintf("%#v", this.HeaderOptions)+",\n")
	}
	if this.SecurityOptions != nil {
		s = append(s, "SecurityOptions: "+fmt.Sprintf("%#v", this.SecurityOptions)+",\n")
	}
	if this.LoggingOptions != nil {
		s = append(s, "LoggingOptions: "+fmt.Sprintf("%#v", this.LoggingOptions)+",\n")
	}
	if this.CacheTtlOptions != nil {
		s = append(s, "CacheTtlOptions: "+fmt.Sprintf("%#v", this.CacheTtlOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNTLSConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CDNTLSConfig{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNTLSConfig_Tls_12Plus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNTLSConfig_Tls_12Plus{` +
		`Tls_12Plus:` + fmt.Sprintf("%#v", this.Tls_12Plus) + `}`}, ", ")
	return s
}
func (this *CDNTLSConfig_Tls_11Plus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNTLSConfig_Tls_11Plus{` +
		`Tls_11Plus:` + fmt.Sprintf("%#v", this.Tls_11Plus) + `}`}, ", ")
	return s
}
func (this *CDNHTTPSAutoCertsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CDNHTTPSAutoCertsType{")
	s = append(s, "HttpRedirect: "+fmt.Sprintf("%#v", this.HttpRedirect)+",\n")
	s = append(s, "AddHsts: "+fmt.Sprintf("%#v", this.AddHsts)+",\n")
	if this.TlsConfig != nil {
		s = append(s, "TlsConfig: "+fmt.Sprintf("%#v", this.TlsConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNDownstreamTlsParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CDNDownstreamTlsParamsType{")
	if this.TlsConfig != nil {
		s = append(s, "TlsConfig: "+fmt.Sprintf("%#v", this.TlsConfig)+",\n")
	}
	if this.TlsCertificates != nil {
		s = append(s, "TlsCertificates: "+fmt.Sprintf("%#v", this.TlsCertificates)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNHTTPSCustomCertsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CDNHTTPSCustomCertsType{")
	s = append(s, "HttpRedirect: "+fmt.Sprintf("%#v", this.HttpRedirect)+",\n")
	s = append(s, "AddHsts: "+fmt.Sprintf("%#v", this.AddHsts)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&cdn_loadbalancer.GlobalSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.LoadbalancerType != nil {
		s = append(s, "LoadbalancerType: "+fmt.Sprintf("%#v", this.LoadbalancerType)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.MoreOption != nil {
		s = append(s, "MoreOption: "+fmt.Sprintf("%#v", this.MoreOption)+",\n")
	}
	if this.OriginPool != nil {
		s = append(s, "OriginPool: "+fmt.Sprintf("%#v", this.OriginPool)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	if this.DnsInfo != nil {
		s = append(s, "DnsInfo: "+fmt.Sprintf("%#v", this.DnsInfo)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "AutoCertState: "+fmt.Sprintf("%#v", this.AutoCertState)+",\n")
	if this.AutoCertInfo != nil {
		s = append(s, "AutoCertInfo: "+fmt.Sprintf("%#v", this.AutoCertInfo)+",\n")
	}
	if this.ServiceDomains != nil {
		s = append(s, "ServiceDomains: "+fmt.Sprintf("%#v", this.ServiceDomains)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GlobalSpecType_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_HttpsAutoCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GlobalSpecType_HttpsAutoCert{` +
		`HttpsAutoCert:` + fmt.Sprintf("%#v", this.HttpsAutoCert) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Https) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GlobalSpecType_Https{` +
		`Https:` + fmt.Sprintf("%#v", this.Https) + `}`}, ", ")
	return s
}
func (this *IpFilteringOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.IpFilteringOptions{")
	if this.IpFilteringType != nil {
		s = append(s, "IpFilteringType: "+fmt.Sprintf("%#v", this.IpFilteringType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpFilteringOptions_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.IpFilteringOptions_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *IpFilteringOptions_BlockList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.IpFilteringOptions_BlockList{` +
		`BlockList:` + fmt.Sprintf("%#v", this.BlockList) + `}`}, ", ")
	return s
}
func (this *GeoFilteringOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.GeoFilteringOptions{")
	if this.GeoFilteringType != nil {
		s = append(s, "GeoFilteringType: "+fmt.Sprintf("%#v", this.GeoFilteringType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoFilteringOptions_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GeoFilteringOptions_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *GeoFilteringOptions_BlockList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GeoFilteringOptions_BlockList{` +
		`BlockList:` + fmt.Sprintf("%#v", this.BlockList) + `}`}, ", ")
	return s
}
func (this *LogHeaderOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_loadbalancer.LogHeaderOptions{")
	s = append(s, "HeaderList: "+fmt.Sprintf("%#v", this.HeaderList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNCustomAuthentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_loadbalancer.CDNCustomAuthentication{")
	s = append(s, "CustomAuthConfig: "+fmt.Sprintf("%#v", this.CustomAuthConfig)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthenticationOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.AuthenticationOptions{")
	if this.AuthOptions != nil {
		s = append(s, "AuthOptions: "+fmt.Sprintf("%#v", this.AuthOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthenticationOptions_DisableAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.AuthenticationOptions_DisableAuth{` +
		`DisableAuth:` + fmt.Sprintf("%#v", this.DisableAuth) + `}`}, ", ")
	return s
}
func (this *AuthenticationOptions_Jwt) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.AuthenticationOptions_Jwt{` +
		`Jwt:` + fmt.Sprintf("%#v", this.Jwt) + `}`}, ", ")
	return s
}
func (this *AuthenticationOptions_Custom) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.AuthenticationOptions_Custom{` +
		`Custom:` + fmt.Sprintf("%#v", this.Custom) + `}`}, ", ")
	return s
}
func (this *CDNOriginServerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CDNOriginServerType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNOriginServerType_PublicIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNOriginServerType_PublicIp{` +
		`PublicIp:` + fmt.Sprintf("%#v", this.PublicIp) + `}`}, ", ")
	return s
}
func (this *CDNOriginServerType_PublicName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNOriginServerType_PublicName{` +
		`PublicName:` + fmt.Sprintf("%#v", this.PublicName) + `}`}, ", ")
	return s
}
func (this *CdnOriginPoolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cdn_loadbalancer.CdnOriginPoolType{")
	if this.PublicName != nil {
		s = append(s, "PublicName: "+fmt.Sprintf("%#v", this.PublicName)+",\n")
	}
	if this.TlsChoice != nil {
		s = append(s, "TlsChoice: "+fmt.Sprintf("%#v", this.TlsChoice)+",\n")
	}
	if this.OriginServers != nil {
		s = append(s, "OriginServers: "+fmt.Sprintf("%#v", this.OriginServers)+",\n")
	}
	s = append(s, "FollowOriginRedirect: "+fmt.Sprintf("%#v", this.FollowOriginRedirect)+",\n")
	s = append(s, "OriginRequestTimeout: "+fmt.Sprintf("%#v", this.OriginRequestTimeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CdnOriginPoolType_NoTls) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CdnOriginPoolType_NoTls{` +
		`NoTls:` + fmt.Sprintf("%#v", this.NoTls) + `}`}, ", ")
	return s
}
func (this *CdnOriginPoolType_UseTls) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CdnOriginPoolType_UseTls{` +
		`UseTls:` + fmt.Sprintf("%#v", this.UseTls) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cdn_loadbalancer.CreateSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.LoadbalancerType != nil {
		s = append(s, "LoadbalancerType: "+fmt.Sprintf("%#v", this.LoadbalancerType)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.MoreOption != nil {
		s = append(s, "MoreOption: "+fmt.Sprintf("%#v", this.MoreOption)+",\n")
	}
	if this.OriginPool != nil {
		s = append(s, "OriginPool: "+fmt.Sprintf("%#v", this.OriginPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CreateSpecType_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_HttpsAutoCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CreateSpecType_HttpsAutoCert{` +
		`HttpsAutoCert:` + fmt.Sprintf("%#v", this.HttpsAutoCert) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_Https) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CreateSpecType_Https{` +
		`Https:` + fmt.Sprintf("%#v", this.Https) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cdn_loadbalancer.ReplaceSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.LoadbalancerType != nil {
		s = append(s, "LoadbalancerType: "+fmt.Sprintf("%#v", this.LoadbalancerType)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.MoreOption != nil {
		s = append(s, "MoreOption: "+fmt.Sprintf("%#v", this.MoreOption)+",\n")
	}
	if this.OriginPool != nil {
		s = append(s, "OriginPool: "+fmt.Sprintf("%#v", this.OriginPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ReplaceSpecType_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_HttpsAutoCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ReplaceSpecType_HttpsAutoCert{` +
		`HttpsAutoCert:` + fmt.Sprintf("%#v", this.HttpsAutoCert) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_Https) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ReplaceSpecType_Https{` +
		`Https:` + fmt.Sprintf("%#v", this.Https) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&cdn_loadbalancer.GetSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.LoadbalancerType != nil {
		s = append(s, "LoadbalancerType: "+fmt.Sprintf("%#v", this.LoadbalancerType)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.MoreOption != nil {
		s = append(s, "MoreOption: "+fmt.Sprintf("%#v", this.MoreOption)+",\n")
	}
	if this.OriginPool != nil {
		s = append(s, "OriginPool: "+fmt.Sprintf("%#v", this.OriginPool)+",\n")
	}
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	if this.DnsInfo != nil {
		s = append(s, "DnsInfo: "+fmt.Sprintf("%#v", this.DnsInfo)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.AutoCertInfo != nil {
		s = append(s, "AutoCertInfo: "+fmt.Sprintf("%#v", this.AutoCertInfo)+",\n")
	}
	if this.ServiceDomains != nil {
		s = append(s, "ServiceDomains: "+fmt.Sprintf("%#v", this.ServiceDomains)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GetSpecType_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *GetSpecType_HttpsAutoCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GetSpecType_HttpsAutoCert{` +
		`HttpsAutoCert:` + fmt.Sprintf("%#v", this.HttpsAutoCert) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Https) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GetSpecType_Https{` +
		`Https:` + fmt.Sprintf("%#v", this.Https) + `}`}, ", ")
	return s
}
func (this *LilacCDNMetricsFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsFilter{")
	s = append(s, "Tag: "+fmt.Sprintf("%#v", this.Tag)+",\n")
	s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNMetricsResponseGroupBy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsResponseGroupBy{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNMetricsResponseValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsResponseValue{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNMetricsResponseSeries) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsResponseSeries{")
	if this.GroupBy != nil {
		s = append(s, "GroupBy: "+fmt.Sprintf("%#v", this.GroupBy)+",\n")
	}
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNMetricsResponseData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsResponseData{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Unit: "+fmt.Sprintf("%#v", this.Unit)+",\n")
	if this.Series != nil {
		s = append(s, "Series: "+fmt.Sprintf("%#v", this.Series)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ProxyTypeHttpsAutoCerts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyTypeHttpsAutoCerts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyTypeHttpsAutoCerts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServerHeaderChoice != nil {
		{
			size := m.ServerHeaderChoice.Size()
			i -= size
			if _, err := m.ServerHeaderChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TlsConfig != nil {
		{
			size, err := m.TlsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AddHsts {
		i--
		if m.AddHsts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HttpRedirect {
		i--
		if m.HttpRedirect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProxyTypeHttpsAutoCerts_DefaultHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyTypeHttpsAutoCerts_DefaultHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultHeader != nil {
		{
			size, err := m.DefaultHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ProxyTypeHttpsAutoCerts_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyTypeHttpsAutoCerts_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *ProxyTypeHttpsAutoCerts_AppendServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyTypeHttpsAutoCerts_AppendServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AppendServerName)
	copy(dAtA[i:], m.AppendServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AppendServerName)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *ProxyTypeHttpsAutoCerts_PassThrough) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyTypeHttpsAutoCerts_PassThrough) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PassThrough != nil {
		{
			size, err := m.PassThrough.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *HeaderControlType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderControlType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderControlType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SecurityOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthOptions != nil {
		{
			size, err := m.AuthOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.GeoFiltering != nil {
		{
			size, err := m.GeoFiltering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IpFiltering != nil {
		{
			size, err := m.IpFiltering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}

func (m *LoggingOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggingOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggingOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OriginLogOptions != nil {
		{
			size, err := m.OriginLogOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ClientLogOptions != nil {
		{
			size, err := m.ClientLogOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}

func (m *CacheTTLOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheTTLOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheTTLOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TtlOptions != nil {
		{
			size := m.TtlOptions.Size()
			i -= size
			if _, err := m.TtlOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CacheTTLOptionsType_CacheTtlDefault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheTTLOptionsType_CacheTtlDefault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CacheTtlDefault)
	copy(dAtA[i:], m.CacheTtlDefault)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.CacheTtlDefault)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CacheTTLOptionsType_CacheTtlOverride) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheTTLOptionsType_CacheTtlOverride) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CacheTtlOverride)
	copy(dAtA[i:], m.CacheTtlOverride)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.CacheTtlOverride)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *CacheTTLOptionsType_CacheDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheTTLOptionsType_CacheDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CacheDisabled != nil {
		{
			size, err := m.CacheDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AdvancedOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvancedOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvancedOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheTtlOptions != nil {
		{
			size, err := m.CacheTtlOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.LoggingOptions != nil {
		{
			size, err := m.LoggingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.SecurityOptions != nil {
		{
			size, err := m.SecurityOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.HeaderOptions != nil {
		{
			size, err := m.HeaderOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}

func (m *CDNTLSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNTLSConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNTLSConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CDNTLSConfig_Tls_12Plus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNTLSConfig_Tls_12Plus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tls_12Plus != nil {
		{
			size, err := m.Tls_12Plus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CDNTLSConfig_Tls_11Plus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNTLSConfig_Tls_11Plus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tls_11Plus != nil {
		{
			size, err := m.Tls_11Plus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CDNHTTPSAutoCertsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNHTTPSAutoCertsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNHTTPSAutoCertsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TlsConfig != nil {
		{
			size, err := m.TlsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AddHsts {
		i--
		if m.AddHsts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HttpRedirect {
		i--
		if m.HttpRedirect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDNDownstreamTlsParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNDownstreamTlsParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNDownstreamTlsParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TlsCertificates) > 0 {
		for iNdEx := len(m.TlsCertificates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TlsCertificates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TlsConfig != nil {
		{
			size, err := m.TlsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNHTTPSCustomCertsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNHTTPSCustomCertsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNHTTPSCustomCertsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TlsParameters != nil {
		{
			size, err := m.TlsParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AddHsts {
		i--
		if m.AddHsts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HttpRedirect {
		i--
		if m.HttpRedirect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceDomains) > 0 {
		for iNdEx := len(m.ServiceDomains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServiceDomains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3f
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.AutoCertInfo != nil {
		{
			size, err := m.AutoCertInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x92
	}
	if m.AutoCertState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertState))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe0
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd8
	}
	if len(m.DnsInfo) > 0 {
		for iNdEx := len(m.DnsInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	if m.ViewInternal != nil {
		{
			size, err := m.ViewInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.LoadbalancerType != nil {
		{
			size := m.LoadbalancerType.Size()
			i -= size
			if _, err := m.LoadbalancerType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OriginPool != nil {
		{
			size, err := m.OriginPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.MoreOption != nil {
		{
			size, err := m.MoreOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_HttpsAutoCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_HttpsAutoCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpsAutoCert != nil {
		{
			size, err := m.HttpsAutoCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Https) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Https) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Https != nil {
		{
			size, err := m.Https.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *IpFilteringOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpFilteringOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpFilteringOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IpFilteringType != nil {
		{
			size := m.IpFilteringType.Size()
			i -= size
			if _, err := m.IpFilteringType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IpFilteringOptions_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpFilteringOptions_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IpFilteringOptions_BlockList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpFilteringOptions_BlockList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockList != nil {
		{
			size, err := m.BlockList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GeoFilteringOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoFilteringOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoFilteringOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GeoFilteringType != nil {
		{
			size := m.GeoFilteringType.Size()
			i -= size
			if _, err := m.GeoFilteringType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GeoFilteringOptions_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoFilteringOptions_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GeoFilteringOptions_BlockList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoFilteringOptions_BlockList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockList != nil {
		{
			size, err := m.BlockList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *LogHeaderOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogHeaderOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogHeaderOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HeaderList) > 0 {
		for iNdEx := len(m.HeaderList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HeaderList[iNdEx])
			copy(dAtA[i:], m.HeaderList[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CDNCustomAuthentication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNCustomAuthentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCustomAuthentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomAuthConfig) > 0 {
		i -= len(m.CustomAuthConfig)
		copy(dAtA[i:], m.CustomAuthConfig)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomAuthConfig)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticationOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthOptions != nil {
		{
			size := m.AuthOptions.Size()
			i -= size
			if _, err := m.AuthOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticationOptions_DisableAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationOptions_DisableAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableAuth != nil {
		{
			size, err := m.DisableAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AuthenticationOptions_Jwt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationOptions_Jwt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Jwt != nil {
		{
			size, err := m.Jwt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AuthenticationOptions_Custom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationOptions_Custom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Custom != nil {
		{
			size, err := m.Custom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CDNOriginServerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNOriginServerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNOriginServerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CDNOriginServerType_PublicIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNOriginServerType_PublicIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PublicIp != nil {
		{
			size, err := m.PublicIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CDNOriginServerType_PublicName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNOriginServerType_PublicName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PublicName != nil {
		{
			size, err := m.PublicName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CdnOriginPoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CdnOriginPoolType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CdnOriginPoolType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OriginRequestTimeout) > 0 {
		i -= len(m.OriginRequestTimeout)
		copy(dAtA[i:], m.OriginRequestTimeout)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OriginRequestTimeout)))
		i--
		dAtA[i] = 0x3a
	}
	if m.FollowOriginRedirect {
		i--
		if m.FollowOriginRedirect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.OriginServers) > 0 {
		for iNdEx := len(m.OriginServers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OriginServers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TlsChoice != nil {
		{
			size := m.TlsChoice.Size()
			i -= size
			if _, err := m.TlsChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PublicName != nil {
		{
			size, err := m.PublicName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CdnOriginPoolType_NoTls) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CdnOriginPoolType_NoTls) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoTls != nil {
		{
			size, err := m.NoTls.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CdnOriginPoolType_UseTls) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CdnOriginPoolType_UseTls) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseTls != nil {
		{
			size, err := m.UseTls.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LoadbalancerType != nil {
		{
			size := m.LoadbalancerType.Size()
			i -= size
			if _, err := m.LoadbalancerType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OriginPool != nil {
		{
			size, err := m.OriginPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.MoreOption != nil {
		{
			size, err := m.MoreOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_HttpsAutoCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_HttpsAutoCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpsAutoCert != nil {
		{
			size, err := m.HttpsAutoCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_Https) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Https) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Https != nil {
		{
			size, err := m.Https.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LoadbalancerType != nil {
		{
			size := m.LoadbalancerType.Size()
			i -= size
			if _, err := m.LoadbalancerType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OriginPool != nil {
		{
			size, err := m.OriginPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.MoreOption != nil {
		{
			size, err := m.MoreOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_HttpsAutoCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_HttpsAutoCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpsAutoCert != nil {
		{
			size, err := m.HttpsAutoCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_Https) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Https) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Https != nil {
		{
			size, err := m.Https.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceDomains) > 0 {
		for iNdEx := len(m.ServiceDomains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServiceDomains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3f
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.AutoCertInfo != nil {
		{
			size, err := m.AutoCertInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x92
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd8
	}
	if len(m.DnsInfo) > 0 {
		for iNdEx := len(m.DnsInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	if m.LoadbalancerType != nil {
		{
			size := m.LoadbalancerType.Size()
			i -= size
			if _, err := m.LoadbalancerType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OriginPool != nil {
		{
			size, err := m.OriginPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.MoreOption != nil {
		{
			size, err := m.MoreOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_HttpsAutoCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_HttpsAutoCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpsAutoCert != nil {
		{
			size, err := m.HttpsAutoCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_Https) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Https) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Https != nil {
		{
			size, err := m.Https.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *LilacCDNMetricsFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Operator))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Tag != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNMetricsResponseGroupBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsResponseGroupBy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsResponseGroupBy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Name))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNMetricsResponseValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsResponseValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsResponseValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Timestamp) > 0 {
		i -= len(m.Timestamp)
		copy(dAtA[i:], m.Timestamp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Timestamp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNMetricsResponseSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsResponseSeries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsResponseSeries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Value[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNMetricsResponseData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsResponseData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsResponseData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Unit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProxyTypeHttpsAutoCerts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpRedirect {
		n += 2
	}
	if m.AddHsts {
		n += 2
	}
	if m.TlsConfig != nil {
		l = m.TlsConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ServerHeaderChoice != nil {
		n += m.ServerHeaderChoice.Size()
	}
	return n
}

func (m *ProxyTypeHttpsAutoCerts_DefaultHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultHeader != nil {
		l = m.DefaultHeader.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProxyTypeHttpsAutoCerts_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ProxyTypeHttpsAutoCerts_AppendServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppendServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ProxyTypeHttpsAutoCerts_PassThrough) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassThrough != nil {
		l = m.PassThrough.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderControlType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SecurityOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpFiltering != nil {
		l = m.IpFiltering.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GeoFiltering != nil {
		l = m.GeoFiltering.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AuthOptions != nil {
		l = m.AuthOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LoggingOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientLogOptions != nil {
		l = m.ClientLogOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginLogOptions != nil {
		l = m.OriginLogOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CacheTTLOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TtlOptions != nil {
		n += m.TtlOptions.Size()
	}
	return n
}

func (m *CacheTTLOptionsType_CacheTtlDefault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacheTtlDefault)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheTTLOptionsType_CacheTtlOverride) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacheTtlOverride)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheTTLOptionsType_CacheDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheDisabled != nil {
		l = m.CacheDisabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvancedOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeaderOptions != nil {
		l = m.HeaderOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.SecurityOptions != nil {
		l = m.SecurityOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LoggingOptions != nil {
		l = m.LoggingOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CacheTtlOptions != nil {
		l = m.CacheTtlOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CDNTLSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *CDNTLSConfig_Tls_12Plus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tls_12Plus != nil {
		l = m.Tls_12Plus.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNTLSConfig_Tls_11Plus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tls_11Plus != nil {
		l = m.Tls_11Plus.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNHTTPSAutoCertsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpRedirect {
		n += 2
	}
	if m.AddHsts {
		n += 2
	}
	if m.TlsConfig != nil {
		l = m.TlsConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CDNDownstreamTlsParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TlsConfig != nil {
		l = m.TlsConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.TlsCertificates) > 0 {
		for _, e := range m.TlsCertificates {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CDNHTTPSCustomCertsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpRedirect {
		n += 2
	}
	if m.AddHsts {
		n += 2
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerType != nil {
		n += m.LoadbalancerType.Size()
	}
	if m.AddLocation {
		n += 2
	}
	if m.MoreOption != nil {
		l = m.MoreOption.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginPool != nil {
		l = m.OriginPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.DnsInfo) > 0 {
		for _, e := range m.DnsInfo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.State != 0 {
		n += 2 + sovTypes(uint64(m.State))
	}
	if m.AutoCertState != 0 {
		n += 2 + sovTypes(uint64(m.AutoCertState))
	}
	if m.AutoCertInfo != nil {
		l = m.AutoCertInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ServiceDomains) > 0 {
		for _, e := range m.ServiceDomains {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_HttpsAutoCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpsAutoCert != nil {
		l = m.HttpsAutoCert.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Https) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Https != nil {
		l = m.Https.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IpFilteringOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpFilteringType != nil {
		n += m.IpFilteringType.Size()
	}
	return n
}

func (m *IpFilteringOptions_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IpFilteringOptions_BlockList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockList != nil {
		l = m.BlockList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GeoFilteringOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GeoFilteringType != nil {
		n += m.GeoFilteringType.Size()
	}
	return n
}

func (m *GeoFilteringOptions_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GeoFilteringOptions_BlockList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockList != nil {
		l = m.BlockList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LogHeaderOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.HeaderList) > 0 {
		for _, s := range m.HeaderList {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CDNCustomAuthentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomAuthConfig)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AuthenticationOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthOptions != nil {
		n += m.AuthOptions.Size()
	}
	return n
}

func (m *AuthenticationOptions_DisableAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableAuth != nil {
		l = m.DisableAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AuthenticationOptions_Jwt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Jwt != nil {
		l = m.Jwt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AuthenticationOptions_Custom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Custom != nil {
		l = m.Custom.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNOriginServerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *CDNOriginServerType_PublicIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicIp != nil {
		l = m.PublicIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNOriginServerType_PublicName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicName != nil {
		l = m.PublicName.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CdnOriginPoolType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicName != nil {
		l = m.PublicName.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TlsChoice != nil {
		n += m.TlsChoice.Size()
	}
	if len(m.OriginServers) > 0 {
		for _, e := range m.OriginServers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.FollowOriginRedirect {
		n += 2
	}
	l = len(m.OriginRequestTimeout)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CdnOriginPoolType_NoTls) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoTls != nil {
		l = m.NoTls.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CdnOriginPoolType_UseTls) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseTls != nil {
		l = m.UseTls.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerType != nil {
		n += m.LoadbalancerType.Size()
	}
	if m.AddLocation {
		n += 2
	}
	if m.MoreOption != nil {
		l = m.MoreOption.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginPool != nil {
		l = m.OriginPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_HttpsAutoCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpsAutoCert != nil {
		l = m.HttpsAutoCert.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_Https) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Https != nil {
		l = m.Https.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerType != nil {
		n += m.LoadbalancerType.Size()
	}
	if m.AddLocation {
		n += 2
	}
	if m.MoreOption != nil {
		l = m.MoreOption.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginPool != nil {
		l = m.OriginPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_HttpsAutoCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpsAutoCert != nil {
		l = m.HttpsAutoCert.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_Https) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Https != nil {
		l = m.Https.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerType != nil {
		n += m.LoadbalancerType.Size()
	}
	if m.AddLocation {
		n += 2
	}
	if m.MoreOption != nil {
		l = m.MoreOption.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginPool != nil {
		l = m.OriginPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.DnsInfo) > 0 {
		for _, e := range m.DnsInfo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.State != 0 {
		n += 2 + sovTypes(uint64(m.State))
	}
	if m.AutoCertInfo != nil {
		l = m.AutoCertInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ServiceDomains) > 0 {
		for _, e := range m.ServiceDomains {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_HttpsAutoCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpsAutoCert != nil {
		l = m.HttpsAutoCert.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_Https) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Https != nil {
		l = m.Https.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LilacCDNMetricsFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovTypes(uint64(m.Tag))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Operator != 0 {
		n += 1 + sovTypes(uint64(m.Operator))
	}
	return n
}

func (m *LilacCDNMetricsResponseGroupBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != 0 {
		n += 1 + sovTypes(uint64(m.Name))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LilacCDNMetricsResponseValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LilacCDNMetricsResponseSeries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LilacCDNMetricsResponseData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Unit != 0 {
		n += 1 + sovTypes(uint64(m.Unit))
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ProxyTypeHttpsAutoCerts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyTypeHttpsAutoCerts{`,
		`HttpRedirect:` + fmt.Sprintf("%v", this.HttpRedirect) + `,`,
		`AddHsts:` + fmt.Sprintf("%v", this.AddHsts) + `,`,
		`TlsConfig:` + strings.Replace(fmt.Sprintf("%v", this.TlsConfig), "TlsConfig", "views.TlsConfig", 1) + `,`,
		`ServerHeaderChoice:` + fmt.Sprintf("%v", this.ServerHeaderChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_DefaultHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyTypeHttpsAutoCerts_DefaultHeader{`,
		`DefaultHeader:` + strings.Replace(fmt.Sprintf("%v", this.DefaultHeader), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyTypeHttpsAutoCerts_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_AppendServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyTypeHttpsAutoCerts_AppendServerName{`,
		`AppendServerName:` + fmt.Sprintf("%v", this.AppendServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_PassThrough) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyTypeHttpsAutoCerts_PassThrough{`,
		`PassThrough:` + strings.Replace(fmt.Sprintf("%v", this.PassThrough), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderControlType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRequestHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.RequestHeadersToAdd {
		repeatedStringForRequestHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForRequestHeadersToAdd += "}"
	repeatedStringForResponseHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.ResponseHeadersToAdd {
		repeatedStringForResponseHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForResponseHeadersToAdd += "}"
	s := strings.Join([]string{`&HeaderControlType{`,
		`RequestHeadersToAdd:` + repeatedStringForRequestHeadersToAdd + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`ResponseHeadersToAdd:` + repeatedStringForResponseHeadersToAdd + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityOptionsType{`,
		`IpFiltering:` + strings.Replace(this.IpFiltering.String(), "IpFilteringOptions", "IpFilteringOptions", 1) + `,`,
		`GeoFiltering:` + strings.Replace(this.GeoFiltering.String(), "GeoFilteringOptions", "GeoFilteringOptions", 1) + `,`,
		`AuthOptions:` + strings.Replace(this.AuthOptions.String(), "AuthenticationOptions", "AuthenticationOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoggingOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoggingOptionsType{`,
		`ClientLogOptions:` + strings.Replace(this.ClientLogOptions.String(), "LogHeaderOptions", "LogHeaderOptions", 1) + `,`,
		`OriginLogOptions:` + strings.Replace(this.OriginLogOptions.String(), "LogHeaderOptions", "LogHeaderOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheTTLOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheTTLOptionsType{`,
		`TtlOptions:` + fmt.Sprintf("%v", this.TtlOptions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheTTLOptionsType_CacheTtlDefault) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheTTLOptionsType_CacheTtlDefault{`,
		`CacheTtlDefault:` + fmt.Sprintf("%v", this.CacheTtlDefault) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheTTLOptionsType_CacheTtlOverride) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheTTLOptionsType_CacheTtlOverride{`,
		`CacheTtlOverride:` + fmt.Sprintf("%v", this.CacheTtlOverride) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheTTLOptionsType_CacheDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheTTLOptionsType_CacheDisabled{`,
		`CacheDisabled:` + strings.Replace(fmt.Sprintf("%v", this.CacheDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvancedOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvancedOptionsType{`,
		`HeaderOptions:` + strings.Replace(this.HeaderOptions.String(), "HeaderControlType", "HeaderControlType", 1) + `,`,
		`SecurityOptions:` + strings.Replace(this.SecurityOptions.String(), "SecurityOptionsType", "SecurityOptionsType", 1) + `,`,
		`LoggingOptions:` + strings.Replace(this.LoggingOptions.String(), "LoggingOptionsType", "LoggingOptionsType", 1) + `,`,
		`CacheTtlOptions:` + strings.Replace(this.CacheTtlOptions.String(), "CacheTTLOptionsType", "CacheTTLOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNTLSConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNTLSConfig{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNTLSConfig_Tls_12Plus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNTLSConfig_Tls_12Plus{`,
		`Tls_12Plus:` + strings.Replace(fmt.Sprintf("%v", this.Tls_12Plus), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNTLSConfig_Tls_11Plus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNTLSConfig_Tls_11Plus{`,
		`Tls_11Plus:` + strings.Replace(fmt.Sprintf("%v", this.Tls_11Plus), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNHTTPSAutoCertsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNHTTPSAutoCertsType{`,
		`HttpRedirect:` + fmt.Sprintf("%v", this.HttpRedirect) + `,`,
		`AddHsts:` + fmt.Sprintf("%v", this.AddHsts) + `,`,
		`TlsConfig:` + strings.Replace(this.TlsConfig.String(), "CDNTLSConfig", "CDNTLSConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNDownstreamTlsParamsType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTlsCertificates := "[]*TlsCertificateType{"
	for _, f := range this.TlsCertificates {
		repeatedStringForTlsCertificates += strings.Replace(fmt.Sprintf("%v", f), "TlsCertificateType", "schema.TlsCertificateType", 1) + ","
	}
	repeatedStringForTlsCertificates += "}"
	s := strings.Join([]string{`&CDNDownstreamTlsParamsType{`,
		`TlsConfig:` + strings.Replace(this.TlsConfig.String(), "CDNTLSConfig", "CDNTLSConfig", 1) + `,`,
		`TlsCertificates:` + repeatedStringForTlsCertificates + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNHTTPSCustomCertsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNHTTPSCustomCertsType{`,
		`HttpRedirect:` + fmt.Sprintf("%v", this.HttpRedirect) + `,`,
		`AddHsts:` + fmt.Sprintf("%v", this.AddHsts) + `,`,
		`TlsParameters:` + strings.Replace(this.TlsParameters.String(), "CDNDownstreamTlsParamsType", "CDNDownstreamTlsParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDnsInfo := "[]*DnsInfo{"
	for _, f := range this.DnsInfo {
		repeatedStringForDnsInfo += strings.Replace(fmt.Sprintf("%v", f), "DnsInfo", "virtual_host_dns_info.DnsInfo", 1) + ","
	}
	repeatedStringForDnsInfo += "}"
	repeatedStringForServiceDomains := "[]*ServiceDomain{"
	for _, f := range this.ServiceDomains {
		repeatedStringForServiceDomains += strings.Replace(fmt.Sprintf("%v", f), "ServiceDomain", "virtual_host.ServiceDomain", 1) + ","
	}
	repeatedStringForServiceDomains += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`LoadbalancerType:` + fmt.Sprintf("%v", this.LoadbalancerType) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`MoreOption:` + strings.Replace(this.MoreOption.String(), "AdvancedOptionsType", "AdvancedOptionsType", 1) + `,`,
		`OriginPool:` + strings.Replace(this.OriginPool.String(), "CdnOriginPoolType", "CdnOriginPoolType", 1) + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`DnsInfo:` + repeatedStringForDnsInfo + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`AutoCertState:` + fmt.Sprintf("%v", this.AutoCertState) + `,`,
		`AutoCertInfo:` + strings.Replace(fmt.Sprintf("%v", this.AutoCertInfo), "AutoCertInfoType", "virtual_host.AutoCertInfoType", 1) + `,`,
		`ServiceDomains:` + repeatedStringForServiceDomains + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ProxyTypeHttp", "http_loadbalancer.ProxyTypeHttp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_HttpsAutoCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_HttpsAutoCert{`,
		`HttpsAutoCert:` + strings.Replace(fmt.Sprintf("%v", this.HttpsAutoCert), "CDNHTTPSAutoCertsType", "CDNHTTPSAutoCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Https) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Https{`,
		`Https:` + strings.Replace(fmt.Sprintf("%v", this.Https), "CDNHTTPSCustomCertsType", "CDNHTTPSCustomCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpFilteringOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpFilteringOptions{`,
		`IpFilteringType:` + fmt.Sprintf("%v", this.IpFilteringType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpFilteringOptions_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpFilteringOptions_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpFilteringOptions_BlockList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpFilteringOptions_BlockList{`,
		`BlockList:` + strings.Replace(fmt.Sprintf("%v", this.BlockList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoFilteringOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoFilteringOptions{`,
		`GeoFilteringType:` + fmt.Sprintf("%v", this.GeoFilteringType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoFilteringOptions_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoFilteringOptions_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "CountryCodeList", "policy.CountryCodeList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoFilteringOptions_BlockList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoFilteringOptions_BlockList{`,
		`BlockList:` + strings.Replace(fmt.Sprintf("%v", this.BlockList), "CountryCodeList", "policy.CountryCodeList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogHeaderOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LogHeaderOptions{`,
		`HeaderList:` + fmt.Sprintf("%v", this.HeaderList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCustomAuthentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNCustomAuthentication{`,
		`CustomAuthConfig:` + fmt.Sprintf("%v", this.CustomAuthConfig) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationOptions{`,
		`AuthOptions:` + fmt.Sprintf("%v", this.AuthOptions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationOptions_DisableAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationOptions_DisableAuth{`,
		`DisableAuth:` + strings.Replace(fmt.Sprintf("%v", this.DisableAuth), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationOptions_Jwt) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationOptions_Jwt{`,
		`Jwt:` + strings.Replace(fmt.Sprintf("%v", this.Jwt), "JwtTokenAuthOptions", "policy.JwtTokenAuthOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationOptions_Custom) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationOptions_Custom{`,
		`Custom:` + strings.Replace(fmt.Sprintf("%v", this.Custom), "CDNCustomAuthentication", "CDNCustomAuthentication", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNOriginServerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNOriginServerType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNOriginServerType_PublicIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNOriginServerType_PublicIp{`,
		`PublicIp:` + strings.Replace(fmt.Sprintf("%v", this.PublicIp), "OriginServerPublicIP", "origin_pool.OriginServerPublicIP", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNOriginServerType_PublicName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNOriginServerType_PublicName{`,
		`PublicName:` + strings.Replace(fmt.Sprintf("%v", this.PublicName), "OriginServerPublicName", "origin_pool.OriginServerPublicName", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CdnOriginPoolType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOriginServers := "[]*CDNOriginServerType{"
	for _, f := range this.OriginServers {
		repeatedStringForOriginServers += strings.Replace(f.String(), "CDNOriginServerType", "CDNOriginServerType", 1) + ","
	}
	repeatedStringForOriginServers += "}"
	s := strings.Join([]string{`&CdnOriginPoolType{`,
		`PublicName:` + strings.Replace(fmt.Sprintf("%v", this.PublicName), "OriginServerPublicName", "origin_pool.OriginServerPublicName", 1) + `,`,
		`TlsChoice:` + fmt.Sprintf("%v", this.TlsChoice) + `,`,
		`OriginServers:` + repeatedStringForOriginServers + `,`,
		`FollowOriginRedirect:` + fmt.Sprintf("%v", this.FollowOriginRedirect) + `,`,
		`OriginRequestTimeout:` + fmt.Sprintf("%v", this.OriginRequestTimeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CdnOriginPoolType_NoTls) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CdnOriginPoolType_NoTls{`,
		`NoTls:` + strings.Replace(fmt.Sprintf("%v", this.NoTls), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CdnOriginPoolType_UseTls) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CdnOriginPoolType_UseTls{`,
		`UseTls:` + strings.Replace(fmt.Sprintf("%v", this.UseTls), "UpstreamTlsParameters", "origin_pool.UpstreamTlsParameters", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`LoadbalancerType:` + fmt.Sprintf("%v", this.LoadbalancerType) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`MoreOption:` + strings.Replace(this.MoreOption.String(), "AdvancedOptionsType", "AdvancedOptionsType", 1) + `,`,
		`OriginPool:` + strings.Replace(this.OriginPool.String(), "CdnOriginPoolType", "CdnOriginPoolType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ProxyTypeHttp", "http_loadbalancer.ProxyTypeHttp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_HttpsAutoCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_HttpsAutoCert{`,
		`HttpsAutoCert:` + strings.Replace(fmt.Sprintf("%v", this.HttpsAutoCert), "CDNHTTPSAutoCertsType", "CDNHTTPSAutoCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Https) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Https{`,
		`Https:` + strings.Replace(fmt.Sprintf("%v", this.Https), "CDNHTTPSCustomCertsType", "CDNHTTPSCustomCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`LoadbalancerType:` + fmt.Sprintf("%v", this.LoadbalancerType) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`MoreOption:` + strings.Replace(this.MoreOption.String(), "AdvancedOptionsType", "AdvancedOptionsType", 1) + `,`,
		`OriginPool:` + strings.Replace(this.OriginPool.String(), "CdnOriginPoolType", "CdnOriginPoolType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ProxyTypeHttp", "http_loadbalancer.ProxyTypeHttp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_HttpsAutoCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_HttpsAutoCert{`,
		`HttpsAutoCert:` + strings.Replace(fmt.Sprintf("%v", this.HttpsAutoCert), "CDNHTTPSAutoCertsType", "CDNHTTPSAutoCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Https) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Https{`,
		`Https:` + strings.Replace(fmt.Sprintf("%v", this.Https), "CDNHTTPSCustomCertsType", "CDNHTTPSCustomCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDnsInfo := "[]*DnsInfo{"
	for _, f := range this.DnsInfo {
		repeatedStringForDnsInfo += strings.Replace(fmt.Sprintf("%v", f), "DnsInfo", "virtual_host_dns_info.DnsInfo", 1) + ","
	}
	repeatedStringForDnsInfo += "}"
	repeatedStringForServiceDomains := "[]*ServiceDomain{"
	for _, f := range this.ServiceDomains {
		repeatedStringForServiceDomains += strings.Replace(fmt.Sprintf("%v", f), "ServiceDomain", "virtual_host.ServiceDomain", 1) + ","
	}
	repeatedStringForServiceDomains += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`LoadbalancerType:` + fmt.Sprintf("%v", this.LoadbalancerType) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`MoreOption:` + strings.Replace(this.MoreOption.String(), "AdvancedOptionsType", "AdvancedOptionsType", 1) + `,`,
		`OriginPool:` + strings.Replace(this.OriginPool.String(), "CdnOriginPoolType", "CdnOriginPoolType", 1) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`DnsInfo:` + repeatedStringForDnsInfo + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`AutoCertInfo:` + strings.Replace(fmt.Sprintf("%v", this.AutoCertInfo), "AutoCertInfoType", "virtual_host.AutoCertInfoType", 1) + `,`,
		`ServiceDomains:` + repeatedStringForServiceDomains + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ProxyTypeHttp", "http_loadbalancer.ProxyTypeHttp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_HttpsAutoCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_HttpsAutoCert{`,
		`HttpsAutoCert:` + strings.Replace(fmt.Sprintf("%v", this.HttpsAutoCert), "CDNHTTPSAutoCertsType", "CDNHTTPSAutoCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Https) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Https{`,
		`Https:` + strings.Replace(fmt.Sprintf("%v", this.Https), "CDNHTTPSCustomCertsType", "CDNHTTPSCustomCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNMetricsFilter{`,
		`Tag:` + fmt.Sprintf("%v", this.Tag) + `,`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`Operator:` + fmt.Sprintf("%v", this.Operator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsResponseGroupBy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNMetricsResponseGroupBy{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsResponseValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNMetricsResponseValue{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsResponseSeries) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGroupBy := "[]*LilacCDNMetricsResponseGroupBy{"
	for _, f := range this.GroupBy {
		repeatedStringForGroupBy += strings.Replace(f.String(), "LilacCDNMetricsResponseGroupBy", "LilacCDNMetricsResponseGroupBy", 1) + ","
	}
	repeatedStringForGroupBy += "}"
	repeatedStringForValue := "[]*LilacCDNMetricsResponseValue{"
	for _, f := range this.Value {
		repeatedStringForValue += strings.Replace(f.String(), "LilacCDNMetricsResponseValue", "LilacCDNMetricsResponseValue", 1) + ","
	}
	repeatedStringForValue += "}"
	s := strings.Join([]string{`&LilacCDNMetricsResponseSeries{`,
		`GroupBy:` + repeatedStringForGroupBy + `,`,
		`Value:` + repeatedStringForValue + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsResponseData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSeries := "[]*LilacCDNMetricsResponseSeries{"
	for _, f := range this.Series {
		repeatedStringForSeries += strings.Replace(f.String(), "LilacCDNMetricsResponseSeries", "LilacCDNMetricsResponseSeries", 1) + ","
	}
	repeatedStringForSeries += "}"
	s := strings.Join([]string{`&LilacCDNMetricsResponseData{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Unit:` + fmt.Sprintf("%v", this.Unit) + `,`,
		`Series:` + repeatedStringForSeries + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ProxyTypeHttpsAutoCerts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyTypeHttpsAutoCerts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyTypeHttpsAutoCerts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpRedirect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HttpRedirect = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHsts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddHsts = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsConfig == nil {
				m.TlsConfig = &views.TlsConfig{}
			}
			if err := m.TlsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &ProxyTypeHttpsAutoCerts_DefaultHeader{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &ProxyTypeHttpsAutoCerts_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &ProxyTypeHttpsAutoCerts_AppendServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassThrough", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &ProxyTypeHttpsAutoCerts_PassThrough{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderControlType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderControlType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderControlType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFiltering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpFiltering == nil {
				m.IpFiltering = &IpFilteringOptions{}
			}
			if err := m.IpFiltering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoFiltering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeoFiltering == nil {
				m.GeoFiltering = &GeoFilteringOptions{}
			}
			if err := m.GeoFiltering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthOptions == nil {
				m.AuthOptions = &AuthenticationOptions{}
			}
			if err := m.AuthOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggingOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggingOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggingOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientLogOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientLogOptions == nil {
				m.ClientLogOptions = &LogHeaderOptions{}
			}
			if err := m.ClientLogOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginLogOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginLogOptions == nil {
				m.OriginLogOptions = &LogHeaderOptions{}
			}
			if err := m.OriginLogOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheTTLOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheTTLOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheTTLOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtlDefault", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TtlOptions = &CacheTTLOptionsType_CacheTtlDefault{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtlOverride", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TtlOptions = &CacheTTLOptionsType_CacheTtlOverride{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TtlOptions = &CacheTTLOptionsType_CacheDisabled{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvancedOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvancedOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvancedOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeaderOptions == nil {
				m.HeaderOptions = &HeaderControlType{}
			}
			if err := m.HeaderOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityOptions == nil {
				m.SecurityOptions = &SecurityOptionsType{}
			}
			if err := m.SecurityOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoggingOptions == nil {
				m.LoggingOptions = &LoggingOptionsType{}
			}
			if err := m.LoggingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtlOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CacheTtlOptions == nil {
				m.CacheTtlOptions = &CacheTTLOptionsType{}
			}
			if err := m.CacheTtlOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNTLSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNTLSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNTLSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls_12Plus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CDNTLSConfig_Tls_12Plus{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls_11Plus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CDNTLSConfig_Tls_11Plus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNHTTPSAutoCertsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNHTTPSAutoCertsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNHTTPSAutoCertsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpRedirect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HttpRedirect = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHsts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddHsts = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsConfig == nil {
				m.TlsConfig = &CDNTLSConfig{}
			}
			if err := m.TlsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNDownstreamTlsParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNDownstreamTlsParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNDownstreamTlsParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsConfig == nil {
				m.TlsConfig = &CDNTLSConfig{}
			}
			if err := m.TlsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCertificates = append(m.TlsCertificates, &schema.TlsCertificateType{})
			if err := m.TlsCertificates[len(m.TlsCertificates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNHTTPSCustomCertsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNHTTPSCustomCertsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNHTTPSCustomCertsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpRedirect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HttpRedirect = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHsts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddHsts = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &CDNDownstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GlobalSpecType_Http{v}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoreOption == nil {
				m.MoreOption = &AdvancedOptionsType{}
			}
			if err := m.MoreOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginPool == nil {
				m.OriginPool = &CdnOriginPoolType{}
			}
			if err := m.OriginPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsAutoCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSAutoCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GlobalSpecType_HttpsAutoCert{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Https", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSCustomCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GlobalSpecType_Https{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 1002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsInfo = append(m.DnsInfo, &virtual_host_dns_info.DnsInfo{})
			if err := m.DnsInfo[len(m.DnsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= virtual_host.VirtualHostState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1004:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertState", wireType)
			}
			m.AutoCertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoCertState |= virtual_host.CertificationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1010:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoCertInfo == nil {
				m.AutoCertInfo = &virtual_host.AutoCertInfoType{}
			}
			if err := m.AutoCertInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1011:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceDomains = append(m.ServiceDomains, &virtual_host.ServiceDomain{})
			if err := m.ServiceDomains[len(m.ServiceDomains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpFilteringOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpFilteringOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpFilteringOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpFilteringType = &IpFilteringOptions_AllowList{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpFilteringType = &IpFilteringOptions_BlockList{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoFilteringOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoFilteringOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoFilteringOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.CountryCodeList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GeoFilteringType = &GeoFilteringOptions_AllowList{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.CountryCodeList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GeoFilteringType = &GeoFilteringOptions_BlockList{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogHeaderOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogHeaderOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogHeaderOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderList = append(m.HeaderList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNCustomAuthentication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNCustomAuthentication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNCustomAuthentication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomAuthConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomAuthConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthOptions = &AuthenticationOptions_DisableAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.JwtTokenAuthOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthOptions = &AuthenticationOptions_Jwt{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Custom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNCustomAuthentication{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthOptions = &AuthenticationOptions_Custom{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNOriginServerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNOriginServerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNOriginServerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &origin_pool.OriginServerPublicIP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CDNOriginServerType_PublicIp{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &origin_pool.OriginServerPublicName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CDNOriginServerType_PublicName{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CdnOriginPoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CdnOriginPoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CdnOriginPoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicName == nil {
				m.PublicName = &origin_pool.OriginServerPublicName{}
			}
			if err := m.PublicName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoTls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TlsChoice = &CdnOriginPoolType_NoTls{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &origin_pool.UpstreamTlsParameters{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TlsChoice = &CdnOriginPoolType_UseTls{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginServers = append(m.OriginServers, &CDNOriginServerType{})
			if err := m.OriginServers[len(m.OriginServers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowOriginRedirect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FollowOriginRedirect = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginRequestTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginRequestTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &CreateSpecType_Http{v}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoreOption == nil {
				m.MoreOption = &AdvancedOptionsType{}
			}
			if err := m.MoreOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginPool == nil {
				m.OriginPool = &CdnOriginPoolType{}
			}
			if err := m.OriginPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsAutoCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSAutoCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &CreateSpecType_HttpsAutoCert{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Https", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSCustomCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &CreateSpecType_Https{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &ReplaceSpecType_Http{v}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoreOption == nil {
				m.MoreOption = &AdvancedOptionsType{}
			}
			if err := m.MoreOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginPool == nil {
				m.OriginPool = &CdnOriginPoolType{}
			}
			if err := m.OriginPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsAutoCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSAutoCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &ReplaceSpecType_HttpsAutoCert{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Https", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSCustomCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &ReplaceSpecType_Https{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GetSpecType_Http{v}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoreOption == nil {
				m.MoreOption = &AdvancedOptionsType{}
			}
			if err := m.MoreOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginPool == nil {
				m.OriginPool = &CdnOriginPoolType{}
			}
			if err := m.OriginPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsAutoCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSAutoCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GetSpecType_HttpsAutoCert{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Https", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSCustomCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GetSpecType_Https{v}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 1002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsInfo = append(m.DnsInfo, &virtual_host_dns_info.DnsInfo{})
			if err := m.DnsInfo[len(m.DnsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= virtual_host.VirtualHostState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1010:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoCertInfo == nil {
				m.AutoCertInfo = &virtual_host.AutoCertInfoType{}
			}
			if err := m.AutoCertInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1011:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceDomains = append(m.ServiceDomains, &virtual_host.ServiceDomain{})
			if err := m.ServiceDomains[len(m.ServiceDomains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= LilacCDNMetricsTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			m.Operator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operator |= LilacCDNMetricsOperatorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsResponseGroupBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseGroupBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseGroupBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			m.Name = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Name |= LilacCDNMetricsTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsResponseValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsResponseSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &LilacCDNMetricsResponseGroupBy{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &LilacCDNMetricsResponseValue{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsResponseData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LilacCDNMetricsFieldSelector(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= LilacCDNMetricUnit(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &LilacCDNMetricsResponseSeries{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
