// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package dns_zone

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *DnsZoneMetricsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DnsZoneMetricsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DnsZoneMetricsRequest) DeepCopy() *DnsZoneMetricsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DnsZoneMetricsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DnsZoneMetricsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DnsZoneMetricsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DnsZoneMetricsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDnsZoneMetricsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDnsZoneMetricsRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateDnsZoneMetricsRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateDnsZoneMetricsRequest) LimitValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for limit")
	}

	return validatorFn, nil
}

func (v *ValidateDnsZoneMetricsRequest) StepValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for step")
	}

	return validatorFn, nil
}

func (v *ValidateDnsZoneMetricsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DnsZoneMetricsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DnsZoneMetricsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["filter"]; exists {

		vOpts := append(opts, db.WithValidateField("filter"))
		if err := fv(ctx, m.GetFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["group_by"]; exists {

		vOpts := append(opts, db.WithValidateField("group_by"))
		for idx, item := range m.GetGroupBy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDnsZoneMetricsRequestValidator = func() *ValidateDnsZoneMetricsRequest {
	v := &ValidateDnsZoneMetricsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DnsZoneMetricsRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DnsZoneMetricsRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	vrhLimit := v.LimitValidationRuleHandler
	rulesLimit := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFn, err = vrhLimit(rulesLimit)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DnsZoneMetricsRequest.limit: %s", err)
		panic(errMsg)
	}
	v.FldValidators["limit"] = vFn

	vrhStep := v.StepValidationRuleHandler
	rulesStep := map[string]string{
		"ves.io.schema.rules.string.query_step": "true",
	}
	vFn, err = vrhStep(rulesStep)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DnsZoneMetricsRequest.step: %s", err)
		panic(errMsg)
	}
	v.FldValidators["step"] = vFn

	return v
}()

func DnsZoneMetricsRequestValidator() db.Validator {
	return DefaultDnsZoneMetricsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DnsZoneMetricsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DnsZoneMetricsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DnsZoneMetricsResponse) DeepCopy() *DnsZoneMetricsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DnsZoneMetricsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DnsZoneMetricsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DnsZoneMetricsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DnsZoneMetricsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateDnsZoneMetricsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDnsZoneMetricsResponse) StepValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for step")
	}

	return validatorFn, nil
}

func (v *ValidateDnsZoneMetricsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DnsZoneMetricsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DnsZoneMetricsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDnsZoneMetricsResponseValidator = func() *ValidateDnsZoneMetricsResponse {
	v := &ValidateDnsZoneMetricsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStep := v.StepValidationRuleHandler
	rulesStep := map[string]string{
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFn, err = vrhStep(rulesStep)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DnsZoneMetricsResponse.step: %s", err)
		panic(errMsg)
	}
	v.FldValidators["step"] = vFn

	return v
}()

func DnsZoneMetricsResponseValidator() db.Validator {
	return DefaultDnsZoneMetricsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *DnsZoneRequestLogRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DnsZoneRequestLogRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DnsZoneRequestLogRequest) DeepCopy() *DnsZoneRequestLogRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DnsZoneRequestLogRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DnsZoneRequestLogRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DnsZoneRequestLogRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DnsZoneRequestLogRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDnsZoneRequestLogRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDnsZoneRequestLogRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateDnsZoneRequestLogRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateDnsZoneRequestLogRequest) LimitValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for limit")
	}

	return validatorFn, nil
}

func (v *ValidateDnsZoneRequestLogRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DnsZoneRequestLogRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DnsZoneRequestLogRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["filter"]; exists {

		vOpts := append(opts, db.WithValidateField("filter"))
		if err := fv(ctx, m.GetFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDnsZoneRequestLogRequestValidator = func() *ValidateDnsZoneRequestLogRequest {
	v := &ValidateDnsZoneRequestLogRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DnsZoneRequestLogRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DnsZoneRequestLogRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	vrhLimit := v.LimitValidationRuleHandler
	rulesLimit := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "500",
	}
	vFn, err = vrhLimit(rulesLimit)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DnsZoneRequestLogRequest.limit: %s", err)
		panic(errMsg)
	}
	v.FldValidators["limit"] = vFn

	return v
}()

func DnsZoneRequestLogRequestValidator() db.Validator {
	return DefaultDnsZoneRequestLogRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DnsZoneRequestLogResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DnsZoneRequestLogResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DnsZoneRequestLogResponse) DeepCopy() *DnsZoneRequestLogResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DnsZoneRequestLogResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DnsZoneRequestLogResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DnsZoneRequestLogResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DnsZoneRequestLogResponseValidator().Validate(ctx, m, opts...)
}

type ValidateDnsZoneRequestLogResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDnsZoneRequestLogResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DnsZoneRequestLogResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DnsZoneRequestLogResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["logs"]; exists {

		vOpts := append(opts, db.WithValidateField("logs"))
		for idx, item := range m.GetLogs() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDnsZoneRequestLogResponseValidator = func() *ValidateDnsZoneRequestLogResponse {
	v := &ValidateDnsZoneRequestLogResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["logs"] = DnsZoneRequestLogsResponseDataValidator().Validate

	return v
}()

func DnsZoneRequestLogResponseValidator() db.Validator {
	return DefaultDnsZoneRequestLogResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *DnsZoneRequestLogsResponseData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DnsZoneRequestLogsResponseData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DnsZoneRequestLogsResponseData) DeepCopy() *DnsZoneRequestLogsResponseData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DnsZoneRequestLogsResponseData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DnsZoneRequestLogsResponseData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DnsZoneRequestLogsResponseData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DnsZoneRequestLogsResponseDataValidator().Validate(ctx, m, opts...)
}

type ValidateDnsZoneRequestLogsResponseData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDnsZoneRequestLogsResponseData) TimestampValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for timestamp")
	}

	return validatorFn, nil
}

func (v *ValidateDnsZoneRequestLogsResponseData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DnsZoneRequestLogsResponseData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DnsZoneRequestLogsResponseData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("client_subnet"))
		if err := fv(ctx, m.GetClientSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["country_code"]; exists {

		vOpts := append(opts, db.WithValidateField("country_code"))
		if err := fv(ctx, m.GetCountryCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_zone_name"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_zone_name"))
		if err := fv(ctx, m.GetDnsZoneName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query_type"]; exists {

		vOpts := append(opts, db.WithValidateField("query_type"))
		if err := fv(ctx, m.GetQueryType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_code"]; exists {

		vOpts := append(opts, db.WithValidateField("response_code"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("timestamp"))
		if err := fv(ctx, m.GetTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDnsZoneRequestLogsResponseDataValidator = func() *ValidateDnsZoneRequestLogsResponseData {
	v := &ValidateDnsZoneRequestLogsResponseData{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTimestamp := v.TimestampValidationRuleHandler
	rulesTimestamp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTimestamp(rulesTimestamp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DnsZoneRequestLogsResponseData.timestamp: %s", err)
		panic(errMsg)
	}
	v.FldValidators["timestamp"] = vFn

	return v
}()

func DnsZoneRequestLogsResponseDataValidator() db.Validator {
	return DefaultDnsZoneRequestLogsResponseDataValidator
}

// augmented methods on protoc/std generated struct

func (m *MetricsData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MetricsData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MetricsData) DeepCopy() *MetricsData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MetricsData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MetricsData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MetricsData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MetricsDataValidator().Validate(ctx, m, opts...)
}

type ValidateMetricsData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMetricsData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MetricsData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MetricsData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		for idx, item := range m.GetValue() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMetricsDataValidator = func() *ValidateMetricsData {
	v := &ValidateMetricsData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MetricsDataValidator() db.Validator {
	return DefaultMetricsDataValidator
}
