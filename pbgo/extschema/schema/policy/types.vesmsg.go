// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package policy

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_app_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_firewall"
	ves_io_schema_waf_rule_list "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/waf_rule_list"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AppFirewallAttackTypeContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppFirewallAttackTypeContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppFirewallAttackTypeContext) DeepCopy() *AppFirewallAttackTypeContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppFirewallAttackTypeContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppFirewallAttackTypeContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppFirewallAttackTypeContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppFirewallAttackTypeContextValidator().Validate(ctx, m, opts...)
}

type ValidateAppFirewallAttackTypeContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppFirewallAttackTypeContext) ExcludeAttackTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_app_firewall.AttackType)
		return int32(i)
	}
	// ves_io_schema_app_firewall.AttackType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_app_firewall.AttackType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exclude_attack_type")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallAttackTypeContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppFirewallAttackTypeContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppFirewallAttackTypeContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_attack_type"]; exists {

		vOpts := append(opts, db.WithValidateField("exclude_attack_type"))
		if err := fv(ctx, m.GetExcludeAttackType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppFirewallAttackTypeContextValidator = func() *ValidateAppFirewallAttackTypeContext {
	v := &ValidateAppFirewallAttackTypeContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeAttackType := v.ExcludeAttackTypeValidationRuleHandler
	rulesExcludeAttackType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhExcludeAttackType(rulesExcludeAttackType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallAttackTypeContext.exclude_attack_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_attack_type"] = vFn

	return v
}()

func AppFirewallAttackTypeContextValidator() db.Validator {
	return DefaultAppFirewallAttackTypeContextValidator
}

// augmented methods on protoc/std generated struct

func (m *AppFirewallDetectionControl) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppFirewallDetectionControl) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppFirewallDetectionControl) DeepCopy() *AppFirewallDetectionControl {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppFirewallDetectionControl{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppFirewallDetectionControl) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppFirewallDetectionControl) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppFirewallDetectionControlValidator().Validate(ctx, m, opts...)
}

type ValidateAppFirewallDetectionControl struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppFirewallDetectionControl) ExcludeSignatureContextsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_signature_contexts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AppFirewallSignatureContext, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AppFirewallSignatureContextValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_signature_contexts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppFirewallSignatureContext)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppFirewallSignatureContext, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_signature_contexts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_signature_contexts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallDetectionControl) ExcludeViolationContextsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_violation_contexts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AppFirewallViolationContext, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AppFirewallViolationContextValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_violation_contexts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppFirewallViolationContext)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppFirewallViolationContext, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_violation_contexts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_violation_contexts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallDetectionControl) ExcludeAttackTypeContextsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_attack_type_contexts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AppFirewallAttackTypeContext, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AppFirewallAttackTypeContextValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_attack_type_contexts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppFirewallAttackTypeContext)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppFirewallAttackTypeContext, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_attack_type_contexts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_attack_type_contexts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallDetectionControl) ExcludeBotNameContextsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_bot_name_contexts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*BotNameContext, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := BotNameContextValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_bot_name_contexts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*BotNameContext)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*BotNameContext, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_bot_name_contexts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_bot_name_contexts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallDetectionControl) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppFirewallDetectionControl)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppFirewallDetectionControl got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_attack_type_contexts"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_attack_type_contexts"))
		if err := fv(ctx, m.GetExcludeAttackTypeContexts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude_bot_name_contexts"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_bot_name_contexts"))
		if err := fv(ctx, m.GetExcludeBotNameContexts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude_signature_contexts"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_signature_contexts"))
		if err := fv(ctx, m.GetExcludeSignatureContexts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude_violation_contexts"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_violation_contexts"))
		if err := fv(ctx, m.GetExcludeViolationContexts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppFirewallDetectionControlValidator = func() *ValidateAppFirewallDetectionControl {
	v := &ValidateAppFirewallDetectionControl{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeSignatureContexts := v.ExcludeSignatureContextsValidationRuleHandler
	rulesExcludeSignatureContexts := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1024",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeSignatureContexts(rulesExcludeSignatureContexts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallDetectionControl.exclude_signature_contexts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_signature_contexts"] = vFn

	vrhExcludeViolationContexts := v.ExcludeViolationContextsValidationRuleHandler
	rulesExcludeViolationContexts := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeViolationContexts(rulesExcludeViolationContexts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallDetectionControl.exclude_violation_contexts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_violation_contexts"] = vFn

	vrhExcludeAttackTypeContexts := v.ExcludeAttackTypeContextsValidationRuleHandler
	rulesExcludeAttackTypeContexts := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeAttackTypeContexts(rulesExcludeAttackTypeContexts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallDetectionControl.exclude_attack_type_contexts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_attack_type_contexts"] = vFn

	vrhExcludeBotNameContexts := v.ExcludeBotNameContextsValidationRuleHandler
	rulesExcludeBotNameContexts := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeBotNameContexts(rulesExcludeBotNameContexts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallDetectionControl.exclude_bot_name_contexts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_bot_name_contexts"] = vFn

	return v
}()

func AppFirewallDetectionControlValidator() db.Validator {
	return DefaultAppFirewallDetectionControlValidator
}

// augmented methods on protoc/std generated struct

func (m *AppFirewallSignatureContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppFirewallSignatureContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppFirewallSignatureContext) DeepCopy() *AppFirewallSignatureContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppFirewallSignatureContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppFirewallSignatureContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppFirewallSignatureContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppFirewallSignatureContextValidator().Validate(ctx, m, opts...)
}

type ValidateAppFirewallSignatureContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppFirewallSignatureContext) SignatureIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for signature_id")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallSignatureContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppFirewallSignatureContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppFirewallSignatureContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["signature_id"]; exists {

		vOpts := append(opts, db.WithValidateField("signature_id"))
		if err := fv(ctx, m.GetSignatureId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppFirewallSignatureContextValidator = func() *ValidateAppFirewallSignatureContext {
	v := &ValidateAppFirewallSignatureContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSignatureId := v.SignatureIdValidationRuleHandler
	rulesSignatureId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "10000000",
		"ves.io.schema.rules.uint32.lte":       "300000000",
	}
	vFn, err = vrhSignatureId(rulesSignatureId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallSignatureContext.signature_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["signature_id"] = vFn

	return v
}()

func AppFirewallSignatureContextValidator() db.Validator {
	return DefaultAppFirewallSignatureContextValidator
}

// augmented methods on protoc/std generated struct

func (m *AppFirewallViolationContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppFirewallViolationContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppFirewallViolationContext) DeepCopy() *AppFirewallViolationContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppFirewallViolationContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppFirewallViolationContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppFirewallViolationContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppFirewallViolationContextValidator().Validate(ctx, m, opts...)
}

type ValidateAppFirewallViolationContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppFirewallViolationContext) ExcludeViolationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_app_firewall.AppFirewallViolationType)
		return int32(i)
	}
	// ves_io_schema_app_firewall.AppFirewallViolationType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_app_firewall.AppFirewallViolationType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exclude_violation")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallViolationContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppFirewallViolationContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppFirewallViolationContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_violation"]; exists {

		vOpts := append(opts, db.WithValidateField("exclude_violation"))
		if err := fv(ctx, m.GetExcludeViolation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppFirewallViolationContextValidator = func() *ValidateAppFirewallViolationContext {
	v := &ValidateAppFirewallViolationContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeViolation := v.ExcludeViolationValidationRuleHandler
	rulesExcludeViolation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhExcludeViolation(rulesExcludeViolation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallViolationContext.exclude_violation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_violation"] = vFn

	return v
}()

func AppFirewallViolationContextValidator() db.Validator {
	return DefaultAppFirewallViolationContextValidator
}

// augmented methods on protoc/std generated struct

func (m *ArgMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ArgMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ArgMatcherType) DeepCopy() *ArgMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ArgMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ArgMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ArgMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ArgMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateArgMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateArgMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateArgMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateArgMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ArgMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ArgMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *ArgMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*ArgMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ArgMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*ArgMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ArgMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*ArgMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ArgMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*ArgMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultArgMatcherTypeValidator = func() *ValidateArgMatcherType {
	v := &ValidateArgMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ArgMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.json_path": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ArgMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func ArgMatcherTypeValidator() db.Validator {
	return DefaultArgMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AsnMatchList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AsnMatchList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AsnMatchList) DeepCopy() *AsnMatchList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AsnMatchList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AsnMatchList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AsnMatchList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AsnMatchListValidator().Validate(ctx, m, opts...)
}

type ValidateAsnMatchList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAsnMatchList) AsNumbersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepUint32ItemRules(rules)
	itemValFn, err := db.NewUint32ValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for as_numbers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []uint32, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for as_numbers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]uint32)
		if !ok {
			return fmt.Errorf("Repeated validation expected []uint32, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated as_numbers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items as_numbers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAsnMatchList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AsnMatchList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AsnMatchList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["as_numbers"]; exists {
		vOpts := append(opts, db.WithValidateField("as_numbers"))
		if err := fv(ctx, m.GetAsNumbers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAsnMatchListValidator = func() *ValidateAsnMatchList {
	v := &ValidateAsnMatchList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsNumbers := v.AsNumbersValidationRuleHandler
	rulesAsNumbers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAsNumbers(rulesAsNumbers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AsnMatchList.as_numbers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["as_numbers"] = vFn

	return v
}()

func AsnMatchListValidator() db.Validator {
	return DefaultAsnMatchListValidator
}

// augmented methods on protoc/std generated struct

func (m *AsnMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AsnMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AsnMatcherType) DeepCopy() *AsnMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AsnMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AsnMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AsnMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AsnMatcherTypeValidator().Validate(ctx, m, opts...)
}

func (m *AsnMatcherType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAsnSetsDRefInfo()

}

func (m *AsnMatcherType) GetAsnSetsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAsnSets()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("AsnMatcherType.asn_sets[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "bgp_asn_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "asn_sets",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAsnSetsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AsnMatcherType) GetAsnSetsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "bgp_asn_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: bgp_asn_set")
	}
	for _, ref := range m.GetAsnSets() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateAsnMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAsnMatcherType) AsnSetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for asn_sets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for asn_sets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated asn_sets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items asn_sets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAsnMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AsnMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AsnMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asn_sets"]; exists {
		vOpts := append(opts, db.WithValidateField("asn_sets"))
		if err := fv(ctx, m.GetAsnSets(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAsnMatcherTypeValidator = func() *ValidateAsnMatcherType {
	v := &ValidateAsnMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsnSets := v.AsnSetsValidationRuleHandler
	rulesAsnSets := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhAsnSets(rulesAsnSets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AsnMatcherType.asn_sets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["asn_sets"] = vFn

	return v
}()

func AsnMatcherTypeValidator() db.Validator {
	return DefaultAsnMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotAction) DeepCopy() *BotAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotActionValidator().Validate(ctx, m, opts...)
}

type ValidateBotAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotAction) ActionTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_type")
	}
	return validatorFn, nil
}

func (v *ValidateBotAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_type"]; exists {
		val := m.GetActionType()
		vOpts := append(opts,
			db.WithValidateField("action_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionType().(type) {
	case *BotAction_None:
		if fv, exists := v.FldValidators["action_type.none"]; exists {
			val := m.GetActionType().(*BotAction_None).None
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotAction_BotSkipProcessing:
		if fv, exists := v.FldValidators["action_type.bot_skip_processing"]; exists {
			val := m.GetActionType().(*BotAction_BotSkipProcessing).BotSkipProcessing
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("bot_skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotActionValidator = func() *ValidateBotAction {
	v := &ValidateBotAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionType := v.ActionTypeValidationRuleHandler
	rulesActionType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionType(rulesActionType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotAction.action_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_type"] = vFn

	return v
}()

func BotActionValidator() db.Validator {
	return DefaultBotActionValidator
}

// augmented methods on protoc/std generated struct

func (m *BotNameContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotNameContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotNameContext) DeepCopy() *BotNameContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotNameContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotNameContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotNameContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotNameContextValidator().Validate(ctx, m, opts...)
}

type ValidateBotNameContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotNameContext) BotNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bot_name")
	}

	return validatorFn, nil
}

func (v *ValidateBotNameContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotNameContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotNameContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bot_name"]; exists {

		vOpts := append(opts, db.WithValidateField("bot_name"))
		if err := fv(ctx, m.GetBotName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotNameContextValidator = func() *ValidateBotNameContext {
	v := &ValidateBotNameContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBotName := v.BotNameValidationRuleHandler
	rulesBotName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhBotName(rulesBotName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotNameContext.bot_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bot_name"] = vFn

	return v
}()

func BotNameContextValidator() db.Validator {
	return DefaultBotNameContextValidator
}

// augmented methods on protoc/std generated struct

func (m *ClientMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ClientMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ClientMatcher) DeepCopy() *ClientMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ClientMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ClientMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ClientMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ClientMatcherValidator().Validate(ctx, m, opts...)
}

func (m *ClientMatcher) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetIpAsnChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ClientMatcher) GetIpAsnChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpAsnChoice() == nil {
		return nil, nil
	}
	switch m.GetIpAsnChoice().(type) {
	case *ClientMatcher_AnyIp:

		return nil, nil

	case *ClientMatcher_IpPrefixList:

		return nil, nil

	case *ClientMatcher_IpMatcher:
		drInfos, err := m.GetIpMatcher().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetIpMatcher().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "ip_matcher." + dri.DRField
		}
		return drInfos, err

	case *ClientMatcher_AsnList:

		return nil, nil

	case *ClientMatcher_AsnMatcher:
		drInfos, err := m.GetAsnMatcher().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAsnMatcher().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "asn_matcher." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateClientMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateClientMatcher) ClientChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for client_choice")
	}
	return validatorFn, nil
}

func (v *ValidateClientMatcher) IpAsnChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_asn_choice")
	}
	return validatorFn, nil
}

func (v *ValidateClientMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ClientMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ClientMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_choice"]; exists {
		val := m.GetClientChoice()
		vOpts := append(opts,
			db.WithValidateField("client_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClientChoice().(type) {
	case *ClientMatcher_AnyClient:
		if fv, exists := v.FldValidators["client_choice.any_client"]; exists {
			val := m.GetClientChoice().(*ClientMatcher_AnyClient).AnyClient
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("any_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_IpThreatCategoryList:
		if fv, exists := v.FldValidators["client_choice.ip_threat_category_list"]; exists {
			val := m.GetClientChoice().(*ClientMatcher_IpThreatCategoryList).IpThreatCategoryList
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("ip_threat_category_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_ClientSelector:
		if fv, exists := v.FldValidators["client_choice.client_selector"]; exists {
			val := m.GetClientChoice().(*ClientMatcher_ClientSelector).ClientSelector
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("client_selector"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ip_asn_choice"]; exists {
		val := m.GetIpAsnChoice()
		vOpts := append(opts,
			db.WithValidateField("ip_asn_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetIpAsnChoice().(type) {
	case *ClientMatcher_AnyIp:
		if fv, exists := v.FldValidators["ip_asn_choice.any_ip"]; exists {
			val := m.GetIpAsnChoice().(*ClientMatcher_AnyIp).AnyIp
			vOpts := append(opts,
				db.WithValidateField("ip_asn_choice"),
				db.WithValidateField("any_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_IpPrefixList:
		if fv, exists := v.FldValidators["ip_asn_choice.ip_prefix_list"]; exists {
			val := m.GetIpAsnChoice().(*ClientMatcher_IpPrefixList).IpPrefixList
			vOpts := append(opts,
				db.WithValidateField("ip_asn_choice"),
				db.WithValidateField("ip_prefix_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_IpMatcher:
		if fv, exists := v.FldValidators["ip_asn_choice.ip_matcher"]; exists {
			val := m.GetIpAsnChoice().(*ClientMatcher_IpMatcher).IpMatcher
			vOpts := append(opts,
				db.WithValidateField("ip_asn_choice"),
				db.WithValidateField("ip_matcher"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_AsnList:
		if fv, exists := v.FldValidators["ip_asn_choice.asn_list"]; exists {
			val := m.GetIpAsnChoice().(*ClientMatcher_AsnList).AsnList
			vOpts := append(opts,
				db.WithValidateField("ip_asn_choice"),
				db.WithValidateField("asn_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_AsnMatcher:
		if fv, exists := v.FldValidators["ip_asn_choice.asn_matcher"]; exists {
			val := m.GetIpAsnChoice().(*ClientMatcher_AsnMatcher).AsnMatcher
			vOpts := append(opts,
				db.WithValidateField("ip_asn_choice"),
				db.WithValidateField("asn_matcher"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_fingerprint_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_fingerprint_matcher"))
		if err := fv(ctx, m.GetTlsFingerprintMatcher(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultClientMatcherValidator = func() *ValidateClientMatcher {
	v := &ValidateClientMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClientChoice := v.ClientChoiceValidationRuleHandler
	rulesClientChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClientChoice(rulesClientChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClientMatcher.client_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_choice"] = vFn

	vrhIpAsnChoice := v.IpAsnChoiceValidationRuleHandler
	rulesIpAsnChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhIpAsnChoice(rulesIpAsnChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClientMatcher.ip_asn_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_asn_choice"] = vFn

	v.FldValidators["client_choice.ip_threat_category_list"] = IPThreatCategoryListTypeValidator().Validate
	v.FldValidators["client_choice.client_selector"] = ves_io_schema.LabelSelectorTypeValidator().Validate

	v.FldValidators["ip_asn_choice.ip_prefix_list"] = PrefixMatchListValidator().Validate
	v.FldValidators["ip_asn_choice.ip_matcher"] = IpMatcherTypeValidator().Validate
	v.FldValidators["ip_asn_choice.asn_list"] = AsnMatchListValidator().Validate
	v.FldValidators["ip_asn_choice.asn_matcher"] = AsnMatcherTypeValidator().Validate

	v.FldValidators["tls_fingerprint_matcher"] = TlsFingerprintMatcherTypeValidator().Validate

	return v
}()

func ClientMatcherValidator() db.Validator {
	return DefaultClientMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *ContentRewriteAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ContentRewriteAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ContentRewriteAction) DeepCopy() *ContentRewriteAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ContentRewriteAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ContentRewriteAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ContentRewriteAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ContentRewriteActionValidator().Validate(ctx, m, opts...)
}

type ValidateContentRewriteAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateContentRewriteAction) InsertContentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for insert_content")
	}

	return validatorFn, nil
}

func (v *ValidateContentRewriteAction) ElementSelectorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for element_selector")
	}

	return validatorFn, nil
}

func (v *ValidateContentRewriteAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ContentRewriteAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ContentRewriteAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["element_selector"]; exists {

		vOpts := append(opts, db.WithValidateField("element_selector"))
		if err := fv(ctx, m.GetElementSelector(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["insert_content"]; exists {

		vOpts := append(opts, db.WithValidateField("insert_content"))
		if err := fv(ctx, m.GetInsertContent(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inserted_types"]; exists {

		vOpts := append(opts, db.WithValidateField("inserted_types"))
		for key, value := range m.GetInsertedTypes() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["position"]; exists {

		vOpts := append(opts, db.WithValidateField("position"))
		if err := fv(ctx, m.GetPosition(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultContentRewriteActionValidator = func() *ValidateContentRewriteAction {
	v := &ValidateContentRewriteAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInsertContent := v.InsertContentValidationRuleHandler
	rulesInsertContent := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFn, err = vrhInsertContent(rulesInsertContent)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContentRewriteAction.insert_content: %s", err)
		panic(errMsg)
	}
	v.FldValidators["insert_content"] = vFn

	vrhElementSelector := v.ElementSelectorValidationRuleHandler
	rulesElementSelector := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhElementSelector(rulesElementSelector)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContentRewriteAction.element_selector: %s", err)
		panic(errMsg)
	}
	v.FldValidators["element_selector"] = vFn

	return v
}()

func ContentRewriteActionValidator() db.Validator {
	return DefaultContentRewriteActionValidator
}

// augmented methods on protoc/std generated struct

func (m *CookieMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CookieMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CookieMatcherType) DeepCopy() *CookieMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CookieMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CookieMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CookieMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CookieMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCookieMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCookieMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateCookieMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCookieMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CookieMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CookieMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *CookieMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*CookieMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*CookieMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*CookieMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*CookieMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCookieMatcherTypeValidator = func() *ValidateCookieMatcherType {
	v := &ValidateCookieMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func CookieMatcherTypeValidator() db.Validator {
	return DefaultCookieMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CountryCodeList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CountryCodeList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CountryCodeList) DeepCopy() *CountryCodeList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CountryCodeList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CountryCodeList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CountryCodeList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CountryCodeListValidator().Validate(ctx, m, opts...)
}

type ValidateCountryCodeList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCountryCodeList) CountryCodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(CountryCode)
		return int32(i)
	}
	// CountryCode_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, CountryCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for country_codes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []CountryCode, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for country_codes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]CountryCode)
		if !ok {
			return fmt.Errorf("Repeated validation expected []CountryCode, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated country_codes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items country_codes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCountryCodeList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CountryCodeList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CountryCodeList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["country_codes"]; exists {
		vOpts := append(opts, db.WithValidateField("country_codes"))
		if err := fv(ctx, m.GetCountryCodes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["invert_match"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_match"))
		if err := fv(ctx, m.GetInvertMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCountryCodeListValidator = func() *ValidateCountryCodeList {
	v := &ValidateCountryCodeList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCountryCodes := v.CountryCodesValidationRuleHandler
	rulesCountryCodes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCountryCodes(rulesCountryCodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CountryCodeList.country_codes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["country_codes"] = vFn

	return v
}()

func CountryCodeListValidator() db.Validator {
	return DefaultCountryCodeListValidator
}

// augmented methods on protoc/std generated struct

func (m *DataGuardControl) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DataGuardControl) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DataGuardControl) DeepCopy() *DataGuardControl {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DataGuardControl{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DataGuardControl) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DataGuardControl) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DataGuardControlValidator().Validate(ctx, m, opts...)
}

type ValidateDataGuardControl struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDataGuardControl) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DataGuardControl)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DataGuardControl got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["policy_name"]; exists {

		vOpts := append(opts, db.WithValidateField("policy_name"))
		if err := fv(ctx, m.GetPolicyName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDataGuardControlValidator = func() *ValidateDataGuardControl {
	v := &ValidateDataGuardControl{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DataGuardControlValidator() db.Validator {
	return DefaultDataGuardControlValidator
}

// augmented methods on protoc/std generated struct

func (m *DenyInformation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DenyInformation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DenyInformation) DeepCopy() *DenyInformation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DenyInformation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DenyInformation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DenyInformation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DenyInformationValidator().Validate(ctx, m, opts...)
}

type ValidateDenyInformation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDenyInformation) ResponseCodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_code")
	}

	return validatorFn, nil
}

func (v *ValidateDenyInformation) ErrorMessageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for error_message")
	}

	return validatorFn, nil
}

func (v *ValidateDenyInformation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DenyInformation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DenyInformation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error_message"]; exists {

		vOpts := append(opts, db.WithValidateField("error_message"))
		if err := fv(ctx, m.GetErrorMessage(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetEventType().(type) {
	case *DenyInformation_UndefinedSecEvent:
		if fv, exists := v.FldValidators["event_type.undefined_sec_event"]; exists {
			val := m.GetEventType().(*DenyInformation_UndefinedSecEvent).UndefinedSecEvent
			vOpts := append(opts,
				db.WithValidateField("event_type"),
				db.WithValidateField("undefined_sec_event"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DenyInformation_ApiSecEvent:
		if fv, exists := v.FldValidators["event_type.api_sec_event"]; exists {
			val := m.GetEventType().(*DenyInformation_ApiSecEvent).ApiSecEvent
			vOpts := append(opts,
				db.WithValidateField("event_type"),
				db.WithValidateField("api_sec_event"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["response_code"]; exists {

		vOpts := append(opts, db.WithValidateField("response_code"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDenyInformationValidator = func() *ValidateDenyInformation {
	v := &ValidateDenyInformation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseCode := v.ResponseCodeValidationRuleHandler
	rulesResponseCode := map[string]string{
		"ves.io.schema.rules.uint32.lte": "599",
	}
	vFn, err = vrhResponseCode(rulesResponseCode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DenyInformation.response_code: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_code"] = vFn

	vrhErrorMessage := v.ErrorMessageValidationRuleHandler
	rulesErrorMessage := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "512",
	}
	vFn, err = vrhErrorMessage(rulesErrorMessage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DenyInformation.error_message: %s", err)
		panic(errMsg)
	}
	v.FldValidators["error_message"] = vFn

	return v
}()

func DenyInformationValidator() db.Validator {
	return DefaultDenyInformationValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderMatcherType) DeepCopy() *HeaderMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateHeaderMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *HeaderMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderMatcherTypeValidator = func() *ValidateHeaderMatcherType {
	v := &ValidateHeaderMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func HeaderMatcherTypeValidator() db.Validator {
	return DefaultHeaderMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderMatcherTypeBasic) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderMatcherTypeBasic) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderMatcherTypeBasic) DeepCopy() *HeaderMatcherTypeBasic {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderMatcherTypeBasic{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderMatcherTypeBasic) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderMatcherTypeBasic) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderMatcherTypeBasicValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderMatcherTypeBasic struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderMatcherTypeBasic) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateHeaderMatcherTypeBasic) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderMatcherTypeBasic) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderMatcherTypeBasic)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderMatcherTypeBasic got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *HeaderMatcherTypeBasic_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*HeaderMatcherTypeBasic_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherTypeBasic_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*HeaderMatcherTypeBasic_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherTypeBasic_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*HeaderMatcherTypeBasic_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderMatcherTypeBasicValidator = func() *ValidateHeaderMatcherTypeBasic {
	v := &ValidateHeaderMatcherTypeBasic{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherTypeBasic.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherTypeBasic.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func HeaderMatcherTypeBasicValidator() db.Validator {
	return DefaultHeaderMatcherTypeBasicValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpCookieName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpCookieName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpCookieName) DeepCopy() *HttpCookieName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpCookieName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpCookieName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpCookieName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpCookieNameValidator().Validate(ctx, m, opts...)
}

type ValidateHttpCookieName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpCookieName) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHttpCookieName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpCookieName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpCookieName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpCookieNameValidator = func() *ValidateHttpCookieName {
	v := &ValidateHttpCookieName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpCookieName.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func HttpCookieNameValidator() db.Validator {
	return DefaultHttpCookieNameValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpHeaderName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpHeaderName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpHeaderName) DeepCopy() *HttpHeaderName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpHeaderName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpHeaderName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpHeaderName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpHeaderNameValidator().Validate(ctx, m, opts...)
}

type ValidateHttpHeaderName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpHeaderName) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHttpHeaderName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpHeaderName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpHeaderName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpHeaderNameValidator = func() *ValidateHttpHeaderName {
	v := &ValidateHttpHeaderName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpHeaderName.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func HttpHeaderNameValidator() db.Validator {
	return DefaultHttpHeaderNameValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpMethodMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpMethodMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpMethodMatcherType) DeepCopy() *HttpMethodMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpMethodMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpMethodMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpMethodMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpMethodMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHttpMethodMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpMethodMatcherType) MethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpMethod)
		return int32(i)
	}
	// ves_io_schema.HttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.HttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.HttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.HttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.HttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHttpMethodMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpMethodMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpMethodMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["methods"]; exists {
		vOpts := append(opts, db.WithValidateField("methods"))
		if err := fv(ctx, m.GetMethods(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpMethodMatcherTypeValidator = func() *ValidateHttpMethodMatcherType {
	v := &ValidateHttpMethodMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMethods := v.MethodsValidationRuleHandler
	rulesMethods := map[string]string{
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.max_items":               "16",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhMethods(rulesMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpMethodMatcherType.methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["methods"] = vFn

	return v
}()

func HttpMethodMatcherTypeValidator() db.Validator {
	return DefaultHttpMethodMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpQueryParameterName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpQueryParameterName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpQueryParameterName) DeepCopy() *HttpQueryParameterName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpQueryParameterName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpQueryParameterName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpQueryParameterName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpQueryParameterNameValidator().Validate(ctx, m, opts...)
}

type ValidateHttpQueryParameterName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpQueryParameterName) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateHttpQueryParameterName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpQueryParameterName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpQueryParameterName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpQueryParameterNameValidator = func() *ValidateHttpQueryParameterName {
	v := &ValidateHttpQueryParameterName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpQueryParameterName.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	return v
}()

func HttpQueryParameterNameValidator() db.Validator {
	return DefaultHttpQueryParameterNameValidator
}

// augmented methods on protoc/std generated struct

func (m *IPThreatCategoryListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPThreatCategoryListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPThreatCategoryListType) DeepCopy() *IPThreatCategoryListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPThreatCategoryListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPThreatCategoryListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPThreatCategoryListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPThreatCategoryListTypeValidator().Validate(ctx, m, opts...)
}

type ValidateIPThreatCategoryListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPThreatCategoryListType) IpThreatCategoriesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(IPThreatCategory)
		return int32(i)
	}
	// IPThreatCategory_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, IPThreatCategory_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_threat_categories")
	}
	itemsValidatorFn := func(ctx context.Context, elems []IPThreatCategory, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ip_threat_categories")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]IPThreatCategory)
		if !ok {
			return fmt.Errorf("Repeated validation expected []IPThreatCategory, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ip_threat_categories")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ip_threat_categories")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIPThreatCategoryListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPThreatCategoryListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPThreatCategoryListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip_threat_categories"]; exists {
		vOpts := append(opts, db.WithValidateField("ip_threat_categories"))
		if err := fv(ctx, m.GetIpThreatCategories(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPThreatCategoryListTypeValidator = func() *ValidateIPThreatCategoryListType {
	v := &ValidateIPThreatCategoryListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpThreatCategories := v.IpThreatCategoriesValidationRuleHandler
	rulesIpThreatCategories := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhIpThreatCategories(rulesIpThreatCategories)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPThreatCategoryListType.ip_threat_categories: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_threat_categories"] = vFn

	return v
}()

func IPThreatCategoryListTypeValidator() db.Validator {
	return DefaultIPThreatCategoryListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IpMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IpMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IpMatcherType) DeepCopy() *IpMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IpMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IpMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IpMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IpMatcherTypeValidator().Validate(ctx, m, opts...)
}

func (m *IpMatcherType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPrefixSetsDRefInfo()

}

func (m *IpMatcherType) GetPrefixSetsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetPrefixSets()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("IpMatcherType.prefix_sets[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "prefix_sets",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetPrefixSetsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *IpMatcherType) GetPrefixSetsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetPrefixSets() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateIpMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIpMatcherType) PrefixSetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for prefix_sets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefix_sets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefix_sets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefix_sets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIpMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IpMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IpMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix_sets"]; exists {
		vOpts := append(opts, db.WithValidateField("prefix_sets"))
		if err := fv(ctx, m.GetPrefixSets(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIpMatcherTypeValidator = func() *ValidateIpMatcherType {
	v := &ValidateIpMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixSets := v.PrefixSetsValidationRuleHandler
	rulesPrefixSets := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhPrefixSets(rulesPrefixSets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IpMatcherType.prefix_sets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefix_sets"] = vFn

	return v
}()

func IpMatcherTypeValidator() db.Validator {
	return DefaultIpMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JwtTokenAuthOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JwtTokenAuthOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *JwtTokenAuthOptions) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetSecretKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting JwtTokenAuthOptions.secret_key")
	}

	return nil
}

func (m *JwtTokenAuthOptions) DeepCopy() *JwtTokenAuthOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JwtTokenAuthOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JwtTokenAuthOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JwtTokenAuthOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JwtTokenAuthOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateJwtTokenAuthOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJwtTokenAuthOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JwtTokenAuthOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JwtTokenAuthOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["secret_key"]; exists {

		vOpts := append(opts, db.WithValidateField("secret_key"))
		if err := fv(ctx, m.GetSecretKey(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTokenSource().(type) {
	case *JwtTokenAuthOptions_Header:
		if fv, exists := v.FldValidators["token_source.header"]; exists {
			val := m.GetTokenSource().(*JwtTokenAuthOptions_Header).Header
			vOpts := append(opts,
				db.WithValidateField("token_source"),
				db.WithValidateField("header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JwtTokenAuthOptions_Cookie:
		if fv, exists := v.FldValidators["token_source.cookie"]; exists {
			val := m.GetTokenSource().(*JwtTokenAuthOptions_Cookie).Cookie
			vOpts := append(opts,
				db.WithValidateField("token_source"),
				db.WithValidateField("cookie"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JwtTokenAuthOptions_QueryParam:
		if fv, exists := v.FldValidators["token_source.query_param"]; exists {
			val := m.GetTokenSource().(*JwtTokenAuthOptions_QueryParam).QueryParam
			vOpts := append(opts,
				db.WithValidateField("token_source"),
				db.WithValidateField("query_param"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JwtTokenAuthOptions_BearerToken:
		if fv, exists := v.FldValidators["token_source.bearer_token"]; exists {
			val := m.GetTokenSource().(*JwtTokenAuthOptions_BearerToken).BearerToken
			vOpts := append(opts,
				db.WithValidateField("token_source"),
				db.WithValidateField("bearer_token"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJwtTokenAuthOptionsValidator = func() *ValidateJwtTokenAuthOptions {
	v := &ValidateJwtTokenAuthOptions{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["token_source.header"] = HttpHeaderNameValidator().Validate
	v.FldValidators["token_source.cookie"] = HttpCookieNameValidator().Validate
	v.FldValidators["token_source.query_param"] = HttpQueryParameterNameValidator().Validate

	v.FldValidators["secret_key"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func JwtTokenAuthOptionsValidator() db.Validator {
	return DefaultJwtTokenAuthOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *L4DestMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *L4DestMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *L4DestMatcherType) DeepCopy() *L4DestMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &L4DestMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *L4DestMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *L4DestMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return L4DestMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateL4DestMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateL4DestMatcherType) L4DestsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for l4_dests")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.L4DestType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.L4DestTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for l4_dests")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.L4DestType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.L4DestType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated l4_dests")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items l4_dests")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateL4DestMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*L4DestMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *L4DestMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["l4_dests"]; exists {
		vOpts := append(opts, db.WithValidateField("l4_dests"))
		if err := fv(ctx, m.GetL4Dests(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultL4DestMatcherTypeValidator = func() *ValidateL4DestMatcherType {
	v := &ValidateL4DestMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhL4Dests := v.L4DestsValidationRuleHandler
	rulesL4Dests := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhL4Dests(rulesL4Dests)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for L4DestMatcherType.l4_dests: %s", err)
		panic(errMsg)
	}
	v.FldValidators["l4_dests"] = vFn

	return v
}()

func L4DestMatcherTypeValidator() db.Validator {
	return DefaultL4DestMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatcherType) DeepCopy() *MatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatcherType) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherType) RegexValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for regex_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for regex_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated regex_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items regex_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherType) TransformersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(Transformer)
		return int32(i)
	}
	// Transformer_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, Transformer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for transformers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []Transformer, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for transformers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]Transformer)
		if !ok {
			return fmt.Errorf("Repeated validation expected []Transformer, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated transformers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items transformers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regex_values"]; exists {
		vOpts := append(opts, db.WithValidateField("regex_values"))
		if err := fv(ctx, m.GetRegexValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transformers"]; exists {
		vOpts := append(opts, db.WithValidateField("transformers"))
		if err := fv(ctx, m.GetTransformers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatcherTypeValidator = func() *ValidateMatcherType {
	v := &ValidateMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "64",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherType.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhRegexValues := v.RegexValuesValidationRuleHandler
	rulesRegexValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRegexValues(rulesRegexValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherType.regex_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regex_values"] = vFn

	vrhTransformers := v.TransformersValidationRuleHandler
	rulesTransformers := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "9",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhTransformers(rulesTransformers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherType.transformers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["transformers"] = vFn

	return v
}()

func MatcherTypeValidator() db.Validator {
	return DefaultMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MatcherTypeBasic) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatcherTypeBasic) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatcherTypeBasic) DeepCopy() *MatcherTypeBasic {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatcherTypeBasic{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatcherTypeBasic) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatcherTypeBasic) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatcherTypeBasicValidator().Validate(ctx, m, opts...)
}

type ValidateMatcherTypeBasic struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatcherTypeBasic) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherTypeBasic) RegexValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for regex_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for regex_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated regex_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items regex_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherTypeBasic) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatcherTypeBasic)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatcherTypeBasic got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regex_values"]; exists {
		vOpts := append(opts, db.WithValidateField("regex_values"))
		if err := fv(ctx, m.GetRegexValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatcherTypeBasicValidator = func() *ValidateMatcherTypeBasic {
	v := &ValidateMatcherTypeBasic{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherTypeBasic.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhRegexValues := v.RegexValuesValidationRuleHandler
	rulesRegexValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRegexValues(rulesRegexValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherTypeBasic.regex_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regex_values"] = vFn

	return v
}()

func MatcherTypeBasicValidator() db.Validator {
	return DefaultMatcherTypeBasicValidator
}

// augmented methods on protoc/std generated struct

func (m *ModifyAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ModifyAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ModifyAction) DeepCopy() *ModifyAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ModifyAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ModifyAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ModifyAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ModifyActionValidator().Validate(ctx, m, opts...)
}

type ValidateModifyAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateModifyAction) ActionTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_type")
	}
	return validatorFn, nil
}

func (v *ValidateModifyAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ModifyAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ModifyAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_type"]; exists {
		val := m.GetActionType()
		vOpts := append(opts,
			db.WithValidateField("action_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionType().(type) {
	case *ModifyAction_Default:
		if fv, exists := v.FldValidators["action_type.default"]; exists {
			val := m.GetActionType().(*ModifyAction_Default).Default
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ModifyAction_SkipProcessing:
		if fv, exists := v.FldValidators["action_type.skip_processing"]; exists {
			val := m.GetActionType().(*ModifyAction_SkipProcessing).SkipProcessing
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultModifyActionValidator = func() *ValidateModifyAction {
	v := &ValidateModifyAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionType := v.ActionTypeValidationRuleHandler
	rulesActionType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionType(rulesActionType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ModifyAction.action_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_type"] = vFn

	return v
}()

func ModifyActionValidator() db.Validator {
	return DefaultModifyActionValidator
}

// augmented methods on protoc/std generated struct

func (m *PathMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PathMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PathMatcherType) DeepCopy() *PathMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PathMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PathMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PathMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PathMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePathMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePathMatcherType) PrefixValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for prefix_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefix_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefix_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefix_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) RegexValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for regex_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for regex_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated regex_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items regex_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) TransformersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(Transformer)
		return int32(i)
	}
	// Transformer_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, Transformer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for transformers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []Transformer, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for transformers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]Transformer)
		if !ok {
			return fmt.Errorf("Repeated validation expected []Transformer, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated transformers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items transformers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) SuffixValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for suffix_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for suffix_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated suffix_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items suffix_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PathMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PathMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix_values"]; exists {
		vOpts := append(opts, db.WithValidateField("prefix_values"))
		if err := fv(ctx, m.GetPrefixValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regex_values"]; exists {
		vOpts := append(opts, db.WithValidateField("regex_values"))
		if err := fv(ctx, m.GetRegexValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["suffix_values"]; exists {
		vOpts := append(opts, db.WithValidateField("suffix_values"))
		if err := fv(ctx, m.GetSuffixValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transformers"]; exists {
		vOpts := append(opts, db.WithValidateField("transformers"))
		if err := fv(ctx, m.GetTransformers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPathMatcherTypeValidator = func() *ValidatePathMatcherType {
	v := &ValidatePathMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixValues := v.PrefixValuesValidationRuleHandler
	rulesPrefixValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.http_path": "true",
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhPrefixValues(rulesPrefixValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.prefix_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefix_values"] = vFn

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.http_path": "true",
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhRegexValues := v.RegexValuesValidationRuleHandler
	rulesRegexValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRegexValues(rulesRegexValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.regex_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regex_values"] = vFn

	vrhTransformers := v.TransformersValidationRuleHandler
	rulesTransformers := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "9",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhTransformers(rulesTransformers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.transformers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["transformers"] = vFn

	vrhSuffixValues := v.SuffixValuesValidationRuleHandler
	rulesSuffixValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "64",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "64",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhSuffixValues(rulesSuffixValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.suffix_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["suffix_values"] = vFn

	return v
}()

func PathMatcherTypeValidator() db.Validator {
	return DefaultPathMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortMatcherType) DeepCopy() *PortMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortMatcherType) PortsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ports")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ports")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ports")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ports")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePortMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ports"]; exists {
		vOpts := append(opts, db.WithValidateField("ports"))
		if err := fv(ctx, m.GetPorts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortMatcherTypeValidator = func() *ValidatePortMatcherType {
	v := &ValidatePortMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPorts := v.PortsValidationRuleHandler
	rulesPorts := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.string.port_range": "true",
		"ves.io.schema.rules.repeated.max_items":               "16",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhPorts(rulesPorts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortMatcherType.ports: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ports"] = vFn

	return v
}()

func PortMatcherTypeValidator() db.Validator {
	return DefaultPortMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PrefixMatchList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PrefixMatchList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PrefixMatchList) DeepCopy() *PrefixMatchList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PrefixMatchList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PrefixMatchList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PrefixMatchList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PrefixMatchListValidator().Validate(ctx, m, opts...)
}

type ValidatePrefixMatchList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePrefixMatchList) IpPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ip_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ip_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ip_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ip_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePrefixMatchList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PrefixMatchList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PrefixMatchList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_match"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_match"))
		if err := fv(ctx, m.GetInvertMatch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("ip_prefixes"))
		if err := fv(ctx, m.GetIpPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPrefixMatchListValidator = func() *ValidatePrefixMatchList {
	v := &ValidatePrefixMatchList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpPrefixes := v.IpPrefixesValidationRuleHandler
	rulesIpPrefixes := map[string]string{
		"ves.io.schema.rules.message.required":                  "true",
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "128",
		"ves.io.schema.rules.repeated.min_items":                "1",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhIpPrefixes(rulesIpPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PrefixMatchList.ip_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_prefixes"] = vFn

	return v
}()

func PrefixMatchListValidator() db.Validator {
	return DefaultPrefixMatchListValidator
}

// augmented methods on protoc/std generated struct

func (m *QueryParameterMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *QueryParameterMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *QueryParameterMatcherType) DeepCopy() *QueryParameterMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &QueryParameterMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *QueryParameterMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *QueryParameterMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return QueryParameterMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateQueryParameterMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateQueryParameterMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateQueryParameterMatcherType) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateQueryParameterMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*QueryParameterMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *QueryParameterMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *QueryParameterMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParameterMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParameterMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParameterMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultQueryParameterMatcherTypeValidator = func() *ValidateQueryParameterMatcherType {
	v := &ValidateQueryParameterMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for QueryParameterMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for QueryParameterMatcherType.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func QueryParameterMatcherTypeValidator() db.Validator {
	return DefaultQueryParameterMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RequestMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RequestMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RequestMatcher) DeepCopy() *RequestMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RequestMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RequestMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RequestMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RequestMatcherValidator().Validate(ctx, m, opts...)
}

type ValidateRequestMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRequestMatcher) QueryParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for query_params")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*QueryParameterMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := QueryParameterMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for query_params")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*QueryParameterMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*QueryParameterMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated query_params")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query_params")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRequestMatcher) HeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*HeaderMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := HeaderMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*HeaderMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*HeaderMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRequestMatcher) CookieMatchersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookie_matchers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CookieMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CookieMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookie_matchers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CookieMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CookieMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookie_matchers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookie_matchers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRequestMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RequestMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RequestMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_matchers"]; exists {
		vOpts := append(opts, db.WithValidateField("cookie_matchers"))
		if err := fv(ctx, m.GetCookieMatchers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["headers"]; exists {
		vOpts := append(opts, db.WithValidateField("headers"))
		if err := fv(ctx, m.GetHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query_params"]; exists {
		vOpts := append(opts, db.WithValidateField("query_params"))
		if err := fv(ctx, m.GetQueryParams(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRequestMatcherValidator = func() *ValidateRequestMatcher {
	v := &ValidateRequestMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryParams := v.QueryParamsValidationRuleHandler
	rulesQueryParams := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhQueryParams(rulesQueryParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestMatcher.query_params: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_params"] = vFn

	vrhHeaders := v.HeadersValidationRuleHandler
	rulesHeaders := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhHeaders(rulesHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestMatcher.headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["headers"] = vFn

	vrhCookieMatchers := v.CookieMatchersValidationRuleHandler
	rulesCookieMatchers := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhCookieMatchers(rulesCookieMatchers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestMatcher.cookie_matchers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_matchers"] = vFn

	return v
}()

func RequestMatcherValidator() db.Validator {
	return DefaultRequestMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *RoleMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RoleMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RoleMatcherType) DeepCopy() *RoleMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RoleMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RoleMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RoleMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RoleMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRoleMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRoleMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}

	return validatorFn, nil
}

func (v *ValidateRoleMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RoleMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RoleMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["match"]; exists {

		vOpts := append(opts, db.WithValidateField("match"))
		if err := fv(ctx, m.GetMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRoleMatcherTypeValidator = func() *ValidateRoleMatcherType {
	v := &ValidateRoleMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "63",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RoleMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	return v
}()

func RoleMatcherTypeValidator() db.Validator {
	return DefaultRoleMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotBlockMitigationActionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotBlockMitigationActionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotBlockMitigationActionType) DeepCopy() *ShapeBotBlockMitigationActionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotBlockMitigationActionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotBlockMitigationActionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotBlockMitigationActionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotBlockMitigationActionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotBlockMitigationActionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotBlockMitigationActionType) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpStatusCode)
		return int32(i)
	}
	// ves_io_schema.HttpStatusCode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.HttpStatusCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotBlockMitigationActionType) BodyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for body")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotBlockMitigationActionType) BodyHashValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for body_hash")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotBlockMitigationActionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotBlockMitigationActionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotBlockMitigationActionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["body"]; exists {

		vOpts := append(opts, db.WithValidateField("body"))
		if err := fv(ctx, m.GetBody(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["body_hash"]; exists {

		vOpts := append(opts, db.WithValidateField("body_hash"))
		if err := fv(ctx, m.GetBodyHash(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotBlockMitigationActionTypeValidator = func() *ValidateShapeBotBlockMitigationActionType {
	v := &ValidateShapeBotBlockMitigationActionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.not_in":       "[0]",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotBlockMitigationActionType.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	vrhBody := v.BodyValidationRuleHandler
	rulesBody := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhBody(rulesBody)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotBlockMitigationActionType.body: %s", err)
		panic(errMsg)
	}
	v.FldValidators["body"] = vFn

	vrhBodyHash := v.BodyHashValidationRuleHandler
	rulesBodyHash := map[string]string{
		"ves.io.schema.rules.string.max_len": "32",
		"ves.io.schema.rules.string.min_len": "32",
	}
	vFn, err = vrhBodyHash(rulesBodyHash)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotBlockMitigationActionType.body_hash: %s", err)
		panic(errMsg)
	}
	v.FldValidators["body_hash"] = vFn

	return v
}()

func ShapeBotBlockMitigationActionTypeValidator() db.Validator {
	return DefaultShapeBotBlockMitigationActionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotFlagMitigationActionChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotFlagMitigationActionChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotFlagMitigationActionChoiceType) DeepCopy() *ShapeBotFlagMitigationActionChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotFlagMitigationActionChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotFlagMitigationActionChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotFlagMitigationActionChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotFlagMitigationActionChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotFlagMitigationActionChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotFlagMitigationActionChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotFlagMitigationActionChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotFlagMitigationActionChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetSendHeadersChoice().(type) {
	case *ShapeBotFlagMitigationActionChoiceType_NoHeaders:
		if fv, exists := v.FldValidators["send_headers_choice.no_headers"]; exists {
			val := m.GetSendHeadersChoice().(*ShapeBotFlagMitigationActionChoiceType_NoHeaders).NoHeaders
			vOpts := append(opts,
				db.WithValidateField("send_headers_choice"),
				db.WithValidateField("no_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotFlagMitigationActionChoiceType_AppendHeaders:
		if fv, exists := v.FldValidators["send_headers_choice.append_headers"]; exists {
			val := m.GetSendHeadersChoice().(*ShapeBotFlagMitigationActionChoiceType_AppendHeaders).AppendHeaders
			vOpts := append(opts,
				db.WithValidateField("send_headers_choice"),
				db.WithValidateField("append_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotFlagMitigationActionChoiceTypeValidator = func() *ValidateShapeBotFlagMitigationActionChoiceType {
	v := &ValidateShapeBotFlagMitigationActionChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["send_headers_choice.append_headers"] = ShapeBotFlagMitigationActionTypeValidator().Validate

	return v
}()

func ShapeBotFlagMitigationActionChoiceTypeValidator() db.Validator {
	return DefaultShapeBotFlagMitigationActionChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotFlagMitigationActionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotFlagMitigationActionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotFlagMitigationActionType) DeepCopy() *ShapeBotFlagMitigationActionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotFlagMitigationActionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotFlagMitigationActionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotFlagMitigationActionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotFlagMitigationActionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotFlagMitigationActionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotFlagMitigationActionType) InferenceHeaderNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inference_header_name")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotFlagMitigationActionType) AutoTypeHeaderNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for auto_type_header_name")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotFlagMitigationActionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotFlagMitigationActionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotFlagMitigationActionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auto_type_header_name"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_type_header_name"))
		if err := fv(ctx, m.GetAutoTypeHeaderName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inference_header_name"]; exists {

		vOpts := append(opts, db.WithValidateField("inference_header_name"))
		if err := fv(ctx, m.GetInferenceHeaderName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotFlagMitigationActionTypeValidator = func() *ValidateShapeBotFlagMitigationActionType {
	v := &ValidateShapeBotFlagMitigationActionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInferenceHeaderName := v.InferenceHeaderNameValidationRuleHandler
	rulesInferenceHeaderName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhInferenceHeaderName(rulesInferenceHeaderName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotFlagMitigationActionType.inference_header_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inference_header_name"] = vFn

	vrhAutoTypeHeaderName := v.AutoTypeHeaderNameValidationRuleHandler
	rulesAutoTypeHeaderName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhAutoTypeHeaderName(rulesAutoTypeHeaderName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotFlagMitigationActionType.auto_type_header_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["auto_type_header_name"] = vFn

	return v
}()

func ShapeBotFlagMitigationActionTypeValidator() db.Validator {
	return DefaultShapeBotFlagMitigationActionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotMitigationAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotMitigationAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotMitigationAction) DeepCopy() *ShapeBotMitigationAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotMitigationAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotMitigationAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotMitigationAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotMitigationActionValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotMitigationAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotMitigationAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotMitigationAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotMitigationAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetActionType().(type) {
	case *ShapeBotMitigationAction_None:
		if fv, exists := v.FldValidators["action_type.none"]; exists {
			val := m.GetActionType().(*ShapeBotMitigationAction_None).None
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotMitigationAction_Block:
		if fv, exists := v.FldValidators["action_type.block"]; exists {
			val := m.GetActionType().(*ShapeBotMitigationAction_Block).Block
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotMitigationAction_Redirect:
		if fv, exists := v.FldValidators["action_type.redirect"]; exists {
			val := m.GetActionType().(*ShapeBotMitigationAction_Redirect).Redirect
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("redirect"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotMitigationAction_Flag:
		if fv, exists := v.FldValidators["action_type.flag"]; exists {
			val := m.GetActionType().(*ShapeBotMitigationAction_Flag).Flag
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("flag"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotMitigationActionValidator = func() *ValidateShapeBotMitigationAction {
	v := &ValidateShapeBotMitigationAction{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["action_type.block"] = ShapeBotBlockMitigationActionTypeValidator().Validate
	v.FldValidators["action_type.redirect"] = ShapeBotRedirectMitigationActionTypeValidator().Validate
	v.FldValidators["action_type.flag"] = ShapeBotFlagMitigationActionChoiceTypeValidator().Validate

	return v
}()

func ShapeBotMitigationActionValidator() db.Validator {
	return DefaultShapeBotMitigationActionValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotRedirectMitigationActionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotRedirectMitigationActionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotRedirectMitigationActionType) DeepCopy() *ShapeBotRedirectMitigationActionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotRedirectMitigationActionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotRedirectMitigationActionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotRedirectMitigationActionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotRedirectMitigationActionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotRedirectMitigationActionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotRedirectMitigationActionType) UriValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for uri")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotRedirectMitigationActionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotRedirectMitigationActionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotRedirectMitigationActionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["uri"]; exists {

		vOpts := append(opts, db.WithValidateField("uri"))
		if err := fv(ctx, m.GetUri(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotRedirectMitigationActionTypeValidator = func() *ValidateShapeBotRedirectMitigationActionType {
	v := &ValidateShapeBotRedirectMitigationActionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUri := v.UriValidationRuleHandler
	rulesUri := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhUri(rulesUri)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotRedirectMitigationActionType.uri: %s", err)
		panic(errMsg)
	}
	v.FldValidators["uri"] = vFn

	return v
}()

func ShapeBotRedirectMitigationActionTypeValidator() db.Validator {
	return DefaultShapeBotRedirectMitigationActionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeProtectedEndpointAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeProtectedEndpointAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeProtectedEndpointAction) DeepCopy() *ShapeProtectedEndpointAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeProtectedEndpointAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeProtectedEndpointAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeProtectedEndpointAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeProtectedEndpointActionValidator().Validate(ctx, m, opts...)
}

type ValidateShapeProtectedEndpointAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeProtectedEndpointAction) AppTrafficTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(AppTrafficType)
		return int32(i)
	}
	// AppTrafficType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, AppTrafficType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for app_traffic_type")
	}

	return validatorFn, nil
}

func (v *ValidateShapeProtectedEndpointAction) MitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for mitigation")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeProtectedEndpointAction) WebScrapingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewBoolValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for web_scraping")
	}

	return validatorFn, nil
}

func (v *ValidateShapeProtectedEndpointAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeProtectedEndpointAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeProtectedEndpointAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["app_traffic_type"]; exists {

		vOpts := append(opts, db.WithValidateField("app_traffic_type"))
		if err := fv(ctx, m.GetAppTrafficType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("mitigation"))
		if err := fv(ctx, m.GetMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["web_scraping"]; exists {

		vOpts := append(opts, db.WithValidateField("web_scraping"))
		if err := fv(ctx, m.GetWebScraping(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeProtectedEndpointActionValidator = func() *ValidateShapeProtectedEndpointAction {
	v := &ValidateShapeProtectedEndpointAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAppTrafficType := v.AppTrafficTypeValidationRuleHandler
	rulesAppTrafficType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAppTrafficType(rulesAppTrafficType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeProtectedEndpointAction.app_traffic_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_traffic_type"] = vFn

	vrhMitigation := v.MitigationValidationRuleHandler
	rulesMitigation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMitigation(rulesMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeProtectedEndpointAction.mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mitigation"] = vFn

	vrhWebScraping := v.WebScrapingValidationRuleHandler
	rulesWebScraping := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWebScraping(rulesWebScraping)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeProtectedEndpointAction.web_scraping: %s", err)
		panic(errMsg)
	}
	v.FldValidators["web_scraping"] = vFn

	return v
}()

func ShapeProtectedEndpointActionValidator() db.Validator {
	return DefaultShapeProtectedEndpointActionValidator
}

// augmented methods on protoc/std generated struct

func (m *SimpleDataGuardRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SimpleDataGuardRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SimpleDataGuardRule) DeepCopy() *SimpleDataGuardRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SimpleDataGuardRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SimpleDataGuardRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SimpleDataGuardRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SimpleDataGuardRuleValidator().Validate(ctx, m, opts...)
}

type ValidateSimpleDataGuardRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSimpleDataGuardRule) ActionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleDataGuardRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleDataGuardRule) DomainChoiceExactValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExactValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact_value")
	}
	return oValidatorFn_ExactValue, nil
}
func (v *ValidateSimpleDataGuardRule) DomainChoiceSuffixValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SuffixValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for suffix_value")
	}
	return oValidatorFn_SuffixValue, nil
}

func (v *ValidateSimpleDataGuardRule) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for path")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.PathMatcherTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleDataGuardRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleDataGuardRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SimpleDataGuardRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SimpleDataGuardRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_choice"]; exists {
		val := m.GetActionChoice()
		vOpts := append(opts,
			db.WithValidateField("action_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionChoice().(type) {
	case *SimpleDataGuardRule_ApplyDataGuard:
		if fv, exists := v.FldValidators["action_choice.apply_data_guard"]; exists {
			val := m.GetActionChoice().(*SimpleDataGuardRule_ApplyDataGuard).ApplyDataGuard
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("apply_data_guard"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleDataGuardRule_SkipDataGuard:
		if fv, exists := v.FldValidators["action_choice.skip_data_guard"]; exists {
			val := m.GetActionChoice().(*SimpleDataGuardRule_SkipDataGuard).SkipDataGuard
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("skip_data_guard"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *SimpleDataGuardRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*SimpleDataGuardRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleDataGuardRule_ExactValue:
		if fv, exists := v.FldValidators["domain_choice.exact_value"]; exists {
			val := m.GetDomainChoice().(*SimpleDataGuardRule_ExactValue).ExactValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("exact_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleDataGuardRule_SuffixValue:
		if fv, exists := v.FldValidators["domain_choice.suffix_value"]; exists {
			val := m.GetDomainChoice().(*SimpleDataGuardRule_SuffixValue).SuffixValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("suffix_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSimpleDataGuardRuleValidator = func() *ValidateSimpleDataGuardRule {
	v := &ValidateSimpleDataGuardRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionChoice := v.ActionChoiceValidationRuleHandler
	rulesActionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionChoice(rulesActionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleDataGuardRule.action_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_choice"] = vFn

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleDataGuardRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceExactValue := v.DomainChoiceExactValueValidationRuleHandler
	rulesDomainChoiceExactValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.exact_value"], err = vrhDomainChoiceExactValue(rulesDomainChoiceExactValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleDataGuardRule.domain_choice_exact_value: %s", err)
		panic(errMsg)
	}
	vrhDomainChoiceSuffixValue := v.DomainChoiceSuffixValueValidationRuleHandler
	rulesDomainChoiceSuffixValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.suffix_value"], err = vrhDomainChoiceSuffixValue(rulesDomainChoiceSuffixValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleDataGuardRule.domain_choice_suffix_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.exact_value"] = vFnMap["domain_choice.exact_value"]
	v.FldValidators["domain_choice.suffix_value"] = vFnMap["domain_choice.suffix_value"]

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleDataGuardRule.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleDataGuardRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	return v
}()

func SimpleDataGuardRuleValidator() db.Validator {
	return DefaultSimpleDataGuardRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *SimpleWafExclusionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SimpleWafExclusionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SimpleWafExclusionRule) DeepCopy() *SimpleWafExclusionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SimpleWafExclusionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SimpleWafExclusionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SimpleWafExclusionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SimpleWafExclusionRuleValidator().Validate(ctx, m, opts...)
}

type ValidateSimpleWafExclusionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSimpleWafExclusionRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) DomainChoiceExactValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExactValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact_value")
	}
	return oValidatorFn_ExactValue, nil
}
func (v *ValidateSimpleWafExclusionRule) DomainChoiceSuffixValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SuffixValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for suffix_value")
	}
	return oValidatorFn_SuffixValue, nil
}

func (v *ValidateSimpleWafExclusionRule) PathRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_regex")
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) MethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpMethod)
		return int32(i)
	}
	// ves_io_schema.HttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.HttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.HttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.HttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.HttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) ExcludeRuleIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_waf_rule_list.WafRuleID)
		return int32(i)
	}
	// ves_io_schema_waf_rule_list.WafRuleID_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema_waf_rule_list.WafRuleID_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exclude_rule_ids")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema_waf_rule_list.WafRuleID, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_rule_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema_waf_rule_list.WafRuleID)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema_waf_rule_list.WafRuleID, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_rule_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_rule_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) AppFirewallDetectionControlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn := AppFirewallDetectionControlValidator().Validate

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SimpleWafExclusionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SimpleWafExclusionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["app_firewall_detection_control"]; exists {

		vOpts := append(opts, db.WithValidateField("app_firewall_detection_control"))
		if err := fv(ctx, m.GetAppFirewallDetectionControl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *SimpleWafExclusionRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*SimpleWafExclusionRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleWafExclusionRule_ExactValue:
		if fv, exists := v.FldValidators["domain_choice.exact_value"]; exists {
			val := m.GetDomainChoice().(*SimpleWafExclusionRule_ExactValue).ExactValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("exact_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleWafExclusionRule_SuffixValue:
		if fv, exists := v.FldValidators["domain_choice.suffix_value"]; exists {
			val := m.GetDomainChoice().(*SimpleWafExclusionRule_SuffixValue).SuffixValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("suffix_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["exclude_rule_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_rule_ids"))
		if err := fv(ctx, m.GetExcludeRuleIds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["expiration_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("expiration_timestamp"))
		if err := fv(ctx, m.GetExpirationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["methods"]; exists {
		vOpts := append(opts, db.WithValidateField("methods"))
		if err := fv(ctx, m.GetMethods(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path_regex"]; exists {

		vOpts := append(opts, db.WithValidateField("path_regex"))
		if err := fv(ctx, m.GetPathRegex(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSimpleWafExclusionRuleValidator = func() *ValidateSimpleWafExclusionRule {
	v := &ValidateSimpleWafExclusionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceExactValue := v.DomainChoiceExactValueValidationRuleHandler
	rulesDomainChoiceExactValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.exact_value"], err = vrhDomainChoiceExactValue(rulesDomainChoiceExactValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleWafExclusionRule.domain_choice_exact_value: %s", err)
		panic(errMsg)
	}
	vrhDomainChoiceSuffixValue := v.DomainChoiceSuffixValueValidationRuleHandler
	rulesDomainChoiceSuffixValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.suffix_value"], err = vrhDomainChoiceSuffixValue(rulesDomainChoiceSuffixValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleWafExclusionRule.domain_choice_suffix_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.exact_value"] = vFnMap["domain_choice.exact_value"]
	v.FldValidators["domain_choice.suffix_value"] = vFnMap["domain_choice.suffix_value"]

	vrhPathRegex := v.PathRegexValidationRuleHandler
	rulesPathRegex := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.regex":     "true",
	}
	vFn, err = vrhPathRegex(rulesPathRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.path_regex: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path_regex"] = vFn

	vrhMethods := v.MethodsValidationRuleHandler
	rulesMethods := map[string]string{
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.max_items":               "16",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhMethods(rulesMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["methods"] = vFn

	vrhExcludeRuleIds := v.ExcludeRuleIdsValidationRuleHandler
	rulesExcludeRuleIds := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeRuleIds(rulesExcludeRuleIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.exclude_rule_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_rule_ids"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhAppFirewallDetectionControl := v.AppFirewallDetectionControlValidationRuleHandler
	rulesAppFirewallDetectionControl := map[string]string{
		"ves.io.schema.rules.message.required_one_nonzero_field": "true",
	}
	vFn, err = vrhAppFirewallDetectionControl(rulesAppFirewallDetectionControl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.app_firewall_detection_control: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_firewall_detection_control"] = vFn

	return v
}()

func SimpleWafExclusionRuleValidator() db.Validator {
	return DefaultSimpleWafExclusionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *StringMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StringMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StringMatcherType) DeepCopy() *StringMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StringMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StringMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StringMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StringMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStringMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStringMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStringMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StringMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StringMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		vOpts := append(opts, db.WithValidateField("match"))
		if err := fv(ctx, m.GetMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStringMatcherTypeValidator = func() *ValidateStringMatcherType {
	v := &ValidateStringMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.max_bytes": "63",
		"ves.io.schema.rules.repeated.max_items":              "64",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StringMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	return v
}()

func StringMatcherTypeValidator() db.Validator {
	return DefaultStringMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsFingerprintMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsFingerprintMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TlsFingerprintMatcherType) DeepCopy() *TlsFingerprintMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsFingerprintMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsFingerprintMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsFingerprintMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsFingerprintMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTlsFingerprintMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsFingerprintMatcherType) ClassesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(KnownTlsFingerprintClass)
		return int32(i)
	}
	// KnownTlsFingerprintClass_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, KnownTlsFingerprintClass_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for classes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []KnownTlsFingerprintClass, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for classes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]KnownTlsFingerprintClass)
		if !ok {
			return fmt.Errorf("Repeated validation expected []KnownTlsFingerprintClass, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated classes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items classes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsFingerprintMatcherType) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsFingerprintMatcherType) ExcludedValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for excluded_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for excluded_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated excluded_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items excluded_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsFingerprintMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsFingerprintMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsFingerprintMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["classes"]; exists {
		vOpts := append(opts, db.WithValidateField("classes"))
		if err := fv(ctx, m.GetClasses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["excluded_values"]; exists {
		vOpts := append(opts, db.WithValidateField("excluded_values"))
		if err := fv(ctx, m.GetExcludedValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsFingerprintMatcherTypeValidator = func() *ValidateTlsFingerprintMatcherType {
	v := &ValidateTlsFingerprintMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClasses := v.ClassesValidationRuleHandler
	rulesClasses := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhClasses(rulesClasses)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsFingerprintMatcherType.classes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["classes"] = vFn

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.len": "32",
		"ves.io.schema.rules.repeated.max_items":        "16",
		"ves.io.schema.rules.repeated.unique":           "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsFingerprintMatcherType.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhExcludedValues := v.ExcludedValuesValidationRuleHandler
	rulesExcludedValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.len": "32",
		"ves.io.schema.rules.repeated.max_items":        "32",
		"ves.io.schema.rules.repeated.unique":           "true",
	}
	vFn, err = vrhExcludedValues(rulesExcludedValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsFingerprintMatcherType.excluded_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["excluded_values"] = vFn

	return v
}()

func TlsFingerprintMatcherTypeValidator() db.Validator {
	return DefaultTlsFingerprintMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *URLItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *URLItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *URLItem) DeepCopy() *URLItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &URLItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *URLItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *URLItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return URLItemValidator().Validate(ctx, m, opts...)
}

type ValidateURLItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateURLItem) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateURLItem) DomainChoiceDomainValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DomainValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_value")
	}
	return oValidatorFn_DomainValue, nil
}
func (v *ValidateURLItem) DomainChoiceDomainRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DomainRegex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_regex")
	}
	return oValidatorFn_DomainRegex, nil
}

func (v *ValidateURLItem) PathChoicePathValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_value")
	}
	return oValidatorFn_PathValue, nil
}
func (v *ValidateURLItem) PathChoicePathRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathRegex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_regex")
	}
	return oValidatorFn_PathRegex, nil
}
func (v *ValidateURLItem) PathChoicePathPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_prefix")
	}
	return oValidatorFn_PathPrefix, nil
}

func (v *ValidateURLItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*URLItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *URLItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *URLItem_DomainValue:
		if fv, exists := v.FldValidators["domain_choice.domain_value"]; exists {
			val := m.GetDomainChoice().(*URLItem_DomainValue).DomainValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("domain_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *URLItem_DomainRegex:
		if fv, exists := v.FldValidators["domain_choice.domain_regex"]; exists {
			val := m.GetDomainChoice().(*URLItem_DomainRegex).DomainRegex
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("domain_regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetPathChoice().(type) {
	case *URLItem_PathValue:
		if fv, exists := v.FldValidators["path_choice.path_value"]; exists {
			val := m.GetPathChoice().(*URLItem_PathValue).PathValue
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *URLItem_PathRegex:
		if fv, exists := v.FldValidators["path_choice.path_regex"]; exists {
			val := m.GetPathChoice().(*URLItem_PathRegex).PathRegex
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *URLItem_PathPrefix:
		if fv, exists := v.FldValidators["path_choice.path_prefix"]; exists {
			val := m.GetPathChoice().(*URLItem_PathPrefix).PathPrefix
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultURLItemValidator = func() *ValidateURLItem {
	v := &ValidateURLItem{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for URLItem.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceDomainValue := v.DomainChoiceDomainValueValidationRuleHandler
	rulesDomainChoiceDomainValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFnMap["domain_choice.domain_value"], err = vrhDomainChoiceDomainValue(rulesDomainChoiceDomainValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.domain_choice_domain_value: %s", err)
		panic(errMsg)
	}
	vrhDomainChoiceDomainRegex := v.DomainChoiceDomainRegexValidationRuleHandler
	rulesDomainChoiceDomainRegex := map[string]string{
		"ves.io.schema.rules.string.regex": "true",
	}
	vFnMap["domain_choice.domain_regex"], err = vrhDomainChoiceDomainRegex(rulesDomainChoiceDomainRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.domain_choice_domain_regex: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.domain_value"] = vFnMap["domain_choice.domain_value"]
	v.FldValidators["domain_choice.domain_regex"] = vFnMap["domain_choice.domain_regex"]

	vrhPathChoicePathValue := v.PathChoicePathValueValidationRuleHandler
	rulesPathChoicePathValue := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["path_choice.path_value"], err = vrhPathChoicePathValue(rulesPathChoicePathValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.path_choice_path_value: %s", err)
		panic(errMsg)
	}
	vrhPathChoicePathRegex := v.PathChoicePathRegexValidationRuleHandler
	rulesPathChoicePathRegex := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFnMap["path_choice.path_regex"], err = vrhPathChoicePathRegex(rulesPathChoicePathRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.path_choice_path_regex: %s", err)
		panic(errMsg)
	}
	vrhPathChoicePathPrefix := v.PathChoicePathPrefixValidationRuleHandler
	rulesPathChoicePathPrefix := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["path_choice.path_prefix"], err = vrhPathChoicePathPrefix(rulesPathChoicePathPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.path_choice_path_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["path_choice.path_value"] = vFnMap["path_choice.path_value"]
	v.FldValidators["path_choice.path_regex"] = vFnMap["path_choice.path_regex"]
	v.FldValidators["path_choice.path_prefix"] = vFnMap["path_choice.path_prefix"]

	return v
}()

func URLItemValidator() db.Validator {
	return DefaultURLItemValidator
}

// augmented methods on protoc/std generated struct

func (m *URLMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *URLMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *URLMatcherType) DeepCopy() *URLMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &URLMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *URLMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *URLMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return URLMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateURLMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateURLMatcherType) UrlItemsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for url_items")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*URLItem, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := URLItemValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for url_items")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*URLItem)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*URLItem, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated url_items")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items url_items")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateURLMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*URLMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *URLMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url_items"]; exists {
		vOpts := append(opts, db.WithValidateField("url_items"))
		if err := fv(ctx, m.GetUrlItems(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultURLMatcherTypeValidator = func() *ValidateURLMatcherType {
	v := &ValidateURLMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUrlItems := v.UrlItemsValidationRuleHandler
	rulesUrlItems := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhUrlItems(rulesUrlItems)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for URLMatcherType.url_items: %s", err)
		panic(errMsg)
	}
	v.FldValidators["url_items"] = vFn

	return v
}()

func URLMatcherTypeValidator() db.Validator {
	return DefaultURLMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WafAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WafAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WafAction) DeepCopy() *WafAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WafAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WafAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WafAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WafActionValidator().Validate(ctx, m, opts...)
}

func (m *WafAction) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetActionTypeDRefInfo()

}

// GetDRefInfo for the field's type
func (m *WafAction) GetActionTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetActionType() == nil {
		return nil, nil
	}
	switch m.GetActionType().(type) {
	case *WafAction_WafSkipProcessing:

		return nil, nil

	case *WafAction_WafRuleControl:
		drInfos, err := m.GetWafRuleControl().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetWafRuleControl().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "waf_rule_control." + dri.DRField
		}
		return drInfos, err

	case *WafAction_None:

		return nil, nil

	case *WafAction_WafInlineRuleControl:

		return nil, nil

	case *WafAction_WafInMonitoringMode:

		return nil, nil

	case *WafAction_AppFirewallDetectionControl:

		return nil, nil

	case *WafAction_DataGuardControl:

		return nil, nil

	default:
		return nil, nil
	}

}

type ValidateWafAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWafAction) ActionTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_type")
	}
	return validatorFn, nil
}

func (v *ValidateWafAction) ActionTypeAppFirewallDetectionControlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return AppFirewallDetectionControlValidator().Validate, nil
}

func (v *ValidateWafAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WafAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WafAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_type"]; exists {
		val := m.GetActionType()
		vOpts := append(opts,
			db.WithValidateField("action_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionType().(type) {
	case *WafAction_WafSkipProcessing:
		if fv, exists := v.FldValidators["action_type.waf_skip_processing"]; exists {
			val := m.GetActionType().(*WafAction_WafSkipProcessing).WafSkipProcessing
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("waf_skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_WafRuleControl:
		if fv, exists := v.FldValidators["action_type.waf_rule_control"]; exists {
			val := m.GetActionType().(*WafAction_WafRuleControl).WafRuleControl
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("waf_rule_control"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_None:
		if fv, exists := v.FldValidators["action_type.none"]; exists {
			val := m.GetActionType().(*WafAction_None).None
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_WafInlineRuleControl:
		if fv, exists := v.FldValidators["action_type.waf_inline_rule_control"]; exists {
			val := m.GetActionType().(*WafAction_WafInlineRuleControl).WafInlineRuleControl
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("waf_inline_rule_control"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_WafInMonitoringMode:
		if fv, exists := v.FldValidators["action_type.waf_in_monitoring_mode"]; exists {
			val := m.GetActionType().(*WafAction_WafInMonitoringMode).WafInMonitoringMode
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("waf_in_monitoring_mode"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_AppFirewallDetectionControl:
		if fv, exists := v.FldValidators["action_type.app_firewall_detection_control"]; exists {
			val := m.GetActionType().(*WafAction_AppFirewallDetectionControl).AppFirewallDetectionControl
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("app_firewall_detection_control"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_DataGuardControl:
		if fv, exists := v.FldValidators["action_type.data_guard_control"]; exists {
			val := m.GetActionType().(*WafAction_DataGuardControl).DataGuardControl
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("data_guard_control"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWafActionValidator = func() *ValidateWafAction {
	v := &ValidateWafAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionType := v.ActionTypeValidationRuleHandler
	rulesActionType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionType(rulesActionType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WafAction.action_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_type"] = vFn

	vrhActionTypeAppFirewallDetectionControl := v.ActionTypeAppFirewallDetectionControlValidationRuleHandler
	rulesActionTypeAppFirewallDetectionControl := map[string]string{
		"ves.io.schema.rules.message.required_one_nonzero_field": "true",
	}
	vFnMap["action_type.app_firewall_detection_control"], err = vrhActionTypeAppFirewallDetectionControl(rulesActionTypeAppFirewallDetectionControl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field WafAction.action_type_app_firewall_detection_control: %s", err)
		panic(errMsg)
	}

	v.FldValidators["action_type.app_firewall_detection_control"] = vFnMap["action_type.app_firewall_detection_control"]

	v.FldValidators["action_type.waf_rule_control"] = WafRuleControlValidator().Validate
	v.FldValidators["action_type.waf_inline_rule_control"] = WafInlineRuleControlValidator().Validate

	return v
}()

func WafActionValidator() db.Validator {
	return DefaultWafActionValidator
}

// augmented methods on protoc/std generated struct

func (m *WafInlineRuleControl) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WafInlineRuleControl) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WafInlineRuleControl) DeepCopy() *WafInlineRuleControl {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WafInlineRuleControl{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WafInlineRuleControl) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WafInlineRuleControl) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WafInlineRuleControlValidator().Validate(ctx, m, opts...)
}

type ValidateWafInlineRuleControl struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWafInlineRuleControl) ExcludeRuleIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_waf_rule_list.WafRuleID)
		return int32(i)
	}
	// ves_io_schema_waf_rule_list.WafRuleID_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema_waf_rule_list.WafRuleID_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exclude_rule_ids")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema_waf_rule_list.WafRuleID, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_rule_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema_waf_rule_list.WafRuleID)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema_waf_rule_list.WafRuleID, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_rule_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_rule_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWafInlineRuleControl) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WafInlineRuleControl)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WafInlineRuleControl got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_rule_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_rule_ids"))
		if err := fv(ctx, m.GetExcludeRuleIds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["monitoring_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("monitoring_mode"))
		if err := fv(ctx, m.GetMonitoringMode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWafInlineRuleControlValidator = func() *ValidateWafInlineRuleControl {
	v := &ValidateWafInlineRuleControl{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeRuleIds := v.ExcludeRuleIdsValidationRuleHandler
	rulesExcludeRuleIds := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeRuleIds(rulesExcludeRuleIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WafInlineRuleControl.exclude_rule_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_rule_ids"] = vFn

	return v
}()

func WafInlineRuleControlValidator() db.Validator {
	return DefaultWafInlineRuleControlValidator
}

// augmented methods on protoc/std generated struct

func (m *WafRuleControl) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WafRuleControl) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WafRuleControl) DeepCopy() *WafRuleControl {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WafRuleControl{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WafRuleControl) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WafRuleControl) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WafRuleControlValidator().Validate(ctx, m, opts...)
}

func (m *WafRuleControl) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetExcludeRuleIdsDRefInfo()

}

func (m *WafRuleControl) GetExcludeRuleIdsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetExcludeRuleIds()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("WafRuleControl.exclude_rule_ids[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "waf_rule_list.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "exclude_rule_ids",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetExcludeRuleIdsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WafRuleControl) GetExcludeRuleIdsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "waf_rule_list.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: waf_rule_list")
	}
	for _, ref := range m.GetExcludeRuleIds() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateWafRuleControl struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWafRuleControl) ExcludeRuleIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_rule_ids")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_rule_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_rule_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_rule_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWafRuleControl) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WafRuleControl)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WafRuleControl got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_rule_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_rule_ids"))
		if err := fv(ctx, m.GetExcludeRuleIds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["monitoring_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("monitoring_mode"))
		if err := fv(ctx, m.GetMonitoringMode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWafRuleControlValidator = func() *ValidateWafRuleControl {
	v := &ValidateWafRuleControl{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeRuleIds := v.ExcludeRuleIdsValidationRuleHandler
	rulesExcludeRuleIds := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhExcludeRuleIds(rulesExcludeRuleIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WafRuleControl.exclude_rule_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_rule_ids"] = vFn

	return v
}()

func WafRuleControlValidator() db.Validator {
	return DefaultWafRuleControlValidator
}

// create setters in HeaderMatcherTypeBasic from HeaderMatcherType for oneof fields
func (r *HeaderMatcherTypeBasic) SetMatchToHeaderMatcherType(o *HeaderMatcherType) error {
	switch of := r.Match.(type) {
	case nil:
		o.Match = nil

	case *HeaderMatcherTypeBasic_CheckNotPresent:
		o.Match = &HeaderMatcherType_CheckNotPresent{CheckNotPresent: of.CheckNotPresent}

	case *HeaderMatcherTypeBasic_CheckPresent:
		o.Match = &HeaderMatcherType_CheckPresent{CheckPresent: of.CheckPresent}

	case *HeaderMatcherTypeBasic_Item:
		o.Match = &HeaderMatcherType_Item{Item: of.Item}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *HeaderMatcherTypeBasic) GetMatchFromHeaderMatcherType(o *HeaderMatcherType) error {
	switch of := o.Match.(type) {
	case nil:
		r.Match = nil

	case *HeaderMatcherType_CheckNotPresent:
		r.Match = &HeaderMatcherTypeBasic_CheckNotPresent{CheckNotPresent: of.CheckNotPresent}

	case *HeaderMatcherType_CheckPresent:
		r.Match = &HeaderMatcherTypeBasic_CheckPresent{CheckPresent: of.CheckPresent}

	case *HeaderMatcherType_Item:
		r.Match = &HeaderMatcherTypeBasic_Item{Item: of.Item}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *HeaderMatcherTypeBasic) fromHeaderMatcherType(f *HeaderMatcherType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetMatchFromHeaderMatcherType(f)
	m.Name = f.GetName()
}

func (m *HeaderMatcherTypeBasic) FromHeaderMatcherType(f *HeaderMatcherType) {
	m.fromHeaderMatcherType(f, true)
}

func (m *HeaderMatcherTypeBasic) FromHeaderMatcherTypeWithoutDeepCopy(f *HeaderMatcherType) {
	m.fromHeaderMatcherType(f, false)
}

func (m *HeaderMatcherTypeBasic) toHeaderMatcherType(f *HeaderMatcherType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetMatchToHeaderMatcherType(f)
	f.Name = m1.Name
}

func (m *HeaderMatcherTypeBasic) ToHeaderMatcherType(f *HeaderMatcherType) {
	m.toHeaderMatcherType(f, true)
}

func (m *HeaderMatcherTypeBasic) ToHeaderMatcherTypeWithoutDeepCopy(f *HeaderMatcherType) {
	m.toHeaderMatcherType(f, false)
}

func (m *MatcherTypeBasic) fromMatcherType(f *MatcherType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.ExactValues = f.GetExactValues()
	m.RegexValues = f.GetRegexValues()
}

func (m *MatcherTypeBasic) FromMatcherType(f *MatcherType) {
	m.fromMatcherType(f, true)
}

func (m *MatcherTypeBasic) FromMatcherTypeWithoutDeepCopy(f *MatcherType) {
	m.fromMatcherType(f, false)
}

func (m *MatcherTypeBasic) toMatcherType(f *MatcherType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.ExactValues = m1.ExactValues
	f.RegexValues = m1.RegexValues
}

func (m *MatcherTypeBasic) ToMatcherType(f *MatcherType) {
	m.toMatcherType(f, true)
}

func (m *MatcherTypeBasic) ToMatcherTypeWithoutDeepCopy(f *MatcherType) {
	m.toMatcherType(f, false)
}
