// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/policy/types.proto

package policy

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	app_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_firewall"
	waf_rule_list "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/waf_rule_list"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PolicySetType
//
// x-displayName: "Policy Set Type"
// The type a policy set indicates it's purpose.
// The primary use of the type is to determine the relative order of evaluation when there are multiple policy sets in a namespace. For example, a rate limiting
// policy set is evaluated before a network security policy set. The type is also used to enforce constraints on the action in rules that are part of the policy
// set. For example, a rate limiting policy set cannot contain a rule with an ALLOW or DENY action - the only valid actions are NEXT_POLICY and NEXT_POLICY_SET.
//
// - NETWORK_SECURITY Policy Set is used to apply L7 security to API requests
// - RATE_LIMITING Policy Set is used to rate limit API requests
type PolicySetType int32

const (
	// Network Security
	//
	// x-displayName: "Policy Set for Network Security"
	// Policy Set is used to apply L7 security to API requests
	NETWORK_SECURITY PolicySetType = 0
	// Rate Limiting
	//
	// x-displayName: "Policy Set for Rate Limiting"
	// Policy Set is used to rate limit API requests
	RATE_LIMITING PolicySetType = 1
	// Policy Based Routing
	//
	// x-displayName: "Policy Set for Policy Based Routing"
	// Policy Set is used to perform policy based routing
	POLICY_BASED_ROUTING PolicySetType = 2
	// WAF Exclusion
	//
	// x-displayName: "Policy Set for WAF Exclusion"
	// Policy Set is used to exclude WAF rules that result in false positives in the WAF module
	WAF_EXCLUSION PolicySetType = 3
	// Bot Protection
	//
	// x-displayName: "Policy Set for Bot Defense"
	// Policy Set is used to provide Bot Defense for Web or Mobile applications
	SHAPE_BOT_PROTECTION PolicySetType = 4
)

var PolicySetType_name = map[int32]string{
	0: "NETWORK_SECURITY",
	1: "RATE_LIMITING",
	2: "POLICY_BASED_ROUTING",
	3: "WAF_EXCLUSION",
	4: "SHAPE_BOT_PROTECTION",
}

var PolicySetType_value = map[string]int32{
	"NETWORK_SECURITY":     0,
	"RATE_LIMITING":        1,
	"POLICY_BASED_ROUTING": 2,
	"WAF_EXCLUSION":        3,
	"SHAPE_BOT_PROTECTION": 4,
}

func (PolicySetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{0}
}

// PolicySetScope
//
// x-displayName: "Policy Set Scope"
// The scope of a policy set. This could be per namespace or per virtual host.
type PolicySetScope int32

const (
	// per namespace
	//
	// x-displayName: "Policy Set for Namespace"
	// Policy Set is used for the entire namespace.
	POLICY_SET_SCOPE_NAMESPACE PolicySetScope = 0
	// per virtual host
	//
	// x-displayName: "Policy Set for Namespace"
	// Policy Set is used for a specific virtual host.
	POLICY_SET_SCOPE_VIRTUAL_HOST PolicySetScope = 1
)

var PolicySetScope_name = map[int32]string{
	0: "POLICY_SET_SCOPE_NAMESPACE",
	1: "POLICY_SET_SCOPE_VIRTUAL_HOST",
}

var PolicySetScope_value = map[string]int32{
	"POLICY_SET_SCOPE_NAMESPACE":    0,
	"POLICY_SET_SCOPE_VIRTUAL_HOST": 1,
}

func (PolicySetScope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{1}
}

// RuleCombiningAlgorithm
//
// x-displayName: "Rule Combining Algorithm"
// The rule combining algorithm for a policy determines how the list of rules in the policy is evaluated.
// If any of the rules is configured with a App Firewall action, the rule combining algorithm must be configured to be FIRST_MATCH.
//
// - FIRST_MATCH Rules are evaluated sequentially till a matching rule is identified
// - ALLOW_OVERRIDES Rules with an ALLOW action are evaluated prior to rules with a DENY action
// - DENY_OVERRIDES Rules with a DENY action are evaluated prior to rules with an ALLOW action
type RuleCombiningAlgorithm int32

const (
	// First Match
	//
	// x-displayName: "First Rule Match"
	// Rules are evaluated sequentially till a matching rule is identified
	FIRST_MATCH RuleCombiningAlgorithm = 0
	// Deny Overrides
	//
	// x-displayName: "Deny Rule Overrides"
	// Rules with a DENY action are evaluated prior to rules with an ALLOW action
	DENY_OVERRIDES RuleCombiningAlgorithm = 1
	// Allow Overrides
	//
	// x-displayName: "Allow Rule Overrides"
	// Rules with an ALLOW action are evaluated prior to rules with a DENY action
	ALLOW_OVERRIDES RuleCombiningAlgorithm = 2
)

var RuleCombiningAlgorithm_name = map[int32]string{
	0: "FIRST_MATCH",
	1: "DENY_OVERRIDES",
	2: "ALLOW_OVERRIDES",
}

var RuleCombiningAlgorithm_value = map[string]int32{
	"FIRST_MATCH":     0,
	"DENY_OVERRIDES":  1,
	"ALLOW_OVERRIDES": 2,
}

func (RuleCombiningAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{2}
}

// Transformer
//
// x-displayName: "Transformer"
// Transformers to be applied on the part of the request before matching.
type Transformer int32

const (
	// transformer none
	//
	// x-displayName: "Transformer None"
	// No transformers enabled
	TRANSFORMER_NONE Transformer = 0
	// lower case
	//
	// x-displayName: "Lower Case"
	// Convert string to lower case
	LOWER_CASE Transformer = 1
	// upper case
	//
	// x-displayName: "Upper Case"
	// Convert string to upper case
	UPPER_CASE Transformer = 2
	// base64 decode
	//
	// x-displayName: "Base64 Decode"
	// Decode string assuming base64 encoding
	BASE64_DECODE Transformer = 3
	// normalize path
	//
	// x-displayName: "Normalize Path"
	// Normalize URL path so that /a/b/../c will be transformed to /a/c
	NORMALIZE_PATH Transformer = 4
	// remove whitespace
	//
	// x-displayName: "Remove Whitespace"
	// Remove whitespaces
	REMOVE_WHITESPACE Transformer = 5
	// URL decode
	//
	// x-displayName: "URL Decode"
	// Decode string assuming URL encoding as per rfc1738
	URL_DECODE Transformer = 6
	// trim left
	//
	// x-displayName: "Trim Left"
	// Remove whitespace from the left side of the input string
	TRIM_LEFT Transformer = 7
	// trim right
	//
	// x-displayName: "Trim Right"
	// Remove whitespace from the right side of the input string
	TRIM_RIGHT Transformer = 8
	// trim
	//
	// x-displayName: "Trim"
	// Remove whitespace from the both sides of the input string
	TRIM Transformer = 9
)

var Transformer_name = map[int32]string{
	0: "TRANSFORMER_NONE",
	1: "LOWER_CASE",
	2: "UPPER_CASE",
	3: "BASE64_DECODE",
	4: "NORMALIZE_PATH",
	5: "REMOVE_WHITESPACE",
	6: "URL_DECODE",
	7: "TRIM_LEFT",
	8: "TRIM_RIGHT",
	9: "TRIM",
}

var Transformer_value = map[string]int32{
	"TRANSFORMER_NONE":  0,
	"LOWER_CASE":        1,
	"UPPER_CASE":        2,
	"BASE64_DECODE":     3,
	"NORMALIZE_PATH":    4,
	"REMOVE_WHITESPACE": 5,
	"URL_DECODE":        6,
	"TRIM_LEFT":         7,
	"TRIM_RIGHT":        8,
	"TRIM":              9,
}

func (Transformer) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{3}
}

// URL Category
//
// x-displayName: "URL Category"
// The url categories to use when a policy based url category is configured.
type URLCategory int32

const (
	// UNCATEGORIZED
	//
	// x-displayName: "Uncategorized"
	// Uncategorized
	UNCATEGORIZED URLCategory = 0
	// REAL_ESTATE
	//
	// x-displayName: "Real Estate"
	// Real Estate
	REAL_ESTATE URLCategory = 1
	// COMPUTER_AND_INTERNET_SECURITY
	//
	// x-displayName: "Computer and Internet Security"
	// Computer and Internet Security
	COMPUTER_AND_INTERNET_SECURITY URLCategory = 2
	// FINANCIAL_SERVICES
	//
	// x-displayName: "Financial Services"
	// Financial Services
	FINANCIAL_SERVICES URLCategory = 3
	// BUSINESS_AND_ECONOMY
	//
	// x-displayName: "Business and Economy"
	// Business and Economy
	BUSINESS_AND_ECONOMY URLCategory = 4
	// COMPUTER_AND_INTERNET_INFO
	//
	// x-displayName: "Computer and Internet Info"
	// Computer and Internet Info
	COMPUTER_AND_INTERNET_INFO URLCategory = 5
	// AUCTIONS
	//
	// x-displayName: "Auctions"
	// Auctions
	AUCTIONS URLCategory = 6
	// SHOPPING
	//
	// x-displayName: "Shopping"
	// Shopping
	SHOPPING URLCategory = 7
	// CULT_AND_OCCULT
	//
	// x-displayName: "Cult and Occult"
	// Cult and Occult
	CULT_AND_OCCULT URLCategory = 8
	// TRAVEL
	//
	// x-displayName: "Travel"
	// Travel
	TRAVEL URLCategory = 9
	// ABUSED_DRUGS
	//
	// x-displayName: "Abused Drugs"
	// Abused Drugs
	ABUSED_DRUGS URLCategory = 10
	// ADULT_AND_PORNOGRAPHY
	//
	// x-displayName: "Adult and Pornography"
	// Adult and Pornography
	ADULT_AND_PORNOGRAPHY URLCategory = 11
	// HOME_AND_GARDEN
	//
	// x-displayName: "Home and Garden"
	// Home and Garden
	HOME_AND_GARDEN URLCategory = 12
	// MILITARY
	//
	// x-displayName: "Military"
	// Military
	MILITARY URLCategory = 13
	// SOCIAL_NETWORKING
	//
	// x-displayName: "Social Networking"
	// Social Networking
	SOCIAL_NETWORKING URLCategory = 14
	// DEAD_SITES
	//
	// x-displayName: "Dead Sites"
	// Dead Sites
	DEAD_SITES URLCategory = 15
	// INDIVIDUAL_STOCK_ADVICE_AND_TOOLS
	//
	// x-displayName: "Individual Stock Advice and Tools"
	// Individual Stock Advice and Tools
	INDIVIDUAL_STOCK_ADVICE_AND_TOOLS URLCategory = 16
	// TRAINING_AND_TOOLS
	//
	// x-displayName: "Training and Tools"
	// Training and Tools
	TRAINING_AND_TOOLS URLCategory = 17
	// DATING
	//
	// x-displayName: "Dating"
	// Dating
	DATING URLCategory = 18
	// SEX_EDUCATION
	//
	// x-displayName: "Sex Education"
	// Sex Education
	SEX_EDUCATION URLCategory = 19
	// RELIGION
	//
	// x-displayName: "Religion"
	// Religion
	RELIGION URLCategory = 20
	// ENTERTAINMENT_AND_ARTS
	//
	// x-displayName: "Entertainment and Arts"
	// Entertainment and Arts
	ENTERTAINMENT_AND_ARTS URLCategory = 21
	// PERSONAL_SITES_AND_BLOGS
	//
	// x-displayName: "Personal sites and Blogs"
	// Personal sites and Blogs
	PERSONAL_SITES_AND_BLOGS URLCategory = 22
	// LEGAL
	//
	// x-displayName: "Legal"
	// Legal
	LEGAL URLCategory = 23
	// LOCAL_INFORMATION
	//
	// x-displayName: "Local Information"
	// Local Information
	LOCAL_INFORMATION URLCategory = 24
	// STREAMING_MEDIA
	//
	// x-displayName: "Streaming Media"
	// Streaming Media
	STREAMING_MEDIA URLCategory = 25
	// JOB_SEARCH
	//
	// x-displayName: "Job Search"
	// Job Search
	JOB_SEARCH URLCategory = 26
	// GAMBLING
	//
	// x-displayName: "Gambling"
	// Gambling
	GAMBLING URLCategory = 27
	// TRANSLATION
	//
	// x-displayName: "Translation"
	// Translation
	TRANSLATION URLCategory = 28
	// REFERENCE_AND_RESEARCH
	//
	// x-displayName: "Reference and Research"
	// Reference and Research
	REFERENCE_AND_RESEARCH URLCategory = 29
	// SHAREWARE_AND_FREEWARE
	//
	// x-displayName: "Shareware and Freeware"
	// Shareware and Freeware
	SHAREWARE_AND_FREEWARE URLCategory = 30
	// PEER_TO_PEER
	//
	// x-displayName: "Peer to Peer"
	// Peer to Peer
	PEER_TO_PEER URLCategory = 31
	// MARIJUANA
	//
	// x-displayName: "Marijuana"
	// Marijuana
	MARIJUANA URLCategory = 32
	// HACKING
	//
	// x-displayName: "Hacking"
	// Hacking
	HACKING URLCategory = 33
	// GAMES
	//
	// x-displayName: "Games"
	// Games
	GAMES URLCategory = 34
	// PHILOSOPHY_AND_POLITICAL_ADVOCACY
	//
	// x-displayName: "Philosophy and Political Advocacy"
	// Philosophy and Political Advocacy
	PHILOSOPHY_AND_POLITICAL_ADVOCACY URLCategory = 35
	// WEAPONS
	//
	// x-displayName: "Weapons"
	// Weapons
	WEAPONS URLCategory = 36
	// PAY_TO_SURF
	//
	// x-displayName: "Pay to Surf"
	// Pay to Surf
	PAY_TO_SURF URLCategory = 37
	// HUNTING_AND_FISHING
	//
	// x-displayName: "Hunting and Fishing"
	// Hunting and Fishing
	HUNTING_AND_FISHING URLCategory = 38
	// SOCIETY
	//
	// x-displayName: "Society"
	// Society
	SOCIETY URLCategory = 39
	// EDUCATIONAL_INSTITUTIONS
	//
	// x-displayName: "Educational Institutions"
	// Educational Institutions
	EDUCATIONAL_INSTITUTIONS URLCategory = 40
	// ONLINE_GREETING_CARDS
	//
	// x-displayName: "Online Greeting Cards"
	// Online Greeting Cards
	ONLINE_GREETING_CARDS URLCategory = 41
	// SPORTS
	//
	// x-displayName: "Sports"
	// Sports
	SPORTS URLCategory = 42
	// SWIMSUITS_AND_INTIMATE_APPAREL
	//
	// x-displayName: "Swimsuits and Intimate Apparel"
	// Swimsuits and Intimate Apparel
	SWIMSUITS_AND_INTIMATE_APPAREL URLCategory = 43
	// QUESTIONABLE
	//
	// x-displayName: "Questionable"
	// Questionable
	QUESTIONABLE URLCategory = 44
	// KIDS
	//
	// x-displayName: "Kids"
	// Kids
	KIDS URLCategory = 45
	// HATE_AND_RACISM
	//
	// x-displayName: "Hate and Racism"
	// Hate and Racism
	HATE_AND_RACISM URLCategory = 46
	// PERSONAL_STORAGE
	//
	// x-displayName: "Personal Storage"
	// Personal Storage
	PERSONAL_STORAGE URLCategory = 47
	// VIOLENCE
	//
	// x-displayName: "Violence"
	// Violence
	VIOLENCE URLCategory = 48
	// KEYLOGGERS_AND_MONITORING
	//
	// x-displayName: "Keyloggers and Monitoring"
	// Keyloggers and Monitoring
	KEYLOGGERS_AND_MONITORING URLCategory = 49
	// SEARCH_ENGINES
	//
	// x-displayName: "Search Engines"
	// Search Engines
	SEARCH_ENGINES URLCategory = 50
	// INTERNET_PORTALS
	//
	// x-displayName: "Internet Portals"
	// Internet Portals
	INTERNET_PORTALS URLCategory = 51
	// WEB_ADVERTISEMENTS
	//
	// x-displayName: "Web Advertisements"
	// Web Advertisements
	WEB_ADVERTISEMENTS URLCategory = 52
	// CHEATING
	//
	// x-displayName: "Cheating"
	// Cheating
	CHEATING URLCategory = 53
	// GROSS
	//
	// x-displayName: "Gross"
	// Gross
	GROSS URLCategory = 54
	// WEB_BASED_EMAIL
	//
	// x-displayName: "Web-based Email"
	// Web-based Email
	WEB_BASED_EMAIL URLCategory = 55
	// MALWARE_SITES
	//
	// x-displayName: "Malware Sites"
	// Malware Sites
	MALWARE_SITES URLCategory = 56
	// PHISHING_AND_OTHER_FRAUDS
	//
	// x-displayName: "Phishing and Other Frauds"
	// Phishing and Other Frauds
	PHISHING_AND_OTHER_FRAUDS URLCategory = 57
	// PROXY_AVOIDANCE_AND_ANONYMIZERS
	//
	// x-displayName: "Proxy Avoidance and Anonymizers"
	// Proxy Avoidance and Anonymizers
	PROXY_AVOIDANCE_AND_ANONYMIZERS URLCategory = 58
	// SPYWARE_AND_ADWARE
	//
	// x-displayName: "Spyware and Adware"
	// Spyware and Adware
	SPYWARE_AND_ADWARE URLCategory = 59
	// MUSIC
	//
	// x-displayName: "Music"
	// Music
	MUSIC URLCategory = 60
	// GOVERNMENT
	//
	// x-displayName: "Government"
	// Government
	GOVERNMENT URLCategory = 61
	// NUDITY
	//
	// x-displayName: "Nudity"
	// Nudity
	NUDITY URLCategory = 62
	// NEWS_AND_MEDIA
	//
	// x-displayName: "News and Media"
	// News and Media
	NEWS_AND_MEDIA URLCategory = 63
	// ILLEGAL
	//
	// x-displayName: "Illegal"
	// Illegal
	ILLEGAL URLCategory = 64
	// CONTENT_DELIVERY_NETWORKS
	//
	// x-displayName: "Content Delivery Networks"
	// Content Delivery Networks
	CONTENT_DELIVERY_NETWORKS URLCategory = 65
	// INTERNET_COMMUNICATIONS
	//
	// x-displayName: "Internet Communications"
	// Internet Communications
	INTERNET_COMMUNICATIONS URLCategory = 66
	// BOT_NETS
	//
	// x-displayName: "Bot Nets"
	// Bot Nets
	BOT_NETS URLCategory = 67
	// ABORTION
	//
	// x-displayName: "Abortion"
	// Abortion
	ABORTION URLCategory = 68
	// HEALTH_AND_MEDICINE
	//
	// x-displayName: "Health and Medicine"
	// Health and Medicine
	HEALTH_AND_MEDICINE URLCategory = 69
	// CONFIRMED_SPAM_SOURCES
	//
	// x-displayName: "Confirmed SPAM Sources"
	// Confirmed SPAM Sources
	CONFIRMED_SPAM_SOURCES URLCategory = 70
	// SPAM_URLS
	//
	// x-displayName: "SPAM URLs"
	// SPAM URLs
	SPAM_URLS URLCategory = 71
	// UNCONFIRMED_SPAM_SOURCES
	//
	// x-displayName: "Unconfirmed SPAM Sources"
	// Unconfirmed SPAM Sources
	UNCONFIRMED_SPAM_SOURCES URLCategory = 72
	// OPEN_HTTP_PROXIES
	//
	// x-displayName: "Open HTTP Proxies"
	// Open HTTP Proxies
	OPEN_HTTP_PROXIES URLCategory = 73
	// DYNAMICALLY_GENERATED_CONTENT
	//
	// x-displayName: "Dynamically Generated Content"
	// Dynamically Generated Content
	DYNAMICALLY_GENERATED_CONTENT URLCategory = 74
	// PARKED_DOMAINS
	//
	// x-displayName: "Parked Domains"
	// Parked Domains
	PARKED_DOMAINS URLCategory = 75
	// ALCOHOL_AND_TOBACCO
	//
	// x-displayName: "Alcohol and Tobacco"
	// Alcohol and Tobacco
	ALCOHOL_AND_TOBACCO URLCategory = 76
	// PRIVATE_IP_ADDRESSES
	//
	// x-displayName: "Private IP Addresses"
	// Private IP Addresses
	PRIVATE_IP_ADDRESSES URLCategory = 77
	// IMAGE_AND_VIDEO_SEARCH
	//
	// x-displayName: "Image and Video Search"
	// Image and Video Search
	IMAGE_AND_VIDEO_SEARCH URLCategory = 78
	// FASHION_AND_BEAUTY
	//
	// x-displayName: "Fashion and Beauty"
	// Fashion and Beauty
	FASHION_AND_BEAUTY URLCategory = 79
	// RECREATION_AND_HOBBIES
	//
	// x-displayName: "Recreation and Hobbies"
	// Recreation and Hobbies
	RECREATION_AND_HOBBIES URLCategory = 80
	// MOTOR_VEHICLES
	//
	// x-displayName: "Motor Vehicles"
	// Motor Vehicles
	MOTOR_VEHICLES URLCategory = 81
	// WEB_HOSTING
	//
	// x-displayName: "Web Hosting"
	// Web Hosting
	WEB_HOSTING URLCategory = 82
)

var URLCategory_name = map[int32]string{
	0:  "UNCATEGORIZED",
	1:  "REAL_ESTATE",
	2:  "COMPUTER_AND_INTERNET_SECURITY",
	3:  "FINANCIAL_SERVICES",
	4:  "BUSINESS_AND_ECONOMY",
	5:  "COMPUTER_AND_INTERNET_INFO",
	6:  "AUCTIONS",
	7:  "SHOPPING",
	8:  "CULT_AND_OCCULT",
	9:  "TRAVEL",
	10: "ABUSED_DRUGS",
	11: "ADULT_AND_PORNOGRAPHY",
	12: "HOME_AND_GARDEN",
	13: "MILITARY",
	14: "SOCIAL_NETWORKING",
	15: "DEAD_SITES",
	16: "INDIVIDUAL_STOCK_ADVICE_AND_TOOLS",
	17: "TRAINING_AND_TOOLS",
	18: "DATING",
	19: "SEX_EDUCATION",
	20: "RELIGION",
	21: "ENTERTAINMENT_AND_ARTS",
	22: "PERSONAL_SITES_AND_BLOGS",
	23: "LEGAL",
	24: "LOCAL_INFORMATION",
	25: "STREAMING_MEDIA",
	26: "JOB_SEARCH",
	27: "GAMBLING",
	28: "TRANSLATION",
	29: "REFERENCE_AND_RESEARCH",
	30: "SHAREWARE_AND_FREEWARE",
	31: "PEER_TO_PEER",
	32: "MARIJUANA",
	33: "HACKING",
	34: "GAMES",
	35: "PHILOSOPHY_AND_POLITICAL_ADVOCACY",
	36: "WEAPONS",
	37: "PAY_TO_SURF",
	38: "HUNTING_AND_FISHING",
	39: "SOCIETY",
	40: "EDUCATIONAL_INSTITUTIONS",
	41: "ONLINE_GREETING_CARDS",
	42: "SPORTS",
	43: "SWIMSUITS_AND_INTIMATE_APPAREL",
	44: "QUESTIONABLE",
	45: "KIDS",
	46: "HATE_AND_RACISM",
	47: "PERSONAL_STORAGE",
	48: "VIOLENCE",
	49: "KEYLOGGERS_AND_MONITORING",
	50: "SEARCH_ENGINES",
	51: "INTERNET_PORTALS",
	52: "WEB_ADVERTISEMENTS",
	53: "CHEATING",
	54: "GROSS",
	55: "WEB_BASED_EMAIL",
	56: "MALWARE_SITES",
	57: "PHISHING_AND_OTHER_FRAUDS",
	58: "PROXY_AVOIDANCE_AND_ANONYMIZERS",
	59: "SPYWARE_AND_ADWARE",
	60: "MUSIC",
	61: "GOVERNMENT",
	62: "NUDITY",
	63: "NEWS_AND_MEDIA",
	64: "ILLEGAL",
	65: "CONTENT_DELIVERY_NETWORKS",
	66: "INTERNET_COMMUNICATIONS",
	67: "BOT_NETS",
	68: "ABORTION",
	69: "HEALTH_AND_MEDICINE",
	70: "CONFIRMED_SPAM_SOURCES",
	71: "SPAM_URLS",
	72: "UNCONFIRMED_SPAM_SOURCES",
	73: "OPEN_HTTP_PROXIES",
	74: "DYNAMICALLY_GENERATED_CONTENT",
	75: "PARKED_DOMAINS",
	76: "ALCOHOL_AND_TOBACCO",
	77: "PRIVATE_IP_ADDRESSES",
	78: "IMAGE_AND_VIDEO_SEARCH",
	79: "FASHION_AND_BEAUTY",
	80: "RECREATION_AND_HOBBIES",
	81: "MOTOR_VEHICLES",
	82: "WEB_HOSTING",
}

var URLCategory_value = map[string]int32{
	"UNCATEGORIZED":                     0,
	"REAL_ESTATE":                       1,
	"COMPUTER_AND_INTERNET_SECURITY":    2,
	"FINANCIAL_SERVICES":                3,
	"BUSINESS_AND_ECONOMY":              4,
	"COMPUTER_AND_INTERNET_INFO":        5,
	"AUCTIONS":                          6,
	"SHOPPING":                          7,
	"CULT_AND_OCCULT":                   8,
	"TRAVEL":                            9,
	"ABUSED_DRUGS":                      10,
	"ADULT_AND_PORNOGRAPHY":             11,
	"HOME_AND_GARDEN":                   12,
	"MILITARY":                          13,
	"SOCIAL_NETWORKING":                 14,
	"DEAD_SITES":                        15,
	"INDIVIDUAL_STOCK_ADVICE_AND_TOOLS": 16,
	"TRAINING_AND_TOOLS":                17,
	"DATING":                            18,
	"SEX_EDUCATION":                     19,
	"RELIGION":                          20,
	"ENTERTAINMENT_AND_ARTS":            21,
	"PERSONAL_SITES_AND_BLOGS":          22,
	"LEGAL":                             23,
	"LOCAL_INFORMATION":                 24,
	"STREAMING_MEDIA":                   25,
	"JOB_SEARCH":                        26,
	"GAMBLING":                          27,
	"TRANSLATION":                       28,
	"REFERENCE_AND_RESEARCH":            29,
	"SHAREWARE_AND_FREEWARE":            30,
	"PEER_TO_PEER":                      31,
	"MARIJUANA":                         32,
	"HACKING":                           33,
	"GAMES":                             34,
	"PHILOSOPHY_AND_POLITICAL_ADVOCACY": 35,
	"WEAPONS":                           36,
	"PAY_TO_SURF":                       37,
	"HUNTING_AND_FISHING":               38,
	"SOCIETY":                           39,
	"EDUCATIONAL_INSTITUTIONS":          40,
	"ONLINE_GREETING_CARDS":             41,
	"SPORTS":                            42,
	"SWIMSUITS_AND_INTIMATE_APPAREL":    43,
	"QUESTIONABLE":                      44,
	"KIDS":                              45,
	"HATE_AND_RACISM":                   46,
	"PERSONAL_STORAGE":                  47,
	"VIOLENCE":                          48,
	"KEYLOGGERS_AND_MONITORING":         49,
	"SEARCH_ENGINES":                    50,
	"INTERNET_PORTALS":                  51,
	"WEB_ADVERTISEMENTS":                52,
	"CHEATING":                          53,
	"GROSS":                             54,
	"WEB_BASED_EMAIL":                   55,
	"MALWARE_SITES":                     56,
	"PHISHING_AND_OTHER_FRAUDS":         57,
	"PROXY_AVOIDANCE_AND_ANONYMIZERS":   58,
	"SPYWARE_AND_ADWARE":                59,
	"MUSIC":                             60,
	"GOVERNMENT":                        61,
	"NUDITY":                            62,
	"NEWS_AND_MEDIA":                    63,
	"ILLEGAL":                           64,
	"CONTENT_DELIVERY_NETWORKS":         65,
	"INTERNET_COMMUNICATIONS":           66,
	"BOT_NETS":                          67,
	"ABORTION":                          68,
	"HEALTH_AND_MEDICINE":               69,
	"CONFIRMED_SPAM_SOURCES":            70,
	"SPAM_URLS":                         71,
	"UNCONFIRMED_SPAM_SOURCES":          72,
	"OPEN_HTTP_PROXIES":                 73,
	"DYNAMICALLY_GENERATED_CONTENT":     74,
	"PARKED_DOMAINS":                    75,
	"ALCOHOL_AND_TOBACCO":               76,
	"PRIVATE_IP_ADDRESSES":              77,
	"IMAGE_AND_VIDEO_SEARCH":            78,
	"FASHION_AND_BEAUTY":                79,
	"RECREATION_AND_HOBBIES":            80,
	"MOTOR_VEHICLES":                    81,
	"WEB_HOSTING":                       82,
}

func (URLCategory) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{4}
}

// IP Threat Category
//
// x-displayName: "IP Threat Category"
// The IP threat categories to use when a policy based IP threat category is configured.
type IPThreatCategory int32

const (
	// SPAM_SOURCES
	//
	// x-displayName: "Spam Sources"
	SPAM_SOURCES IPThreatCategory = 0
	// WINDOWS_EXPLOITS
	//
	// x-displayName: "Windows Exploits"
	WINDOWS_EXPLOITS IPThreatCategory = 1
	// WEB_ATTACKS
	//
	// x-displayName: "Web Attacks"
	WEB_ATTACKS IPThreatCategory = 2
	// BOTNETS
	//
	// x-displayName: "Botnets"
	BOTNETS IPThreatCategory = 3
	// SCANNERS
	//
	// x-displayName: "Scanners"
	SCANNERS IPThreatCategory = 4
	// REPUTATION
	//
	// x-displayName: "Reputation"
	REPUTATION IPThreatCategory = 5
	// PHISHING
	//
	// x-displayName: "Phishing"
	PHISHING IPThreatCategory = 6
	// PROXY
	//
	// x-displayName: "Anonymous Proxies"
	PROXY IPThreatCategory = 7
	// MOBILE_THREATS
	//
	// x-displayName: "Mobile Threats"
	MOBILE_THREATS IPThreatCategory = 8
	// TOR_PROXY
	//
	// x-displayName: "Tor Proxy"
	TOR_PROXY IPThreatCategory = 9
	// DENIAL_OF_SERVICE
	//
	// x-displayName: "Denial of service"
	DENIAL_OF_SERVICE IPThreatCategory = 10
	// NETWORK
	//
	// x-displayName: "Network Attacks"
	NETWORK IPThreatCategory = 11
)

var IPThreatCategory_name = map[int32]string{
	0:  "SPAM_SOURCES",
	1:  "WINDOWS_EXPLOITS",
	2:  "WEB_ATTACKS",
	3:  "BOTNETS",
	4:  "SCANNERS",
	5:  "REPUTATION",
	6:  "PHISHING",
	7:  "PROXY",
	8:  "MOBILE_THREATS",
	9:  "TOR_PROXY",
	10: "DENIAL_OF_SERVICE",
	11: "NETWORK",
}

var IPThreatCategory_value = map[string]int32{
	"SPAM_SOURCES":      0,
	"WINDOWS_EXPLOITS":  1,
	"WEB_ATTACKS":       2,
	"BOTNETS":           3,
	"SCANNERS":          4,
	"REPUTATION":        5,
	"PHISHING":          6,
	"PROXY":             7,
	"MOBILE_THREATS":    8,
	"TOR_PROXY":         9,
	"DENIAL_OF_SERVICE": 10,
	"NETWORK":           11,
}

func (IPThreatCategory) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{5}
}

// TLS known fingerprint class
//
// x-displayName: "TLS known fingerprint class"
// Specifies known TLS fingerprint classes
type KnownTlsFingerprintClass int32

const (
	// TLS_FINGERPRINT_NONE
	//
	// x-displayName: "TLS Fingerprint None"
	// No TLS fingerprint
	TLS_FINGERPRINT_NONE KnownTlsFingerprintClass = 0
	// ANY_MALICIOUS_FINGERPRINT
	//
	// x-displayName: "Any Known Malicious Fingerprint"
	// TLS fingerprints known to be associated with malicious clients
	ANY_MALICIOUS_FINGERPRINT KnownTlsFingerprintClass = 1
	// ADWARE
	//
	// x-displayName: "ADWARE"
	// TLS fingerprints known to be associated with adware
	ADWARE KnownTlsFingerprintClass = 2
	// ADWIND
	//
	// x-displayName: "ADWIND"
	// TLS fingerprints known to be associated with adwind
	ADWIND KnownTlsFingerprintClass = 3
	// DRIDEX
	//
	// x-displayName: "DRIDEX"
	// TLS fingerprints known to be associated with dridex
	DRIDEX KnownTlsFingerprintClass = 4
	// GOOTKIT
	//
	// x-displayName: "GOOTKIT"
	// TLS fingerprints known to be associated with gootkit
	GOOTKIT KnownTlsFingerprintClass = 5
	// GOZI
	//
	// x-displayName: "GOZI"
	// TLS fingerprints known to be associated with gozi
	GOZI KnownTlsFingerprintClass = 6
	// JBIFROST
	//
	// x-displayName: "JBIFROST"
	// TLS fingerprints known to be associated with jbifrost
	JBIFROST KnownTlsFingerprintClass = 7
	// QUAKBOT
	//
	// x-displayName: "QUAKBOT"
	// TLS fingerprints known to be associated with quakbot
	QUAKBOT KnownTlsFingerprintClass = 8
	// RANSOMWARE
	//
	// x-displayName: "RANSOMWARE"
	// TLS fingerprints known to be associated with ransomware
	RANSOMWARE KnownTlsFingerprintClass = 9
	// TROLDESH
	//
	// x-displayName: "TROLDESH"
	// TLS fingerprints known to be associated with troldesh
	TROLDESH KnownTlsFingerprintClass = 10
	// TOFSEE
	//
	// x-displayName: "TOFSEE"
	// TLS fingerprints known to be associated with tofsee
	TOFSEE KnownTlsFingerprintClass = 11
	// TORRENTLOCKER
	//
	// x-displayName: "TORRENTLOCKER"
	// TLS fingerprints known to be associated with torrentlocker
	TORRENTLOCKER KnownTlsFingerprintClass = 12
	// TRICKBOT
	//
	// x-displayName: "TRICKBOT"
	// TLS fingerprints known to be associated with trickbot
	TRICKBOT KnownTlsFingerprintClass = 13
)

var KnownTlsFingerprintClass_name = map[int32]string{
	0:  "TLS_FINGERPRINT_NONE",
	1:  "ANY_MALICIOUS_FINGERPRINT",
	2:  "ADWARE",
	3:  "ADWIND",
	4:  "DRIDEX",
	5:  "GOOTKIT",
	6:  "GOZI",
	7:  "JBIFROST",
	8:  "QUAKBOT",
	9:  "RANSOMWARE",
	10: "TROLDESH",
	11: "TOFSEE",
	12: "TORRENTLOCKER",
	13: "TRICKBOT",
}

var KnownTlsFingerprintClass_value = map[string]int32{
	"TLS_FINGERPRINT_NONE":      0,
	"ANY_MALICIOUS_FINGERPRINT": 1,
	"ADWARE":                    2,
	"ADWIND":                    3,
	"DRIDEX":                    4,
	"GOOTKIT":                   5,
	"GOZI":                      6,
	"JBIFROST":                  7,
	"QUAKBOT":                   8,
	"RANSOMWARE":                9,
	"TROLDESH":                  10,
	"TOFSEE":                    11,
	"TORRENTLOCKER":             12,
	"TRICKBOT":                  13,
}

func (KnownTlsFingerprintClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{6}
}

// CountryCode
//
// x-displayName: "Country Code"
// ISO 3166 Aplpha-2 country codes
type CountryCode int32

const (
	// x-displayName: "None"
	COUNTRY_NONE CountryCode = 0
	// x-displayName: "Andorra"
	COUNTRY_AD CountryCode = 1
	// x-displayName: "United Arab Emirates"
	COUNTRY_AE CountryCode = 2
	// x-displayName: "Afghanistan"
	COUNTRY_AF CountryCode = 3
	// x-displayName: "Antigua and Barbuda"
	COUNTRY_AG CountryCode = 4
	// x-displayName: "Anguilla"
	COUNTRY_AI CountryCode = 5
	// x-displayName: "Albania"
	COUNTRY_AL CountryCode = 6
	// x-displayName: "Armenia"
	COUNTRY_AM CountryCode = 7
	// x-displayName: "Netherlands Antilles"
	COUNTRY_AN CountryCode = 8
	// x-displayName: "Angola"
	COUNTRY_AO CountryCode = 9
	// x-displayName: "Antarctica"
	COUNTRY_AQ CountryCode = 10
	// x-displayName: "Argentina"
	COUNTRY_AR CountryCode = 11
	// x-displayName: "American Samoa"
	COUNTRY_AS CountryCode = 12
	// x-displayName: "Austria"
	COUNTRY_AT CountryCode = 13
	// x-displayName: "Australia"
	COUNTRY_AU CountryCode = 14
	// x-displayName: "Aruba"
	COUNTRY_AW CountryCode = 15
	// x-displayName: "Aland Islands"
	COUNTRY_AX CountryCode = 16
	// x-displayName: "Azerbaijan"
	COUNTRY_AZ CountryCode = 17
	// x-displayName: "Bosnia and Herzegovina"
	COUNTRY_BA CountryCode = 18
	// x-displayName: "Barbados"
	COUNTRY_BB CountryCode = 19
	// x-displayName: "Bangladesh"
	COUNTRY_BD CountryCode = 20
	// x-displayName: "Belgium"
	COUNTRY_BE CountryCode = 21
	// x-displayName: "Burkina Faso"
	COUNTRY_BF CountryCode = 22
	// x-displayName: "Bulgaria"
	COUNTRY_BG CountryCode = 23
	// x-displayName: "Bahrain"
	COUNTRY_BH CountryCode = 24
	// x-displayName: "Burundi"
	COUNTRY_BI CountryCode = 25
	// x-displayName: "Benin"
	COUNTRY_BJ CountryCode = 26
	// x-displayName: "Saint Barthelemy"
	COUNTRY_BL CountryCode = 27
	// x-displayName: "Bermuda"
	COUNTRY_BM CountryCode = 28
	// x-displayName: "Brunei Darussalam"
	COUNTRY_BN CountryCode = 29
	// x-displayName: "Bolivia"
	COUNTRY_BO CountryCode = 30
	// x-displayName: "Saint Eustatius and Saba Bonaire"
	COUNTRY_BQ CountryCode = 31
	// x-displayName: "Brazil"
	COUNTRY_BR CountryCode = 32
	// x-displayName: "Bahamas"
	COUNTRY_BS CountryCode = 33
	// x-displayName: "Bhutan"
	COUNTRY_BT CountryCode = 34
	// x-displayName: "Bouvet Island"
	COUNTRY_BV CountryCode = 35
	// x-displayName: "Botswana"
	COUNTRY_BW CountryCode = 36
	// x-displayName: "Belarus"
	COUNTRY_BY CountryCode = 37
	// x-displayName: "Belize"
	COUNTRY_BZ CountryCode = 38
	// x-displayName: "Canada"
	COUNTRY_CA CountryCode = 39
	// x-displayName: "Cocos (Keeling) Islands"
	COUNTRY_CC CountryCode = 40
	// x-displayName: "The Democratic Republic of Congo"
	COUNTRY_CD CountryCode = 41
	// x-displayName: "Central African Republic"
	COUNTRY_CF CountryCode = 42
	// x-displayName: "Congo"
	COUNTRY_CG CountryCode = 43
	// x-displayName: "Switzerland"
	COUNTRY_CH CountryCode = 44
	// x-displayName: "Cote d'Ivoire"
	COUNTRY_CI CountryCode = 45
	// x-displayName: "Cook Islands"
	COUNTRY_CK CountryCode = 46
	// x-displayName: "Chile"
	COUNTRY_CL CountryCode = 47
	// x-displayName: "Cameroon"
	COUNTRY_CM CountryCode = 48
	// x-displayName: "China"
	COUNTRY_CN CountryCode = 49
	// x-displayName: "Colombia"
	COUNTRY_CO CountryCode = 50
	// x-displayName: "Costa Rica"
	COUNTRY_CR CountryCode = 51
	// x-displayName: "Serbia and Montenegro"
	COUNTRY_CS CountryCode = 52
	// x-displayName: "Cuba"
	COUNTRY_CU CountryCode = 53
	// x-displayName: "Cape Verde"
	COUNTRY_CV CountryCode = 54
	// x-displayName: "Curacao"
	COUNTRY_CW CountryCode = 55
	// x-displayName: "Christmas Island"
	COUNTRY_CX CountryCode = 56
	// x-displayName: "Cyprus"
	COUNTRY_CY CountryCode = 57
	// x-displayName: "Czechia"
	COUNTRY_CZ CountryCode = 58
	// x-displayName: "Germany"
	COUNTRY_DE CountryCode = 59
	// x-displayName: "Djibouti"
	COUNTRY_DJ CountryCode = 60
	// x-displayName: "Denmark"
	COUNTRY_DK CountryCode = 61
	// x-displayName: "Dominica"
	COUNTRY_DM CountryCode = 62
	// x-displayName: "Dominican Republic"
	COUNTRY_DO CountryCode = 63
	// x-displayName: "Algeria"
	COUNTRY_DZ CountryCode = 64
	// x-displayName: "Ecuador"
	COUNTRY_EC CountryCode = 65
	// x-displayName: "Estonia"
	COUNTRY_EE CountryCode = 66
	// x-displayName: "Egypt"
	COUNTRY_EG CountryCode = 67
	// x-displayName: "Western Sahara"
	COUNTRY_EH CountryCode = 68
	// x-displayName: "Eritrea"
	COUNTRY_ER CountryCode = 69
	// x-displayName: "Spain"
	COUNTRY_ES CountryCode = 70
	// x-displayName: "Ethiopia"
	COUNTRY_ET CountryCode = 71
	// x-displayName: "Finland"
	COUNTRY_FI CountryCode = 72
	// x-displayName: "Fiji"
	COUNTRY_FJ CountryCode = 73
	// x-displayName: "Falkland Islands (Malvinas)"
	COUNTRY_FK CountryCode = 74
	// x-displayName: "Federated States of Micronesia"
	COUNTRY_FM CountryCode = 75
	// x-displayName: "Faroe Islands"
	COUNTRY_FO CountryCode = 76
	// x-displayName: "France"
	COUNTRY_FR CountryCode = 77
	// x-displayName: "Gabon"
	COUNTRY_GA CountryCode = 78
	// x-displayName: "United Kingdom"
	COUNTRY_GB CountryCode = 79
	// x-displayName: "Grenada"
	COUNTRY_GD CountryCode = 80
	// x-displayName: "Georgia"
	COUNTRY_GE CountryCode = 81
	// x-displayName: "French Guiana"
	COUNTRY_GF CountryCode = 82
	// x-displayName: "Guernsey"
	COUNTRY_GG CountryCode = 83
	// x-displayName: "Ghana"
	COUNTRY_GH CountryCode = 84
	// x-displayName: "Gibraltar"
	COUNTRY_GI CountryCode = 85
	// x-displayName: "Greenland"
	COUNTRY_GL CountryCode = 86
	// x-displayName: "Gambia"
	COUNTRY_GM CountryCode = 87
	// x-displayName: "Guinea"
	COUNTRY_GN CountryCode = 88
	// x-displayName: "Guadeloupe"
	COUNTRY_GP CountryCode = 89
	// x-displayName: "Equatorial Guinea"
	COUNTRY_GQ CountryCode = 90
	// x-displayName: "Greece"
	COUNTRY_GR CountryCode = 91
	// x-displayName: "South Georgia & The South Sandwich Islands"
	COUNTRY_GS CountryCode = 92
	// x-displayName: "Guatemala"
	COUNTRY_GT CountryCode = 93
	// x-displayName: "Guam"
	COUNTRY_GU CountryCode = 94
	// x-displayName: "Guinea-Bissau"
	COUNTRY_GW CountryCode = 95
	// x-displayName: "Guyana"
	COUNTRY_GY CountryCode = 96
	// x-displayName: "Hong Kong"
	COUNTRY_HK CountryCode = 97
	// x-displayName: "Heard and Mc Donald Islands"
	COUNTRY_HM CountryCode = 98
	// x-displayName: "Honduras"
	COUNTRY_HN CountryCode = 99
	// x-displayName: "Croatia"
	COUNTRY_HR CountryCode = 100
	// x-displayName: "Haiti"
	COUNTRY_HT CountryCode = 101
	// x-displayName: "Hungary"
	COUNTRY_HU CountryCode = 102
	// x-displayName: "Indonesia"
	COUNTRY_ID CountryCode = 103
	// x-displayName: "Ireland"
	COUNTRY_IE CountryCode = 104
	// x-displayName: "Israel"
	COUNTRY_IL CountryCode = 105
	// x-displayName: "Isle of Man"
	COUNTRY_IM CountryCode = 106
	// x-displayName: "India"
	COUNTRY_IN CountryCode = 107
	// x-displayName: "British Indian Ocean Territory"
	COUNTRY_IO CountryCode = 108
	// x-displayName: "Iraq"
	COUNTRY_IQ CountryCode = 109
	// x-displayName: "Islamic Republic of Iran"
	COUNTRY_IR CountryCode = 110
	// x-displayName: "Iceland"
	COUNTRY_IS CountryCode = 111
	// x-displayName: "Italy"
	COUNTRY_IT CountryCode = 112
	// x-displayName: "Jersey"
	COUNTRY_JE CountryCode = 113
	// x-displayName: "Jamaica"
	COUNTRY_JM CountryCode = 114
	// x-displayName: "Jordan"
	COUNTRY_JO CountryCode = 115
	// x-displayName: "Japan"
	COUNTRY_JP CountryCode = 116
	// x-displayName: "Kenya"
	COUNTRY_KE CountryCode = 117
	// x-displayName: "Kyrgyzstan"
	COUNTRY_KG CountryCode = 118
	// x-displayName: "Cambodia"
	COUNTRY_KH CountryCode = 119
	// x-displayName: "Kiribati"
	COUNTRY_KI CountryCode = 120
	// x-displayName: "Comoros"
	COUNTRY_KM CountryCode = 121
	// x-displayName: "Saint Kitts & Nevis"
	COUNTRY_KN CountryCode = 122
	// x-displayName: "Democratic People's Republic of Korea"
	COUNTRY_KP CountryCode = 123
	// x-displayName: "Republic of Korea"
	COUNTRY_KR CountryCode = 124
	// x-displayName: "Kuwait"
	COUNTRY_KW CountryCode = 125
	// x-displayName: "Cayman Islands"
	COUNTRY_KY CountryCode = 126
	// x-displayName: "Kazakstan"
	COUNTRY_KZ CountryCode = 127
	// x-displayName: "People's Democratic Republic Lao"
	COUNTRY_LA CountryCode = 128
	// x-displayName: "Lebanon"
	COUNTRY_LB CountryCode = 129
	// x-displayName: "Saint Lucia"
	COUNTRY_LC CountryCode = 130
	// x-displayName: "Liechtenstein"
	COUNTRY_LI CountryCode = 131
	// x-displayName: "Sri Lanka"
	COUNTRY_LK CountryCode = 132
	// x-displayName: "Liberia"
	COUNTRY_LR CountryCode = 133
	// x-displayName: "Lesotho"
	COUNTRY_LS CountryCode = 134
	// x-displayName: "Lithuania"
	COUNTRY_LT CountryCode = 135
	// x-displayName: "Luxembourg"
	COUNTRY_LU CountryCode = 136
	// x-displayName: "Latvia"
	COUNTRY_LV CountryCode = 137
	// x-displayName: "Libyan Arab Jamahiriya"
	COUNTRY_LY CountryCode = 138
	// x-displayName: "Morocco"
	COUNTRY_MA CountryCode = 139
	// x-displayName: "Monaco"
	COUNTRY_MC CountryCode = 140
	// x-displayName: "Republic of Moldova"
	COUNTRY_MD CountryCode = 141
	// x-displayName: "Montenegro"
	COUNTRY_ME CountryCode = 142
	// x-displayName: "Saint Martin"
	COUNTRY_MF CountryCode = 143
	// x-displayName: "Madagascar"
	COUNTRY_MG CountryCode = 144
	// x-displayName: "Marshall Islands"
	COUNTRY_MH CountryCode = 145
	// x-displayName: "The Former Yugoslav Republic Of Macedonia"
	COUNTRY_MK CountryCode = 146
	// x-displayName: "Mali"
	COUNTRY_ML CountryCode = 147
	// x-displayName: "Myanmar"
	COUNTRY_MM CountryCode = 148
	// x-displayName: "Mongolia"
	COUNTRY_MN CountryCode = 149
	// x-displayName: "Macao"
	COUNTRY_MO CountryCode = 150
	// x-displayName: "Northern Mariana Islands"
	COUNTRY_MP CountryCode = 151
	// x-displayName: "Martinique"
	COUNTRY_MQ CountryCode = 152
	// x-displayName: "Mauritania"
	COUNTRY_MR CountryCode = 153
	// x-displayName: "Montserrat"
	COUNTRY_MS CountryCode = 154
	// x-displayName: "Malta"
	COUNTRY_MT CountryCode = 155
	// x-displayName: "Mauritius"
	COUNTRY_MU CountryCode = 156
	// x-displayName: "Maldives"
	COUNTRY_MV CountryCode = 157
	// x-displayName: "Malawi"
	COUNTRY_MW CountryCode = 158
	// x-displayName: "Mexico"
	COUNTRY_MX CountryCode = 159
	// x-displayName: "Malaysia"
	COUNTRY_MY CountryCode = 160
	// x-displayName: "Mozambique"
	COUNTRY_MZ CountryCode = 161
	// x-displayName: "Namibia"
	COUNTRY_NA CountryCode = 162
	// x-displayName: "New Caledonia"
	COUNTRY_NC CountryCode = 163
	// x-displayName: "Niger"
	COUNTRY_NE CountryCode = 164
	// x-displayName: "Norfolk Island"
	COUNTRY_NF CountryCode = 165
	// x-displayName: "Nigeria"
	COUNTRY_NG CountryCode = 166
	// x-displayName: "Nicaragua"
	COUNTRY_NI CountryCode = 167
	// x-displayName: "Netherlands"
	COUNTRY_NL CountryCode = 168
	// x-displayName: "Norway"
	COUNTRY_NO CountryCode = 169
	// x-displayName: "Nepal"
	COUNTRY_NP CountryCode = 170
	// x-displayName: "Nauru"
	COUNTRY_NR CountryCode = 171
	// x-displayName: "Niue"
	COUNTRY_NU CountryCode = 172
	// x-displayName: "New Zealand"
	COUNTRY_NZ CountryCode = 173
	// x-displayName: "Oman"
	COUNTRY_OM CountryCode = 174
	// x-displayName: "Panama"
	COUNTRY_PA CountryCode = 175
	// x-displayName: "Peru"
	COUNTRY_PE CountryCode = 176
	// x-displayName: "French Polynesia"
	COUNTRY_PF CountryCode = 177
	// x-displayName: "Papua New Guinea"
	COUNTRY_PG CountryCode = 178
	// x-displayName: "Philippines"
	COUNTRY_PH CountryCode = 179
	// x-displayName: "Pakistan"
	COUNTRY_PK CountryCode = 180
	// x-displayName: "Poland"
	COUNTRY_PL CountryCode = 181
	// x-displayName: "Saint Pierre and Miquelon"
	COUNTRY_PM CountryCode = 182
	// x-displayName: "Pitcairn"
	COUNTRY_PN CountryCode = 183
	// x-displayName: "Puerto Rico"
	COUNTRY_PR CountryCode = 184
	// x-displayName: "Palestinian Territory"
	COUNTRY_PS CountryCode = 185
	// x-displayName: "Portugal"
	COUNTRY_PT CountryCode = 186
	// x-displayName: "Palau"
	COUNTRY_PW CountryCode = 187
	// x-displayName: "Paraguay"
	COUNTRY_PY CountryCode = 188
	// x-displayName: "Qatar"
	COUNTRY_QA CountryCode = 189
	// x-displayName: "Reunion"
	COUNTRY_RE CountryCode = 190
	// x-displayName: "Romania"
	COUNTRY_RO CountryCode = 191
	// x-displayName: "Republic of Serbia"
	COUNTRY_RS CountryCode = 192
	// x-displayName: "Russia Federation"
	COUNTRY_RU CountryCode = 193
	// x-displayName: "Rwanda"
	COUNTRY_RW CountryCode = 194
	// x-displayName: "Saudi Arabia"
	COUNTRY_SA CountryCode = 195
	// x-displayName: "Solomon Islands"
	COUNTRY_SB CountryCode = 196
	// x-displayName: "Seychelles"
	COUNTRY_SC CountryCode = 197
	// x-displayName: "Sudan"
	COUNTRY_SD CountryCode = 198
	// x-displayName: "Sweden"
	COUNTRY_SE CountryCode = 199
	// x-displayName: "Singapore"
	COUNTRY_SG CountryCode = 200
	// x-displayName: "Saint Helena"
	COUNTRY_SH CountryCode = 201
	// x-displayName: "Slovenia"
	COUNTRY_SI CountryCode = 202
	// x-displayName: "Svalbard and Jan Mayen"
	COUNTRY_SJ CountryCode = 203
	// x-displayName: "Slovakia"
	COUNTRY_SK CountryCode = 204
	// x-displayName: "Sierra Leone"
	COUNTRY_SL CountryCode = 205
	// x-displayName: "San Marino"
	COUNTRY_SM CountryCode = 206
	// x-displayName: "Senegal"
	COUNTRY_SN CountryCode = 207
	// x-displayName: "Somalia"
	COUNTRY_SO CountryCode = 208
	// x-displayName: "Suriname"
	COUNTRY_SR CountryCode = 209
	// x-displayName: "South Sudan"
	COUNTRY_SS CountryCode = 210
	// x-displayName: "Sao Tome and Principe"
	COUNTRY_ST CountryCode = 211
	// x-displayName: "El Salvador"
	COUNTRY_SV CountryCode = 212
	// x-displayName: "Sint Maarten"
	COUNTRY_SX CountryCode = 213
	// x-displayName: "Syrian Arab Republic"
	COUNTRY_SY CountryCode = 214
	// x-displayName: "Swaziland"
	COUNTRY_SZ CountryCode = 215
	// x-displayName: "Turks and Caicos Islands"
	COUNTRY_TC CountryCode = 216
	// x-displayName: "Chad"
	COUNTRY_TD CountryCode = 217
	// x-displayName: "French Southern Territories"
	COUNTRY_TF CountryCode = 218
	// x-displayName: "Togo"
	COUNTRY_TG CountryCode = 219
	// x-displayName: "Thailand"
	COUNTRY_TH CountryCode = 220
	// x-displayName: "Tajikistan"
	COUNTRY_TJ CountryCode = 221
	// x-displayName: "Tokelau"
	COUNTRY_TK CountryCode = 222
	// x-displayName: "Timor-Leste"
	COUNTRY_TL CountryCode = 223
	// x-displayName: "Turkmenistan"
	COUNTRY_TM CountryCode = 224
	// x-displayName: "Tunisia"
	COUNTRY_TN CountryCode = 225
	// x-displayName: "Tonga"
	COUNTRY_TO CountryCode = 226
	// x-displayName: "Turkey"
	COUNTRY_TR CountryCode = 227
	// x-displayName: "Trinidad and Tobago"
	COUNTRY_TT CountryCode = 228
	// x-displayName: "Tuvalu"
	COUNTRY_TV CountryCode = 229
	// x-displayName: "Taiwan"
	COUNTRY_TW CountryCode = 230
	// x-displayName: "United Republic of Tanzania"
	COUNTRY_TZ CountryCode = 231
	// x-displayName: "Ukraine"
	COUNTRY_UA CountryCode = 232
	// x-displayName: "Uganda"
	COUNTRY_UG CountryCode = 233
	// x-displayName: "United States Minor Outlying Islands"
	COUNTRY_UM CountryCode = 234
	// x-displayName: "United States"
	COUNTRY_US CountryCode = 235
	// x-displayName: "Uruguay"
	COUNTRY_UY CountryCode = 236
	// x-displayName: "Uzbekistan"
	COUNTRY_UZ CountryCode = 237
	// x-displayName: "Holy See (Vatican City State)"
	COUNTRY_VA CountryCode = 238
	// x-displayName: "Saint Vincent and the Grenadines"
	COUNTRY_VC CountryCode = 239
	// x-displayName: "Venezuela"
	COUNTRY_VE CountryCode = 240
	// x-displayName: "British Virgin Islands"
	COUNTRY_VG CountryCode = 241
	// x-displayName: "U.S. Virgin Islands"
	COUNTRY_VI CountryCode = 242
	// x-displayName: "Vietnam"
	COUNTRY_VN CountryCode = 243
	// x-displayName: "Vanuatu"
	COUNTRY_VU CountryCode = 244
	// x-displayName: "Wallis and Futuna"
	COUNTRY_WF CountryCode = 245
	// x-displayName: "Samoa"
	COUNTRY_WS CountryCode = 246
	// x-displayName: "Kosovo"
	COUNTRY_XK CountryCode = 247
	// x-displayName: "Turkish Rep N Cyprus"
	COUNTRY_XT CountryCode = 248
	// x-displayName: "Yemen"
	COUNTRY_YE CountryCode = 249
	// x-displayName: "Mayotte"
	COUNTRY_YT CountryCode = 250
	// x-displayName: "South Africa"
	COUNTRY_ZA CountryCode = 251
	// x-displayName: "Zambia"
	COUNTRY_ZM CountryCode = 252
	// x-displayName: "Zimbabwe"
	COUNTRY_ZW CountryCode = 253
)

var CountryCode_name = map[int32]string{
	0:   "COUNTRY_NONE",
	1:   "COUNTRY_AD",
	2:   "COUNTRY_AE",
	3:   "COUNTRY_AF",
	4:   "COUNTRY_AG",
	5:   "COUNTRY_AI",
	6:   "COUNTRY_AL",
	7:   "COUNTRY_AM",
	8:   "COUNTRY_AN",
	9:   "COUNTRY_AO",
	10:  "COUNTRY_AQ",
	11:  "COUNTRY_AR",
	12:  "COUNTRY_AS",
	13:  "COUNTRY_AT",
	14:  "COUNTRY_AU",
	15:  "COUNTRY_AW",
	16:  "COUNTRY_AX",
	17:  "COUNTRY_AZ",
	18:  "COUNTRY_BA",
	19:  "COUNTRY_BB",
	20:  "COUNTRY_BD",
	21:  "COUNTRY_BE",
	22:  "COUNTRY_BF",
	23:  "COUNTRY_BG",
	24:  "COUNTRY_BH",
	25:  "COUNTRY_BI",
	26:  "COUNTRY_BJ",
	27:  "COUNTRY_BL",
	28:  "COUNTRY_BM",
	29:  "COUNTRY_BN",
	30:  "COUNTRY_BO",
	31:  "COUNTRY_BQ",
	32:  "COUNTRY_BR",
	33:  "COUNTRY_BS",
	34:  "COUNTRY_BT",
	35:  "COUNTRY_BV",
	36:  "COUNTRY_BW",
	37:  "COUNTRY_BY",
	38:  "COUNTRY_BZ",
	39:  "COUNTRY_CA",
	40:  "COUNTRY_CC",
	41:  "COUNTRY_CD",
	42:  "COUNTRY_CF",
	43:  "COUNTRY_CG",
	44:  "COUNTRY_CH",
	45:  "COUNTRY_CI",
	46:  "COUNTRY_CK",
	47:  "COUNTRY_CL",
	48:  "COUNTRY_CM",
	49:  "COUNTRY_CN",
	50:  "COUNTRY_CO",
	51:  "COUNTRY_CR",
	52:  "COUNTRY_CS",
	53:  "COUNTRY_CU",
	54:  "COUNTRY_CV",
	55:  "COUNTRY_CW",
	56:  "COUNTRY_CX",
	57:  "COUNTRY_CY",
	58:  "COUNTRY_CZ",
	59:  "COUNTRY_DE",
	60:  "COUNTRY_DJ",
	61:  "COUNTRY_DK",
	62:  "COUNTRY_DM",
	63:  "COUNTRY_DO",
	64:  "COUNTRY_DZ",
	65:  "COUNTRY_EC",
	66:  "COUNTRY_EE",
	67:  "COUNTRY_EG",
	68:  "COUNTRY_EH",
	69:  "COUNTRY_ER",
	70:  "COUNTRY_ES",
	71:  "COUNTRY_ET",
	72:  "COUNTRY_FI",
	73:  "COUNTRY_FJ",
	74:  "COUNTRY_FK",
	75:  "COUNTRY_FM",
	76:  "COUNTRY_FO",
	77:  "COUNTRY_FR",
	78:  "COUNTRY_GA",
	79:  "COUNTRY_GB",
	80:  "COUNTRY_GD",
	81:  "COUNTRY_GE",
	82:  "COUNTRY_GF",
	83:  "COUNTRY_GG",
	84:  "COUNTRY_GH",
	85:  "COUNTRY_GI",
	86:  "COUNTRY_GL",
	87:  "COUNTRY_GM",
	88:  "COUNTRY_GN",
	89:  "COUNTRY_GP",
	90:  "COUNTRY_GQ",
	91:  "COUNTRY_GR",
	92:  "COUNTRY_GS",
	93:  "COUNTRY_GT",
	94:  "COUNTRY_GU",
	95:  "COUNTRY_GW",
	96:  "COUNTRY_GY",
	97:  "COUNTRY_HK",
	98:  "COUNTRY_HM",
	99:  "COUNTRY_HN",
	100: "COUNTRY_HR",
	101: "COUNTRY_HT",
	102: "COUNTRY_HU",
	103: "COUNTRY_ID",
	104: "COUNTRY_IE",
	105: "COUNTRY_IL",
	106: "COUNTRY_IM",
	107: "COUNTRY_IN",
	108: "COUNTRY_IO",
	109: "COUNTRY_IQ",
	110: "COUNTRY_IR",
	111: "COUNTRY_IS",
	112: "COUNTRY_IT",
	113: "COUNTRY_JE",
	114: "COUNTRY_JM",
	115: "COUNTRY_JO",
	116: "COUNTRY_JP",
	117: "COUNTRY_KE",
	118: "COUNTRY_KG",
	119: "COUNTRY_KH",
	120: "COUNTRY_KI",
	121: "COUNTRY_KM",
	122: "COUNTRY_KN",
	123: "COUNTRY_KP",
	124: "COUNTRY_KR",
	125: "COUNTRY_KW",
	126: "COUNTRY_KY",
	127: "COUNTRY_KZ",
	128: "COUNTRY_LA",
	129: "COUNTRY_LB",
	130: "COUNTRY_LC",
	131: "COUNTRY_LI",
	132: "COUNTRY_LK",
	133: "COUNTRY_LR",
	134: "COUNTRY_LS",
	135: "COUNTRY_LT",
	136: "COUNTRY_LU",
	137: "COUNTRY_LV",
	138: "COUNTRY_LY",
	139: "COUNTRY_MA",
	140: "COUNTRY_MC",
	141: "COUNTRY_MD",
	142: "COUNTRY_ME",
	143: "COUNTRY_MF",
	144: "COUNTRY_MG",
	145: "COUNTRY_MH",
	146: "COUNTRY_MK",
	147: "COUNTRY_ML",
	148: "COUNTRY_MM",
	149: "COUNTRY_MN",
	150: "COUNTRY_MO",
	151: "COUNTRY_MP",
	152: "COUNTRY_MQ",
	153: "COUNTRY_MR",
	154: "COUNTRY_MS",
	155: "COUNTRY_MT",
	156: "COUNTRY_MU",
	157: "COUNTRY_MV",
	158: "COUNTRY_MW",
	159: "COUNTRY_MX",
	160: "COUNTRY_MY",
	161: "COUNTRY_MZ",
	162: "COUNTRY_NA",
	163: "COUNTRY_NC",
	164: "COUNTRY_NE",
	165: "COUNTRY_NF",
	166: "COUNTRY_NG",
	167: "COUNTRY_NI",
	168: "COUNTRY_NL",
	169: "COUNTRY_NO",
	170: "COUNTRY_NP",
	171: "COUNTRY_NR",
	172: "COUNTRY_NU",
	173: "COUNTRY_NZ",
	174: "COUNTRY_OM",
	175: "COUNTRY_PA",
	176: "COUNTRY_PE",
	177: "COUNTRY_PF",
	178: "COUNTRY_PG",
	179: "COUNTRY_PH",
	180: "COUNTRY_PK",
	181: "COUNTRY_PL",
	182: "COUNTRY_PM",
	183: "COUNTRY_PN",
	184: "COUNTRY_PR",
	185: "COUNTRY_PS",
	186: "COUNTRY_PT",
	187: "COUNTRY_PW",
	188: "COUNTRY_PY",
	189: "COUNTRY_QA",
	190: "COUNTRY_RE",
	191: "COUNTRY_RO",
	192: "COUNTRY_RS",
	193: "COUNTRY_RU",
	194: "COUNTRY_RW",
	195: "COUNTRY_SA",
	196: "COUNTRY_SB",
	197: "COUNTRY_SC",
	198: "COUNTRY_SD",
	199: "COUNTRY_SE",
	200: "COUNTRY_SG",
	201: "COUNTRY_SH",
	202: "COUNTRY_SI",
	203: "COUNTRY_SJ",
	204: "COUNTRY_SK",
	205: "COUNTRY_SL",
	206: "COUNTRY_SM",
	207: "COUNTRY_SN",
	208: "COUNTRY_SO",
	209: "COUNTRY_SR",
	210: "COUNTRY_SS",
	211: "COUNTRY_ST",
	212: "COUNTRY_SV",
	213: "COUNTRY_SX",
	214: "COUNTRY_SY",
	215: "COUNTRY_SZ",
	216: "COUNTRY_TC",
	217: "COUNTRY_TD",
	218: "COUNTRY_TF",
	219: "COUNTRY_TG",
	220: "COUNTRY_TH",
	221: "COUNTRY_TJ",
	222: "COUNTRY_TK",
	223: "COUNTRY_TL",
	224: "COUNTRY_TM",
	225: "COUNTRY_TN",
	226: "COUNTRY_TO",
	227: "COUNTRY_TR",
	228: "COUNTRY_TT",
	229: "COUNTRY_TV",
	230: "COUNTRY_TW",
	231: "COUNTRY_TZ",
	232: "COUNTRY_UA",
	233: "COUNTRY_UG",
	234: "COUNTRY_UM",
	235: "COUNTRY_US",
	236: "COUNTRY_UY",
	237: "COUNTRY_UZ",
	238: "COUNTRY_VA",
	239: "COUNTRY_VC",
	240: "COUNTRY_VE",
	241: "COUNTRY_VG",
	242: "COUNTRY_VI",
	243: "COUNTRY_VN",
	244: "COUNTRY_VU",
	245: "COUNTRY_WF",
	246: "COUNTRY_WS",
	247: "COUNTRY_XK",
	248: "COUNTRY_XT",
	249: "COUNTRY_YE",
	250: "COUNTRY_YT",
	251: "COUNTRY_ZA",
	252: "COUNTRY_ZM",
	253: "COUNTRY_ZW",
}

var CountryCode_value = map[string]int32{
	"COUNTRY_NONE": 0,
	"COUNTRY_AD":   1,
	"COUNTRY_AE":   2,
	"COUNTRY_AF":   3,
	"COUNTRY_AG":   4,
	"COUNTRY_AI":   5,
	"COUNTRY_AL":   6,
	"COUNTRY_AM":   7,
	"COUNTRY_AN":   8,
	"COUNTRY_AO":   9,
	"COUNTRY_AQ":   10,
	"COUNTRY_AR":   11,
	"COUNTRY_AS":   12,
	"COUNTRY_AT":   13,
	"COUNTRY_AU":   14,
	"COUNTRY_AW":   15,
	"COUNTRY_AX":   16,
	"COUNTRY_AZ":   17,
	"COUNTRY_BA":   18,
	"COUNTRY_BB":   19,
	"COUNTRY_BD":   20,
	"COUNTRY_BE":   21,
	"COUNTRY_BF":   22,
	"COUNTRY_BG":   23,
	"COUNTRY_BH":   24,
	"COUNTRY_BI":   25,
	"COUNTRY_BJ":   26,
	"COUNTRY_BL":   27,
	"COUNTRY_BM":   28,
	"COUNTRY_BN":   29,
	"COUNTRY_BO":   30,
	"COUNTRY_BQ":   31,
	"COUNTRY_BR":   32,
	"COUNTRY_BS":   33,
	"COUNTRY_BT":   34,
	"COUNTRY_BV":   35,
	"COUNTRY_BW":   36,
	"COUNTRY_BY":   37,
	"COUNTRY_BZ":   38,
	"COUNTRY_CA":   39,
	"COUNTRY_CC":   40,
	"COUNTRY_CD":   41,
	"COUNTRY_CF":   42,
	"COUNTRY_CG":   43,
	"COUNTRY_CH":   44,
	"COUNTRY_CI":   45,
	"COUNTRY_CK":   46,
	"COUNTRY_CL":   47,
	"COUNTRY_CM":   48,
	"COUNTRY_CN":   49,
	"COUNTRY_CO":   50,
	"COUNTRY_CR":   51,
	"COUNTRY_CS":   52,
	"COUNTRY_CU":   53,
	"COUNTRY_CV":   54,
	"COUNTRY_CW":   55,
	"COUNTRY_CX":   56,
	"COUNTRY_CY":   57,
	"COUNTRY_CZ":   58,
	"COUNTRY_DE":   59,
	"COUNTRY_DJ":   60,
	"COUNTRY_DK":   61,
	"COUNTRY_DM":   62,
	"COUNTRY_DO":   63,
	"COUNTRY_DZ":   64,
	"COUNTRY_EC":   65,
	"COUNTRY_EE":   66,
	"COUNTRY_EG":   67,
	"COUNTRY_EH":   68,
	"COUNTRY_ER":   69,
	"COUNTRY_ES":   70,
	"COUNTRY_ET":   71,
	"COUNTRY_FI":   72,
	"COUNTRY_FJ":   73,
	"COUNTRY_FK":   74,
	"COUNTRY_FM":   75,
	"COUNTRY_FO":   76,
	"COUNTRY_FR":   77,
	"COUNTRY_GA":   78,
	"COUNTRY_GB":   79,
	"COUNTRY_GD":   80,
	"COUNTRY_GE":   81,
	"COUNTRY_GF":   82,
	"COUNTRY_GG":   83,
	"COUNTRY_GH":   84,
	"COUNTRY_GI":   85,
	"COUNTRY_GL":   86,
	"COUNTRY_GM":   87,
	"COUNTRY_GN":   88,
	"COUNTRY_GP":   89,
	"COUNTRY_GQ":   90,
	"COUNTRY_GR":   91,
	"COUNTRY_GS":   92,
	"COUNTRY_GT":   93,
	"COUNTRY_GU":   94,
	"COUNTRY_GW":   95,
	"COUNTRY_GY":   96,
	"COUNTRY_HK":   97,
	"COUNTRY_HM":   98,
	"COUNTRY_HN":   99,
	"COUNTRY_HR":   100,
	"COUNTRY_HT":   101,
	"COUNTRY_HU":   102,
	"COUNTRY_ID":   103,
	"COUNTRY_IE":   104,
	"COUNTRY_IL":   105,
	"COUNTRY_IM":   106,
	"COUNTRY_IN":   107,
	"COUNTRY_IO":   108,
	"COUNTRY_IQ":   109,
	"COUNTRY_IR":   110,
	"COUNTRY_IS":   111,
	"COUNTRY_IT":   112,
	"COUNTRY_JE":   113,
	"COUNTRY_JM":   114,
	"COUNTRY_JO":   115,
	"COUNTRY_JP":   116,
	"COUNTRY_KE":   117,
	"COUNTRY_KG":   118,
	"COUNTRY_KH":   119,
	"COUNTRY_KI":   120,
	"COUNTRY_KM":   121,
	"COUNTRY_KN":   122,
	"COUNTRY_KP":   123,
	"COUNTRY_KR":   124,
	"COUNTRY_KW":   125,
	"COUNTRY_KY":   126,
	"COUNTRY_KZ":   127,
	"COUNTRY_LA":   128,
	"COUNTRY_LB":   129,
	"COUNTRY_LC":   130,
	"COUNTRY_LI":   131,
	"COUNTRY_LK":   132,
	"COUNTRY_LR":   133,
	"COUNTRY_LS":   134,
	"COUNTRY_LT":   135,
	"COUNTRY_LU":   136,
	"COUNTRY_LV":   137,
	"COUNTRY_LY":   138,
	"COUNTRY_MA":   139,
	"COUNTRY_MC":   140,
	"COUNTRY_MD":   141,
	"COUNTRY_ME":   142,
	"COUNTRY_MF":   143,
	"COUNTRY_MG":   144,
	"COUNTRY_MH":   145,
	"COUNTRY_MK":   146,
	"COUNTRY_ML":   147,
	"COUNTRY_MM":   148,
	"COUNTRY_MN":   149,
	"COUNTRY_MO":   150,
	"COUNTRY_MP":   151,
	"COUNTRY_MQ":   152,
	"COUNTRY_MR":   153,
	"COUNTRY_MS":   154,
	"COUNTRY_MT":   155,
	"COUNTRY_MU":   156,
	"COUNTRY_MV":   157,
	"COUNTRY_MW":   158,
	"COUNTRY_MX":   159,
	"COUNTRY_MY":   160,
	"COUNTRY_MZ":   161,
	"COUNTRY_NA":   162,
	"COUNTRY_NC":   163,
	"COUNTRY_NE":   164,
	"COUNTRY_NF":   165,
	"COUNTRY_NG":   166,
	"COUNTRY_NI":   167,
	"COUNTRY_NL":   168,
	"COUNTRY_NO":   169,
	"COUNTRY_NP":   170,
	"COUNTRY_NR":   171,
	"COUNTRY_NU":   172,
	"COUNTRY_NZ":   173,
	"COUNTRY_OM":   174,
	"COUNTRY_PA":   175,
	"COUNTRY_PE":   176,
	"COUNTRY_PF":   177,
	"COUNTRY_PG":   178,
	"COUNTRY_PH":   179,
	"COUNTRY_PK":   180,
	"COUNTRY_PL":   181,
	"COUNTRY_PM":   182,
	"COUNTRY_PN":   183,
	"COUNTRY_PR":   184,
	"COUNTRY_PS":   185,
	"COUNTRY_PT":   186,
	"COUNTRY_PW":   187,
	"COUNTRY_PY":   188,
	"COUNTRY_QA":   189,
	"COUNTRY_RE":   190,
	"COUNTRY_RO":   191,
	"COUNTRY_RS":   192,
	"COUNTRY_RU":   193,
	"COUNTRY_RW":   194,
	"COUNTRY_SA":   195,
	"COUNTRY_SB":   196,
	"COUNTRY_SC":   197,
	"COUNTRY_SD":   198,
	"COUNTRY_SE":   199,
	"COUNTRY_SG":   200,
	"COUNTRY_SH":   201,
	"COUNTRY_SI":   202,
	"COUNTRY_SJ":   203,
	"COUNTRY_SK":   204,
	"COUNTRY_SL":   205,
	"COUNTRY_SM":   206,
	"COUNTRY_SN":   207,
	"COUNTRY_SO":   208,
	"COUNTRY_SR":   209,
	"COUNTRY_SS":   210,
	"COUNTRY_ST":   211,
	"COUNTRY_SV":   212,
	"COUNTRY_SX":   213,
	"COUNTRY_SY":   214,
	"COUNTRY_SZ":   215,
	"COUNTRY_TC":   216,
	"COUNTRY_TD":   217,
	"COUNTRY_TF":   218,
	"COUNTRY_TG":   219,
	"COUNTRY_TH":   220,
	"COUNTRY_TJ":   221,
	"COUNTRY_TK":   222,
	"COUNTRY_TL":   223,
	"COUNTRY_TM":   224,
	"COUNTRY_TN":   225,
	"COUNTRY_TO":   226,
	"COUNTRY_TR":   227,
	"COUNTRY_TT":   228,
	"COUNTRY_TV":   229,
	"COUNTRY_TW":   230,
	"COUNTRY_TZ":   231,
	"COUNTRY_UA":   232,
	"COUNTRY_UG":   233,
	"COUNTRY_UM":   234,
	"COUNTRY_US":   235,
	"COUNTRY_UY":   236,
	"COUNTRY_UZ":   237,
	"COUNTRY_VA":   238,
	"COUNTRY_VC":   239,
	"COUNTRY_VE":   240,
	"COUNTRY_VG":   241,
	"COUNTRY_VI":   242,
	"COUNTRY_VN":   243,
	"COUNTRY_VU":   244,
	"COUNTRY_WF":   245,
	"COUNTRY_WS":   246,
	"COUNTRY_XK":   247,
	"COUNTRY_XT":   248,
	"COUNTRY_YE":   249,
	"COUNTRY_YT":   250,
	"COUNTRY_ZA":   251,
	"COUNTRY_ZM":   252,
	"COUNTRY_ZW":   253,
}

func (CountryCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{7}
}

// Rule Action
//
// x-displayName: "Rule Action"
// The rule action determines the disposition of the input request API. If a policy matches a rule with an ALLOW action, the processing of the request proceeds
// forward. If it matches a rule with a DENY action, the processing of the request is terminated and an appropriate message/code returned to the originator. If
// it matches a rule with a NEXT_POLICY_SET action, evaluation of the current policy set terminates and evaluation of the next policy set in the chain begins.
type RuleAction int32

const (
	// DENY
	//
	// x-displayName: "Deny"
	// Deny the request.
	DENY RuleAction = 0
	// ALLOW
	//
	// x-displayName: "Allow"
	// Allow the request to proceed.
	ALLOW RuleAction = 1
	// NEXT_POLICY_SET
	//
	// x-displayName: "Next Policy Set"
	// Terminate evaluation of the current policy set and begin evaluating the next policy set in the chain. Note that the evaluation of any remaining policies
	// in the current policy set is skipped.
	NEXT_POLICY_SET RuleAction = 2
	// NEXT_POLICY
	//
	// x-displayName: "Next Policy"
	// Terminate evaluation of the current policy and begin evaluating the next policy in the policy set. Note that the evaluation of any remaining rules in the
	// current policy is skipped.
	NEXT_POLICY RuleAction = 3
	// LAST_POLICY
	//
	// x-displayName: "Last Policy"
	// Terminate evaluation of the current policy and begin evaluating the last policy in the policy set. Note that the evaluation of any remaining rules in the
	// current policy is skipped.
	LAST_POLICY RuleAction = 4
	// GOTO_POLICY
	//
	// x-displayName: "Goto Policy"
	// Terminate evaluation of the current policy and begin evaluating a specific policy in the policy set. The policy is specified using the goto_policy field in
	// the rule and must be after the current policy in the policy set.
	GOTO_POLICY RuleAction = 5
)

var RuleAction_name = map[int32]string{
	0: "DENY",
	1: "ALLOW",
	2: "NEXT_POLICY_SET",
	3: "NEXT_POLICY",
	4: "LAST_POLICY",
	5: "GOTO_POLICY",
}

var RuleAction_value = map[string]int32{
	"DENY":            0,
	"ALLOW":           1,
	"NEXT_POLICY_SET": 2,
	"NEXT_POLICY":     3,
	"LAST_POLICY":     4,
	"GOTO_POLICY":     5,
}

func (RuleAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{8}
}

// Challenge Action
//
// x-displayName: "Challenge Action"
// The challenge options to use when a policy based challenge is configured.
type ChallengeAction int32

const (
	// DEFAULT_CHALLENGE
	//
	// x-displayName: "Default Challenge"
	// Default challenge.
	DEFAULT_CHALLENGE ChallengeAction = 0
	// ENABLE_JAVASCRIPT_CHALLENGE
	//
	// x-displayName: "Enable Javascript Challenge"
	// Enable javascript challenge.
	ENABLE_JAVASCRIPT_CHALLENGE ChallengeAction = 1
	// ENABLE_CAPTCHA_CHALLENGE
	//
	// x-displayName: "Enable Captcha Challenge"
	// Captcha challenge.
	ENABLE_CAPTCHA_CHALLENGE ChallengeAction = 2
	// DISABLE_CHALLENGE
	//
	// x-displayName: "Disable Challenge"
	// Disable challenge
	DISABLE_CHALLENGE ChallengeAction = 3
	// TEMPORARY_BLOCKING
	//
	// x-displayName: "Block Temporarily"
	// Block the user temporarily.
	TEMPORARY_BLOCKING ChallengeAction = 4
)

var ChallengeAction_name = map[int32]string{
	0: "DEFAULT_CHALLENGE",
	1: "ENABLE_JAVASCRIPT_CHALLENGE",
	2: "ENABLE_CAPTCHA_CHALLENGE",
	3: "DISABLE_CHALLENGE",
	4: "TEMPORARY_BLOCKING",
}

var ChallengeAction_value = map[string]int32{
	"DEFAULT_CHALLENGE":           0,
	"ENABLE_JAVASCRIPT_CHALLENGE": 1,
	"ENABLE_CAPTCHA_CHALLENGE":    2,
	"DISABLE_CHALLENGE":           3,
	"TEMPORARY_BLOCKING":          4,
}

func (ChallengeAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{9}
}

// AppTrafficType
//
// x-displayName: "App Traffic type"
// Application traffic type
type AppTrafficType int32

const (
	// WebTrafficType
	//
	// x-displayName: "Web Traffic"
	// Web application traffic type.
	WEB AppTrafficType = 0
	// MobileTrafficType
	//
	// x-displayName: "Mobile Traffic"
	// Mobile application traffic type.
	MOBILE AppTrafficType = 1
)

var AppTrafficType_name = map[int32]string{
	0: "WEB",
	1: "MOBILE",
}

var AppTrafficType_value = map[string]int32{
	"WEB":    0,
	"MOBILE": 1,
}

func (AppTrafficType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{10}
}

// HTMLPosition
//
// x-displayName: "HTML Position"
// Position of the HTML tag to insert in HTML document
type HTMLPosition int32

const (
	// x-displayName: "Beginning of HTML tag"
	// Beginning of HTML tag.
	BEGINNING HTMLPosition = 0
	// x-displayName: "End of HTML tag"
	// End of HTML tag.
	END HTMLPosition = 1
	// x-displayName: "Before HTML tag"
	// Before HTML tag.
	BEFORE HTMLPosition = 2
	// x-displayName: "After HTML tag"
	// After HTML tag.
	AFTER HTMLPosition = 3
)

var HTMLPosition_name = map[int32]string{
	0: "BEGINNING",
	1: "END",
	2: "BEFORE",
	3: "AFTER",
}

var HTMLPosition_value = map[string]int32{
	"BEGINNING": 0,
	"END":       1,
	"BEFORE":    2,
	"AFTER":     3,
}

func (HTMLPosition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{11}
}

// App Firewall Rule Control
//
// x-displayName: "App Firewall Rule Control"
// App Firewall rule changes to be applied for this request
type WafRuleControl struct {
	// Exclude Rule IDs
	//
	// x-displayName: "Exclude App Firewall Rule List"
	// App Firewall Rule List specifying the rule IDs to be excluded for this request
	ExcludeRuleIds []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=exclude_rule_ids,json=excludeRuleIds,proto3" json:"exclude_rule_ids,omitempty"`
	// Set App Firewall in Monitoring Mode
	//
	// x-displayName: "Set App Firewall in Monitoring Mode"
	// App Firewall will run in monitoring mode without blocking the request
	MonitoringMode bool `protobuf:"varint,2,opt,name=monitoring_mode,json=monitoringMode,proto3" json:"monitoring_mode,omitempty"`
}

func (m *WafRuleControl) Reset()      { *m = WafRuleControl{} }
func (*WafRuleControl) ProtoMessage() {}
func (*WafRuleControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{0}
}
func (m *WafRuleControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WafRuleControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WafRuleControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WafRuleControl.Merge(m, src)
}
func (m *WafRuleControl) XXX_Size() int {
	return m.Size()
}
func (m *WafRuleControl) XXX_DiscardUnknown() {
	xxx_messageInfo_WafRuleControl.DiscardUnknown(m)
}

var xxx_messageInfo_WafRuleControl proto.InternalMessageInfo

func (m *WafRuleControl) GetExcludeRuleIds() []*schema.ObjectRefType {
	if m != nil {
		return m.ExcludeRuleIds
	}
	return nil
}

func (m *WafRuleControl) GetMonitoringMode() bool {
	if m != nil {
		return m.MonitoringMode
	}
	return false
}

// App Firewall Violation Context
//
// x-displayName: "App Firewall Violation Context"
// App Firewall violation context changes to be applied for this request
type AppFirewallViolationContext struct {
	// ViolationType
	//
	// x-displayName: "Violation Type"
	// x-example: "VIOL_MANDATORY_HEADER"
	// x-required
	ExcludeViolation app_firewall.AppFirewallViolationType `protobuf:"varint,1,opt,name=exclude_violation,json=excludeViolation,proto3,enum=ves.io.schema.app_firewall.AppFirewallViolationType" json:"exclude_violation,omitempty"`
}

func (m *AppFirewallViolationContext) Reset()      { *m = AppFirewallViolationContext{} }
func (*AppFirewallViolationContext) ProtoMessage() {}
func (*AppFirewallViolationContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{1}
}
func (m *AppFirewallViolationContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppFirewallViolationContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AppFirewallViolationContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppFirewallViolationContext.Merge(m, src)
}
func (m *AppFirewallViolationContext) XXX_Size() int {
	return m.Size()
}
func (m *AppFirewallViolationContext) XXX_DiscardUnknown() {
	xxx_messageInfo_AppFirewallViolationContext.DiscardUnknown(m)
}

var xxx_messageInfo_AppFirewallViolationContext proto.InternalMessageInfo

func (m *AppFirewallViolationContext) GetExcludeViolation() app_firewall.AppFirewallViolationType {
	if m != nil {
		return m.ExcludeViolation
	}
	return app_firewall.VIOL_NONE
}

// App Firewall Signature Context
//
// x-displayName: "App Firewall Signature Context"
// App Firewall signature context changes to be applied for this request
type AppFirewallSignatureContext struct {
	// SignatureID
	//
	// x-displayName: "SignatureID"
	// x-example: "10000001"
	// x-required
	SignatureId uint32 `protobuf:"varint,1,opt,name=signature_id,json=signatureId,proto3" json:"signature_id,omitempty"`
}

func (m *AppFirewallSignatureContext) Reset()      { *m = AppFirewallSignatureContext{} }
func (*AppFirewallSignatureContext) ProtoMessage() {}
func (*AppFirewallSignatureContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{2}
}
func (m *AppFirewallSignatureContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppFirewallSignatureContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AppFirewallSignatureContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppFirewallSignatureContext.Merge(m, src)
}
func (m *AppFirewallSignatureContext) XXX_Size() int {
	return m.Size()
}
func (m *AppFirewallSignatureContext) XXX_DiscardUnknown() {
	xxx_messageInfo_AppFirewallSignatureContext.DiscardUnknown(m)
}

var xxx_messageInfo_AppFirewallSignatureContext proto.InternalMessageInfo

func (m *AppFirewallSignatureContext) GetSignatureId() uint32 {
	if m != nil {
		return m.SignatureId
	}
	return 0
}

// App Firewall Attack Type Context
//
// x-displayName: "App Firewall Attack Type Context"
// App Firewall Attack Type context changes to be applied for this request
type AppFirewallAttackTypeContext struct {
	// AttackType
	//
	// x-displayName: "Attack Type"
	// x-example: "ATTACK_TYPE_SQL_INJECTION"
	// x-required
	ExcludeAttackType app_firewall.AttackType `protobuf:"varint,1,opt,name=exclude_attack_type,json=excludeAttackType,proto3,enum=ves.io.schema.app_firewall.AttackType" json:"exclude_attack_type,omitempty"`
}

func (m *AppFirewallAttackTypeContext) Reset()      { *m = AppFirewallAttackTypeContext{} }
func (*AppFirewallAttackTypeContext) ProtoMessage() {}
func (*AppFirewallAttackTypeContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{3}
}
func (m *AppFirewallAttackTypeContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppFirewallAttackTypeContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AppFirewallAttackTypeContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppFirewallAttackTypeContext.Merge(m, src)
}
func (m *AppFirewallAttackTypeContext) XXX_Size() int {
	return m.Size()
}
func (m *AppFirewallAttackTypeContext) XXX_DiscardUnknown() {
	xxx_messageInfo_AppFirewallAttackTypeContext.DiscardUnknown(m)
}

var xxx_messageInfo_AppFirewallAttackTypeContext proto.InternalMessageInfo

func (m *AppFirewallAttackTypeContext) GetExcludeAttackType() app_firewall.AttackType {
	if m != nil {
		return m.ExcludeAttackType
	}
	return app_firewall.ATTACK_TYPE_NONE
}

// Bot Name Context
//
// x-displayName: "Bot Name"
// Specifies bot to be excluded by its name.
type BotNameContext struct {
	// BotName
	//
	// x-displayName: "Bot Name"
	// x-required
	// x-example: "Hydra"
	BotName string `protobuf:"bytes,1,opt,name=bot_name,json=botName,proto3" json:"bot_name,omitempty"`
}

func (m *BotNameContext) Reset()      { *m = BotNameContext{} }
func (*BotNameContext) ProtoMessage() {}
func (*BotNameContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{4}
}
func (m *BotNameContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotNameContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotNameContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotNameContext.Merge(m, src)
}
func (m *BotNameContext) XXX_Size() int {
	return m.Size()
}
func (m *BotNameContext) XXX_DiscardUnknown() {
	xxx_messageInfo_BotNameContext.DiscardUnknown(m)
}

var xxx_messageInfo_BotNameContext proto.InternalMessageInfo

func (m *BotNameContext) GetBotName() string {
	if m != nil {
		return m.BotName
	}
	return ""
}

// App Firewall Detection Control
//
// x-displayName: "App Firewall Detection Control"
// Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.
type AppFirewallDetectionControl struct {
	// Exclude Signature Contexts
	//
	// x-displayName: "Exclude App Firewall Signature Contexts"
	// App Firewall signature contexts to be excluded for this request
	ExcludeSignatureContexts []*AppFirewallSignatureContext `protobuf:"bytes,1,rep,name=exclude_signature_contexts,json=excludeSignatureContexts,proto3" json:"exclude_signature_contexts,omitempty"`
	// Exclude Violation Contexts
	//
	// x-displayName: "Exclude App Firewall Violation Contexts"
	// App Firewall violation contexts to be excluded for this request
	ExcludeViolationContexts []*AppFirewallViolationContext `protobuf:"bytes,2,rep,name=exclude_violation_contexts,json=excludeViolationContexts,proto3" json:"exclude_violation_contexts,omitempty"`
	// Exclude Attack Types Contexts
	//
	// x-displayName: "Exclude App Firewall Attack Types Contexts"
	// App Firewall attack types contexts to be excluded for this request
	ExcludeAttackTypeContexts []*AppFirewallAttackTypeContext `protobuf:"bytes,3,rep,name=exclude_attack_type_contexts,json=excludeAttackTypeContexts,proto3" json:"exclude_attack_type_contexts,omitempty"`
	// Exclude Bot Names Contexts
	//
	// x-displayName: "Exclude Bot Names Contexts"
	// Bot names contexts to be excluded for this request
	ExcludeBotNameContexts []*BotNameContext `protobuf:"bytes,4,rep,name=exclude_bot_name_contexts,json=excludeBotNameContexts,proto3" json:"exclude_bot_name_contexts,omitempty"`
}

func (m *AppFirewallDetectionControl) Reset()      { *m = AppFirewallDetectionControl{} }
func (*AppFirewallDetectionControl) ProtoMessage() {}
func (*AppFirewallDetectionControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{5}
}
func (m *AppFirewallDetectionControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppFirewallDetectionControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AppFirewallDetectionControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppFirewallDetectionControl.Merge(m, src)
}
func (m *AppFirewallDetectionControl) XXX_Size() int {
	return m.Size()
}
func (m *AppFirewallDetectionControl) XXX_DiscardUnknown() {
	xxx_messageInfo_AppFirewallDetectionControl.DiscardUnknown(m)
}

var xxx_messageInfo_AppFirewallDetectionControl proto.InternalMessageInfo

func (m *AppFirewallDetectionControl) GetExcludeSignatureContexts() []*AppFirewallSignatureContext {
	if m != nil {
		return m.ExcludeSignatureContexts
	}
	return nil
}

func (m *AppFirewallDetectionControl) GetExcludeViolationContexts() []*AppFirewallViolationContext {
	if m != nil {
		return m.ExcludeViolationContexts
	}
	return nil
}

func (m *AppFirewallDetectionControl) GetExcludeAttackTypeContexts() []*AppFirewallAttackTypeContext {
	if m != nil {
		return m.ExcludeAttackTypeContexts
	}
	return nil
}

func (m *AppFirewallDetectionControl) GetExcludeBotNameContexts() []*BotNameContext {
	if m != nil {
		return m.ExcludeBotNameContexts
	}
	return nil
}

// Data Guard Control
//
// x-displayName: "Data Guard Control"
// Data Guard changes to be applied for this request
type DataGuardControl struct {
	// Set BD Policy name
	//
	// x-displayName: "Policy Name"
	// x-example: "value"
	// Sets the BD Policy to use
	PolicyName string `protobuf:"bytes,1,opt,name=policy_name,json=policyName,proto3" json:"policy_name,omitempty"`
}

func (m *DataGuardControl) Reset()      { *m = DataGuardControl{} }
func (*DataGuardControl) ProtoMessage() {}
func (*DataGuardControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{6}
}
func (m *DataGuardControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataGuardControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataGuardControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataGuardControl.Merge(m, src)
}
func (m *DataGuardControl) XXX_Size() int {
	return m.Size()
}
func (m *DataGuardControl) XXX_DiscardUnknown() {
	xxx_messageInfo_DataGuardControl.DiscardUnknown(m)
}

var xxx_messageInfo_DataGuardControl proto.InternalMessageInfo

func (m *DataGuardControl) GetPolicyName() string {
	if m != nil {
		return m.PolicyName
	}
	return ""
}

// App Firewall Rule Control with inline Rule IDs
//
// x-displayName: "App Firewall Rule Control with inline Rule IDs"
// App Firewall rule changes to be applied for this request
type WafInlineRuleControl struct {
	// Exclude Rule IDs
	//
	// x-displayName: "Exclude App Firewall Rule IDs"
	// App Firewall Rule IDs to be excluded for this request
	ExcludeRuleIds []waf_rule_list.WafRuleID `protobuf:"varint,1,rep,packed,name=exclude_rule_ids,json=excludeRuleIds,proto3,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"exclude_rule_ids,omitempty"`
	// Set App Firewall in Monitoring Mode
	//
	// x-displayName: "Set App Firewall in Monitoring Mode"
	// App Firewall will run in monitoring mode without blocking the request
	MonitoringMode bool `protobuf:"varint,2,opt,name=monitoring_mode,json=monitoringMode,proto3" json:"monitoring_mode,omitempty"`
}

func (m *WafInlineRuleControl) Reset()      { *m = WafInlineRuleControl{} }
func (*WafInlineRuleControl) ProtoMessage() {}
func (*WafInlineRuleControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{7}
}
func (m *WafInlineRuleControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WafInlineRuleControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WafInlineRuleControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WafInlineRuleControl.Merge(m, src)
}
func (m *WafInlineRuleControl) XXX_Size() int {
	return m.Size()
}
func (m *WafInlineRuleControl) XXX_DiscardUnknown() {
	xxx_messageInfo_WafInlineRuleControl.DiscardUnknown(m)
}

var xxx_messageInfo_WafInlineRuleControl proto.InternalMessageInfo

func (m *WafInlineRuleControl) GetExcludeRuleIds() []waf_rule_list.WafRuleID {
	if m != nil {
		return m.ExcludeRuleIds
	}
	return nil
}

func (m *WafInlineRuleControl) GetMonitoringMode() bool {
	if m != nil {
		return m.MonitoringMode
	}
	return false
}

// Bot Action
//
// x-displayName: "Bot Action"
// Modify Bot protection behavior for a matching request. The modification could be to entirely skip Bot processing.
type BotAction struct {
	// Select Bot Action Type
	//
	// x-displayName: "Select Bot Action Type"
	// x-required
	//
	// Types that are valid to be assigned to ActionType:
	//	*BotAction_None
	//	*BotAction_BotSkipProcessing
	ActionType isBotAction_ActionType `protobuf_oneof:"action_type"`
}

func (m *BotAction) Reset()      { *m = BotAction{} }
func (*BotAction) ProtoMessage() {}
func (*BotAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{8}
}
func (m *BotAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotAction.Merge(m, src)
}
func (m *BotAction) XXX_Size() int {
	return m.Size()
}
func (m *BotAction) XXX_DiscardUnknown() {
	xxx_messageInfo_BotAction.DiscardUnknown(m)
}

var xxx_messageInfo_BotAction proto.InternalMessageInfo

type isBotAction_ActionType interface {
	isBotAction_ActionType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type BotAction_None struct {
	None *schema.Empty `protobuf:"bytes,2,opt,name=none,proto3,oneof" json:"none,omitempty"`
}
type BotAction_BotSkipProcessing struct {
	BotSkipProcessing *schema.Empty `protobuf:"bytes,3,opt,name=bot_skip_processing,json=botSkipProcessing,proto3,oneof" json:"bot_skip_processing,omitempty"`
}

func (*BotAction_None) isBotAction_ActionType()              {}
func (*BotAction_BotSkipProcessing) isBotAction_ActionType() {}

func (m *BotAction) GetActionType() isBotAction_ActionType {
	if m != nil {
		return m.ActionType
	}
	return nil
}

func (m *BotAction) GetNone() *schema.Empty {
	if x, ok := m.GetActionType().(*BotAction_None); ok {
		return x.None
	}
	return nil
}

func (m *BotAction) GetBotSkipProcessing() *schema.Empty {
	if x, ok := m.GetActionType().(*BotAction_BotSkipProcessing); ok {
		return x.BotSkipProcessing
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BotAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BotAction_None)(nil),
		(*BotAction_BotSkipProcessing)(nil),
	}
}

// Select Modification Action
//
// x-displayName: "Select Modification Action"
// Modify behavior for a matching request. The modification could be to entirely skip processing.
type ModifyAction struct {
	// Select Action Type
	//
	// x-displayName: "Select Action Type"
	// x-required
	// Select whether to modify the action for the matching request
	//
	// Types that are valid to be assigned to ActionType:
	//	*ModifyAction_Default
	//	*ModifyAction_SkipProcessing
	ActionType isModifyAction_ActionType `protobuf_oneof:"action_type"`
}

func (m *ModifyAction) Reset()      { *m = ModifyAction{} }
func (*ModifyAction) ProtoMessage() {}
func (*ModifyAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{9}
}
func (m *ModifyAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModifyAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyAction.Merge(m, src)
}
func (m *ModifyAction) XXX_Size() int {
	return m.Size()
}
func (m *ModifyAction) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyAction.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyAction proto.InternalMessageInfo

type isModifyAction_ActionType interface {
	isModifyAction_ActionType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ModifyAction_Default struct {
	Default *schema.Empty `protobuf:"bytes,2,opt,name=default,proto3,oneof" json:"default,omitempty"`
}
type ModifyAction_SkipProcessing struct {
	SkipProcessing *schema.Empty `protobuf:"bytes,3,opt,name=skip_processing,json=skipProcessing,proto3,oneof" json:"skip_processing,omitempty"`
}

func (*ModifyAction_Default) isModifyAction_ActionType()        {}
func (*ModifyAction_SkipProcessing) isModifyAction_ActionType() {}

func (m *ModifyAction) GetActionType() isModifyAction_ActionType {
	if m != nil {
		return m.ActionType
	}
	return nil
}

func (m *ModifyAction) GetDefault() *schema.Empty {
	if x, ok := m.GetActionType().(*ModifyAction_Default); ok {
		return x.Default
	}
	return nil
}

func (m *ModifyAction) GetSkipProcessing() *schema.Empty {
	if x, ok := m.GetActionType().(*ModifyAction_SkipProcessing); ok {
		return x.SkipProcessing
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ModifyAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ModifyAction_Default)(nil),
		(*ModifyAction_SkipProcessing)(nil),
	}
}

// App Firewall Action
//
// x-displayName: "App Firewall Action"
// Modify App Firewall behavior for a matching request. The modification could either be to entirely skip firewall processing or to customize the firewall rules
// to be applied as defined by App Firewall Rule Control settings.
type WafAction struct {
	// Select Waf Action Type
	//
	// x-displayName: "Select App Firewall Action Type"
	// x-required
	// Select application firewall Action, skip waf processing or skip rules
	//
	// Types that are valid to be assigned to ActionType:
	//	*WafAction_None
	//	*WafAction_WafSkipProcessing
	//	*WafAction_WafRuleControl
	//	*WafAction_WafInlineRuleControl
	//	*WafAction_WafInMonitoringMode
	//	*WafAction_AppFirewallDetectionControl
	//	*WafAction_DataGuardControl
	ActionType isWafAction_ActionType `protobuf_oneof:"action_type"`
}

func (m *WafAction) Reset()      { *m = WafAction{} }
func (*WafAction) ProtoMessage() {}
func (*WafAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{10}
}
func (m *WafAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WafAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WafAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WafAction.Merge(m, src)
}
func (m *WafAction) XXX_Size() int {
	return m.Size()
}
func (m *WafAction) XXX_DiscardUnknown() {
	xxx_messageInfo_WafAction.DiscardUnknown(m)
}

var xxx_messageInfo_WafAction proto.InternalMessageInfo

type isWafAction_ActionType interface {
	isWafAction_ActionType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WafAction_None struct {
	None *schema.Empty `protobuf:"bytes,3,opt,name=none,proto3,oneof" json:"none,omitempty"`
}
type WafAction_WafSkipProcessing struct {
	WafSkipProcessing *schema.Empty `protobuf:"bytes,1,opt,name=waf_skip_processing,json=wafSkipProcessing,proto3,oneof" json:"waf_skip_processing,omitempty"`
}
type WafAction_WafRuleControl struct {
	WafRuleControl *WafRuleControl `protobuf:"bytes,2,opt,name=waf_rule_control,json=wafRuleControl,proto3,oneof" json:"waf_rule_control,omitempty"`
}
type WafAction_WafInlineRuleControl struct {
	WafInlineRuleControl *WafInlineRuleControl `protobuf:"bytes,4,opt,name=waf_inline_rule_control,json=wafInlineRuleControl,proto3,oneof" json:"waf_inline_rule_control,omitempty"`
}
type WafAction_WafInMonitoringMode struct {
	WafInMonitoringMode *schema.Empty `protobuf:"bytes,6,opt,name=waf_in_monitoring_mode,json=wafInMonitoringMode,proto3,oneof" json:"waf_in_monitoring_mode,omitempty"`
}
type WafAction_AppFirewallDetectionControl struct {
	AppFirewallDetectionControl *AppFirewallDetectionControl `protobuf:"bytes,7,opt,name=app_firewall_detection_control,json=appFirewallDetectionControl,proto3,oneof" json:"app_firewall_detection_control,omitempty"`
}
type WafAction_DataGuardControl struct {
	DataGuardControl *DataGuardControl `protobuf:"bytes,8,opt,name=data_guard_control,json=dataGuardControl,proto3,oneof" json:"data_guard_control,omitempty"`
}

func (*WafAction_None) isWafAction_ActionType()                        {}
func (*WafAction_WafSkipProcessing) isWafAction_ActionType()           {}
func (*WafAction_WafRuleControl) isWafAction_ActionType()              {}
func (*WafAction_WafInlineRuleControl) isWafAction_ActionType()        {}
func (*WafAction_WafInMonitoringMode) isWafAction_ActionType()         {}
func (*WafAction_AppFirewallDetectionControl) isWafAction_ActionType() {}
func (*WafAction_DataGuardControl) isWafAction_ActionType()            {}

func (m *WafAction) GetActionType() isWafAction_ActionType {
	if m != nil {
		return m.ActionType
	}
	return nil
}

func (m *WafAction) GetNone() *schema.Empty {
	if x, ok := m.GetActionType().(*WafAction_None); ok {
		return x.None
	}
	return nil
}

func (m *WafAction) GetWafSkipProcessing() *schema.Empty {
	if x, ok := m.GetActionType().(*WafAction_WafSkipProcessing); ok {
		return x.WafSkipProcessing
	}
	return nil
}

func (m *WafAction) GetWafRuleControl() *WafRuleControl {
	if x, ok := m.GetActionType().(*WafAction_WafRuleControl); ok {
		return x.WafRuleControl
	}
	return nil
}

func (m *WafAction) GetWafInlineRuleControl() *WafInlineRuleControl {
	if x, ok := m.GetActionType().(*WafAction_WafInlineRuleControl); ok {
		return x.WafInlineRuleControl
	}
	return nil
}

func (m *WafAction) GetWafInMonitoringMode() *schema.Empty {
	if x, ok := m.GetActionType().(*WafAction_WafInMonitoringMode); ok {
		return x.WafInMonitoringMode
	}
	return nil
}

func (m *WafAction) GetAppFirewallDetectionControl() *AppFirewallDetectionControl {
	if x, ok := m.GetActionType().(*WafAction_AppFirewallDetectionControl); ok {
		return x.AppFirewallDetectionControl
	}
	return nil
}

func (m *WafAction) GetDataGuardControl() *DataGuardControl {
	if x, ok := m.GetActionType().(*WafAction_DataGuardControl); ok {
		return x.DataGuardControl
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WafAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WafAction_None)(nil),
		(*WafAction_WafSkipProcessing)(nil),
		(*WafAction_WafRuleControl)(nil),
		(*WafAction_WafInlineRuleControl)(nil),
		(*WafAction_WafInMonitoringMode)(nil),
		(*WafAction_AppFirewallDetectionControl)(nil),
		(*WafAction_DataGuardControl)(nil),
	}
}

// ContentRewriteAction
//
// x-displayName: "Content Rewrite Action"
// Rewrite HTML response action to insert HTML content such as Javascript <script> tags into the HTML document
type ContentRewriteAction struct {
	// Insert Content
	//
	// x-displayName: "HTML Content to insert"
	// x-example: "value"
	// HTML content to insert.
	InsertContent string `protobuf:"bytes,1,opt,name=insert_content,json=insertContent,proto3" json:"insert_content,omitempty"`
	// Element selector
	//
	// x-displayName: "Element selector to rewrite"
	// x-example: "value"
	// x-required
	// Element selector to insert into.
	ElementSelector string `protobuf:"bytes,2,opt,name=element_selector,json=elementSelector,proto3" json:"element_selector,omitempty"`
	// Position
	//
	// x-displayName: "HTML position"
	// Position of HTML content to be inserted within HTML tag.
	Position HTMLPosition `protobuf:"varint,3,opt,name=position,proto3,enum=ves.io.schema.policy.HTMLPosition" json:"position,omitempty"`
	// Inserted types
	//
	// x-displayName: "Inserted types"
	// Inserted types of security configuration like Bot Defense, Client Side Defense.
	InsertedTypes map[string]bool `protobuf:"bytes,4,rep,name=inserted_types,json=insertedTypes,proto3" json:"inserted_types,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ContentRewriteAction) Reset()      { *m = ContentRewriteAction{} }
func (*ContentRewriteAction) ProtoMessage() {}
func (*ContentRewriteAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{11}
}
func (m *ContentRewriteAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentRewriteAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ContentRewriteAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentRewriteAction.Merge(m, src)
}
func (m *ContentRewriteAction) XXX_Size() int {
	return m.Size()
}
func (m *ContentRewriteAction) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentRewriteAction.DiscardUnknown(m)
}

var xxx_messageInfo_ContentRewriteAction proto.InternalMessageInfo

func (m *ContentRewriteAction) GetInsertContent() string {
	if m != nil {
		return m.InsertContent
	}
	return ""
}

func (m *ContentRewriteAction) GetElementSelector() string {
	if m != nil {
		return m.ElementSelector
	}
	return ""
}

func (m *ContentRewriteAction) GetPosition() HTMLPosition {
	if m != nil {
		return m.Position
	}
	return BEGINNING
}

func (m *ContentRewriteAction) GetInsertedTypes() map[string]bool {
	if m != nil {
		return m.InsertedTypes
	}
	return nil
}

// ShapeProtectedEndpointAction
//
// x-displayName: "Protected Endpoint Action"
// Protected Endpoint Action
type ShapeProtectedEndpointAction struct {
	// Application traffic type
	//
	// x-displayName: "Traffic type"
	// x-required
	// Traffic type
	AppTrafficType AppTrafficType `protobuf:"varint,1,opt,name=app_traffic_type,json=appTrafficType,proto3,enum=ves.io.schema.policy.AppTrafficType" json:"app_traffic_type,omitempty"`
	// Mitigation
	//
	// x-displayName: "Mitigation"
	// x-required
	// Mitigation action for protected endpoint
	Mitigation *ShapeBotMitigationAction `protobuf:"bytes,2,opt,name=mitigation,proto3" json:"mitigation,omitempty"`
	// Web scraping
	//
	// x-displayName: "Web scraping"
	// x-required
	// Web scraping protection enabled for protected endpoint
	WebScraping bool `protobuf:"varint,3,opt,name=web_scraping,json=webScraping,proto3" json:"web_scraping,omitempty"`
}

func (m *ShapeProtectedEndpointAction) Reset()      { *m = ShapeProtectedEndpointAction{} }
func (*ShapeProtectedEndpointAction) ProtoMessage() {}
func (*ShapeProtectedEndpointAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{12}
}
func (m *ShapeProtectedEndpointAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShapeProtectedEndpointAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ShapeProtectedEndpointAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShapeProtectedEndpointAction.Merge(m, src)
}
func (m *ShapeProtectedEndpointAction) XXX_Size() int {
	return m.Size()
}
func (m *ShapeProtectedEndpointAction) XXX_DiscardUnknown() {
	xxx_messageInfo_ShapeProtectedEndpointAction.DiscardUnknown(m)
}

var xxx_messageInfo_ShapeProtectedEndpointAction proto.InternalMessageInfo

func (m *ShapeProtectedEndpointAction) GetAppTrafficType() AppTrafficType {
	if m != nil {
		return m.AppTrafficType
	}
	return WEB
}

func (m *ShapeProtectedEndpointAction) GetMitigation() *ShapeBotMitigationAction {
	if m != nil {
		return m.Mitigation
	}
	return nil
}

func (m *ShapeProtectedEndpointAction) GetWebScraping() bool {
	if m != nil {
		return m.WebScraping
	}
	return false
}

// ShapeBotMitigationAction
//
// x-displayName: "Bot Mitigation Action"
// Modify Bot Defense behavior for a matching request.
type ShapeBotMitigationAction struct {
	// action_type
	//
	// x-displayName: "Select Bot Mitigation action"
	// Mitigation action.
	//
	// Types that are valid to be assigned to ActionType:
	//	*ShapeBotMitigationAction_None
	//	*ShapeBotMitigationAction_Block
	//	*ShapeBotMitigationAction_Redirect
	//	*ShapeBotMitigationAction_Flag
	ActionType isShapeBotMitigationAction_ActionType `protobuf_oneof:"action_type"`
}

func (m *ShapeBotMitigationAction) Reset()      { *m = ShapeBotMitigationAction{} }
func (*ShapeBotMitigationAction) ProtoMessage() {}
func (*ShapeBotMitigationAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{13}
}
func (m *ShapeBotMitigationAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShapeBotMitigationAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ShapeBotMitigationAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShapeBotMitigationAction.Merge(m, src)
}
func (m *ShapeBotMitigationAction) XXX_Size() int {
	return m.Size()
}
func (m *ShapeBotMitigationAction) XXX_DiscardUnknown() {
	xxx_messageInfo_ShapeBotMitigationAction.DiscardUnknown(m)
}

var xxx_messageInfo_ShapeBotMitigationAction proto.InternalMessageInfo

type isShapeBotMitigationAction_ActionType interface {
	isShapeBotMitigationAction_ActionType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ShapeBotMitigationAction_None struct {
	None *schema.Empty `protobuf:"bytes,2,opt,name=none,proto3,oneof" json:"none,omitempty"`
}
type ShapeBotMitigationAction_Block struct {
	Block *ShapeBotBlockMitigationActionType `protobuf:"bytes,3,opt,name=block,proto3,oneof" json:"block,omitempty"`
}
type ShapeBotMitigationAction_Redirect struct {
	Redirect *ShapeBotRedirectMitigationActionType `protobuf:"bytes,4,opt,name=redirect,proto3,oneof" json:"redirect,omitempty"`
}
type ShapeBotMitigationAction_Flag struct {
	Flag *ShapeBotFlagMitigationActionChoiceType `protobuf:"bytes,5,opt,name=flag,proto3,oneof" json:"flag,omitempty"`
}

func (*ShapeBotMitigationAction_None) isShapeBotMitigationAction_ActionType()     {}
func (*ShapeBotMitigationAction_Block) isShapeBotMitigationAction_ActionType()    {}
func (*ShapeBotMitigationAction_Redirect) isShapeBotMitigationAction_ActionType() {}
func (*ShapeBotMitigationAction_Flag) isShapeBotMitigationAction_ActionType()     {}

func (m *ShapeBotMitigationAction) GetActionType() isShapeBotMitigationAction_ActionType {
	if m != nil {
		return m.ActionType
	}
	return nil
}

func (m *ShapeBotMitigationAction) GetNone() *schema.Empty {
	if x, ok := m.GetActionType().(*ShapeBotMitigationAction_None); ok {
		return x.None
	}
	return nil
}

func (m *ShapeBotMitigationAction) GetBlock() *ShapeBotBlockMitigationActionType {
	if x, ok := m.GetActionType().(*ShapeBotMitigationAction_Block); ok {
		return x.Block
	}
	return nil
}

func (m *ShapeBotMitigationAction) GetRedirect() *ShapeBotRedirectMitigationActionType {
	if x, ok := m.GetActionType().(*ShapeBotMitigationAction_Redirect); ok {
		return x.Redirect
	}
	return nil
}

func (m *ShapeBotMitigationAction) GetFlag() *ShapeBotFlagMitigationActionChoiceType {
	if x, ok := m.GetActionType().(*ShapeBotMitigationAction_Flag); ok {
		return x.Flag
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ShapeBotMitigationAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ShapeBotMitigationAction_None)(nil),
		(*ShapeBotMitigationAction_Block)(nil),
		(*ShapeBotMitigationAction_Redirect)(nil),
		(*ShapeBotMitigationAction_Flag)(nil),
	}
}

// ShapeBotFlagMitigationActionChoiceType
//
// x-displayName: "Select Flag Bot Mitigation Action"
// Flag mitigation action.
type ShapeBotFlagMitigationActionChoiceType struct {
	// send_headers_choice
	//
	// x-displayName: "Include Mitigation Headers"
	// Flag mitigation headers.
	//
	// Types that are valid to be assigned to SendHeadersChoice:
	//	*ShapeBotFlagMitigationActionChoiceType_NoHeaders
	//	*ShapeBotFlagMitigationActionChoiceType_AppendHeaders
	SendHeadersChoice isShapeBotFlagMitigationActionChoiceType_SendHeadersChoice `protobuf_oneof:"send_headers_choice"`
}

func (m *ShapeBotFlagMitigationActionChoiceType) Reset() {
	*m = ShapeBotFlagMitigationActionChoiceType{}
}
func (*ShapeBotFlagMitigationActionChoiceType) ProtoMessage() {}
func (*ShapeBotFlagMitigationActionChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{14}
}
func (m *ShapeBotFlagMitigationActionChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShapeBotFlagMitigationActionChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ShapeBotFlagMitigationActionChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShapeBotFlagMitigationActionChoiceType.Merge(m, src)
}
func (m *ShapeBotFlagMitigationActionChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *ShapeBotFlagMitigationActionChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_ShapeBotFlagMitigationActionChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_ShapeBotFlagMitigationActionChoiceType proto.InternalMessageInfo

type isShapeBotFlagMitigationActionChoiceType_SendHeadersChoice interface {
	isShapeBotFlagMitigationActionChoiceType_SendHeadersChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ShapeBotFlagMitigationActionChoiceType_NoHeaders struct {
	NoHeaders *schema.Empty `protobuf:"bytes,2,opt,name=no_headers,json=noHeaders,proto3,oneof" json:"no_headers,omitempty"`
}
type ShapeBotFlagMitigationActionChoiceType_AppendHeaders struct {
	AppendHeaders *ShapeBotFlagMitigationActionType `protobuf:"bytes,3,opt,name=append_headers,json=appendHeaders,proto3,oneof" json:"append_headers,omitempty"`
}

func (*ShapeBotFlagMitigationActionChoiceType_NoHeaders) isShapeBotFlagMitigationActionChoiceType_SendHeadersChoice() {
}
func (*ShapeBotFlagMitigationActionChoiceType_AppendHeaders) isShapeBotFlagMitigationActionChoiceType_SendHeadersChoice() {
}

func (m *ShapeBotFlagMitigationActionChoiceType) GetSendHeadersChoice() isShapeBotFlagMitigationActionChoiceType_SendHeadersChoice {
	if m != nil {
		return m.SendHeadersChoice
	}
	return nil
}

func (m *ShapeBotFlagMitigationActionChoiceType) GetNoHeaders() *schema.Empty {
	if x, ok := m.GetSendHeadersChoice().(*ShapeBotFlagMitigationActionChoiceType_NoHeaders); ok {
		return x.NoHeaders
	}
	return nil
}

func (m *ShapeBotFlagMitigationActionChoiceType) GetAppendHeaders() *ShapeBotFlagMitigationActionType {
	if x, ok := m.GetSendHeadersChoice().(*ShapeBotFlagMitigationActionChoiceType_AppendHeaders); ok {
		return x.AppendHeaders
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ShapeBotFlagMitigationActionChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ShapeBotFlagMitigationActionChoiceType_NoHeaders)(nil),
		(*ShapeBotFlagMitigationActionChoiceType_AppendHeaders)(nil),
	}
}

// ShapeBotFlagMitigationActionType
//
// x-displayName: "Append Flag Mitigation Headers"
// Append flag mitigation headers to forwarded request.
type ShapeBotFlagMitigationActionType struct {
	// inference_header_name
	//
	// x-displayName: "Inference Header Name"
	// x-example: "Bot-Inference"
	// x-required
	// A case-insensitive HTTP header name.
	InferenceHeaderName string `protobuf:"bytes,1,opt,name=inference_header_name,json=inferenceHeaderName,proto3" json:"inference_header_name,omitempty"`
	// auto_type_header_name
	//
	// x-displayName: "Automation Type Header Name"
	// x-example: "Bot-Automation-Type"
	// x-required
	// A case-insensitive HTTP header name.
	AutoTypeHeaderName string `protobuf:"bytes,2,opt,name=auto_type_header_name,json=autoTypeHeaderName,proto3" json:"auto_type_header_name,omitempty"`
}

func (m *ShapeBotFlagMitigationActionType) Reset()      { *m = ShapeBotFlagMitigationActionType{} }
func (*ShapeBotFlagMitigationActionType) ProtoMessage() {}
func (*ShapeBotFlagMitigationActionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{15}
}
func (m *ShapeBotFlagMitigationActionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShapeBotFlagMitigationActionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ShapeBotFlagMitigationActionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShapeBotFlagMitigationActionType.Merge(m, src)
}
func (m *ShapeBotFlagMitigationActionType) XXX_Size() int {
	return m.Size()
}
func (m *ShapeBotFlagMitigationActionType) XXX_DiscardUnknown() {
	xxx_messageInfo_ShapeBotFlagMitigationActionType.DiscardUnknown(m)
}

var xxx_messageInfo_ShapeBotFlagMitigationActionType proto.InternalMessageInfo

func (m *ShapeBotFlagMitigationActionType) GetInferenceHeaderName() string {
	if m != nil {
		return m.InferenceHeaderName
	}
	return ""
}

func (m *ShapeBotFlagMitigationActionType) GetAutoTypeHeaderName() string {
	if m != nil {
		return m.AutoTypeHeaderName
	}
	return ""
}

// ShapeBotBlockMitigationActionType
//
// x-displayName: "Block bot mitigation"
// Block request and respond with custom content.
type ShapeBotBlockMitigationActionType struct {
	// Status
	//
	// x-displayName: "Status"
	// HTTP Status code to respond with
	Status schema.HttpStatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=ves.io.schema.HttpStatusCode" json:"status,omitempty"`
	// body
	//
	// x-displayName: "Body"
	// x-example: "string://LzxwPiBZb3VyIHJlcXVlc3Qgd2FzIGJsb2NrZWQgPC9wPg=="
	// Custom body message is of type uri_ref. Currently supported URL schemes is string:///.
	// For string:/// scheme, message needs to be encoded in Base64 format.
	// You can specify this message as base64 encoded plain text message e.g. "Your request was blocked"
	// or it can be HTML paragraph or a body string encoded as base64 string
	// E.g. "<p> Your request was blocked </p>". Base64 encoded string for this html is "LzxwPiBZb3VyIHJlcXVlc3Qgd2FzIGJsb2NrZWQgPC9wPg=="
	Body string `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	// body_hash
	//
	// x-displayName: "Body Hash"
	// x-example: "92959a96fd69146c5fe7cbde6e5720f2"
	// Represents the corresponding MD5 Hash for the body message.
	BodyHash string `protobuf:"bytes,3,opt,name=body_hash,json=bodyHash,proto3" json:"body_hash,omitempty"`
}

func (m *ShapeBotBlockMitigationActionType) Reset()      { *m = ShapeBotBlockMitigationActionType{} }
func (*ShapeBotBlockMitigationActionType) ProtoMessage() {}
func (*ShapeBotBlockMitigationActionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{16}
}
func (m *ShapeBotBlockMitigationActionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShapeBotBlockMitigationActionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ShapeBotBlockMitigationActionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShapeBotBlockMitigationActionType.Merge(m, src)
}
func (m *ShapeBotBlockMitigationActionType) XXX_Size() int {
	return m.Size()
}
func (m *ShapeBotBlockMitigationActionType) XXX_DiscardUnknown() {
	xxx_messageInfo_ShapeBotBlockMitigationActionType.DiscardUnknown(m)
}

var xxx_messageInfo_ShapeBotBlockMitigationActionType proto.InternalMessageInfo

func (m *ShapeBotBlockMitigationActionType) GetStatus() schema.HttpStatusCode {
	if m != nil {
		return m.Status
	}
	return schema.EmptyStatusCode
}

func (m *ShapeBotBlockMitigationActionType) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *ShapeBotBlockMitigationActionType) GetBodyHash() string {
	if m != nil {
		return m.BodyHash
	}
	return ""
}

// ShapeBotRedirectMitigationTypeAction
//
// x-displayName: "Redirect bot mitigation"
// Redirect request to a custom URI.
type ShapeBotRedirectMitigationActionType struct {
	// URI
	//
	// x-displayName: "URI"
	// x-example: "Enter URI"
	// x-required
	// URI location for redirect may be relative or absolute.
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
}

func (m *ShapeBotRedirectMitigationActionType) Reset()      { *m = ShapeBotRedirectMitigationActionType{} }
func (*ShapeBotRedirectMitigationActionType) ProtoMessage() {}
func (*ShapeBotRedirectMitigationActionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{17}
}
func (m *ShapeBotRedirectMitigationActionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShapeBotRedirectMitigationActionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ShapeBotRedirectMitigationActionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShapeBotRedirectMitigationActionType.Merge(m, src)
}
func (m *ShapeBotRedirectMitigationActionType) XXX_Size() int {
	return m.Size()
}
func (m *ShapeBotRedirectMitigationActionType) XXX_DiscardUnknown() {
	xxx_messageInfo_ShapeBotRedirectMitigationActionType.DiscardUnknown(m)
}

var xxx_messageInfo_ShapeBotRedirectMitigationActionType proto.InternalMessageInfo

func (m *ShapeBotRedirectMitigationActionType) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

// Prefix Match List
//
// x-displayName: "IP Prefix Match List"
// List of IPv4 Prefix strings to match against.
type PrefixMatchList struct {
	// ip prefixes
	//
	// x-displayName: "IP Prefix List"
	// x-example: "192.168.20.0/24"
	// x-required
	// List of IPv4 prefix strings.
	IpPrefixes []string `protobuf:"bytes,1,rep,name=ip_prefixes,json=ipPrefixes,proto3" json:"ip_prefixes,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert Match Result"
	// Invert the match result.
	InvertMatch bool `protobuf:"varint,2,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
}

func (m *PrefixMatchList) Reset()      { *m = PrefixMatchList{} }
func (*PrefixMatchList) ProtoMessage() {}
func (*PrefixMatchList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{18}
}
func (m *PrefixMatchList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrefixMatchList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PrefixMatchList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefixMatchList.Merge(m, src)
}
func (m *PrefixMatchList) XXX_Size() int {
	return m.Size()
}
func (m *PrefixMatchList) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefixMatchList.DiscardUnknown(m)
}

var xxx_messageInfo_PrefixMatchList proto.InternalMessageInfo

func (m *PrefixMatchList) GetIpPrefixes() []string {
	if m != nil {
		return m.IpPrefixes
	}
	return nil
}

func (m *PrefixMatchList) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// Asn Match List
//
// x-displayName: "ASN Match List"
// An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy.
type AsnMatchList struct {
	// as numbers
	//
	// x-displayName: "AS Numbers"
	// x-example: "[713, 7932, 847325, 4683, 15269, 1000001]"
	// x-required
	// An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy.
	AsNumbers []uint32 `protobuf:"varint,1,rep,packed,name=as_numbers,json=asNumbers,proto3" json:"as_numbers,omitempty"`
}

func (m *AsnMatchList) Reset()      { *m = AsnMatchList{} }
func (*AsnMatchList) ProtoMessage() {}
func (*AsnMatchList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{19}
}
func (m *AsnMatchList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AsnMatchList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AsnMatchList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AsnMatchList.Merge(m, src)
}
func (m *AsnMatchList) XXX_Size() int {
	return m.Size()
}
func (m *AsnMatchList) XXX_DiscardUnknown() {
	xxx_messageInfo_AsnMatchList.DiscardUnknown(m)
}

var xxx_messageInfo_AsnMatchList proto.InternalMessageInfo

func (m *AsnMatchList) GetAsNumbers() []uint32 {
	if m != nil {
		return m.AsNumbers
	}
	return nil
}

// SimpleWafExclusionRule
//
// x-displayName: "WAF Exclusion Rule"
// Simple WAF exclusion rule specifies a simple set of match conditions to be matched to skip a list of WAF rule ids
type SimpleWafExclusionRule struct {
	// Domain
	//
	// x-displayName: "Domain"
	// x-example: "mybloggingwebsite.org"
	// x-required
	// Domain to be matched
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*SimpleWafExclusionRule_AnyDomain
	//	*SimpleWafExclusionRule_ExactValue
	//	*SimpleWafExclusionRule_SuffixValue
	DomainChoice isSimpleWafExclusionRule_DomainChoice `protobuf_oneof:"domain_choice"`
	// Path Regex
	//
	// x-displayName: "Path Regex"
	// x-example: "/blog_id/.*"
	// x-required
	// path regex to be matched
	PathRegex string `protobuf:"bytes,6,opt,name=path_regex,json=pathRegex,proto3" json:"path_regex,omitempty"`
	// Methods
	//
	// x-displayName: "Methods"
	// x-example: "GET"
	// methods to be matched
	Methods []schema.HttpMethod `protobuf:"varint,7,rep,packed,name=methods,proto3,enum=ves.io.schema.HttpMethod" json:"methods,omitempty"`
	// Exclude WAF Rules
	//
	// x-displayName: "Exclude WAF Rules"
	// x-example: "[942260, 942200]"
	// x-required
	// WAF Rules to be excluded when match conditions are met
	ExcludeRuleIds []waf_rule_list.WafRuleID `protobuf:"varint,8,rep,packed,name=exclude_rule_ids,json=excludeRuleIds,proto3,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"exclude_rule_ids,omitempty"`
	// expiration timestamp
	//
	// x-displayName: "Expiration Timestamp"
	// x-example: "2019-12-31:44:34.171543432Z"
	// The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in
	// the configuration but is not applied anymore.
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,9,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Common attributes for the rule including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,10,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// App Firewall Detection control
	//
	// x-displayName: "App Firewall Detection Control"
	// Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.
	AppFirewallDetectionControl *AppFirewallDetectionControl `protobuf:"bytes,11,opt,name=app_firewall_detection_control,json=appFirewallDetectionControl,proto3" json:"app_firewall_detection_control,omitempty"`
}

func (m *SimpleWafExclusionRule) Reset()      { *m = SimpleWafExclusionRule{} }
func (*SimpleWafExclusionRule) ProtoMessage() {}
func (*SimpleWafExclusionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{20}
}
func (m *SimpleWafExclusionRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleWafExclusionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SimpleWafExclusionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleWafExclusionRule.Merge(m, src)
}
func (m *SimpleWafExclusionRule) XXX_Size() int {
	return m.Size()
}
func (m *SimpleWafExclusionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleWafExclusionRule.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleWafExclusionRule proto.InternalMessageInfo

type isSimpleWafExclusionRule_DomainChoice interface {
	isSimpleWafExclusionRule_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SimpleWafExclusionRule_AnyDomain struct {
	AnyDomain *schema.Empty `protobuf:"bytes,4,opt,name=any_domain,json=anyDomain,proto3,oneof" json:"any_domain,omitempty"`
}
type SimpleWafExclusionRule_ExactValue struct {
	ExactValue string `protobuf:"bytes,12,opt,name=exact_value,json=exactValue,proto3,oneof" json:"exact_value,omitempty"`
}
type SimpleWafExclusionRule_SuffixValue struct {
	SuffixValue string `protobuf:"bytes,13,opt,name=suffix_value,json=suffixValue,proto3,oneof" json:"suffix_value,omitempty"`
}

func (*SimpleWafExclusionRule_AnyDomain) isSimpleWafExclusionRule_DomainChoice()   {}
func (*SimpleWafExclusionRule_ExactValue) isSimpleWafExclusionRule_DomainChoice()  {}
func (*SimpleWafExclusionRule_SuffixValue) isSimpleWafExclusionRule_DomainChoice() {}

func (m *SimpleWafExclusionRule) GetDomainChoice() isSimpleWafExclusionRule_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetAnyDomain() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*SimpleWafExclusionRule_AnyDomain); ok {
		return x.AnyDomain
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetExactValue() string {
	if x, ok := m.GetDomainChoice().(*SimpleWafExclusionRule_ExactValue); ok {
		return x.ExactValue
	}
	return ""
}

func (m *SimpleWafExclusionRule) GetSuffixValue() string {
	if x, ok := m.GetDomainChoice().(*SimpleWafExclusionRule_SuffixValue); ok {
		return x.SuffixValue
	}
	return ""
}

func (m *SimpleWafExclusionRule) GetPathRegex() string {
	if m != nil {
		return m.PathRegex
	}
	return ""
}

func (m *SimpleWafExclusionRule) GetMethods() []schema.HttpMethod {
	if m != nil {
		return m.Methods
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetExcludeRuleIds() []waf_rule_list.WafRuleID {
	if m != nil {
		return m.ExcludeRuleIds
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetAppFirewallDetectionControl() *AppFirewallDetectionControl {
	if m != nil {
		return m.AppFirewallDetectionControl
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SimpleWafExclusionRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SimpleWafExclusionRule_AnyDomain)(nil),
		(*SimpleWafExclusionRule_ExactValue)(nil),
		(*SimpleWafExclusionRule_SuffixValue)(nil),
	}
}

// SimpleDataGuardRule
//
// x-displayName: "Data Guard Rule Specification (Data Leakage Protection)"
// Simple Data Guard rule specifies a simple set of match conditions to enable data guard protection
type SimpleDataGuardRule struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Common attributes for the rule including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,10,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// action choice
	//
	// x-displayName: "Action"
	// x-required
	// Specify the action to be taken for the domain and path match condition.
	//
	// Types that are valid to be assigned to ActionChoice:
	//	*SimpleDataGuardRule_ApplyDataGuard
	//	*SimpleDataGuardRule_SkipDataGuard
	ActionChoice isSimpleDataGuardRule_ActionChoice `protobuf_oneof:"action_choice"`
	// Domain
	//
	// x-displayName: "Domain"
	// x-example: "mybloggingwebsite.org"
	// x-required
	// Domain to be matched
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*SimpleDataGuardRule_AnyDomain
	//	*SimpleDataGuardRule_ExactValue
	//	*SimpleDataGuardRule_SuffixValue
	DomainChoice isSimpleDataGuardRule_DomainChoice `protobuf_oneof:"domain_choice"`
	// Path
	//
	// x-displayName: "Path"
	// x-required
	// URI path matcher.
	Path *schema.PathMatcherType `protobuf:"bytes,6,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *SimpleDataGuardRule) Reset()      { *m = SimpleDataGuardRule{} }
func (*SimpleDataGuardRule) ProtoMessage() {}
func (*SimpleDataGuardRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{21}
}
func (m *SimpleDataGuardRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleDataGuardRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SimpleDataGuardRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleDataGuardRule.Merge(m, src)
}
func (m *SimpleDataGuardRule) XXX_Size() int {
	return m.Size()
}
func (m *SimpleDataGuardRule) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleDataGuardRule.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleDataGuardRule proto.InternalMessageInfo

type isSimpleDataGuardRule_ActionChoice interface {
	isSimpleDataGuardRule_ActionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isSimpleDataGuardRule_DomainChoice interface {
	isSimpleDataGuardRule_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SimpleDataGuardRule_ApplyDataGuard struct {
	ApplyDataGuard *schema.Empty `protobuf:"bytes,15,opt,name=apply_data_guard,json=applyDataGuard,proto3,oneof" json:"apply_data_guard,omitempty"`
}
type SimpleDataGuardRule_SkipDataGuard struct {
	SkipDataGuard *schema.Empty `protobuf:"bytes,16,opt,name=skip_data_guard,json=skipDataGuard,proto3,oneof" json:"skip_data_guard,omitempty"`
}
type SimpleDataGuardRule_AnyDomain struct {
	AnyDomain *schema.Empty `protobuf:"bytes,4,opt,name=any_domain,json=anyDomain,proto3,oneof" json:"any_domain,omitempty"`
}
type SimpleDataGuardRule_ExactValue struct {
	ExactValue string `protobuf:"bytes,12,opt,name=exact_value,json=exactValue,proto3,oneof" json:"exact_value,omitempty"`
}
type SimpleDataGuardRule_SuffixValue struct {
	SuffixValue string `protobuf:"bytes,13,opt,name=suffix_value,json=suffixValue,proto3,oneof" json:"suffix_value,omitempty"`
}

func (*SimpleDataGuardRule_ApplyDataGuard) isSimpleDataGuardRule_ActionChoice() {}
func (*SimpleDataGuardRule_SkipDataGuard) isSimpleDataGuardRule_ActionChoice()  {}
func (*SimpleDataGuardRule_AnyDomain) isSimpleDataGuardRule_DomainChoice()      {}
func (*SimpleDataGuardRule_ExactValue) isSimpleDataGuardRule_DomainChoice()     {}
func (*SimpleDataGuardRule_SuffixValue) isSimpleDataGuardRule_DomainChoice()    {}

func (m *SimpleDataGuardRule) GetActionChoice() isSimpleDataGuardRule_ActionChoice {
	if m != nil {
		return m.ActionChoice
	}
	return nil
}
func (m *SimpleDataGuardRule) GetDomainChoice() isSimpleDataGuardRule_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *SimpleDataGuardRule) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *SimpleDataGuardRule) GetApplyDataGuard() *schema.Empty {
	if x, ok := m.GetActionChoice().(*SimpleDataGuardRule_ApplyDataGuard); ok {
		return x.ApplyDataGuard
	}
	return nil
}

func (m *SimpleDataGuardRule) GetSkipDataGuard() *schema.Empty {
	if x, ok := m.GetActionChoice().(*SimpleDataGuardRule_SkipDataGuard); ok {
		return x.SkipDataGuard
	}
	return nil
}

func (m *SimpleDataGuardRule) GetAnyDomain() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*SimpleDataGuardRule_AnyDomain); ok {
		return x.AnyDomain
	}
	return nil
}

func (m *SimpleDataGuardRule) GetExactValue() string {
	if x, ok := m.GetDomainChoice().(*SimpleDataGuardRule_ExactValue); ok {
		return x.ExactValue
	}
	return ""
}

func (m *SimpleDataGuardRule) GetSuffixValue() string {
	if x, ok := m.GetDomainChoice().(*SimpleDataGuardRule_SuffixValue); ok {
		return x.SuffixValue
	}
	return ""
}

func (m *SimpleDataGuardRule) GetPath() *schema.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SimpleDataGuardRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SimpleDataGuardRule_ApplyDataGuard)(nil),
		(*SimpleDataGuardRule_SkipDataGuard)(nil),
		(*SimpleDataGuardRule_AnyDomain)(nil),
		(*SimpleDataGuardRule_ExactValue)(nil),
		(*SimpleDataGuardRule_SuffixValue)(nil),
	}
}

// Deny Information
//
// x-displayName: "Deny Information"
// Detailed information including HTTP response code and error message to be sent when the policy or policy set action is DENY.
type DenyInformation struct {
	// response_code
	//
	// x-displayName: "HTTP Response Code"
	// x-example: 400
	// The HTTP status code to use in the response. The default code is Forbidden (403).
	ResponseCode uint32 `protobuf:"varint,1,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	// error_message
	//
	// x-displayName: "Error Message"
	// x-example: "Denied because the URL path contains an unknown object type"
	// An error message associated with a DENY action in a policy or policy set, that is meaningful to the end user. Note that this error message is included
	// in the body but does not constitute the entire body.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// event_type
	//
	// x-displayName: "Event Type"
	// Event Type
	//
	// Types that are valid to be assigned to EventType:
	//	*DenyInformation_UndefinedSecEvent
	//	*DenyInformation_ApiSecEvent
	EventType isDenyInformation_EventType `protobuf_oneof:"event_type"`
}

func (m *DenyInformation) Reset()      { *m = DenyInformation{} }
func (*DenyInformation) ProtoMessage() {}
func (*DenyInformation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{22}
}
func (m *DenyInformation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenyInformation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DenyInformation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenyInformation.Merge(m, src)
}
func (m *DenyInformation) XXX_Size() int {
	return m.Size()
}
func (m *DenyInformation) XXX_DiscardUnknown() {
	xxx_messageInfo_DenyInformation.DiscardUnknown(m)
}

var xxx_messageInfo_DenyInformation proto.InternalMessageInfo

type isDenyInformation_EventType interface {
	isDenyInformation_EventType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DenyInformation_UndefinedSecEvent struct {
	UndefinedSecEvent *schema.Empty `protobuf:"bytes,4,opt,name=undefined_sec_event,json=undefinedSecEvent,proto3,oneof" json:"undefined_sec_event,omitempty"`
}
type DenyInformation_ApiSecEvent struct {
	ApiSecEvent *schema.Empty `protobuf:"bytes,5,opt,name=api_sec_event,json=apiSecEvent,proto3,oneof" json:"api_sec_event,omitempty"`
}

func (*DenyInformation_UndefinedSecEvent) isDenyInformation_EventType() {}
func (*DenyInformation_ApiSecEvent) isDenyInformation_EventType()       {}

func (m *DenyInformation) GetEventType() isDenyInformation_EventType {
	if m != nil {
		return m.EventType
	}
	return nil
}

func (m *DenyInformation) GetResponseCode() uint32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *DenyInformation) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *DenyInformation) GetUndefinedSecEvent() *schema.Empty {
	if x, ok := m.GetEventType().(*DenyInformation_UndefinedSecEvent); ok {
		return x.UndefinedSecEvent
	}
	return nil
}

func (m *DenyInformation) GetApiSecEvent() *schema.Empty {
	if x, ok := m.GetEventType().(*DenyInformation_ApiSecEvent); ok {
		return x.ApiSecEvent
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DenyInformation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DenyInformation_UndefinedSecEvent)(nil),
		(*DenyInformation_ApiSecEvent)(nil),
	}
}

// TlsFingerprintMatcherType
//
// x-displayName: "TLS Fingerprint Matcher"
// A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known
// classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input
// fingerprint is not one of the excluded values.
type TlsFingerprintMatcherType struct {
	// classes
	//
	// x-displayName: "TLS fingerprint classes"
	// x-example: "['ADWARE', 'TRICKBOT']
	// A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.
	Classes []KnownTlsFingerprintClass `protobuf:"varint,1,rep,packed,name=classes,proto3,enum=ves.io.schema.policy.KnownTlsFingerprintClass" json:"classes,omitempty"`
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']"
	// A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.
	ExactValues []string `protobuf:"bytes,2,rep,name=exact_values,json=exactValues,proto3" json:"exact_values,omitempty"`
	// excluded values
	//
	// x-displayName: "Excluded Values"
	// x-example: "['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']"
	// A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one
	// or more known TLS fingerprint classes in the enclosing matcher.
	ExcludedValues []string `protobuf:"bytes,3,rep,name=excluded_values,json=excludedValues,proto3" json:"excluded_values,omitempty"`
}

func (m *TlsFingerprintMatcherType) Reset()      { *m = TlsFingerprintMatcherType{} }
func (*TlsFingerprintMatcherType) ProtoMessage() {}
func (*TlsFingerprintMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{23}
}
func (m *TlsFingerprintMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsFingerprintMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsFingerprintMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsFingerprintMatcherType.Merge(m, src)
}
func (m *TlsFingerprintMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *TlsFingerprintMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsFingerprintMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_TlsFingerprintMatcherType proto.InternalMessageInfo

func (m *TlsFingerprintMatcherType) GetClasses() []KnownTlsFingerprintClass {
	if m != nil {
		return m.Classes
	}
	return nil
}

func (m *TlsFingerprintMatcherType) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *TlsFingerprintMatcherType) GetExcludedValues() []string {
	if m != nil {
		return m.ExcludedValues
	}
	return nil
}

// PathMatcherType
//
// x-displayName: "Path Matcher"
// A path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set
// of supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.
type PathMatcherType struct {
	// prefix values
	//
	// x-displayName: "Prefix Values"
	// x-example: "['/api/web/namespaces/project179/users/', '/api/config/namespaces/', '/api/data/namespaces/']"
	// A list of path prefix values to match the input HTTP path against.
	PrefixValues []string `protobuf:"bytes,1,rep,name=prefix_values,json=prefixValues,proto3" json:"prefix_values,omitempty"`
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['/api/web/namespaces/project179/users/user1', '/api/config/namespaces/accounting/bgps', '/api/data/namespaces/project443/virtual_host_101']"
	// A list of exact path values to match the input HTTP path against.
	ExactValues []string `protobuf:"bytes,2,rep,name=exact_values,json=exactValues,proto3" json:"exact_values,omitempty"`
	// regex values
	//
	// x-displayName: "Regex Values"
	// x-example: "['^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$', '/api/data/namespaces/proj404/virtual_hosts/([a-z]([-a-z0-9]*[a-z0-9])?)$']"
	// A list of regular expressions to match the input HTTP path against.
	RegexValues []string `protobuf:"bytes,3,rep,name=regex_values,json=regexValues,proto3" json:"regex_values,omitempty"`
	// Suffix values
	//
	// x-displayName: "Suffix Values"
	// x-example: "['.exe', '.shtml', '.wmz']"
	// A list of path suffix values to match the input HTTP path against.
	SuffixValues []string `protobuf:"bytes,5,rep,name=suffix_values,json=suffixValues,proto3" json:"suffix_values,omitempty"`
	// transformers
	//
	// x-displayName: "Transformers"
	// x-example: "[BASE64_DECODE, LOWER_CASE]
	// An ordered list of transformers (starting from index 0) to be applied to the path before matching.
	Transformers []Transformer `protobuf:"varint,4,rep,packed,name=transformers,proto3,enum=ves.io.schema.policy.Transformer" json:"transformers,omitempty"`
}

func (m *PathMatcherType) Reset()      { *m = PathMatcherType{} }
func (*PathMatcherType) ProtoMessage() {}
func (*PathMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{24}
}
func (m *PathMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PathMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathMatcherType.Merge(m, src)
}
func (m *PathMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *PathMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_PathMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_PathMatcherType proto.InternalMessageInfo

func (m *PathMatcherType) GetPrefixValues() []string {
	if m != nil {
		return m.PrefixValues
	}
	return nil
}

func (m *PathMatcherType) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *PathMatcherType) GetRegexValues() []string {
	if m != nil {
		return m.RegexValues
	}
	return nil
}

func (m *PathMatcherType) GetSuffixValues() []string {
	if m != nil {
		return m.SuffixValues
	}
	return nil
}

func (m *PathMatcherType) GetTransformers() []Transformer {
	if m != nil {
		return m.Transformers
	}
	return nil
}

// MatcherType
//
// x-displayName: "Matcher"
// A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set
// of supported match criteria includes a list of exact values and a list of regular expressions.
type MatcherType struct {
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['new york', 'london', 'sydney', 'tokyo', 'cairo']"
	// A list of exact values to match the input against.
	ExactValues []string `protobuf:"bytes,1,rep,name=exact_values,json=exactValues,proto3" json:"exact_values,omitempty"`
	// regex values
	//
	// x-displayName: "Regex Values"
	// x-example: "['^new .*$', 'san f.*', '.* del .*']"
	// A list of regular expressions to match the input against.
	RegexValues []string `protobuf:"bytes,2,rep,name=regex_values,json=regexValues,proto3" json:"regex_values,omitempty"`
	// transformers
	//
	// x-displayName: "Transformers"
	// x-example: "[BASE64_DECODE, LOWER_CASE]
	// An ordered list of transformers (starting from index 0) to be applied to the path before matching.
	Transformers []Transformer `protobuf:"varint,3,rep,packed,name=transformers,proto3,enum=ves.io.schema.policy.Transformer" json:"transformers,omitempty"`
}

func (m *MatcherType) Reset()      { *m = MatcherType{} }
func (*MatcherType) ProtoMessage() {}
func (*MatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{25}
}
func (m *MatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatcherType.Merge(m, src)
}
func (m *MatcherType) XXX_Size() int {
	return m.Size()
}
func (m *MatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_MatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_MatcherType proto.InternalMessageInfo

func (m *MatcherType) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *MatcherType) GetRegexValues() []string {
	if m != nil {
		return m.RegexValues
	}
	return nil
}

func (m *MatcherType) GetTransformers() []Transformer {
	if m != nil {
		return m.Transformers
	}
	return nil
}

// MatcherTypeBasic
//
// x-displayName: "Matcher"
// A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set
// of supported match criteria includes a list of exact values and a list of regular expressions.
type MatcherTypeBasic struct {
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['new york', 'london', 'sydney', 'tokyo', 'cairo']"
	// A list of exact values to match the input against.
	ExactValues []string `protobuf:"bytes,1,rep,name=exact_values,json=exactValues,proto3" json:"exact_values,omitempty"`
	// regex values
	//
	// x-displayName: "Regex Values"
	// x-example: "['^new .*$', 'san f.*', '.* del .*']"
	// A list of regular expressions to match the input against.
	RegexValues []string `protobuf:"bytes,2,rep,name=regex_values,json=regexValues,proto3" json:"regex_values,omitempty"`
}

func (m *MatcherTypeBasic) Reset()      { *m = MatcherTypeBasic{} }
func (*MatcherTypeBasic) ProtoMessage() {}
func (*MatcherTypeBasic) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{26}
}
func (m *MatcherTypeBasic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatcherTypeBasic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MatcherTypeBasic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatcherTypeBasic.Merge(m, src)
}
func (m *MatcherTypeBasic) XXX_Size() int {
	return m.Size()
}
func (m *MatcherTypeBasic) XXX_DiscardUnknown() {
	xxx_messageInfo_MatcherTypeBasic.DiscardUnknown(m)
}

var xxx_messageInfo_MatcherTypeBasic proto.InternalMessageInfo

func (m *MatcherTypeBasic) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *MatcherTypeBasic) GetRegexValues() []string {
	if m != nil {
		return m.RegexValues
	}
	return nil
}

// CookieMatcherType
//
// x-displayName: "Cookie Matcher"
// A cookie matcher specifies the name of a single cookie and the criteria to match it. The input has a list of values for each
// cookie in the request.
// A cookie matcher can check for one of the following:
// * Presence or absence of the cookie
// * At least one of the values for the cookie in the request satisfies the MatcherType item
type CookieMatcherType struct {
	// name
	//
	// x-displayName: "Cookie Name"
	// x-example: "Session"
	// x-required
	// A case-sensitive cookie name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*CookieMatcherType_Presence
	//	*CookieMatcherType_CheckPresent
	//	*CookieMatcherType_CheckNotPresent
	//	*CookieMatcherType_Item
	Match isCookieMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Matcher"
	// Invert Match of the expression defined
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *CookieMatcherType) Reset()      { *m = CookieMatcherType{} }
func (*CookieMatcherType) ProtoMessage() {}
func (*CookieMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{27}
}
func (m *CookieMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CookieMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CookieMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CookieMatcherType.Merge(m, src)
}
func (m *CookieMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *CookieMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_CookieMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_CookieMatcherType proto.InternalMessageInfo

type isCookieMatcherType_Match interface {
	isCookieMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CookieMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof" json:"presence,omitempty"`
}
type CookieMatcherType_CheckPresent struct {
	CheckPresent *schema.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,proto3,oneof" json:"check_present,omitempty"`
}
type CookieMatcherType_CheckNotPresent struct {
	CheckNotPresent *schema.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,proto3,oneof" json:"check_not_present,omitempty"`
}
type CookieMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,proto3,oneof" json:"item,omitempty"`
}

func (*CookieMatcherType_Presence) isCookieMatcherType_Match()        {}
func (*CookieMatcherType_CheckPresent) isCookieMatcherType_Match()    {}
func (*CookieMatcherType_CheckNotPresent) isCookieMatcherType_Match() {}
func (*CookieMatcherType_Item) isCookieMatcherType_Match()            {}

func (m *CookieMatcherType) GetMatch() isCookieMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *CookieMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CookieMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*CookieMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *CookieMatcherType) GetCheckPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*CookieMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *CookieMatcherType) GetCheckNotPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*CookieMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *CookieMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*CookieMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *CookieMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CookieMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CookieMatcherType_Presence)(nil),
		(*CookieMatcherType_CheckPresent)(nil),
		(*CookieMatcherType_CheckNotPresent)(nil),
		(*CookieMatcherType_Item)(nil),
	}
}

// ArgMatcherType
//
// x-displayName: "Argument Matcher"
// A argument matcher specifies the name of a single argument in the body and the criteria to match it.
// A argument matcher can check for one of the following:
// * Presence or absence of the argument
// * At least one of the values for the argument in the request satisfies the MatcherType item
type ArgMatcherType struct {
	// name
	//
	// x-displayName: "Argument Name"
	// x-example: "name"
	// x-example: "phones[_]"
	// x-example: "cars.make.toyota.models[1]"
	// x-example: "cars.make.honda.models[_]"
	// x-example: "cars.make[_].models[_]"
	// x-required
	// A case-sensitive JSON path in the HTTP request body.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*ArgMatcherType_Presence
	//	*ArgMatcherType_CheckPresent
	//	*ArgMatcherType_CheckNotPresent
	//	*ArgMatcherType_Item
	Match isArgMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Matcher"
	// Invert Match of the expression defined
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *ArgMatcherType) Reset()      { *m = ArgMatcherType{} }
func (*ArgMatcherType) ProtoMessage() {}
func (*ArgMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{28}
}
func (m *ArgMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ArgMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgMatcherType.Merge(m, src)
}
func (m *ArgMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *ArgMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_ArgMatcherType proto.InternalMessageInfo

type isArgMatcherType_Match interface {
	isArgMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ArgMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof" json:"presence,omitempty"`
}
type ArgMatcherType_CheckPresent struct {
	CheckPresent *schema.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,proto3,oneof" json:"check_present,omitempty"`
}
type ArgMatcherType_CheckNotPresent struct {
	CheckNotPresent *schema.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,proto3,oneof" json:"check_not_present,omitempty"`
}
type ArgMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,proto3,oneof" json:"item,omitempty"`
}

func (*ArgMatcherType_Presence) isArgMatcherType_Match()        {}
func (*ArgMatcherType_CheckPresent) isArgMatcherType_Match()    {}
func (*ArgMatcherType_CheckNotPresent) isArgMatcherType_Match() {}
func (*ArgMatcherType_Item) isArgMatcherType_Match()            {}

func (m *ArgMatcherType) GetMatch() isArgMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ArgMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ArgMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*ArgMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *ArgMatcherType) GetCheckPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*ArgMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *ArgMatcherType) GetCheckNotPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*ArgMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *ArgMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*ArgMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *ArgMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ArgMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ArgMatcherType_Presence)(nil),
		(*ArgMatcherType_CheckPresent)(nil),
		(*ArgMatcherType_CheckNotPresent)(nil),
		(*ArgMatcherType_Item)(nil),
	}
}

// HeaderMatcherType
//
// x-displayName: "Header Matcher"
// A header matcher specifies the name of a single HTTP header and the criteria for the input request to match it. The input has a list of actual values for each
// header name in the original HTTP request.
// A header matcher can check for one of the following:
// * Presence or absence of the header in the input
// * At least one of the values for the header in the input satisfies the MatcherType item
type HeaderMatcherType struct {
	// name
	//
	// x-displayName: "Header Name"
	// x-example: "Accept-Encoding"
	// x-required
	// A case-insensitive HTTP header name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*HeaderMatcherType_Presence
	//	*HeaderMatcherType_CheckPresent
	//	*HeaderMatcherType_CheckNotPresent
	//	*HeaderMatcherType_Item
	Match isHeaderMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Header Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *HeaderMatcherType) Reset()      { *m = HeaderMatcherType{} }
func (*HeaderMatcherType) ProtoMessage() {}
func (*HeaderMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{29}
}
func (m *HeaderMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcherType.Merge(m, src)
}
func (m *HeaderMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcherType proto.InternalMessageInfo

type isHeaderMatcherType_Match interface {
	isHeaderMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof" json:"presence,omitempty"`
}
type HeaderMatcherType_CheckPresent struct {
	CheckPresent *schema.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,proto3,oneof" json:"check_present,omitempty"`
}
type HeaderMatcherType_CheckNotPresent struct {
	CheckNotPresent *schema.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,proto3,oneof" json:"check_not_present,omitempty"`
}
type HeaderMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,proto3,oneof" json:"item,omitempty"`
}

func (*HeaderMatcherType_Presence) isHeaderMatcherType_Match()        {}
func (*HeaderMatcherType_CheckPresent) isHeaderMatcherType_Match()    {}
func (*HeaderMatcherType_CheckNotPresent) isHeaderMatcherType_Match() {}
func (*HeaderMatcherType_Item) isHeaderMatcherType_Match()            {}

func (m *HeaderMatcherType) GetMatch() isHeaderMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *HeaderMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*HeaderMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *HeaderMatcherType) GetCheckPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*HeaderMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *HeaderMatcherType) GetCheckNotPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*HeaderMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *HeaderMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*HeaderMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *HeaderMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderMatcherType_Presence)(nil),
		(*HeaderMatcherType_CheckPresent)(nil),
		(*HeaderMatcherType_CheckNotPresent)(nil),
		(*HeaderMatcherType_Item)(nil),
	}
}

// HeaderMatcherTypeBasic
//
// x-displayName: "Header Matcher"
// A header matcher specifies the name of a single HTTP header and the criteria for the input request to match it. The input has a list of actual values for each
// header name in the original HTTP request.
// A header matcher can check for one of the following:
// * Presence or absence of the header in the input
// * At least one of the values for the header in the input satisfies the MatcherType item
type HeaderMatcherTypeBasic struct {
	// name
	//
	// x-displayName: "Header Name"
	// x-example: "Accept-Encoding"
	// x-required
	// A case-insensitive HTTP header name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*HeaderMatcherTypeBasic_CheckPresent
	//	*HeaderMatcherTypeBasic_CheckNotPresent
	//	*HeaderMatcherTypeBasic_Item
	Match isHeaderMatcherTypeBasic_Match `protobuf_oneof:"match"`
}

func (m *HeaderMatcherTypeBasic) Reset()      { *m = HeaderMatcherTypeBasic{} }
func (*HeaderMatcherTypeBasic) ProtoMessage() {}
func (*HeaderMatcherTypeBasic) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{30}
}
func (m *HeaderMatcherTypeBasic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatcherTypeBasic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderMatcherTypeBasic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcherTypeBasic.Merge(m, src)
}
func (m *HeaderMatcherTypeBasic) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatcherTypeBasic) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcherTypeBasic.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcherTypeBasic proto.InternalMessageInfo

type isHeaderMatcherTypeBasic_Match interface {
	isHeaderMatcherTypeBasic_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcherTypeBasic_CheckPresent struct {
	CheckPresent *schema.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,proto3,oneof" json:"check_present,omitempty"`
}
type HeaderMatcherTypeBasic_CheckNotPresent struct {
	CheckNotPresent *schema.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,proto3,oneof" json:"check_not_present,omitempty"`
}
type HeaderMatcherTypeBasic_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,proto3,oneof" json:"item,omitempty"`
}

func (*HeaderMatcherTypeBasic_CheckPresent) isHeaderMatcherTypeBasic_Match()    {}
func (*HeaderMatcherTypeBasic_CheckNotPresent) isHeaderMatcherTypeBasic_Match() {}
func (*HeaderMatcherTypeBasic_Item) isHeaderMatcherTypeBasic_Match()            {}

func (m *HeaderMatcherTypeBasic) GetMatch() isHeaderMatcherTypeBasic_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *HeaderMatcherTypeBasic) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcherTypeBasic) GetCheckPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*HeaderMatcherTypeBasic_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *HeaderMatcherTypeBasic) GetCheckNotPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*HeaderMatcherTypeBasic_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *HeaderMatcherTypeBasic) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*HeaderMatcherTypeBasic_Item); ok {
		return x.Item
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderMatcherTypeBasic) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderMatcherTypeBasic_CheckPresent)(nil),
		(*HeaderMatcherTypeBasic_CheckNotPresent)(nil),
		(*HeaderMatcherTypeBasic_Item)(nil),
	}
}

// QueryParameterMatcherType
//
// x-displayName: "Query Parameter Matcher"
// A query parameter matcher specifies the name of a single query parameter and the criteria for the input request to match it. The input has a list of actual
// values for each query parameter name in the original HTTP request.
// A query parameter matcher can check for one of the following:
// * Presence or absence of the query parameter in the input
// * At least one of the values for the query parameter in the input satisfies the MatcherType item
type QueryParameterMatcherType struct {
	// key
	//
	// x-displayName: "Query Parameter Name"
	// x-example: "sourceid"
	// x-required
	// A case-sensitive HTTP query parameter name.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*QueryParameterMatcherType_Presence
	//	*QueryParameterMatcherType_CheckPresent
	//	*QueryParameterMatcherType_CheckNotPresent
	//	*QueryParameterMatcherType_Item
	Match isQueryParameterMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Query Parameter Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *QueryParameterMatcherType) Reset()      { *m = QueryParameterMatcherType{} }
func (*QueryParameterMatcherType) ProtoMessage() {}
func (*QueryParameterMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{31}
}
func (m *QueryParameterMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParameterMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryParameterMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParameterMatcherType.Merge(m, src)
}
func (m *QueryParameterMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *QueryParameterMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParameterMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParameterMatcherType proto.InternalMessageInfo

type isQueryParameterMatcherType_Match interface {
	isQueryParameterMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryParameterMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof" json:"presence,omitempty"`
}
type QueryParameterMatcherType_CheckPresent struct {
	CheckPresent *schema.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,proto3,oneof" json:"check_present,omitempty"`
}
type QueryParameterMatcherType_CheckNotPresent struct {
	CheckNotPresent *schema.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,proto3,oneof" json:"check_not_present,omitempty"`
}
type QueryParameterMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,proto3,oneof" json:"item,omitempty"`
}

func (*QueryParameterMatcherType_Presence) isQueryParameterMatcherType_Match()        {}
func (*QueryParameterMatcherType_CheckPresent) isQueryParameterMatcherType_Match()    {}
func (*QueryParameterMatcherType_CheckNotPresent) isQueryParameterMatcherType_Match() {}
func (*QueryParameterMatcherType_Item) isQueryParameterMatcherType_Match()            {}

func (m *QueryParameterMatcherType) GetMatch() isQueryParameterMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *QueryParameterMatcherType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *QueryParameterMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *QueryParameterMatcherType) GetCheckPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *QueryParameterMatcherType) GetCheckNotPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *QueryParameterMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *QueryParameterMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryParameterMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryParameterMatcherType_Presence)(nil),
		(*QueryParameterMatcherType_CheckPresent)(nil),
		(*QueryParameterMatcherType_CheckNotPresent)(nil),
		(*QueryParameterMatcherType_Item)(nil),
	}
}

// HttpMethodMatcherType
//
// x-displayName: "HTTP Method Matcher"
// A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list.
// The result of the match based on the method list is inverted if invert_matcher is true.
type HttpMethodMatcherType struct {
	// methods
	//
	// x-displayName: "Method List"
	// List of methods values to match against.
	// x-example: "['GET', 'POST', 'DELETE']"
	Methods []schema.HttpMethod `protobuf:"varint,1,rep,packed,name=methods,proto3,enum=ves.io.schema.HttpMethod" json:"methods,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert Method Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *HttpMethodMatcherType) Reset()      { *m = HttpMethodMatcherType{} }
func (*HttpMethodMatcherType) ProtoMessage() {}
func (*HttpMethodMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{32}
}
func (m *HttpMethodMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpMethodMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HttpMethodMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpMethodMatcherType.Merge(m, src)
}
func (m *HttpMethodMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *HttpMethodMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpMethodMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_HttpMethodMatcherType proto.InternalMessageInfo

func (m *HttpMethodMatcherType) GetMethods() []schema.HttpMethod {
	if m != nil {
		return m.Methods
	}
	return nil
}

func (m *HttpMethodMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// RoleMatcherType
//
// x-displayName: "Role Matcher"
// A role matcher specifies a single value for matching an input list of roles. The match is considered successful if the specified value is present in the input
// list.
type RoleMatcherType struct {
	// match
	//
	// x-displayName: "Role"
	// x-required
	// x-example: "ves-io-monitor-role"
	// x-example: "ves-io-uam-role"
	// x-example: "custom-role-security-czar'"
	// Value of the expected role.
	Match string `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
}

func (m *RoleMatcherType) Reset()      { *m = RoleMatcherType{} }
func (*RoleMatcherType) ProtoMessage() {}
func (*RoleMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{33}
}
func (m *RoleMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RoleMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleMatcherType.Merge(m, src)
}
func (m *RoleMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *RoleMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_RoleMatcherType proto.InternalMessageInfo

func (m *RoleMatcherType) GetMatch() string {
	if m != nil {
		return m.Match
	}
	return ""
}

// StringMatcherType
//
// x-displayName: "String Matcher"
// A matcher specifies a list of values for matching an input string. The match is considered successful if the input value is present in the list. The result of
// the match is inverted if invert_matcher is true.
type StringMatcherType struct {
	// match
	//
	// x-displayName: "Exact Values"
	// x-required
	// x-example: "['new york', 'london', 'sydney', 'tokyo', 'cairo']"
	// A list of exact values to match the input against.
	Match []string `protobuf:"bytes,1,rep,name=match,proto3" json:"match,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert String Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *StringMatcherType) Reset()      { *m = StringMatcherType{} }
func (*StringMatcherType) ProtoMessage() {}
func (*StringMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{34}
}
func (m *StringMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StringMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringMatcherType.Merge(m, src)
}
func (m *StringMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *StringMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_StringMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_StringMatcherType proto.InternalMessageInfo

func (m *StringMatcherType) GetMatch() []string {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *StringMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// ip matcher type
//
// x-displayName: "IP Prefix Matcher"
// Match any ip prefix contained in the list of ip_prefix_sets.
// The result of the match is inverted if invert_matcher is true.
type IpMatcherType struct {
	// prefix_sets
	//
	// x-displayName: "IP Prefix Sets"
	// x-required
	// A list of references to ip_prefix_set objects.
	PrefixSets []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=prefix_sets,json=prefixSets,proto3" json:"prefix_sets,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert IP Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *IpMatcherType) Reset()      { *m = IpMatcherType{} }
func (*IpMatcherType) ProtoMessage() {}
func (*IpMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{35}
}
func (m *IpMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpMatcherType.Merge(m, src)
}
func (m *IpMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *IpMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_IpMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_IpMatcherType proto.InternalMessageInfo

func (m *IpMatcherType) GetPrefixSets() []*schema.ObjectRefType {
	if m != nil {
		return m.PrefixSets
	}
	return nil
}

func (m *IpMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// asn matcher type
//
// x-displayName: "ASN Matcher"
// Match any AS number contained in the list of bgp_asn_sets.
type AsnMatcherType struct {
	// asn_sets
	//
	// x-displayName: "BGP ASN Sets"
	// x-required
	// A list of references to bgp_asn_set objects.
	AsnSets []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=asn_sets,json=asnSets,proto3" json:"asn_sets,omitempty"`
}

func (m *AsnMatcherType) Reset()      { *m = AsnMatcherType{} }
func (*AsnMatcherType) ProtoMessage() {}
func (*AsnMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{36}
}
func (m *AsnMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AsnMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AsnMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AsnMatcherType.Merge(m, src)
}
func (m *AsnMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *AsnMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_AsnMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_AsnMatcherType proto.InternalMessageInfo

func (m *AsnMatcherType) GetAsnSets() []*schema.ObjectRefType {
	if m != nil {
		return m.AsnSets
	}
	return nil
}

// port matcher type
//
// x-displayName: "Port Matcher"
// A port matcher specifies a list of port ranges as match criteria. The match is considered successful if the input port falls within any of the port ranges.
// The result of the match is inverted if invert_matcher is true.
type PortMatcherType struct {
	// port ranges
	//
	// x-displayName: "Port Ranges"
	// x-required
	// x-example: "8000-8191"
	// A list of strings, each of which is a single port value or a tuple of start and end port values separated by "-". The start and end values are considered
	// to be part of the range.
	Ports []string `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert Port Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *PortMatcherType) Reset()      { *m = PortMatcherType{} }
func (*PortMatcherType) ProtoMessage() {}
func (*PortMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{37}
}
func (m *PortMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortMatcherType.Merge(m, src)
}
func (m *PortMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *PortMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_PortMatcherType proto.InternalMessageInfo

func (m *PortMatcherType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *PortMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// url item
//
// x-displayName: "URL Item"
// A URL item specifies exact or regular expression match criteria for the domain and path.
type URLItem struct {
	// domain choice
	//
	// x-displayName: "Domain Match"
	// x-required
	// Select Domain Match.
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*URLItem_DomainValue
	//	*URLItem_DomainRegex
	DomainChoice isURLItem_DomainChoice `protobuf_oneof:"domain_choice"`
	// path choice
	//
	// x-displayName: "Path Match"
	// Select Path Match.
	//
	// Types that are valid to be assigned to PathChoice:
	//	*URLItem_PathValue
	//	*URLItem_PathPrefix
	//	*URLItem_PathRegex
	PathChoice isURLItem_PathChoice `protobuf_oneof:"path_choice"`
}

func (m *URLItem) Reset()      { *m = URLItem{} }
func (*URLItem) ProtoMessage() {}
func (*URLItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{38}
}
func (m *URLItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *URLItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLItem.Merge(m, src)
}
func (m *URLItem) XXX_Size() int {
	return m.Size()
}
func (m *URLItem) XXX_DiscardUnknown() {
	xxx_messageInfo_URLItem.DiscardUnknown(m)
}

var xxx_messageInfo_URLItem proto.InternalMessageInfo

type isURLItem_DomainChoice interface {
	isURLItem_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isURLItem_PathChoice interface {
	isURLItem_PathChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type URLItem_DomainValue struct {
	DomainValue string `protobuf:"bytes,2,opt,name=domain_value,json=domainValue,proto3,oneof" json:"domain_value,omitempty"`
}
type URLItem_DomainRegex struct {
	DomainRegex string `protobuf:"bytes,3,opt,name=domain_regex,json=domainRegex,proto3,oneof" json:"domain_regex,omitempty"`
}
type URLItem_PathValue struct {
	PathValue string `protobuf:"bytes,5,opt,name=path_value,json=pathValue,proto3,oneof" json:"path_value,omitempty"`
}
type URLItem_PathPrefix struct {
	PathPrefix string `protobuf:"bytes,7,opt,name=path_prefix,json=pathPrefix,proto3,oneof" json:"path_prefix,omitempty"`
}
type URLItem_PathRegex struct {
	PathRegex string `protobuf:"bytes,6,opt,name=path_regex,json=pathRegex,proto3,oneof" json:"path_regex,omitempty"`
}

func (*URLItem_DomainValue) isURLItem_DomainChoice() {}
func (*URLItem_DomainRegex) isURLItem_DomainChoice() {}
func (*URLItem_PathValue) isURLItem_PathChoice()     {}
func (*URLItem_PathPrefix) isURLItem_PathChoice()    {}
func (*URLItem_PathRegex) isURLItem_PathChoice()     {}

func (m *URLItem) GetDomainChoice() isURLItem_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}
func (m *URLItem) GetPathChoice() isURLItem_PathChoice {
	if m != nil {
		return m.PathChoice
	}
	return nil
}

func (m *URLItem) GetDomainValue() string {
	if x, ok := m.GetDomainChoice().(*URLItem_DomainValue); ok {
		return x.DomainValue
	}
	return ""
}

func (m *URLItem) GetDomainRegex() string {
	if x, ok := m.GetDomainChoice().(*URLItem_DomainRegex); ok {
		return x.DomainRegex
	}
	return ""
}

func (m *URLItem) GetPathValue() string {
	if x, ok := m.GetPathChoice().(*URLItem_PathValue); ok {
		return x.PathValue
	}
	return ""
}

func (m *URLItem) GetPathPrefix() string {
	if x, ok := m.GetPathChoice().(*URLItem_PathPrefix); ok {
		return x.PathPrefix
	}
	return ""
}

func (m *URLItem) GetPathRegex() string {
	if x, ok := m.GetPathChoice().(*URLItem_PathRegex); ok {
		return x.PathRegex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*URLItem) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*URLItem_DomainValue)(nil),
		(*URLItem_DomainRegex)(nil),
		(*URLItem_PathValue)(nil),
		(*URLItem_PathPrefix)(nil),
		(*URLItem_PathRegex)(nil),
	}
}

// url matcher type
//
// x-displayName: "URL Matcher"
// A URL matcher specifies a list of URL items as match criteria. The match is considered successful if the input domain and path match any of the URL items.
// The result of the match is inverted if invert_matcher is true.
type URLMatcherType struct {
	// url items
	//
	// x-displayName: "URL Items"
	// x-required
	// A list of URL items used as match criteria. The match is considered successful if the domain and path match any of the URL items.
	UrlItems []*URLItem `protobuf:"bytes,1,rep,name=url_items,json=urlItems,proto3" json:"url_items,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert URL Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *URLMatcherType) Reset()      { *m = URLMatcherType{} }
func (*URLMatcherType) ProtoMessage() {}
func (*URLMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{39}
}
func (m *URLMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *URLMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLMatcherType.Merge(m, src)
}
func (m *URLMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *URLMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_URLMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_URLMatcherType proto.InternalMessageInfo

func (m *URLMatcherType) GetUrlItems() []*URLItem {
	if m != nil {
		return m.UrlItems
	}
	return nil
}

func (m *URLMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// l4 dest matcher type
//
// x-displayName: "L4 Destination Matcher"
// A L4 Destination matcher specifies a list of L4 Destinations as match criteria. The match is considered successful if the destination IP and port match any
// of the L4 Destinations.
// The result of the match is inverted if invert_matcher is true.
type L4DestMatcherType struct {
	// prefixes
	//
	// x-displayName: "L4 Destinations"
	// x-required
	// A list of L4 destinations used as match criteria. The match is considered successful if the destination IP and path match any of the L4 destinations.
	L4Dests []*schema.L4DestType `protobuf:"bytes,4,rep,name=l4_dests,json=l4Dests,proto3" json:"l4_dests,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert L4 Destination Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,3,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *L4DestMatcherType) Reset()      { *m = L4DestMatcherType{} }
func (*L4DestMatcherType) ProtoMessage() {}
func (*L4DestMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{40}
}
func (m *L4DestMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4DestMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *L4DestMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4DestMatcherType.Merge(m, src)
}
func (m *L4DestMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *L4DestMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_L4DestMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_L4DestMatcherType proto.InternalMessageInfo

func (m *L4DestMatcherType) GetL4Dests() []*schema.L4DestType {
	if m != nil {
		return m.L4Dests
	}
	return nil
}

func (m *L4DestMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// Country Code List
//
// x-displayName: "Country Codes List"
// List of Country Codes to match against.
type CountryCodeList struct {
	// country codes
	//
	// x-displayName: "Country Codes List"
	// x-example: "IN, DE"
	// x-required
	// List of Country Codes
	CountryCodes []CountryCode `protobuf:"varint,1,rep,packed,name=country_codes,json=countryCodes,proto3,enum=ves.io.schema.policy.CountryCode" json:"country_codes,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert Match Result"
	// Invert the match result.
	InvertMatch bool `protobuf:"varint,2,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
}

func (m *CountryCodeList) Reset()      { *m = CountryCodeList{} }
func (*CountryCodeList) ProtoMessage() {}
func (*CountryCodeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{41}
}
func (m *CountryCodeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountryCodeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CountryCodeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountryCodeList.Merge(m, src)
}
func (m *CountryCodeList) XXX_Size() int {
	return m.Size()
}
func (m *CountryCodeList) XXX_DiscardUnknown() {
	xxx_messageInfo_CountryCodeList.DiscardUnknown(m)
}

var xxx_messageInfo_CountryCodeList proto.InternalMessageInfo

func (m *CountryCodeList) GetCountryCodes() []CountryCode {
	if m != nil {
		return m.CountryCodes
	}
	return nil
}

func (m *CountryCodeList) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// HttpHeaderName
//
// x-displayName: "Name of the field"
// Specifies the name of the field
type HttpHeaderName struct {
	// name
	//
	// x-displayName: "Header Name"
	// x-example: "X-Token"
	// x-required
	// A case-insensitive field header name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *HttpHeaderName) Reset()      { *m = HttpHeaderName{} }
func (*HttpHeaderName) ProtoMessage() {}
func (*HttpHeaderName) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{42}
}
func (m *HttpHeaderName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpHeaderName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HttpHeaderName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpHeaderName.Merge(m, src)
}
func (m *HttpHeaderName) XXX_Size() int {
	return m.Size()
}
func (m *HttpHeaderName) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpHeaderName.DiscardUnknown(m)
}

var xxx_messageInfo_HttpHeaderName proto.InternalMessageInfo

func (m *HttpHeaderName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// HttpCookieName
//
// x-displayName: "Name of the cookie field"
// Specifies the name of the cookie field
type HttpCookieName struct {
	// name
	//
	// x-displayName: "Cookie Name"
	// x-example: "token"
	// x-required
	// A case-insensitive cookie name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *HttpCookieName) Reset()      { *m = HttpCookieName{} }
func (*HttpCookieName) ProtoMessage() {}
func (*HttpCookieName) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{43}
}
func (m *HttpCookieName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpCookieName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HttpCookieName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpCookieName.Merge(m, src)
}
func (m *HttpCookieName) XXX_Size() int {
	return m.Size()
}
func (m *HttpCookieName) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpCookieName.DiscardUnknown(m)
}

var xxx_messageInfo_HttpCookieName proto.InternalMessageInfo

func (m *HttpCookieName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// HttpQueryParameterName
//
// x-displayName: "Key name of the query parameter"
// Specifies the key name of the query parameter
type HttpQueryParameterName struct {
	// key
	//
	// x-displayName: "Query Parameter Name"
	// x-example: "sourceid"
	// x-required
	// A case-sensitive HTTP query parameter name.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *HttpQueryParameterName) Reset()      { *m = HttpQueryParameterName{} }
func (*HttpQueryParameterName) ProtoMessage() {}
func (*HttpQueryParameterName) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{44}
}
func (m *HttpQueryParameterName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpQueryParameterName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HttpQueryParameterName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpQueryParameterName.Merge(m, src)
}
func (m *HttpQueryParameterName) XXX_Size() int {
	return m.Size()
}
func (m *HttpQueryParameterName) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpQueryParameterName.DiscardUnknown(m)
}

var xxx_messageInfo_HttpQueryParameterName proto.InternalMessageInfo

func (m *HttpQueryParameterName) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// JwtTokenAuthOptions
//
// x-displayName: "JWT Token Authentication"
// JWT token Authentication
type JwtTokenAuthOptions struct {
	// secret_key
	//
	// x-displayName: "Secret Key"
	// x-example: "{!<=,d_]b[UFX78T"
	// Secret Key for JWT
	SecretKey *schema.SecretType `protobuf:"bytes,1,opt,name=secret_key,json=secretKey,proto3" json:"secret_key,omitempty"`
	// Token Source
	//
	// x-displayName: "Source for the token"
	// Select the source for the token value
	//
	// Types that are valid to be assigned to TokenSource:
	//	*JwtTokenAuthOptions_Header
	//	*JwtTokenAuthOptions_Cookie
	//	*JwtTokenAuthOptions_QueryParam
	//	*JwtTokenAuthOptions_BearerToken
	TokenSource isJwtTokenAuthOptions_TokenSource `protobuf_oneof:"token_source"`
}

func (m *JwtTokenAuthOptions) Reset()      { *m = JwtTokenAuthOptions{} }
func (*JwtTokenAuthOptions) ProtoMessage() {}
func (*JwtTokenAuthOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{45}
}
func (m *JwtTokenAuthOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JwtTokenAuthOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JwtTokenAuthOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JwtTokenAuthOptions.Merge(m, src)
}
func (m *JwtTokenAuthOptions) XXX_Size() int {
	return m.Size()
}
func (m *JwtTokenAuthOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_JwtTokenAuthOptions.DiscardUnknown(m)
}

var xxx_messageInfo_JwtTokenAuthOptions proto.InternalMessageInfo

type isJwtTokenAuthOptions_TokenSource interface {
	isJwtTokenAuthOptions_TokenSource()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type JwtTokenAuthOptions_Header struct {
	Header *HttpHeaderName `protobuf:"bytes,3,opt,name=header,proto3,oneof" json:"header,omitempty"`
}
type JwtTokenAuthOptions_Cookie struct {
	Cookie *HttpCookieName `protobuf:"bytes,4,opt,name=cookie,proto3,oneof" json:"cookie,omitempty"`
}
type JwtTokenAuthOptions_QueryParam struct {
	QueryParam *HttpQueryParameterName `protobuf:"bytes,5,opt,name=query_param,json=queryParam,proto3,oneof" json:"query_param,omitempty"`
}
type JwtTokenAuthOptions_BearerToken struct {
	BearerToken *schema.Empty `protobuf:"bytes,6,opt,name=bearer_token,json=bearerToken,proto3,oneof" json:"bearer_token,omitempty"`
}

func (*JwtTokenAuthOptions_Header) isJwtTokenAuthOptions_TokenSource()      {}
func (*JwtTokenAuthOptions_Cookie) isJwtTokenAuthOptions_TokenSource()      {}
func (*JwtTokenAuthOptions_QueryParam) isJwtTokenAuthOptions_TokenSource()  {}
func (*JwtTokenAuthOptions_BearerToken) isJwtTokenAuthOptions_TokenSource() {}

func (m *JwtTokenAuthOptions) GetTokenSource() isJwtTokenAuthOptions_TokenSource {
	if m != nil {
		return m.TokenSource
	}
	return nil
}

func (m *JwtTokenAuthOptions) GetSecretKey() *schema.SecretType {
	if m != nil {
		return m.SecretKey
	}
	return nil
}

func (m *JwtTokenAuthOptions) GetHeader() *HttpHeaderName {
	if x, ok := m.GetTokenSource().(*JwtTokenAuthOptions_Header); ok {
		return x.Header
	}
	return nil
}

func (m *JwtTokenAuthOptions) GetCookie() *HttpCookieName {
	if x, ok := m.GetTokenSource().(*JwtTokenAuthOptions_Cookie); ok {
		return x.Cookie
	}
	return nil
}

func (m *JwtTokenAuthOptions) GetQueryParam() *HttpQueryParameterName {
	if x, ok := m.GetTokenSource().(*JwtTokenAuthOptions_QueryParam); ok {
		return x.QueryParam
	}
	return nil
}

func (m *JwtTokenAuthOptions) GetBearerToken() *schema.Empty {
	if x, ok := m.GetTokenSource().(*JwtTokenAuthOptions_BearerToken); ok {
		return x.BearerToken
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*JwtTokenAuthOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*JwtTokenAuthOptions_Header)(nil),
		(*JwtTokenAuthOptions_Cookie)(nil),
		(*JwtTokenAuthOptions_QueryParam)(nil),
		(*JwtTokenAuthOptions_BearerToken)(nil),
	}
}

// IP Threat Category List Type
//
// x-displayName: "IP Threat Category List Type"
// List of ip threat categories
type IPThreatCategoryListType struct {
	// IP Threat Categories
	//
	// x-displayName: "List of IP Threat Categories to choose"
	// x-required
	// The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions
	IpThreatCategories []IPThreatCategory `protobuf:"varint,1,rep,packed,name=ip_threat_categories,json=ipThreatCategories,proto3,enum=ves.io.schema.policy.IPThreatCategory" json:"ip_threat_categories,omitempty"`
}

func (m *IPThreatCategoryListType) Reset()      { *m = IPThreatCategoryListType{} }
func (*IPThreatCategoryListType) ProtoMessage() {}
func (*IPThreatCategoryListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{46}
}
func (m *IPThreatCategoryListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPThreatCategoryListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IPThreatCategoryListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPThreatCategoryListType.Merge(m, src)
}
func (m *IPThreatCategoryListType) XXX_Size() int {
	return m.Size()
}
func (m *IPThreatCategoryListType) XXX_DiscardUnknown() {
	xxx_messageInfo_IPThreatCategoryListType.DiscardUnknown(m)
}

var xxx_messageInfo_IPThreatCategoryListType proto.InternalMessageInfo

func (m *IPThreatCategoryListType) GetIpThreatCategories() []IPThreatCategory {
	if m != nil {
		return m.IpThreatCategories
	}
	return nil
}

// Client Matcher
//
// x-displayName: "Client Matcher"
// Client conditions for matching a rule
type ClientMatcher struct {
	// client choice
	//
	// x-displayName: "Client Selection"
	// x-required
	// Select clients for which the rule the will be applied. The actual names of the client are extracted from its TLS certificate.
	//
	// Types that are valid to be assigned to ClientChoice:
	//	*ClientMatcher_AnyClient
	//	*ClientMatcher_IpThreatCategoryList
	//	*ClientMatcher_ClientSelector
	ClientChoice isClientMatcher_ClientChoice `protobuf_oneof:"client_choice"`
	// ip asn choice
	//
	// x-displayName: "Source IPv4/Asn Match"
	// x-required
	// Match source IPv4 address of the request
	//
	// Types that are valid to be assigned to IpAsnChoice:
	//	*ClientMatcher_AnyIp
	//	*ClientMatcher_IpPrefixList
	//	*ClientMatcher_IpMatcher
	//	*ClientMatcher_AsnList
	//	*ClientMatcher_AsnMatcher
	IpAsnChoice isClientMatcher_IpAsnChoice `protobuf_oneof:"ip_asn_choice"`
	// TLS JA3 fingerprint matcher
	//
	// x-displayName: "TLS Fingerprint Matcher"
	// TLS JA3 fingerprints to be matched.
	// The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.
	TlsFingerprintMatcher *TlsFingerprintMatcherType `protobuf:"bytes,13,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher,proto3" json:"tls_fingerprint_matcher,omitempty"`
}

func (m *ClientMatcher) Reset()      { *m = ClientMatcher{} }
func (*ClientMatcher) ProtoMessage() {}
func (*ClientMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{47}
}
func (m *ClientMatcher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClientMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientMatcher.Merge(m, src)
}
func (m *ClientMatcher) XXX_Size() int {
	return m.Size()
}
func (m *ClientMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_ClientMatcher proto.InternalMessageInfo

type isClientMatcher_ClientChoice interface {
	isClientMatcher_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isClientMatcher_IpAsnChoice interface {
	isClientMatcher_IpAsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientMatcher_AnyClient struct {
	AnyClient *schema.Empty `protobuf:"bytes,2,opt,name=any_client,json=anyClient,proto3,oneof" json:"any_client,omitempty"`
}
type ClientMatcher_IpThreatCategoryList struct {
	IpThreatCategoryList *IPThreatCategoryListType `protobuf:"bytes,3,opt,name=ip_threat_category_list,json=ipThreatCategoryList,proto3,oneof" json:"ip_threat_category_list,omitempty"`
}
type ClientMatcher_ClientSelector struct {
	ClientSelector *schema.LabelSelectorType `protobuf:"bytes,4,opt,name=client_selector,json=clientSelector,proto3,oneof" json:"client_selector,omitempty"`
}
type ClientMatcher_AnyIp struct {
	AnyIp *schema.Empty `protobuf:"bytes,8,opt,name=any_ip,json=anyIp,proto3,oneof" json:"any_ip,omitempty"`
}
type ClientMatcher_IpPrefixList struct {
	IpPrefixList *PrefixMatchList `protobuf:"bytes,9,opt,name=ip_prefix_list,json=ipPrefixList,proto3,oneof" json:"ip_prefix_list,omitempty"`
}
type ClientMatcher_IpMatcher struct {
	IpMatcher *IpMatcherType `protobuf:"bytes,10,opt,name=ip_matcher,json=ipMatcher,proto3,oneof" json:"ip_matcher,omitempty"`
}
type ClientMatcher_AsnList struct {
	AsnList *AsnMatchList `protobuf:"bytes,11,opt,name=asn_list,json=asnList,proto3,oneof" json:"asn_list,omitempty"`
}
type ClientMatcher_AsnMatcher struct {
	AsnMatcher *AsnMatcherType `protobuf:"bytes,12,opt,name=asn_matcher,json=asnMatcher,proto3,oneof" json:"asn_matcher,omitempty"`
}

func (*ClientMatcher_AnyClient) isClientMatcher_ClientChoice()            {}
func (*ClientMatcher_IpThreatCategoryList) isClientMatcher_ClientChoice() {}
func (*ClientMatcher_ClientSelector) isClientMatcher_ClientChoice()       {}
func (*ClientMatcher_AnyIp) isClientMatcher_IpAsnChoice()                 {}
func (*ClientMatcher_IpPrefixList) isClientMatcher_IpAsnChoice()          {}
func (*ClientMatcher_IpMatcher) isClientMatcher_IpAsnChoice()             {}
func (*ClientMatcher_AsnList) isClientMatcher_IpAsnChoice()               {}
func (*ClientMatcher_AsnMatcher) isClientMatcher_IpAsnChoice()            {}

func (m *ClientMatcher) GetClientChoice() isClientMatcher_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}
func (m *ClientMatcher) GetIpAsnChoice() isClientMatcher_IpAsnChoice {
	if m != nil {
		return m.IpAsnChoice
	}
	return nil
}

func (m *ClientMatcher) GetAnyClient() *schema.Empty {
	if x, ok := m.GetClientChoice().(*ClientMatcher_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *ClientMatcher) GetIpThreatCategoryList() *IPThreatCategoryListType {
	if x, ok := m.GetClientChoice().(*ClientMatcher_IpThreatCategoryList); ok {
		return x.IpThreatCategoryList
	}
	return nil
}

func (m *ClientMatcher) GetClientSelector() *schema.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*ClientMatcher_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *ClientMatcher) GetAnyIp() *schema.Empty {
	if x, ok := m.GetIpAsnChoice().(*ClientMatcher_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *ClientMatcher) GetIpPrefixList() *PrefixMatchList {
	if x, ok := m.GetIpAsnChoice().(*ClientMatcher_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *ClientMatcher) GetIpMatcher() *IpMatcherType {
	if x, ok := m.GetIpAsnChoice().(*ClientMatcher_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *ClientMatcher) GetAsnList() *AsnMatchList {
	if x, ok := m.GetIpAsnChoice().(*ClientMatcher_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *ClientMatcher) GetAsnMatcher() *AsnMatcherType {
	if x, ok := m.GetIpAsnChoice().(*ClientMatcher_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *ClientMatcher) GetTlsFingerprintMatcher() *TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientMatcher) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientMatcher_AnyClient)(nil),
		(*ClientMatcher_IpThreatCategoryList)(nil),
		(*ClientMatcher_ClientSelector)(nil),
		(*ClientMatcher_AnyIp)(nil),
		(*ClientMatcher_IpPrefixList)(nil),
		(*ClientMatcher_IpMatcher)(nil),
		(*ClientMatcher_AsnList)(nil),
		(*ClientMatcher_AsnMatcher)(nil),
	}
}

// Request Matcher
//
// x-displayName: "Request Matcher"
// Request conditions for matching a rule
type RequestMatcher struct {
	// query params
	//
	// x-displayName: "HTTP Query Parameters"
	// A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances
	// of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name.
	// Note that all specified query parameter predicates must evaluate to true.
	QueryParams []*QueryParameterMatcherType `protobuf:"bytes,1,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
	// headers
	//
	// x-displayName: "HTTP Headers"
	// A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType
	// instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.
	// Note that all specified header predicates must evaluate to true.
	Headers []*HeaderMatcherType `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
	// cookie matchers
	//
	// x-displayName: "Cookie Matchers"
	// A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances
	// of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.
	// Note that all specified cookie matcher predicates must evaluate to true.
	CookieMatchers []*CookieMatcherType `protobuf:"bytes,3,rep,name=cookie_matchers,json=cookieMatchers,proto3" json:"cookie_matchers,omitempty"`
}

func (m *RequestMatcher) Reset()      { *m = RequestMatcher{} }
func (*RequestMatcher) ProtoMessage() {}
func (*RequestMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{48}
}
func (m *RequestMatcher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequestMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestMatcher.Merge(m, src)
}
func (m *RequestMatcher) XXX_Size() int {
	return m.Size()
}
func (m *RequestMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_RequestMatcher proto.InternalMessageInfo

func (m *RequestMatcher) GetQueryParams() []*QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *RequestMatcher) GetHeaders() []*HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *RequestMatcher) GetCookieMatchers() []*CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.policy.PolicySetType", PolicySetType_name, PolicySetType_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.PolicySetType", PolicySetType_name, PolicySetType_value)
	proto.RegisterEnum("ves.io.schema.policy.PolicySetScope", PolicySetScope_name, PolicySetScope_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.PolicySetScope", PolicySetScope_name, PolicySetScope_value)
	proto.RegisterEnum("ves.io.schema.policy.RuleCombiningAlgorithm", RuleCombiningAlgorithm_name, RuleCombiningAlgorithm_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.RuleCombiningAlgorithm", RuleCombiningAlgorithm_name, RuleCombiningAlgorithm_value)
	proto.RegisterEnum("ves.io.schema.policy.Transformer", Transformer_name, Transformer_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.Transformer", Transformer_name, Transformer_value)
	proto.RegisterEnum("ves.io.schema.policy.URLCategory", URLCategory_name, URLCategory_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.URLCategory", URLCategory_name, URLCategory_value)
	proto.RegisterEnum("ves.io.schema.policy.IPThreatCategory", IPThreatCategory_name, IPThreatCategory_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.IPThreatCategory", IPThreatCategory_name, IPThreatCategory_value)
	proto.RegisterEnum("ves.io.schema.policy.KnownTlsFingerprintClass", KnownTlsFingerprintClass_name, KnownTlsFingerprintClass_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.KnownTlsFingerprintClass", KnownTlsFingerprintClass_name, KnownTlsFingerprintClass_value)
	proto.RegisterEnum("ves.io.schema.policy.CountryCode", CountryCode_name, CountryCode_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.CountryCode", CountryCode_name, CountryCode_value)
	proto.RegisterEnum("ves.io.schema.policy.RuleAction", RuleAction_name, RuleAction_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.RuleAction", RuleAction_name, RuleAction_value)
	proto.RegisterEnum("ves.io.schema.policy.ChallengeAction", ChallengeAction_name, ChallengeAction_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.ChallengeAction", ChallengeAction_name, ChallengeAction_value)
	proto.RegisterEnum("ves.io.schema.policy.AppTrafficType", AppTrafficType_name, AppTrafficType_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.AppTrafficType", AppTrafficType_name, AppTrafficType_value)
	proto.RegisterEnum("ves.io.schema.policy.HTMLPosition", HTMLPosition_name, HTMLPosition_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.HTMLPosition", HTMLPosition_name, HTMLPosition_value)
	proto.RegisterType((*WafRuleControl)(nil), "ves.io.schema.policy.WafRuleControl")
	golang_proto.RegisterType((*WafRuleControl)(nil), "ves.io.schema.policy.WafRuleControl")
	proto.RegisterType((*AppFirewallViolationContext)(nil), "ves.io.schema.policy.AppFirewallViolationContext")
	golang_proto.RegisterType((*AppFirewallViolationContext)(nil), "ves.io.schema.policy.AppFirewallViolationContext")
	proto.RegisterType((*AppFirewallSignatureContext)(nil), "ves.io.schema.policy.AppFirewallSignatureContext")
	golang_proto.RegisterType((*AppFirewallSignatureContext)(nil), "ves.io.schema.policy.AppFirewallSignatureContext")
	proto.RegisterType((*AppFirewallAttackTypeContext)(nil), "ves.io.schema.policy.AppFirewallAttackTypeContext")
	golang_proto.RegisterType((*AppFirewallAttackTypeContext)(nil), "ves.io.schema.policy.AppFirewallAttackTypeContext")
	proto.RegisterType((*BotNameContext)(nil), "ves.io.schema.policy.BotNameContext")
	golang_proto.RegisterType((*BotNameContext)(nil), "ves.io.schema.policy.BotNameContext")
	proto.RegisterType((*AppFirewallDetectionControl)(nil), "ves.io.schema.policy.AppFirewallDetectionControl")
	golang_proto.RegisterType((*AppFirewallDetectionControl)(nil), "ves.io.schema.policy.AppFirewallDetectionControl")
	proto.RegisterType((*DataGuardControl)(nil), "ves.io.schema.policy.DataGuardControl")
	golang_proto.RegisterType((*DataGuardControl)(nil), "ves.io.schema.policy.DataGuardControl")
	proto.RegisterType((*WafInlineRuleControl)(nil), "ves.io.schema.policy.WafInlineRuleControl")
	golang_proto.RegisterType((*WafInlineRuleControl)(nil), "ves.io.schema.policy.WafInlineRuleControl")
	proto.RegisterType((*BotAction)(nil), "ves.io.schema.policy.BotAction")
	golang_proto.RegisterType((*BotAction)(nil), "ves.io.schema.policy.BotAction")
	proto.RegisterType((*ModifyAction)(nil), "ves.io.schema.policy.ModifyAction")
	golang_proto.RegisterType((*ModifyAction)(nil), "ves.io.schema.policy.ModifyAction")
	proto.RegisterType((*WafAction)(nil), "ves.io.schema.policy.WafAction")
	golang_proto.RegisterType((*WafAction)(nil), "ves.io.schema.policy.WafAction")
	proto.RegisterType((*ContentRewriteAction)(nil), "ves.io.schema.policy.ContentRewriteAction")
	golang_proto.RegisterType((*ContentRewriteAction)(nil), "ves.io.schema.policy.ContentRewriteAction")
	proto.RegisterMapType((map[string]bool)(nil), "ves.io.schema.policy.ContentRewriteAction.InsertedTypesEntry")
	golang_proto.RegisterMapType((map[string]bool)(nil), "ves.io.schema.policy.ContentRewriteAction.InsertedTypesEntry")
	proto.RegisterType((*ShapeProtectedEndpointAction)(nil), "ves.io.schema.policy.ShapeProtectedEndpointAction")
	golang_proto.RegisterType((*ShapeProtectedEndpointAction)(nil), "ves.io.schema.policy.ShapeProtectedEndpointAction")
	proto.RegisterType((*ShapeBotMitigationAction)(nil), "ves.io.schema.policy.ShapeBotMitigationAction")
	golang_proto.RegisterType((*ShapeBotMitigationAction)(nil), "ves.io.schema.policy.ShapeBotMitigationAction")
	proto.RegisterType((*ShapeBotFlagMitigationActionChoiceType)(nil), "ves.io.schema.policy.ShapeBotFlagMitigationActionChoiceType")
	golang_proto.RegisterType((*ShapeBotFlagMitigationActionChoiceType)(nil), "ves.io.schema.policy.ShapeBotFlagMitigationActionChoiceType")
	proto.RegisterType((*ShapeBotFlagMitigationActionType)(nil), "ves.io.schema.policy.ShapeBotFlagMitigationActionType")
	golang_proto.RegisterType((*ShapeBotFlagMitigationActionType)(nil), "ves.io.schema.policy.ShapeBotFlagMitigationActionType")
	proto.RegisterType((*ShapeBotBlockMitigationActionType)(nil), "ves.io.schema.policy.ShapeBotBlockMitigationActionType")
	golang_proto.RegisterType((*ShapeBotBlockMitigationActionType)(nil), "ves.io.schema.policy.ShapeBotBlockMitigationActionType")
	proto.RegisterType((*ShapeBotRedirectMitigationActionType)(nil), "ves.io.schema.policy.ShapeBotRedirectMitigationActionType")
	golang_proto.RegisterType((*ShapeBotRedirectMitigationActionType)(nil), "ves.io.schema.policy.ShapeBotRedirectMitigationActionType")
	proto.RegisterType((*PrefixMatchList)(nil), "ves.io.schema.policy.PrefixMatchList")
	golang_proto.RegisterType((*PrefixMatchList)(nil), "ves.io.schema.policy.PrefixMatchList")
	proto.RegisterType((*AsnMatchList)(nil), "ves.io.schema.policy.AsnMatchList")
	golang_proto.RegisterType((*AsnMatchList)(nil), "ves.io.schema.policy.AsnMatchList")
	proto.RegisterType((*SimpleWafExclusionRule)(nil), "ves.io.schema.policy.SimpleWafExclusionRule")
	golang_proto.RegisterType((*SimpleWafExclusionRule)(nil), "ves.io.schema.policy.SimpleWafExclusionRule")
	proto.RegisterType((*SimpleDataGuardRule)(nil), "ves.io.schema.policy.SimpleDataGuardRule")
	golang_proto.RegisterType((*SimpleDataGuardRule)(nil), "ves.io.schema.policy.SimpleDataGuardRule")
	proto.RegisterType((*DenyInformation)(nil), "ves.io.schema.policy.DenyInformation")
	golang_proto.RegisterType((*DenyInformation)(nil), "ves.io.schema.policy.DenyInformation")
	proto.RegisterType((*TlsFingerprintMatcherType)(nil), "ves.io.schema.policy.TlsFingerprintMatcherType")
	golang_proto.RegisterType((*TlsFingerprintMatcherType)(nil), "ves.io.schema.policy.TlsFingerprintMatcherType")
	proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.policy.PathMatcherType")
	golang_proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.policy.PathMatcherType")
	proto.RegisterType((*MatcherType)(nil), "ves.io.schema.policy.MatcherType")
	golang_proto.RegisterType((*MatcherType)(nil), "ves.io.schema.policy.MatcherType")
	proto.RegisterType((*MatcherTypeBasic)(nil), "ves.io.schema.policy.MatcherTypeBasic")
	golang_proto.RegisterType((*MatcherTypeBasic)(nil), "ves.io.schema.policy.MatcherTypeBasic")
	proto.RegisterType((*CookieMatcherType)(nil), "ves.io.schema.policy.CookieMatcherType")
	golang_proto.RegisterType((*CookieMatcherType)(nil), "ves.io.schema.policy.CookieMatcherType")
	proto.RegisterType((*ArgMatcherType)(nil), "ves.io.schema.policy.ArgMatcherType")
	golang_proto.RegisterType((*ArgMatcherType)(nil), "ves.io.schema.policy.ArgMatcherType")
	proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.policy.HeaderMatcherType")
	golang_proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.policy.HeaderMatcherType")
	proto.RegisterType((*HeaderMatcherTypeBasic)(nil), "ves.io.schema.policy.HeaderMatcherTypeBasic")
	golang_proto.RegisterType((*HeaderMatcherTypeBasic)(nil), "ves.io.schema.policy.HeaderMatcherTypeBasic")
	proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.policy.QueryParameterMatcherType")
	golang_proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.policy.QueryParameterMatcherType")
	proto.RegisterType((*HttpMethodMatcherType)(nil), "ves.io.schema.policy.HttpMethodMatcherType")
	golang_proto.RegisterType((*HttpMethodMatcherType)(nil), "ves.io.schema.policy.HttpMethodMatcherType")
	proto.RegisterType((*RoleMatcherType)(nil), "ves.io.schema.policy.RoleMatcherType")
	golang_proto.RegisterType((*RoleMatcherType)(nil), "ves.io.schema.policy.RoleMatcherType")
	proto.RegisterType((*StringMatcherType)(nil), "ves.io.schema.policy.StringMatcherType")
	golang_proto.RegisterType((*StringMatcherType)(nil), "ves.io.schema.policy.StringMatcherType")
	proto.RegisterType((*IpMatcherType)(nil), "ves.io.schema.policy.IpMatcherType")
	golang_proto.RegisterType((*IpMatcherType)(nil), "ves.io.schema.policy.IpMatcherType")
	proto.RegisterType((*AsnMatcherType)(nil), "ves.io.schema.policy.AsnMatcherType")
	golang_proto.RegisterType((*AsnMatcherType)(nil), "ves.io.schema.policy.AsnMatcherType")
	proto.RegisterType((*PortMatcherType)(nil), "ves.io.schema.policy.PortMatcherType")
	golang_proto.RegisterType((*PortMatcherType)(nil), "ves.io.schema.policy.PortMatcherType")
	proto.RegisterType((*URLItem)(nil), "ves.io.schema.policy.URLItem")
	golang_proto.RegisterType((*URLItem)(nil), "ves.io.schema.policy.URLItem")
	proto.RegisterType((*URLMatcherType)(nil), "ves.io.schema.policy.URLMatcherType")
	golang_proto.RegisterType((*URLMatcherType)(nil), "ves.io.schema.policy.URLMatcherType")
	proto.RegisterType((*L4DestMatcherType)(nil), "ves.io.schema.policy.L4DestMatcherType")
	golang_proto.RegisterType((*L4DestMatcherType)(nil), "ves.io.schema.policy.L4DestMatcherType")
	proto.RegisterType((*CountryCodeList)(nil), "ves.io.schema.policy.CountryCodeList")
	golang_proto.RegisterType((*CountryCodeList)(nil), "ves.io.schema.policy.CountryCodeList")
	proto.RegisterType((*HttpHeaderName)(nil), "ves.io.schema.policy.HttpHeaderName")
	golang_proto.RegisterType((*HttpHeaderName)(nil), "ves.io.schema.policy.HttpHeaderName")
	proto.RegisterType((*HttpCookieName)(nil), "ves.io.schema.policy.HttpCookieName")
	golang_proto.RegisterType((*HttpCookieName)(nil), "ves.io.schema.policy.HttpCookieName")
	proto.RegisterType((*HttpQueryParameterName)(nil), "ves.io.schema.policy.HttpQueryParameterName")
	golang_proto.RegisterType((*HttpQueryParameterName)(nil), "ves.io.schema.policy.HttpQueryParameterName")
	proto.RegisterType((*JwtTokenAuthOptions)(nil), "ves.io.schema.policy.JwtTokenAuthOptions")
	golang_proto.RegisterType((*JwtTokenAuthOptions)(nil), "ves.io.schema.policy.JwtTokenAuthOptions")
	proto.RegisterType((*IPThreatCategoryListType)(nil), "ves.io.schema.policy.IPThreatCategoryListType")
	golang_proto.RegisterType((*IPThreatCategoryListType)(nil), "ves.io.schema.policy.IPThreatCategoryListType")
	proto.RegisterType((*ClientMatcher)(nil), "ves.io.schema.policy.ClientMatcher")
	golang_proto.RegisterType((*ClientMatcher)(nil), "ves.io.schema.policy.ClientMatcher")
	proto.RegisterType((*RequestMatcher)(nil), "ves.io.schema.policy.RequestMatcher")
	golang_proto.RegisterType((*RequestMatcher)(nil), "ves.io.schema.policy.RequestMatcher")
}

func init() { proto.RegisterFile("ves.io/schema/policy/types.proto", fileDescriptor_d3fbb7e1d0915ae2) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/policy/types.proto", fileDescriptor_d3fbb7e1d0915ae2)
}

var fileDescriptor_d3fbb7e1d0915ae2 = []byte{
	// 9595 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x7d, 0x98, 0x1c, 0xc9,
	0x79, 0xd7, 0xf6, 0xee, 0xec, 0x57, 0xed, 0x57, 0xa9, 0xf5, 0x71, 0x2b, 0xdd, 0xdd, 0xde, 0xdc,
	0xde, 0x97, 0x2c, 0xeb, 0x56, 0xfd, 0xfd, 0xa1, 0xe4, 0x74, 0xd7, 0x33, 0xd3, 0xbb, 0xd3, 0xda,
	0x99, 0xe9, 0x51, 0x77, 0xcf, 0xae, 0x56, 0xf9, 0x98, 0x54, 0x77, 0x57, 0xaf, 0xc6, 0xb7, 0x3b,
	0xb3, 0x9e, 0x99, 0x3d, 0x9d, 0x00, 0x93, 0x8b, 0xb1, 0x4d, 0xe2, 0x00, 0x36, 0x86, 0x10, 0x3b,
	0xc4, 0xc6, 0x38, 0x09, 0x71, 0x1c, 0x0c, 0x0e, 0x90, 0x10, 0xbc, 0x07, 0x11, 0x10, 0xc2, 0x71,
	0x04, 0x38, 0x20, 0x90, 0xc3, 0x04, 0x12, 0xcb, 0x04, 0x9c, 0x00, 0x89, 0xb9, 0x84, 0xe0, 0x38,
	0xe4, 0x79, 0x78, 0xaa, 0xbb, 0x67, 0x76, 0x6a, 0xb5, 0x2b, 0xc9, 0x8e, 0xf3, 0xf0, 0xf8, 0x89,
	0xfe, 0xd2, 0xfe, 0x7e, 0x5d, 0xf5, 0xd6, 0x5b, 0x6f, 0xbd, 0xf5, 0xd6, 0xdb, 0xd5, 0x55, 0x23,
	0x90, 0x7d, 0x09, 0x77, 0x96, 0x1a, 0xad, 0x0b, 0x9d, 0xe0, 0x3a, 0xde, 0x46, 0x17, 0x76, 0x5a,
	0x5b, 0x8d, 0xe0, 0xe6, 0x85, 0xee, 0xcd, 0x1d, 0xdc, 0x59, 0xda, 0x69, 0xb7, 0xba, 0x2d, 0xf6,
	0x44, 0x52, 0x62, 0x29, 0x29, 0xb1, 0x94, 0x94, 0x38, 0xf3, 0xec, 0x66, 0xa3, 0x7b, 0x7d, 0xd7,
	0x5f, 0x0a, 0x5a, 0xdb, 0x17, 0x36, 0x5b, 0x9b, 0xad, 0x0b, 0x71, 0x61, 0x7f, 0x37, 0x8a, 0x51,
	0x0c, 0xe2, 0xbf, 0x12, 0x21, 0x67, 0x1e, 0xdb, 0x6c, 0xb5, 0x36, 0xb7, 0xf0, 0x7e, 0xa9, 0x6e,
	0x63, 0x1b, 0x77, 0xba, 0x68, 0x7b, 0x27, 0x2d, 0xf0, 0x34, 0xad, 0x07, 0xda, 0xd9, 0xa9, 0x47,
	0x8d, 0x36, 0xbe, 0x81, 0xb6, 0xb6, 0x06, 0xb5, 0x39, 0xf3, 0x10, 0x5d, 0xae, 0x89, 0xbb, 0xe9,
	0x83, 0x87, 0xe9, 0x07, 0xad, 0x9d, 0x6e, 0xa3, 0xd5, 0xec, 0xd5, 0x3a, 0x4d, 0x3f, 0x1c, 0x14,
	0xf8, 0x08, 0xfd, 0xe8, 0x25, 0xb4, 0xd5, 0x08, 0x51, 0x17, 0xa7, 0x4f, 0x0f, 0x98, 0xe7, 0xa5,
	0x06, 0xbe, 0x51, 0xa7, 0x45, 0x3f, 0x43, 0x97, 0xb8, 0x81, 0xa2, 0x7a, 0x7b, 0x77, 0x0b, 0xd7,
	0xb7, 0x1a, 0x9d, 0xee, 0x60, 0x43, 0x8b, 0x1f, 0x65, 0xc0, 0xec, 0x3a, 0x8a, 0x9c, 0xdd, 0x2d,
	0x9c, 0x6f, 0x35, 0xbb, 0xed, 0xd6, 0x16, 0xeb, 0x03, 0x88, 0x5f, 0x0e, 0xb6, 0x76, 0x43, 0x9c,
	0xd4, 0x69, 0x84, 0x9d, 0x79, 0x26, 0x3b, 0x72, 0x76, 0x4a, 0x78, 0x64, 0x89, 0xb6, 0xba, 0xed,
	0xbf, 0x03, 0x07, 0x5d, 0x07, 0x47, 0xde, 0xcd, 0x1d, 0x9c, 0x3b, 0xf3, 0xa9, 0x77, 0xcd, 0x50,
	0x0d, 0x7d, 0xf6, 0xd7, 0x6e, 0x8d, 0x8c, 0x7e, 0x88, 0x19, 0x86, 0x19, 0x67, 0x36, 0x95, 0x48,
	0xda, 0xb1, 0xc2, 0x0e, 0xfb, 0x0c, 0x98, 0xdb, 0x6e, 0x35, 0x1b, 0xdd, 0x56, 0xbb, 0xd1, 0xdc,
	0xac, 0x6f, 0xb7, 0x42, 0x3c, 0x3f, 0x9c, 0x65, 0xce, 0x4e, 0x38, 0xb3, 0xfb, 0x74, 0xb9, 0x15,
	0xe2, 0xc5, 0x57, 0x18, 0xf0, 0xb0, 0xb1, 0xb3, 0xb3, 0x9c, 0x5a, 0x7d, 0xad, 0xd1, 0xda, 0x42,
	0xa4, 0xa3, 0x44, 0x59, 0xfc, 0x72, 0x97, 0x45, 0xe0, 0x58, 0x4f, 0xd9, 0x97, 0x7a, 0xcf, 0xe6,
	0x99, 0x2c, 0x73, 0x76, 0x56, 0x90, 0x0e, 0x68, 0x3b, 0x38, 0x7a, 0x4b, 0x87, 0xc9, 0x24, 0xbd,
	0x70, 0x7a, 0x7d, 0xef, 0xb3, 0x8b, 0x1e, 0xa5, 0x81, 0xdb, 0xd8, 0x6c, 0xa2, 0xee, 0x6e, 0x1b,
	0xf7, 0x34, 0x90, 0xc1, 0x74, 0xa7, 0xc7, 0xd5, 0x1b, 0x61, 0xdc, 0xf8, 0x4c, 0x8e, 0x25, 0x9d,
	0x9f, 0x39, 0x37, 0x35, 0xff, 0xca, 0xcf, 0xbd, 0xef, 0x03, 0xcc, 0xd9, 0x57, 0x3e, 0x7d, 0x3b,
	0xe3, 0x4c, 0xf5, 0xcb, 0x59, 0xe1, 0xe2, 0x4b, 0xe0, 0x91, 0x01, 0xa9, 0x46, 0xb7, 0x8b, 0x82,
	0x17, 0x89, 0x02, 0x3d, 0xb1, 0x6b, 0xe0, 0x78, 0xaf, 0x63, 0x28, 0x7e, 0x58, 0x27, 0xc3, 0x96,
	0x76, 0xed, 0xe9, 0xbb, 0x76, 0xad, 0x2f, 0xcb, 0xe9, 0xd9, 0x66, 0x9f, 0x5a, 0x7c, 0x3b, 0x98,
	0xcd, 0xb5, 0xba, 0x15, 0xb4, 0xdd, 0x6f, 0xe9, 0x34, 0x98, 0xf0, 0x5b, 0xdd, 0x7a, 0x13, 0x6d,
	0x27, 0xe2, 0x27, 0x9d, 0x71, 0x3f, 0x29, 0xb1, 0xf8, 0x13, 0x19, 0xaa, 0xef, 0x05, 0xdc, 0xc5,
	0x41, 0xcf, 0xfa, 0xc4, 0x55, 0xde, 0xc7, 0x80, 0x33, 0x3d, 0x2d, 0xf7, 0x8d, 0x10, 0x24, 0x82,
	0x7b, 0x5e, 0xc3, 0x2f, 0x1d, 0x36, 0x57, 0x97, 0xee, 0x62, 0xd3, 0xdc, 0x49, 0x62, 0xbd, 0xb1,
	0x0f, 0x31, 0x23, 0xf0, 0x95, 0x89, 0x9e, 0x17, 0xcd, 0x33, 0xce, 0x7c, 0xda, 0xd6, 0xc1, 0xf2,
	0x1d, 0xf6, 0xbd, 0x03, 0x8a, 0xf4, 0xfd, 0x60, 0x5f, 0x91, 0xe1, 0xfb, 0x54, 0xe4, 0xa0, 0x7b,
	0xe5, 0x4e, 0xf4, 0x7d, 0xf8, 0x85, 0x43, 0xf4, 0x38, 0x58, 0xbc, 0xc3, 0x7e, 0x0f, 0x03, 0x1e,
	0x39, 0x64, 0xd8, 0xf6, 0x35, 0x19, 0x89, 0x35, 0x11, 0xee, 0xa9, 0xc9, 0x1d, 0x0e, 0x71, 0x84,
	0x2a, 0xa7, 0xef, 0x18, 0xe1, 0xbe, 0x2e, 0xbb, 0xa0, 0xf7, 0xb0, 0xde, 0x1b, 0xdf, 0x7d, 0x3d,
	0x32, 0xb1, 0x1e, 0x4f, 0x1e, 0xae, 0x07, 0xed, 0x20, 0x47, 0xb4, 0x7c, 0x2a, 0x15, 0x4e, 0x17,
	0xee, 0x2c, 0x8a, 0x00, 0x16, 0x50, 0x17, 0xad, 0xec, 0xa2, 0x76, 0xd8, 0xf3, 0x93, 0xc7, 0xc0,
	0x54, 0x22, 0x7a, 0xd0, 0xcb, 0x40, 0x42, 0xc5, 0x8e, 0xf6, 0xa3, 0x0c, 0x38, 0xb1, 0x8e, 0x22,
	0xab, 0xb9, 0xd5, 0x68, 0xe2, 0xc1, 0x60, 0x14, 0x1d, 0x11, 0x8c, 0xee, 0x9c, 0x03, 0x54, 0xe8,
	0x59, 0x4a, 0x63, 0x9a, 0x55, 0x38, 0x42, 0xfb, 0xaf, 0x39, 0x20, 0xfd, 0x08, 0x03, 0x26, 0x73,
	0xad, 0xae, 0x11, 0xcf, 0x03, 0xf6, 0x1c, 0xc8, 0x34, 0x5b, 0xcd, 0xa4, 0xec, 0x94, 0x70, 0xe2,
	0x80, 0x4a, 0xe6, 0xf6, 0x4e, 0xf7, 0x66, 0x71, 0xc8, 0x89, 0xcb, 0xb0, 0xcb, 0xe0, 0x38, 0x19,
	0x87, 0xce, 0x8b, 0x8d, 0x9d, 0xfa, 0x4e, 0xbb, 0x15, 0xe0, 0x4e, 0xa7, 0xd1, 0xdc, 0x9c, 0x1f,
	0xb9, 0x6b, 0xd5, 0x63, 0x7e, 0xab, 0xeb, 0xbe, 0xd8, 0xd8, 0xa9, 0xf6, 0x2b, 0xe4, 0x16, 0xc0,
	0x14, 0x8a, 0x5b, 0x8f, 0x5d, 0x8b, 0x9d, 0xbb, 0xb5, 0xc7, 0x0c, 0xbf, 0xb1, 0xc7, 0x30, 0xb7,
	0xf7, 0x98, 0x11, 0xe1, 0xbc, 0x78, 0x39, 0x33, 0xc1, 0xc0, 0x61, 0x62, 0xd1, 0xe9, 0x72, 0x2b,
	0x6c, 0x44, 0x37, 0x53, 0x55, 0x39, 0x30, 0x1e, 0xe2, 0x08, 0xed, 0x6e, 0x75, 0xef, 0xa1, 0x6d,
	0xaf, 0x18, 0xfb, 0x3c, 0x98, 0xfb, 0xea, 0x94, 0x9d, 0xed, 0x7c, 0x2d, 0x9a, 0x7e, 0x66, 0x14,
	0x4c, 0xae, 0xa3, 0xe8, 0x80, 0x45, 0x47, 0xee, 0xcf, 0xa2, 0x64, 0xd4, 0x0f, 0x2a, 0xc9, 0xdc,
	0xdd, 0xa2, 0x37, 0x50, 0x44, 0x5b, 0x94, 0xdd, 0x00, 0xb0, 0xef, 0x3d, 0x41, 0xe2, 0x78, 0xa9,
	0x8d, 0x8e, 0x98, 0x20, 0xf4, 0x8a, 0x99, 0x1b, 0x7f, 0xf3, 0x5d, 0xcc, 0x17, 0xf7, 0x18, 0x86,
	0x98, 0xe0, 0x06, 0xbd, 0x98, 0x6e, 0x81, 0x87, 0x88, 0xe8, 0x46, 0xec, 0xd8, 0x74, 0x0b, 0x99,
	0xb8, 0x85, 0x73, 0x47, 0xb6, 0x70, 0xc7, 0x64, 0x18, 0x6c, 0xe7, 0xc4, 0x8d, 0xc3, 0x66, 0x8b,
	0x07, 0x4e, 0x25, 0xad, 0xd5, 0x0f, 0x3a, 0xf3, 0xd8, 0xd1, 0x36, 0x19, 0x14, 0x7b, 0x3c, 0x16,
	0x5b, 0xa6, 0x5c, 0x9e, 0x7d, 0x0f, 0x03, 0x16, 0x06, 0x57, 0x98, 0x7a, 0xd8, 0x5b, 0x07, 0xfa,
	0x7d, 0x19, 0x8f, 0xc5, 0xdf, 0x3b, 0xc0, 0x1e, 0x5c, 0x41, 0x72, 0x20, 0x9e, 0x93, 0xef, 0x67,
	0x86, 0xb3, 0xa4, 0xf9, 0x87, 0xd1, 0x5d, 0x16, 0x9b, 0x3a, 0x60, 0x43, 0xd4, 0x45, 0xf5, 0x4d,
	0x12, 0x59, 0xfa, 0x2d, 0x4f, 0xc4, 0x2d, 0x3f, 0x7d, 0x78, 0xcb, 0x07, 0x03, 0xd1, 0x60, 0x57,
	0x61, 0x78, 0xf0, 0xe1, 0x22, 0xed, 0xae, 0xc7, 0x6f, 0xed, 0x31, 0x23, 0x6f, 0xec, 0x31, 0xa3,
	0xb7, 0xf7, 0x98, 0x71, 0xf1, 0xbc, 0x72, 0x9e, 0x3f, 0xaf, 0x5e, 0xce, 0x4c, 0x8c, 0xc2, 0xb1,
	0xc5, 0x2f, 0x0d, 0x83, 0x13, 0x71, 0xc0, 0x6b, 0x76, 0x1d, 0x7c, 0xa3, 0xdd, 0xe8, 0xe2, 0xd4,
	0x7b, 0x79, 0x30, 0xdb, 0x68, 0x76, 0x70, 0xbb, 0x9b, 0x44, 0xda, 0x66, 0x37, 0x89, 0x75, 0x69,
	0x37, 0xdb, 0x23, 0xf3, 0x1f, 0x7f, 0xde, 0x99, 0x49, 0x4a, 0xa4, 0xf5, 0xd9, 0xe7, 0x00, 0xc4,
	0x5b, 0x78, 0x1b, 0x37, 0xbb, 0xf5, 0x0e, 0xde, 0xc2, 0x41, 0xb7, 0xd5, 0x8e, 0x9d, 0x6f, 0x32,
	0xc9, 0x21, 0x32, 0xed, 0xe1, 0xf9, 0x17, 0xd2, 0x3f, 0x20, 0xe3, 0xcc, 0xa5, 0x65, 0xdd, 0xb4,
	0x28, 0x7b, 0x09, 0x4c, 0xec, 0xb4, 0x3a, 0x8d, 0x38, 0xef, 0x19, 0x89, 0x93, 0x83, 0xc5, 0xc3,
	0x6d, 0x51, 0xf4, 0xca, 0xa5, 0x6a, 0x5a, 0xd2, 0xe9, 0xd7, 0x61, 0xc3, 0x9e, 0xc6, 0x38, 0x8c,
	0xbb, 0xdd, 0x5b, 0x1a, 0x9e, 0x3b, 0x5c, 0xca, 0x61, 0xbd, 0x5e, 0xb2, 0x52, 0x01, 0x64, 0xf9,
	0xe9, 0x98, 0xcd, 0x6e, 0xfb, 0x66, 0xaf, 0x93, 0x29, 0x77, 0xe6, 0x05, 0xc0, 0xde, 0x59, 0x88,
	0x85, 0x60, 0xe4, 0x45, 0x7c, 0x33, 0x5d, 0x0e, 0xc8, 0x9f, 0xec, 0x09, 0x30, 0xfa, 0x12, 0xda,
	0xda, 0xed, 0x05, 0xdf, 0x04, 0x5c, 0x1c, 0xd6, 0x98, 0xc5, 0x5f, 0x67, 0xc0, 0x23, 0xee, 0x75,
	0xb4, 0x83, 0xab, 0xed, 0x16, 0x71, 0x0c, 0x1c, 0x9a, 0xcd, 0x70, 0xa7, 0xd5, 0x68, 0xf6, 0x42,
	0x71, 0x05, 0x40, 0xe2, 0xa4, 0xdd, 0x36, 0x8a, 0xa2, 0x46, 0x30, 0x98, 0x2d, 0x3d, 0x79, 0xa4,
	0x5b, 0x7a, 0x49, 0xe1, 0x38, 0x57, 0x9a, 0x45, 0x14, 0x66, 0x2b, 0x00, 0x6c, 0x37, 0xba, 0x8d,
	0xcd, 0x24, 0xa5, 0x4c, 0xc2, 0xc1, 0xd2, 0xe1, 0x92, 0x62, 0xbd, 0x72, 0xad, 0x6e, 0xb9, 0x5f,
	0x3e, 0xd1, 0xc9, 0x19, 0x90, 0xc0, 0x9e, 0x03, 0xd3, 0x37, 0xb0, 0x5f, 0xef, 0x04, 0x6d, 0xb4,
	0xd3, 0x0b, 0xa5, 0x13, 0x7d, 0x87, 0x74, 0xa6, 0x6e, 0x60, 0xdf, 0x4d, 0x9f, 0x2d, 0xfe, 0xce,
	0x30, 0x98, 0x3f, 0x4a, 0x28, 0x2b, 0xde, 0x7b, 0xcd, 0x19, 0xf4, 0xf3, 0x24, 0x54, 0xda, 0x60,
	0xd4, 0xdf, 0x6a, 0x05, 0x2f, 0xa6, 0x71, 0x55, 0xbd, 0x7b, 0x47, 0x72, 0xa4, 0xe8, 0xc1, 0x86,
	0x89, 0x55, 0x8a, 0x43, 0x4e, 0x22, 0x87, 0xbd, 0x0a, 0x26, 0xda, 0x38, 0x6c, 0xb4, 0x71, 0xd0,
	0x4d, 0x23, 0xd9, 0xc5, 0xbb, 0xcb, 0x74, 0xd2, 0xd2, 0x47, 0x88, 0xed, 0x4b, 0x63, 0x1d, 0x90,
	0x89, 0xb6, 0xd0, 0xe6, 0xfc, 0x68, 0x2c, 0xf5, 0x9b, 0xef, 0x2e, 0x75, 0x79, 0x0b, 0x6d, 0x1e,
	0x94, 0x98, 0xbf, 0xde, 0x6a, 0x04, 0x38, 0x95, 0x1b, 0xcb, 0xca, 0x65, 0xe9, 0xa9, 0x7d, 0xec,
	0xd6, 0x1e, 0x33, 0x9a, 0xae, 0x44, 0xa3, 0xf2, 0x79, 0xa9, 0xbf, 0x16, 0xfd, 0x06, 0x03, 0x9e,
	0xbe, 0x3f, 0xd1, 0xac, 0x0c, 0x40, 0xb3, 0x55, 0xbf, 0x8e, 0x51, 0x88, 0xdb, 0x9d, 0x7b, 0x2c,
	0xa9, 0x93, 0xcd, 0x56, 0x31, 0x29, 0xc8, 0xd6, 0x01, 0x71, 0x34, 0xdc, 0x0c, 0xfb, 0x55, 0x93,
	0x11, 0x51, 0xbe, 0xfa, 0x7e, 0xa6, 0x3d, 0x9c, 0x49, 0xe4, 0xa5, 0x0d, 0xe4, 0x9e, 0x06, 0xc7,
	0x3b, 0x03, 0xe2, 0xeb, 0x41, 0xac, 0xf2, 0x51, 0x8b, 0xef, 0xaf, 0x32, 0x20, 0x7b, 0xaf, 0x36,
	0xd8, 0x6f, 0x03, 0x27, 0x1b, 0xcd, 0x08, 0xb7, 0x71, 0x33, 0xc0, 0xa9, 0xdc, 0x81, 0x44, 0x2e,
	0xf7, 0xb6, 0xcf, 0xed, 0x31, 0x33, 0xb9, 0x56, 0xf7, 0x59, 0xab, 0x57, 0xe8, 0xcb, 0x7b, 0xcc,
	0x50, 0x1a, 0xf1, 0x5e, 0x63, 0x98, 0xf4, 0xaf, 0xb3, 0xaf, 0x0c, 0x3b, 0xc7, 0xfb, 0x72, 0x12,
	0x75, 0x49, 0xf2, 0xc7, 0xfa, 0xe0, 0x24, 0xda, 0xed, 0xb6, 0x92, 0x4c, 0x79, 0x50, 0x7c, 0x12,
	0x06, 0x2f, 0x7c, 0x6e, 0x8f, 0x39, 0x4e, 0xc4, 0x1b, 0xbb, 0xdd, 0xd6, 0x76, 0xac, 0xdb, 0xb3,
	0x44, 0xad, 0x23, 0x1b, 0x61, 0x89, 0xb4, 0xd8, 0x38, 0xfd, 0x36, 0x16, 0x7f, 0x78, 0x18, 0x3c,
	0x7e, 0x4f, 0xef, 0x66, 0x2f, 0x83, 0xb1, 0x4e, 0x17, 0x75, 0x77, 0x3b, 0x69, 0xe4, 0x78, 0xf4,
	0xc0, 0xa0, 0x14, 0xbb, 0xdd, 0x1d, 0x37, 0x2e, 0x90, 0x6f, 0x85, 0x38, 0x77, 0xfc, 0x73, 0x7b,
	0xcc, 0xb0, 0xbd, 0x4a, 0x9a, 0x9e, 0x78, 0x37, 0x33, 0x0a, 0x99, 0x45, 0x66, 0xc8, 0x49, 0x25,
	0xb0, 0xdf, 0xc5, 0x80, 0x8c, 0xdf, 0x0a, 0x6f, 0xa6, 0xbd, 0xd8, 0xfe, 0xdc, 0x1e, 0xb3, 0xe2,
	0x5d, 0xc7, 0xd9, 0x36, 0x7e, 0xe7, 0x2e, 0xee, 0x74, 0x71, 0x98, 0xad, 0x39, 0xa5, 0xec, 0x0d,
	0xd4, 0xc9, 0xb6, 0xf1, 0x3b, 0xe2, 0x80, 0xb6, 0x94, 0xad, 0x6e, 0x61, 0xd4, 0xc1, 0xd9, 0xa0,
	0xd5, 0xec, 0xec, 0x6e, 0x75, 0xb3, 0x37, 0x1a, 0xdd, 0xeb, 0xd9, 0x9b, 0xad, 0xdd, 0x76, 0x16,
	0x85, 0xdb, 0x8d, 0x66, 0xa3, 0xd3, 0x6d, 0xa3, 0x6e, 0xab, 0xbd, 0xf4, 0xe5, 0x3d, 0x26, 0xf3,
	0x89, 0x57, 0x99, 0x19, 0xd4, 0x09, 0x1a, 0x8d, 0xf3, 0x59, 0x1f, 0x75, 0xb0, 0x22, 0xc5, 0x5a,
	0xb4, 0xc7, 0xe6, 0x5f, 0xc9, 0x7e, 0x90, 0x61, 0x9c, 0xb8, 0x69, 0xf6, 0x02, 0x98, 0x24, 0xff,
	0xd6, 0xaf, 0xa3, 0xce, 0xf5, 0xd8, 0xcf, 0x26, 0x73, 0x6c, 0x1a, 0x19, 0xe2, 0x37, 0xac, 0x76,
	0x06, 0x66, 0xe7, 0xb3, 0xce, 0x04, 0x29, 0x54, 0x44, 0x9d, 0xeb, 0x8b, 0x05, 0xf0, 0xe4, 0xfd,
	0xcc, 0x57, 0xf6, 0x11, 0x30, 0xb2, 0xdb, 0x6e, 0x1c, 0x58, 0xdc, 0x48, 0xbb, 0x84, 0x5e, 0xfc,
	0x34, 0x03, 0xe6, 0xaa, 0x6d, 0x1c, 0x35, 0x5e, 0x2e, 0xa3, 0x6e, 0x70, 0xbd, 0xd4, 0xe8, 0x74,
	0x59, 0x17, 0x4c, 0xc5, 0x59, 0x1a, 0x61, 0x71, 0x92, 0xc3, 0x4f, 0xe6, 0x84, 0xde, 0x18, 0x82,
	0x0f, 0x31, 0xe3, 0x8b, 0xa3, 0xed, 0x91, 0x2f, 0xa7, 0x8a, 0xc5, 0xaf, 0x7e, 0x4c, 0x2f, 0x5f,
	0x9f, 0x60, 0x06, 0x32, 0x77, 0x40, 0x52, 0xb7, 0x44, 0x0a, 0x6b, 0x82, 0xe9, 0x46, 0xf3, 0x25,
	0xb2, 0xdc, 0x6e, 0x93, 0x86, 0x92, 0x55, 0x23, 0xb7, 0x78, 0x6b, 0x8f, 0x61, 0x3e, 0xf5, 0x2a,
	0x73, 0x06, 0xc0, 0x20, 0x6c, 0xd6, 0xb7, 0x5a, 0x28, 0xf4, 0xd1, 0x16, 0x6a, 0x06, 0xb8, 0x0d,
	0xc6, 0xb6, 0xd4, 0x3a, 0x0a, 0xb6, 0x9c, 0xa9, 0xa4, 0x5e, 0xac, 0xdf, 0xe2, 0x15, 0x30, 0x6d,
	0x74, 0x9a, 0xfb, 0xba, 0x1a, 0x00, 0xa0, 0x4e, 0xbd, 0xb9, 0xbb, 0xed, 0x93, 0xf9, 0x49, 0x54,
	0x9d, 0xc9, 0x2d, 0xf6, 0xdd, 0x8d, 0xbc, 0x4a, 0xc0, 0x43, 0x55, 0x9b, 0x44, 0x9d, 0x4a, 0x52,
	0x69, 0xf1, 0x36, 0x00, 0xa7, 0xdc, 0xc6, 0xf6, 0xce, 0x16, 0x5e, 0x47, 0x91, 0x49, 0xde, 0x35,
	0x3a, 0x64, 0x41, 0xd8, 0xdd, 0x8a, 0x03, 0x07, 0x6a, 0xde, 0xac, 0x87, 0xad, 0x6d, 0xd4, 0x68,
	0xa6, 0xb1, 0xf3, 0xc8, 0xc0, 0x81, 0x9a, 0x37, 0x0b, 0x71, 0x41, 0x56, 0x06, 0x53, 0xf8, 0x65,
	0x14, 0x74, 0xeb, 0xc9, 0x02, 0x39, 0x9d, 0x8c, 0x66, 0x4f, 0xab, 0xc9, 0xf6, 0x38, 0x64, 0xe6,
	0x5f, 0x19, 0xbe, 0x4e, 0x42, 0x3e, 0x88, 0x0b, 0xae, 0x91, 0x72, 0xac, 0x0a, 0xa6, 0x3b, 0xbb,
	0x51, 0xd4, 0x78, 0x39, 0xad, 0x37, 0x73, 0x97, 0x7a, 0x53, 0x49, 0xc9, 0xa4, 0xa2, 0x08, 0xc0,
	0x0e, 0xea, 0x5e, 0xaf, 0xb7, 0xf1, 0x26, 0x7e, 0x39, 0xce, 0x1f, 0x27, 0xd3, 0x77, 0xa9, 0x78,
	0x96, 0xa5, 0x7f, 0xdd, 0x62, 0x18, 0x67, 0x92, 0x94, 0x73, 0x48, 0x31, 0xf6, 0x2a, 0x18, 0xdf,
	0xc6, 0xdd, 0xeb, 0xad, 0xb0, 0x33, 0x3f, 0x1e, 0xbf, 0xa5, 0x9d, 0x3e, 0x64, 0x06, 0x95, 0xe3,
	0x12, 0xb9, 0x27, 0xf6, 0x07, 0xfe, 0xdd, 0xcc, 0x30, 0x64, 0xee, 0x34, 0xee, 0x3c, 0xe3, 0xf4,
	0xc4, 0xb1, 0xdb, 0x87, 0xbc, 0x08, 0x4e, 0x7c, 0x55, 0x2f, 0x82, 0x0f, 0x0f, 0x78, 0xfe, 0x3d,
	0xdf, 0x07, 0xcb, 0xe0, 0x04, 0x7e, 0x79, 0xa7, 0xd1, 0x4e, 0x36, 0x12, 0xfa, 0xfb, 0x82, 0xf3,
	0x93, 0xf1, 0x70, 0x9d, 0x59, 0x4a, 0x76, 0x0e, 0x97, 0x7a, 0x3b, 0x87, 0x4b, 0x5e, 0xaf, 0x84,
	0x73, 0x7c, 0xbf, 0x5e, 0x9f, 0x64, 0x2f, 0x82, 0x89, 0x6d, 0xdc, 0x45, 0x24, 0xe5, 0x9c, 0x07,
	0xb1, 0x88, 0x85, 0x03, 0x5a, 0x97, 0x71, 0xa7, 0x83, 0x36, 0x71, 0x19, 0x77, 0x51, 0x9c, 0x8e,
	0xf4, 0xcb, 0xb3, 0xef, 0xbe, 0x77, 0xfa, 0x3d, 0xf5, 0x75, 0x48, 0xbf, 0xef, 0x9a, 0x7c, 0x5f,
	0xfc, 0x85, 0xcc, 0x5b, 0x97, 0x66, 0x78, 0xee, 0x3c, 0xc9, 0x83, 0xd5, 0xf3, 0x3c, 0x7f, 0x5e,
	0x7f, 0x7d, 0x8f, 0xf9, 0x99, 0x0c, 0x78, 0x08, 0x64, 0x48, 0x7c, 0x3d, 0x33, 0x07, 0x66, 0x7a,
	0x0a, 0x2f, 0x91, 0xd8, 0x0d, 0xca, 0x60, 0x2c, 0x71, 0xdc, 0x73, 0x79, 0x60, 0x80, 0x63, 0x83,
	0x3e, 0x2f, 0x8c, 0x18, 0xcd, 0x9b, 0xe0, 0x04, 0xe5, 0xcf, 0xc2, 0xa8, 0x49, 0x00, 0x38, 0x45,
	0xbb, 0xab, 0x30, 0xe6, 0xc6, 0x08, 0x9c, 0x00, 0x99, 0x2a, 0xea, 0x5e, 0x3f, 0x33, 0x3d, 0xe8,
	0x95, 0x60, 0x1e, 0x8c, 0x27, 0xce, 0xd4, 0xc9, 0xcd, 0xf4, 0x3d, 0x0f, 0x8e, 0x70, 0x0c, 0xf8,
	0x16, 0x00, 0xfa, 0xbb, 0x44, 0x9d, 0x5c, 0x19, 0xe8, 0x77, 0xb7, 0xe0, 0xd2, 0xd1, 0xbb, 0x58,
	0x70, 0x74, 0x91, 0xda, 0xe0, 0xe3, 0x18, 0xf0, 0x1d, 0x00, 0xf4, 0xb7, 0x7e, 0x3a, 0x39, 0xe7,
	0xbe, 0x85, 0xdf, 0xb9, 0x33, 0x05, 0x47, 0x17, 0xef, 0xdc, 0xbf, 0xe4, 0x18, 0x10, 0x81, 0xe9,
	0x64, 0x47, 0x27, 0x1b, 0xa7, 0xcb, 0xb9, 0x35, 0xf0, 0x4d, 0xf7, 0xd9, 0xc6, 0x61, 0xbb, 0x4e,
	0x70, 0x74, 0xf1, 0xb0, 0xcd, 0x44, 0x8e, 0x01, 0x6e, 0xbc, 0x99, 0x91, 0x25, 0x43, 0xd8, 0xc9,
	0x2d, 0x03, 0xed, 0x3e, 0x1b, 0xb9, 0x63, 0x3f, 0x09, 0x8e, 0x2e, 0xf6, 0x37, 0x11, 0xc1, 0xdb,
	0xc0, 0x9c, 0xd9, 0x9f, 0x03, 0x59, 0x32, 0x09, 0xce, 0x9c, 0x3a, 0x7c, 0x3a, 0xe5, 0x9e, 0x04,
	0x33, 0x89, 0x4f, 0xf4, 0xd2, 0x14, 0xf2, 0xd2, 0x95, 0x79, 0x63, 0x8f, 0x19, 0x21, 0x2f, 0x5d,
	0xd2, 0x79, 0x5e, 0x38, 0xcf, 0xa7, 0xa9, 0xca, 0xe5, 0xcc, 0xc4, 0x30, 0x1c, 0xb9, 0x9c, 0x99,
	0x18, 0x81, 0x99, 0xf4, 0x35, 0xec, 0x03, 0x63, 0xe0, 0x78, 0x12, 0x64, 0xfb, 0x2f, 0x7a, 0x71,
	0x84, 0xfd, 0x83, 0xcc, 0xb6, 0x17, 0xe2, 0xd7, 0x88, 0xad, 0x9b, 0xf5, 0xfd, 0x77, 0xcd, 0xf9,
	0xb9, 0xbb, 0xef, 0x7a, 0xc4, 0xe5, 0xfb, 0x1a, 0xb0, 0x97, 0xd2, 0x6d, 0x93, 0x01, 0x01, 0xf0,
	0xae, 0x02, 0x66, 0x48, 0xf1, 0xfd, 0xfa, 0xf7, 0xbf, 0x3e, 0x30, 0x5f, 0xd3, 0xfa, 0xc0, 0x7c,
	0x8d, 0xeb, 0x03, 0x43, 0xaf, 0x0f, 0x02, 0xc8, 0x90, 0x99, 0x98, 0xee, 0x2c, 0x1c, 0x34, 0x30,
	0x99, 0xac, 0xf1, 0x82, 0x8a, 0xdb, 0xb1, 0x81, 0xe3, 0xb2, 0x17, 0xdf, 0x33, 0xfc, 0xd6, 0xa5,
	0x49, 0x9e, 0x3b, 0xcf, 0x4b, 0x24, 0x90, 0xbc, 0xbe, 0xc7, 0xfc, 0x16, 0x73, 0x74, 0x04, 0x29,
	0xf6, 0x23, 0xc8, 0x25, 0xf0, 0xcd, 0x87, 0x45, 0x90, 0x19, 0xaa, 0xc7, 0x60, 0x9e, 0xee, 0x09,
	0x3b, 0x71, 0xa6, 0x17, 0x3c, 0x56, 0x92, 0xe0, 0x71, 0xee, 0x79, 0xf0, 0x1c, 0x78, 0x08, 0x4c,
	0x11, 0x55, 0x96, 0x92, 0x4c, 0x84, 0x14, 0x4a, 0xb2, 0x09, 0x30, 0x05, 0x26, 0x93, 0x07, 0xa8,
	0x7b, 0x1d, 0x9c, 0x4c, 0xc2, 0xcc, 0x52, 0x1c, 0x66, 0xd8, 0xf1, 0x33, 0xa3, 0xf1, 0xf2, 0x06,
	0x4c, 0x30, 0x45, 0x1c, 0x2c, 0x9b, 0x64, 0x42, 0xe7, 0x14, 0x20, 0x81, 0xd3, 0x77, 0xfa, 0x8b,
	0x30, 0x6a, 0x10, 0x06, 0x3c, 0x74, 0x87, 0x23, 0x08, 0x19, 0xf7, 0xc5, 0xc6, 0x4e, 0xee, 0x69,
	0x30, 0x93, 0xbe, 0x8d, 0xa4, 0x5e, 0x7f, 0xf2, 0xd6, 0x1e, 0x33, 0xf7, 0xc6, 0x1e, 0x33, 0x4b,
	0xde, 0x47, 0x78, 0xf9, 0x3c, 0xaf, 0x7c, 0x69, 0x8f, 0x19, 0xba, 0xef, 0xd9, 0x31, 0x0b, 0xe7,
	0x92, 0x79, 0xb1, 0xf8, 0x7d, 0xc3, 0x60, 0xae, 0x80, 0x9b, 0x37, 0xad, 0x66, 0xd4, 0x6a, 0x27,
	0xb9, 0x32, 0x7b, 0x01, 0xcc, 0xb4, 0x71, 0x67, 0xa7, 0xd5, 0xec, 0x90, 0xf9, 0x1a, 0xe2, 0xf4,
	0x0b, 0x45, 0x12, 0xfa, 0xcf, 0x8d, 0xcc, 0xff, 0x62, 0xc6, 0x99, 0xee, 0x15, 0x20, 0x69, 0x2d,
	0xa9, 0x80, 0xdb, 0xed, 0x56, 0xbb, 0xbe, 0x9d, 0xcc, 0x92, 0x34, 0x83, 0x05, 0xfd, 0xc5, 0x3f,
	0xe3, 0x4c, 0xc7, 0x05, 0xd2, 0x59, 0xc4, 0x2e, 0x83, 0xe3, 0xbb, 0xcd, 0x10, 0x47, 0x8d, 0x26,
	0x0e, 0xeb, 0x1d, 0x1c, 0xd4, 0xf1, 0x4b, 0xb8, 0xd9, 0xbd, 0x47, 0x6a, 0x73, 0xac, 0x5f, 0xc5,
	0xc5, 0x81, 0x49, 0x2a, 0xb0, 0x17, 0xc1, 0x0c, 0xda, 0x69, 0x0c, 0x48, 0x18, 0xbd, 0xab, 0x84,
	0x29, 0xb4, 0xd3, 0xe8, 0xd5, 0xcd, 0x9d, 0x02, 0x20, 0xae, 0x93, 0xbc, 0xe0, 0x4d, 0xf4, 0x0c,
	0x95, 0xda, 0x65, 0xef, 0x19, 0x70, 0xda, 0xdb, 0xea, 0x2c, 0x37, 0x9a, 0x9b, 0xb8, 0xbd, 0xd3,
	0x6e, 0x34, 0xbb, 0x03, 0xce, 0xc9, 0xfa, 0x60, 0x3c, 0xd8, 0x42, 0x9d, 0x0e, 0xee, 0xed, 0x2d,
	0x1f, 0xf1, 0x9e, 0xbf, 0xda, 0x6c, 0xdd, 0x68, 0xd2, 0x62, 0xf2, 0xa4, 0x5e, 0x6e, 0xfe, 0xcb,
	0x7b, 0xcc, 0xf0, 0xe1, 0xf9, 0x4b, 0x2a, 0x98, 0xfd, 0xf0, 0x71, 0x30, 0x3d, 0xe0, 0xad, 0xc9,
	0x37, 0x89, 0xc9, 0xdc, 0x6f, 0xb3, 0xb7, 0xf7, 0x98, 0x9f, 0x67, 0x41, 0x96, 0x47, 0x48, 0xf5,
	0x23, 0xcd, 0xd7, 0x55, 0x2c, 0x4b, 0x5c, 0x80, 0x64, 0x1c, 0x86, 0xaa, 0x1c, 0xa9, 0xbe, 0x26,
	0x6a, 0x92, 0x1f, 0x21, 0x90, 0x15, 0x83, 0x10, 0xc9, 0x42, 0x88, 0x24, 0x14, 0x62, 0x4e, 0x8f,
	0xf8, 0x48, 0xd5, 0x78, 0x14, 0x0a, 0x58, 0x13, 0xc2, 0x20, 0x42, 0x02, 0x07, 0xb2, 0x6a, 0x18,
	0xca, 0x1c, 0xe6, 0x79, 0x21, 0x08, 0x05, 0x51, 0x15, 0x25, 0x24, 0xf2, 0x9c, 0xaf, 0x73, 0x91,
	0x12, 0x49, 0x12, 0x52, 0x83, 0x10, 0x64, 0x79, 0x1f, 0x8b, 0x38, 0xc0, 0x3e, 0x96, 0x11, 0xd2,
	0x43, 0x51, 0x91, 0x25, 0xac, 0x60, 0x95, 0x13, 0x43, 0x8d, 0x8f, 0x14, 0x5d, 0xd0, 0x40, 0x36,
	0x90, 0x05, 0x51, 0x0e, 0x45, 0xa4, 0xf9, 0xba, 0x2e, 0x4a, 0xbe, 0x1a, 0xf9, 0x7e, 0x28, 0x70,
	0x52, 0x28, 0x73, 0x7e, 0xc0, 0xc9, 0x5a, 0x08, 0xb2, 0x58, 0x11, 0x90, 0x1c, 0x49, 0xa1, 0x2c,
	0x6a, 0x81, 0x1f, 0xf1, 0x8a, 0x1e, 0x08, 0x28, 0x52, 0x79, 0x1f, 0x07, 0x82, 0xa8, 0xeb, 0xbe,
	0x04, 0xb2, 0xa1, 0xa0, 0x8b, 0x72, 0x20, 0x6b, 0x11, 0x56, 0x54, 0x45, 0x95, 0xa4, 0x08, 0x07,
	0x81, 0xa6, 0xf0, 0x12, 0xc6, 0xb2, 0x28, 0x2b, 0x81, 0x0a, 0xb2, 0x21, 0x0e, 0x22, 0x5f, 0xd2,
	0x90, 0x2c, 0xaa, 0x9a, 0x8e, 0x7d, 0xcc, 0x69, 0xbc, 0xaf, 0x69, 0x08, 0xf9, 0xbe, 0xac, 0x61,
	0x2c, 0x4a, 0x20, 0x2b, 0xf3, 0x81, 0x22, 0x05, 0xaa, 0x8a, 0x15, 0x2e, 0x12, 0x75, 0x8d, 0xc3,
	0x18, 0xe9, 0x9c, 0xa6, 0xe8, 0xbe, 0xa2, 0x05, 0xb2, 0x86, 0x88, 0xa6, 0xbe, 0xae, 0x21, 0x41,
	0xc2, 0x58, 0xf2, 0x75, 0x5e, 0x94, 0x24, 0x49, 0x8b, 0x22, 0x5f, 0x56, 0x79, 0x29, 0x0a, 0x35,
	0x95, 0x43, 0x01, 0xc8, 0x8a, 0x52, 0xc4, 0x4b, 0x48, 0xd1, 0x51, 0xa8, 0x72, 0x9c, 0x1e, 0x20,
	0x59, 0x53, 0x44, 0x51, 0xd5, 0x05, 0x5e, 0x43, 0x11, 0xaf, 0x46, 0x22, 0xc8, 0x86, 0xaa, 0x82,
	0xb1, 0x22, 0x45, 0xbe, 0x2a, 0xa8, 0xa2, 0x2a, 0x8a, 0x81, 0x8f, 0x25, 0x59, 0x46, 0x81, 0xc6,
	0x07, 0x82, 0x2e, 0x60, 0x05, 0x64, 0xb5, 0x48, 0x09, 0x74, 0x5e, 0x0b, 0x03, 0x5f, 0xd6, 0x64,
	0xec, 0xfb, 0x18, 0x71, 0x32, 0x16, 0x82, 0x40, 0x97, 0x64, 0x91, 0xc3, 0x22, 0xb1, 0x69, 0xc8,
	0xe9, 0x32, 0x56, 0x34, 0x49, 0xd3, 0x43, 0x31, 0x90, 0x45, 0x59, 0xd0, 0xd5, 0x20, 0xd4, 0xc2,
	0x28, 0xf2, 0x39, 0x25, 0xf0, 0x75, 0x90, 0x8d, 0x04, 0xc1, 0x0f, 0x43, 0x59, 0xc5, 0x22, 0x19,
	0x40, 0xac, 0x29, 0x41, 0x88, 0x24, 0x2e, 0x44, 0x42, 0xa8, 0x49, 0x58, 0x13, 0x7d, 0x90, 0x8d,
	0x7c, 0x59, 0xd3, 0x44, 0x3e, 0xd2, 0x74, 0x81, 0xd7, 0x39, 0x85, 0x98, 0x4c, 0x92, 0xb0, 0x20,
	0xfb, 0x81, 0x26, 0x72, 0xbe, 0x24, 0x83, 0x2c, 0x17, 0x04, 0x3c, 0xd6, 0x24, 0x59, 0xd1, 0xb0,
	0xa4, 0xf2, 0x08, 0xf1, 0xa1, 0x22, 0xa0, 0x50, 0xe2, 0x65, 0x0d, 0x85, 0x58, 0xf1, 0x65, 0x90,
	0x15, 0x38, 0x5d, 0xc0, 0x7c, 0x14, 0x45, 0xbe, 0x24, 0x87, 0x2a, 0x96, 0x10, 0xaf, 0x23, 0x59,
	0x8d, 0x74, 0x3f, 0x90, 0xb1, 0xc0, 0x89, 0x08, 0x64, 0x43, 0x5e, 0x43, 0x52, 0x88, 0x34, 0x09,
	0x45, 0xb2, 0x8e, 0x79, 0x9e, 0xd3, 0x34, 0x45, 0x40, 0xa2, 0xee, 0x23, 0xac, 0x06, 0x7a, 0x28,
	0x81, 0x2c, 0x52, 0x78, 0x41, 0xd7, 0x23, 0xdd, 0x97, 0x39, 0x1e, 0x85, 0x41, 0xa4, 0x68, 0x9c,
	0xaf, 0x0b, 0xaa, 0x1c, 0xaa, 0x7a, 0x28, 0xa1, 0x40, 0x01, 0x59, 0x5f, 0xd4, 0x14, 0x5d, 0x52,
	0x90, 0x8c, 0x24, 0x29, 0xe4, 0xc3, 0x30, 0x08, 0x34, 0x49, 0xf4, 0x03, 0x55, 0x16, 0x45, 0x25,
	0x8c, 0x02, 0x0c, 0xb2, 0x9a, 0xa4, 0x6b, 0x11, 0x96, 0x04, 0x45, 0x53, 0x15, 0x29, 0xf4, 0x23,
	0x5d, 0x50, 0x90, 0xa8, 0x09, 0x9a, 0x88, 0xf5, 0x50, 0x0c, 0xb5, 0x88, 0x68, 0x1a, 0x86, 0xbc,
	0xe6, 0x87, 0xa1, 0x28, 0x70, 0x3a, 0x46, 0x2a, 0xaf, 0xe9, 0x9a, 0xce, 0x89, 0x1c, 0x52, 0x22,
	0x5d, 0x14, 0x15, 0x09, 0x64, 0x35, 0x5d, 0xe7, 0x91, 0xa8, 0xa9, 0x58, 0x22, 0xf2, 0x79, 0x55,
	0xe2, 0x22, 0x41, 0x0e, 0x95, 0x48, 0xe6, 0x45, 0x3d, 0xd2, 0x85, 0x10, 0x64, 0xc5, 0x50, 0xd3,
	0x03, 0x2e, 0x8c, 0x7c, 0x3e, 0x42, 0x92, 0xa4, 0xf3, 0xbc, 0xaf, 0x45, 0x48, 0x95, 0x05, 0x11,
	0x47, 0x5a, 0x88, 0x43, 0x1f, 0x64, 0xb1, 0x28, 0x72, 0x7e, 0x80, 0x74, 0x3d, 0xd0, 0x90, 0x2c,
	0xc8, 0x0a, 0xc2, 0xbc, 0xa0, 0x20, 0x59, 0x0e, 0xa4, 0x40, 0x15, 0xe4, 0x40, 0x06, 0x59, 0x4d,
	0xc4, 0x9c, 0xe4, 0x07, 0xb2, 0x16, 0x4a, 0x9c, 0x10, 0xe9, 0x8a, 0x28, 0xea, 0x9a, 0x18, 0xf8,
	0x91, 0x20, 0xa8, 0x82, 0xe4, 0x73, 0x02, 0xc8, 0xfa, 0x5a, 0xa4, 0xf1, 0x8a, 0x2a, 0x06, 0x1c,
	0xe6, 0x43, 0x41, 0xd7, 0x39, 0x4d, 0x94, 0x94, 0x48, 0xf4, 0x91, 0xaf, 0xe9, 0x82, 0xaf, 0xfb,
	0x20, 0x1b, 0xca, 0x32, 0x1f, 0xa1, 0x28, 0x90, 0x22, 0x89, 0x8b, 0xf8, 0x10, 0x07, 0x82, 0xef,
	0x4b, 0xb2, 0xae, 0x71, 0x7e, 0x84, 0x74, 0x49, 0x17, 0x40, 0x56, 0xd0, 0x39, 0x4d, 0x8e, 0x38,
	0x31, 0xd2, 0xb0, 0x86, 0x38, 0x31, 0xe2, 0x7c, 0x51, 0xd7, 0x03, 0x39, 0x50, 0x83, 0x88, 0xf3,
	0x39, 0x5f, 0x23, 0xbe, 0x8e, 0x54, 0x14, 0xf2, 0x92, 0xcc, 0xe9, 0x51, 0xa8, 0xf0, 0x52, 0xa0,
	0xfa, 0xbe, 0x88, 0x64, 0x2e, 0x90, 0x74, 0x4d, 0xf0, 0xb5, 0x00, 0x64, 0xfd, 0x40, 0x09, 0x44,
	0x4d, 0x89, 0x24, 0x32, 0x11, 0x74, 0xd5, 0xd7, 0x43, 0x1d, 0xcb, 0x42, 0x28, 0xa9, 0x82, 0xaf,
	0xaa, 0x42, 0xa8, 0x81, 0xac, 0xcf, 0x8b, 0x21, 0xc7, 0x6b, 0x92, 0x82, 0x42, 0x15, 0xf1, 0x12,
	0x52, 0x39, 0x3f, 0x22, 0x26, 0xe5, 0x15, 0x55, 0x95, 0x03, 0x55, 0x03, 0x59, 0x45, 0xd7, 0xb0,
	0xa8, 0x08, 0xbc, 0x1e, 0x89, 0xba, 0xaa, 0x4b, 0x02, 0x17, 0x21, 0x41, 0xd6, 0x78, 0x5f, 0xe0,
	0x43, 0x14, 0xa8, 0x38, 0x00, 0x59, 0x5e, 0xe5, 0x05, 0x41, 0x53, 0x35, 0x8e, 0x43, 0x81, 0xce,
	0xfb, 0xa2, 0x14, 0xa0, 0x30, 0x94, 0x35, 0x4d, 0x0a, 0xb0, 0x26, 0xcb, 0x0a, 0xd1, 0x54, 0xe6,
	0xc2, 0x00, 0xf3, 0x5a, 0x88, 0x79, 0xdf, 0xe7, 0x25, 0x11, 0x2b, 0x7a, 0xa8, 0x84, 0xa1, 0x2e,
	0xf1, 0xa2, 0xaf, 0x89, 0xb2, 0x4c, 0x66, 0x14, 0x2f, 0x73, 0x28, 0x92, 0x64, 0x5e, 0xf2, 0x35,
	0x45, 0x0b, 0x71, 0xe4, 0x6b, 0xb2, 0x14, 0xfa, 0x5c, 0xa4, 0x08, 0x48, 0x92, 0x78, 0x90, 0x0d,
	0x23, 0x39, 0x10, 0x39, 0xac, 0xa8, 0x5c, 0xe8, 0x23, 0xe2, 0x6c, 0x82, 0xca, 0xe1, 0x50, 0x54,
	0x38, 0x85, 0x0b, 0x22, 0x4e, 0x96, 0x40, 0x56, 0x94, 0x03, 0x0e, 0x89, 0x7c, 0x20, 0x69, 0xbc,
	0x2e, 0xa8, 0x11, 0x27, 0x08, 0x48, 0xf4, 0x65, 0x91, 0x13, 0xc8, 0xd4, 0xe4, 0xb4, 0x38, 0xd2,
	0x05, 0x01, 0x96, 0x7d, 0x55, 0x09, 0x34, 0x9f, 0x57, 0x25, 0x55, 0x08, 0x39, 0x41, 0x52, 0x65,
	0x4d, 0x57, 0x39, 0x24, 0x71, 0x8a, 0x0f, 0xb2, 0x3a, 0xcf, 0x4b, 0xaa, 0x8e, 0x02, 0x0d, 0x71,
	0x1a, 0x2f, 0xe2, 0x90, 0x17, 0x24, 0xde, 0x17, 0x15, 0x4d, 0x09, 0x82, 0x10, 0x85, 0x58, 0x07,
	0x59, 0x4e, 0xc4, 0xbc, 0xa6, 0x20, 0x35, 0xd2, 0x44, 0x41, 0x93, 0xb1, 0x2e, 0x8a, 0x12, 0x1f,
	0x62, 0x49, 0xd5, 0x44, 0x51, 0xe2, 0x38, 0x05, 0x13, 0x7b, 0x44, 0xa1, 0xa4, 0xab, 0x82, 0x10,
	0x69, 0x21, 0xcf, 0x47, 0x62, 0xa8, 0x2a, 0x61, 0x80, 0x35, 0x29, 0xd2, 0x30, 0xa7, 0xeb, 0x48,
	0x25, 0xf3, 0x96, 0xe3, 0x38, 0x59, 0x46, 0x3c, 0xaf, 0x2b, 0x08, 0x63, 0xa4, 0x85, 0xbc, 0x1f,
	0x28, 0x9c, 0xae, 0x69, 0xb2, 0x8f, 0x74, 0x59, 0x04, 0x59, 0x4e, 0xd7, 0x22, 0x59, 0xc6, 0x82,
	0x1a, 0x6a, 0x81, 0xe4, 0x73, 0x48, 0xd6, 0x39, 0x9e, 0x13, 0x02, 0x3f, 0x24, 0x23, 0x1c, 0x91,
	0x59, 0x89, 0x45, 0x5f, 0x40, 0x3e, 0x1f, 0xe9, 0x48, 0x56, 0x22, 0x21, 0xf2, 0xa5, 0x40, 0x17,
	0x24, 0x2d, 0x12, 0x22, 0x89, 0x57, 0x44, 0x9e, 0x44, 0x7e, 0x49, 0xc1, 0x44, 0x11, 0xe4, 0x07,
	0x01, 0xd2, 0x30, 0xd2, 0x7d, 0x84, 0x74, 0x51, 0x08, 0x91, 0xa2, 0x45, 0xa1, 0x2f, 0x0b, 0x3a,
	0xc8, 0x4a, 0xa1, 0x8a, 0x04, 0x2d, 0x54, 0x22, 0x41, 0x50, 0x44, 0x1c, 0x2a, 0x7c, 0x88, 0x35,
	0x2d, 0x40, 0x8a, 0x82, 0x7d, 0x8e, 0xe7, 0xb1, 0x08, 0xb2, 0xbe, 0xe0, 0x2b, 0x7c, 0xe8, 0xab,
	0xbe, 0x2e, 0xe9, 0x1c, 0x52, 0xb8, 0x50, 0x50, 0xb9, 0x20, 0xf0, 0x05, 0xce, 0x97, 0x14, 0x41,
	0x13, 0x14, 0x90, 0xd5, 0x05, 0x59, 0xd5, 0x55, 0x8e, 0x8f, 0x78, 0x49, 0x56, 0x38, 0x19, 0xeb,
	0x38, 0x0c, 0x38, 0x9f, 0xe3, 0x91, 0xce, 0xf1, 0x81, 0x12, 0xca, 0x20, 0xab, 0x2a, 0x3a, 0x2f,
	0xe8, 0xaa, 0x4f, 0xaa, 0x21, 0x89, 0x17, 0x44, 0x31, 0x0a, 0x39, 0xc4, 0xf9, 0x08, 0x71, 0x48,
	0x54, 0xc8, 0xea, 0xc1, 0x2b, 0x38, 0x0a, 0x22, 0x0e, 0x73, 0x9c, 0xcc, 0x49, 0x61, 0x18, 0xe1,
	0x30, 0xc4, 0xbc, 0xe8, 0x47, 0x18, 0xe9, 0xba, 0xaa, 0xcb, 0x02, 0xc8, 0xf2, 0xb2, 0x24, 0x22,
	0x35, 0x90, 0x14, 0x45, 0x14, 0x51, 0x10, 0xa9, 0x24, 0xa8, 0x71, 0xbc, 0x8f, 0x82, 0xc0, 0x0f,
	0xb9, 0xd8, 0xc7, 0x42, 0x25, 0xe2, 0x24, 0x5f, 0x46, 0x3a, 0xcf, 0xf1, 0xbc, 0x1c, 0x49, 0xbe,
	0xcc, 0xe1, 0x00, 0x07, 0x9c, 0x1e, 0x4a, 0x1c, 0xe2, 0xc3, 0x08, 0x64, 0x75, 0x91, 0x14, 0x55,
	0x35, 0x21, 0x54, 0x24, 0x3d, 0xc4, 0xbe, 0xcc, 0x93, 0x80, 0x2a, 0xe1, 0xc0, 0x57, 0x79, 0xc9,
	0xf7, 0x39, 0x90, 0x95, 0xb1, 0xac, 0x8a, 0x81, 0x1e, 0xe8, 0x91, 0xe6, 0x23, 0x55, 0xe0, 0x70,
	0xa4, 0xfb, 0xbc, 0x86, 0xf5, 0x28, 0xc0, 0x02, 0x16, 0x22, 0x15, 0x64, 0x65, 0x9d, 0x43, 0x82,
	0x28, 0x84, 0x64, 0x69, 0x53, 0x24, 0x4e, 0x8f, 0x90, 0xaf, 0x0a, 0x58, 0x95, 0x05, 0xa4, 0x21,
	0x41, 0x21, 0x2b, 0x90, 0x26, 0xe9, 0x3e, 0x27, 0xf9, 0xa1, 0x1f, 0xf2, 0xa1, 0xe0, 0xeb, 0x9a,
	0x18, 0x29, 0x58, 0x43, 0x92, 0xac, 0x62, 0x4e, 0x11, 0x05, 0xb2, 0x02, 0xe9, 0x81, 0x20, 0x6b,
	0x3a, 0xe6, 0x03, 0x0e, 0xeb, 0x91, 0x2c, 0x8a, 0x88, 0x13, 0x84, 0x40, 0x11, 0x38, 0x39, 0xd2,
	0x55, 0x5e, 0xc7, 0x3c, 0xc8, 0xea, 0x0a, 0xf6, 0x91, 0x22, 0x90, 0xe5, 0x43, 0xf0, 0x25, 0x55,
	0xe1, 0x54, 0x5e, 0x17, 0x7c, 0xa4, 0x4a, 0xc4, 0xa1, 0x65, 0x1f, 0x81, 0xac, 0x1a, 0x48, 0x3c,
	0x17, 0x60, 0x4d, 0x14, 0xb0, 0x26, 0x69, 0x48, 0x14, 0x05, 0x5e, 0x12, 0x85, 0x40, 0x47, 0x9a,
	0x80, 0x75, 0x55, 0x20, 0x6b, 0x83, 0x12, 0x85, 0x9a, 0x88, 0x04, 0x3e, 0xd2, 0x23, 0x31, 0x90,
	0x23, 0x3d, 0x8a, 0x54, 0x5f, 0x0e, 0x14, 0xd1, 0xf7, 0x03, 0x5e, 0xd5, 0x43, 0x90, 0x15, 0x42,
	0x4d, 0xd5, 0xa5, 0xc0, 0x57, 0x7d, 0x99, 0xc4, 0x03, 0xd5, 0xc7, 0x58, 0x50, 0x74, 0x19, 0xab,
	0x7a, 0xc0, 0xcb, 0xaa, 0xc2, 0x81, 0x6c, 0x14, 0x6a, 0x5c, 0x84, 0xf4, 0x40, 0xe1, 0x05, 0x2e,
	0x08, 0x89, 0xa3, 0xca, 0x02, 0x27, 0xf3, 0x5c, 0x24, 0x06, 0x8a, 0x24, 0x91, 0xb5, 0x52, 0x56,
	0x23, 0x51, 0x91, 0x04, 0x5f, 0xc2, 0xa2, 0x8a, 0x05, 0x2d, 0x92, 0x03, 0x1f, 0x8b, 0x9c, 0xc0,
	0x05, 0xba, 0x28, 0xf2, 0xbe, 0x14, 0x80, 0xac, 0xce, 0x29, 0x1c, 0x27, 0x09, 0x49, 0xfc, 0x93,
	0xb1, 0x2a, 0xcb, 0x3e, 0x27, 0x89, 0x01, 0x27, 0xab, 0x82, 0x2c, 0x21, 0xe2, 0x85, 0x81, 0xcc,
	0x45, 0x0a, 0xc9, 0x1c, 0x78, 0x55, 0x54, 0x54, 0xc5, 0x97, 0x54, 0x1f, 0x29, 0x9c, 0x26, 0xfb,
	0x21, 0x17, 0x28, 0x01, 0xc6, 0x20, 0x1b, 0x08, 0x1c, 0xef, 0xeb, 0x42, 0xa4, 0xf9, 0x92, 0x26,
	0x46, 0x48, 0xd4, 0x34, 0x1f, 0xf3, 0xaa, 0x14, 0x2a, 0x8a, 0x46, 0x2c, 0x28, 0x81, 0xac, 0xaf,
	0x73, 0x7e, 0xe8, 0x63, 0x5d, 0xe1, 0x91, 0x22, 0x69, 0x11, 0x27, 0x09, 0x6a, 0xe8, 0x0b, 0x3c,
	0x42, 0x48, 0x09, 0x02, 0x5f, 0xd6, 0x41, 0x56, 0x8f, 0x14, 0x21, 0x90, 0x22, 0x41, 0xf1, 0x75,
	0x2e, 0x14, 0x43, 0x55, 0x56, 0x7d, 0x8c, 0x14, 0x4e, 0xc7, 0x9a, 0x10, 0x09, 0x18, 0x45, 0x83,
	0xfb, 0x89, 0x1f, 0x66, 0xb2, 0x87, 0xa6, 0x65, 0x53, 0xfb, 0x6f, 0x40, 0x1d, 0xf6, 0x63, 0xc7,
	0xc1, 0x5c, 0xfa, 0x66, 0x1b, 0xf6, 0xb2, 0xb3, 0x91, 0x07, 0xd9, 0xd9, 0x83, 0xec, 0xec, 0x41,
	0x76, 0xf6, 0x20, 0x3b, 0x7b, 0x90, 0x9d, 0x3d, 0xc8, 0xce, 0x1e, 0x64, 0x67, 0x0f, 0xb2, 0xb3,
	0x07, 0xd9, 0xd9, 0x1f, 0x6e, 0x76, 0x96, 0x3d, 0xe4, 0x63, 0x5c, 0x98, 0x24, 0x68, 0x8b, 0x5f,
	0x19, 0x01, 0x73, 0x07, 0x36, 0x94, 0xd9, 0x08, 0xcc, 0x24, 0x5b, 0xb8, 0xbd, 0x8c, 0x2d, 0xf9,
	0xa2, 0x6c, 0x0c, 0xca, 0xff, 0xe2, 0x30, 0x33, 0x08, 0xd3, 0xaf, 0x96, 0x3d, 0xf8, 0x26, 0x73,
	0xf8, 0x27, 0xc7, 0xe9, 0x44, 0x6e, 0x9a, 0x1c, 0x86, 0x87, 0x6e, 0xdb, 0x7d, 0x1d, 0x9a, 0xa1,
	0x52, 0xd0, 0x10, 0x4c, 0xc7, 0x5b, 0xcd, 0x74, 0xfa, 0x69, 0xdc, 0x5b, 0x6c, 0x0f, 0xde, 0x3a,
	0xaa, 0x95, 0x58, 0x6c, 0xda, 0xca, 0x1a, 0x98, 0x19, 0xdc, 0x21, 0xef, 0xcc, 0x8f, 0xc6, 0xcd,
	0xf0, 0xf1, 0x46, 0xff, 0x87, 0x98, 0xb1, 0xc5, 0x4c, 0x7b, 0xf8, 0xec, 0x0b, 0x47, 0x29, 0x3f,
	0xf8, 0xb9, 0x74, 0x7a, 0xe0, 0x4b, 0x40, 0x87, 0xfd, 0x16, 0x30, 0xdd, 0x6d, 0xa3, 0x66, 0x27,
	0x6a, 0xb5, 0xb7, 0x71, 0x3b, 0x39, 0x41, 0x36, 0x2b, 0x3c, 0x7e, 0xf8, 0x26, 0xaa, 0xb7, 0x5f,
	0x72, 0xe0, 0x6c, 0xee, 0xe4, 0xa0, 0xf0, 0x41, 0x61, 0x8b, 0x3f, 0x3e, 0x0c, 0xa6, 0x06, 0x07,
	0xbe, 0x76, 0x60, 0x40, 0xd2, 0x93, 0x04, 0xf7, 0x39, 0x02, 0x2f, 0xdc, 0xef, 0x08, 0x0c, 0xff,
	0xa1, 0x8c, 0x40, 0xfd, 0x80, 0xa5, 0x46, 0xee, 0xd7, 0x52, 0xf3, 0xb7, 0x06, 0xbf, 0x5c, 0x1f,
	0x6d, 0xad, 0x5f, 0x66, 0x00, 0x1c, 0xb0, 0x56, 0x0e, 0x75, 0x1a, 0xc1, 0x1f, 0xd0, 0x64, 0xf0,
	0xff, 0xab, 0xc9, 0x2e, 0xce, 0xbe, 0x7e, 0x69, 0x70, 0xfc, 0x17, 0x3f, 0x92, 0x01, 0xc7, 0xf2,
	0xad, 0xd6, 0x8b, 0x0d, 0x3c, 0xe8, 0x15, 0x0b, 0x20, 0x33, 0x70, 0x22, 0x09, 0x0c, 0x9c, 0x06,
	0x8a, 0x79, 0x76, 0x11, 0x4c, 0xec, 0xb4, 0x71, 0x07, 0x37, 0x83, 0xf4, 0x6c, 0x61, 0x2e, 0x93,
	0x9e, 0x8f, 0xeb, 0xf3, 0xec, 0x37, 0x81, 0x99, 0xe0, 0x3a, 0x0e, 0x5e, 0xac, 0x27, 0x4c, 0x37,
	0x3d, 0xd5, 0x7a, 0xd4, 0xe7, 0x87, 0xe9, 0xb8, 0x70, 0x35, 0x29, 0xcb, 0xe6, 0xc0, 0xb1, 0xa4,
	0x72, 0xb3, 0xd5, 0xed, 0x0b, 0x98, 0xb8, 0xab, 0x80, 0xb9, 0xb8, 0x42, 0xa5, 0xd5, 0xed, 0xc9,
	0x50, 0x41, 0xa6, 0xd1, 0xc5, 0xdb, 0xe9, 0x89, 0xb0, 0x23, 0xbc, 0x62, 0xa0, 0xd7, 0xc5, 0x21,
	0x27, 0xae, 0xc0, 0x3e, 0x05, 0x66, 0x07, 0xcf, 0xc1, 0xe0, 0x76, 0xfc, 0xed, 0x65, 0xc2, 0x99,
	0x19, 0x38, 0xe5, 0x82, 0xdb, 0x17, 0x7f, 0x8a, 0x79, 0xeb, 0xd2, 0x28, 0x7f, 0x5e, 0x39, 0x2f,
	0xbd, 0xbe, 0xc7, 0xfc, 0x18, 0x03, 0x66, 0xd3, 0x4f, 0x6f, 0x63, 0x89, 0xf1, 0xc0, 0x3a, 0x18,
	0xcd, 0x13, 0x95, 0xce, 0x55, 0x40, 0x09, 0xcc, 0x1f, 0xb0, 0x86, 0x30, 0x9e, 0xaa, 0x09, 0xb2,
	0x87, 0x74, 0x55, 0x98, 0xaa, 0xb4, 0xba, 0xd9, 0x5e, 0x89, 0xd9, 0xa4, 0x23, 0xc2, 0x58, 0x32,
	0x86, 0x60, 0x01, 0x24, 0x9f, 0xf7, 0x73, 0x27, 0xc1, 0x31, 0xf2, 0x60, 0x69, 0xd0, 0x1d, 0xe1,
	0x30, 0x79, 0x1e, 0x7f, 0x60, 0xeb, 0x3f, 0x1f, 0xf4, 0x2b, 0x38, 0x9c, 0x3b, 0x03, 0x46, 0xe3,
	0x8e, 0xc5, 0x07, 0xf7, 0x46, 0xde, 0xd8, 0x63, 0xc6, 0x6e, 0xef, 0x31, 0xa3, 0xe2, 0x79, 0xf5,
	0xbc, 0x76, 0x39, 0x33, 0x31, 0x06, 0xc7, 0xd3, 0x0f, 0xc2, 0x1f, 0xcf, 0x80, 0x59, 0xa3, 0xbd,
	0x39, 0xe8, 0x18, 0x67, 0x29, 0xc7, 0xe8, 0x1d, 0x60, 0xf9, 0x22, 0x75, 0x60, 0xec, 0x81, 0x8b,
	0xfc, 0xd1, 0x71, 0x91, 0x1f, 0xca, 0x80, 0x63, 0xc9, 0xb9, 0xc0, 0x7b, 0x7b, 0xc9, 0x6b, 0x0f,
	0xbc, 0xe4, 0x8f, 0xa8, 0x97, 0xbc, 0x35, 0x02, 0x4e, 0xdd, 0xe1, 0x25, 0xc9, 0x62, 0x7a, 0xff,
	0xae, 0xf2, 0x0d, 0xeb, 0x06, 0x17, 0x5f, 0x63, 0x5e, 0xbf, 0x74, 0xe7, 0x2c, 0x79, 0xeb, 0xd2,
	0x08, 0x1f, 0x9f, 0xda, 0xf8, 0x46, 0x1a, 0xf1, 0x27, 0x7a, 0x23, 0x7e, 0xe6, 0x8e, 0x11, 0x7f,
	0xf7, 0x57, 0x98, 0xe4, 0x59, 0x32, 0xf4, 0x8b, 0x1f, 0xcb, 0x80, 0xd3, 0x57, 0x76, 0x71, 0xfb,
	0x66, 0x15, 0xb5, 0xd1, 0x36, 0xee, 0xd2, 0x21, 0xe2, 0x91, 0x81, 0xcb, 0x0a, 0x54, 0x82, 0x11,
	0x5f, 0x5c, 0x78, 0x10, 0x16, 0x70, 0xfb, 0xe2, 0x4f, 0x0e, 0x86, 0x85, 0x4f, 0x32, 0x60, 0x26,
	0x75, 0x92, 0xd1, 0xd8, 0x74, 0xdf, 0xf8, 0x51, 0xe1, 0xc3, 0x0c, 0x38, 0xb9, 0x7f, 0x80, 0x75,
	0xd0, 0x39, 0x06, 0xce, 0xbd, 0x32, 0x5f, 0xdf, 0x73, 0xaf, 0x77, 0x9a, 0x7e, 0xf8, 0x10, 0xd3,
	0x2f, 0x0a, 0x60, 0xce, 0x69, 0x6d, 0x51, 0x29, 0xf1, 0x63, 0x69, 0xaf, 0x52, 0x97, 0x9d, 0x4c,
	0x2f, 0x11, 0x9d, 0x7d, 0xde, 0x49, 0xf8, 0xc5, 0x9f, 0x66, 0xc0, 0x31, 0xb7, 0x1b, 0x5f, 0xf3,
	0x1a, 0xa8, 0x76, 0x7d, 0xbf, 0x1a, 0x49, 0xe7, 0x9d, 0xcf, 0xbe, 0xca, 0x9c, 0x9f, 0x60, 0x16,
	0x1f, 0xe9, 0xec, 0xe0, 0x60, 0x09, 0xed, 0x34, 0xea, 0x9b, 0xed, 0xd6, 0xee, 0x4e, 0x4f, 0x9b,
	0xa5, 0xf8, 0xdf, 0xb3, 0x0c, 0xc7, 0x5c, 0x1c, 0x0b, 0x5a, 0xcd, 0xa8, 0xb1, 0x49, 0xbd, 0x4c,
	0x3e, 0x7f, 0xe8, 0x8b, 0x57, 0x6a, 0x6d, 0xf1, 0xf0, 0xae, 0xe5, 0xa6, 0x3f, 0xf5, 0x2a, 0x33,
	0xd1, 0x3f, 0xa9, 0x4d, 0x77, 0x34, 0x3d, 0xcf, 0xf3, 0xfd, 0x0c, 0x98, 0xb1, 0x76, 0x06, 0xd5,
	0xde, 0x00, 0x53, 0xe9, 0x7e, 0x40, 0x07, 0x77, 0xef, 0xff, 0xc2, 0x7a, 0xff, 0x4c, 0x3a, 0xa9,
	0x36, 0x70, 0x61, 0x1d, 0x24, 0xac, 0x8b, 0xbb, 0x1d, 0xf6, 0xed, 0x47, 0xe8, 0x99, 0x21, 0xef,
	0x64, 0x07, 0x07, 0x22, 0x00, 0xb3, 0xbd, 0xb3, 0xe4, 0xa9, 0x66, 0x57, 0xc0, 0x04, 0xea, 0x34,
	0xef, 0x5f, 0xad, 0xf9, 0x4f, 0xbd, 0x6b, 0xca, 0xdf, 0xdc, 0xa9, 0xa7, 0x95, 0x06, 0x94, 0x1a,
	0x47, 0x9d, 0x26, 0xd1, 0x68, 0xb1, 0x03, 0xe6, 0xaa, 0xad, 0x36, 0x75, 0x86, 0x49, 0x07, 0xa3,
	0x3b, 0xad, 0x76, 0xb7, 0xf7, 0x72, 0xf7, 0xc4, 0xe0, 0x7b, 0xd6, 0x67, 0x8e, 0x78, 0xcf, 0x4a,
	0x6a, 0xdc, 0xaf, 0x8b, 0xfd, 0xe6, 0x30, 0x18, 0xaf, 0x39, 0x25, 0x8b, 0x04, 0x84, 0x25, 0x30,
	0x9d, 0x9e, 0x4c, 0xdb, 0xbf, 0xae, 0xb5, 0xef, 0x62, 0xc9, 0x61, 0xf2, 0xa4, 0x40, 0x72, 0x58,
	0xf0, 0x42, 0xbf, 0x7c, 0x72, 0x9c, 0x7c, 0x84, 0x8a, 0xa2, 0xb7, 0x98, 0x81, 0x0a, 0xc9, 0x41,
	0x72, 0x39, 0x3d, 0xe7, 0x9b, 0x88, 0x1f, 0xa5, 0x93, 0xf7, 0xe1, 0xde, 0x5a, 0x3b, 0xff, 0xca,
	0x70, 0x31, 0x3d, 0x7f, 0xde, 0x3b, 0xcd, 0x18, 0x9f, 0xee, 0x4b, 0xc7, 0x34, 0x0e, 0xb0, 0x47,
	0xd7, 0x8b, 0x5b, 0x48, 0x4e, 0xff, 0xf5, 0xdb, 0x3b, 0xec, 0xb4, 0xfb, 0xfc, 0xe0, 0x69, 0xf7,
	0xe2, 0xe0, 0x79, 0xf7, 0x8b, 0xd3, 0xf1, 0x9a, 0x48, 0xc2, 0xdd, 0x30, 0x64, 0x72, 0xd9, 0x83,
	0xe7, 0xf5, 0x0e, 0x5e, 0xba, 0xc9, 0x65, 0x53, 0xfd, 0xd2, 0xe7, 0x24, 0xde, 0x8c, 0xbd, 0xb1,
	0xc7, 0x64, 0x92, 0x7b, 0x48, 0xea, 0x79, 0xa5, 0x7f, 0xd6, 0x35, 0x03, 0x47, 0x17, 0x3f, 0xc2,
	0x80, 0xd9, 0x9a, 0x53, 0x1a, 0x1c, 0xe6, 0x6b, 0x60, 0x72, 0xb7, 0xbd, 0x55, 0x27, 0x51, 0xac,
	0xe7, 0x4d, 0x8f, 0x1e, 0x1e, 0xc7, 0xd3, 0xa1, 0xca, 0x2d, 0xdc, 0x39, 0x05, 0xa9, 0x4b, 0x0b,
	0x13, 0xbb, 0xed, 0x2d, 0x52, 0xf0, 0xab, 0xf4, 0xf3, 0x4f, 0x30, 0xe0, 0x58, 0x49, 0x2a, 0xe0,
	0x0e, 0xe5, 0x85, 0x1e, 0x98, 0xd8, 0x92, 0xea, 0x21, 0xee, 0xf4, 0xaf, 0x98, 0x1f, 0x0c, 0x84,
	0x49, 0x9d, 0xd8, 0xd1, 0x17, 0xee, 0xdc, 0xfc, 0xa3, 0x34, 0x1b, 0xdf, 0x8a, 0xcb, 0x1e, 0xa6,
	0xd8, 0xc8, 0x91, 0x8a, 0x0d, 0x1e, 0x16, 0x5e, 0xfc, 0x59, 0x06, 0xcc, 0xe5, 0x5b, 0xbb, 0xcd,
	0x6e, 0xfb, 0x66, 0xbe, 0x15, 0xe2, 0xf8, 0x72, 0xc7, 0x3b, 0xc0, 0x4c, 0x90, 0x50, 0xf1, 0x69,
	0xc8, 0x5e, 0xc0, 0x7e, 0xfc, 0xa8, 0xfb, 0x8e, 0xfd, 0xda, 0x07, 0xae, 0x80, 0x1c, 0x6e, 0xcd,
	0xe9, 0x60, 0xbf, 0xc2, 0xd7, 0xed, 0x7e, 0xca, 0x45, 0x30, 0x4b, 0xd6, 0x8f, 0x81, 0x2b, 0x53,
	0xf7, 0x9d, 0x84, 0x2e, 0x72, 0x49, 0xdd, 0x64, 0xc7, 0x24, 0xae, 0x7b, 0x8f, 0xad, 0x92, 0x45,
	0x05, 0x9c, 0x22, 0x35, 0xe8, 0x4c, 0x28, 0xae, 0x79, 0xd7, 0x14, 0x68, 0xf1, 0xf7, 0x86, 0xc1,
	0xf1, 0xcb, 0x37, 0xba, 0x5e, 0xeb, 0x45, 0xdc, 0x34, 0x76, 0xbb, 0xd7, 0xed, 0xe4, 0x17, 0x49,
	0x58, 0x0d, 0x80, 0x0e, 0x0e, 0xda, 0xb8, 0x5b, 0xef, 0x55, 0xbe, 0xd3, 0x2b, 0xdc, 0xb8, 0x40,
	0x7c, 0x52, 0x78, 0x32, 0x29, 0xbc, 0x8a, 0x6f, 0xb2, 0x97, 0xc0, 0x58, 0x72, 0x1d, 0x2c, 0xcd,
	0x58, 0x8e, 0xb8, 0xc8, 0x49, 0xdb, 0xa6, 0x38, 0xe4, 0xa4, 0xb5, 0x48, 0xfd, 0x20, 0xee, 0x77,
	0x7a, 0x14, 0xf5, 0x2e, 0xf5, 0xf7, 0xed, 0x43, 0xea, 0x27, 0xb5, 0x58, 0x1b, 0x4c, 0xbd, 0x93,
	0x58, 0xa1, 0xbe, 0x43, 0xcc, 0x90, 0x9e, 0x46, 0x3d, 0x7f, 0xb4, 0x90, 0x3b, 0x4d, 0x56, 0x1c,
	0x72, 0xc0, 0x3b, 0xfb, 0x2c, 0xab, 0x83, 0x69, 0x1f, 0xa3, 0x36, 0x6e, 0xd7, 0xbb, 0xc4, 0x4a,
	0x77, 0xbb, 0x95, 0x4d, 0x02, 0x62, 0x52, 0x36, 0x36, 0x68, 0x6e, 0x1e, 0x4c, 0xc7, 0x75, 0xea,
	0x9d, 0xd6, 0x6e, 0x3b, 0x48, 0x4e, 0xb8, 0x92, 0x54, 0xa5, 0xe7, 0xea, 0xef, 0x67, 0xc0, 0xbc,
	0x55, 0xf5, 0xae, 0xb7, 0x31, 0xea, 0xe6, 0x51, 0x17, 0x6f, 0xb6, 0xda, 0x37, 0x89, 0xbf, 0xc7,
	0xd3, 0xb2, 0x09, 0x4e, 0x34, 0x76, 0xea, 0xdd, 0xf8, 0x61, 0x3d, 0x48, 0x9e, 0x36, 0xf0, 0x51,
	0xbf, 0xa4, 0x90, 0xf6, 0xe8, 0xa0, 0xb4, 0x81, 0xdd, 0xda, 0xc1, 0xcd, 0x7a, 0xb6, 0xb1, 0x43,
	0x95, 0x6b, 0xe0, 0xce, 0xe2, 0xf7, 0x8e, 0x81, 0x99, 0xfc, 0x56, 0x03, 0xf7, 0x8f, 0xd9, 0xf6,
	0x0e, 0xb5, 0x07, 0x31, 0x79, 0xaf, 0xdb, 0x92, 0xa8, 0x79, 0x33, 0xa9, 0xcd, 0x6e, 0x82, 0x87,
	0xee, 0x50, 0xfc, 0x66, 0x7c, 0xb1, 0x27, 0x75, 0x89, 0xa5, 0xfb, 0xd3, 0xbd, 0x67, 0x89, 0xe2,
	0x90, 0x73, 0xe2, 0x80, 0xbe, 0xf1, 0x33, 0x76, 0x1d, 0xcc, 0x25, 0xba, 0xed, 0x5f, 0xc2, 0x4e,
	0x7c, 0x26, 0x7b, 0x30, 0x7e, 0x21, 0x1f, 0x6f, 0xf5, 0x6e, 0x5f, 0xc7, 0x61, 0x0c, 0xfc, 0xc0,
	0xab, 0xcc, 0x18, 0xc8, 0x30, 0xc3, 0x23, 0x99, 0xe2, 0x90, 0x33, 0x9b, 0x88, 0xe9, 0xdf, 0xcf,
	0x7e, 0x16, 0x8c, 0x91, 0x8e, 0x37, 0x76, 0xee, 0x9a, 0xac, 0x33, 0xce, 0x28, 0x6a, 0xde, 0xb4,
	0x76, 0xd8, 0x32, 0x98, 0xdd, 0x4f, 0x49, 0xe2, 0x7e, 0x26, 0x37, 0x8e, 0x9e, 0x3a, 0xbc, 0x9f,
	0x07, 0x6e, 0xd9, 0x15, 0x19, 0x67, 0xba, 0x77, 0x3d, 0x2e, 0xee, 0x56, 0x01, 0x80, 0x46, 0x3f,
	0x57, 0x4b, 0xef, 0x42, 0x3c, 0x71, 0x84, 0xc9, 0x06, 0xd3, 0x29, 0xb2, 0xca, 0x35, 0x7a, 0x04,
	0xfb, 0x7c, 0x92, 0xc1, 0xc4, 0xea, 0x24, 0x57, 0x8d, 0x8e, 0xb8, 0x63, 0x3e, 0x78, 0x8b, 0xae,
	0xc8, 0xc4, 0xf9, 0x4a, 0xac, 0xc6, 0x0a, 0x98, 0x22, 0x02, 0x7a, 0x7a, 0x4c, 0xdf, 0x6d, 0x36,
	0xd2, 0xd9, 0x13, 0x59, 0xa6, 0x51, 0x9f, 0x61, 0xb7, 0xc1, 0x43, 0xdd, 0xad, 0x4e, 0x3d, 0xda,
	0x3f, 0x80, 0xdd, 0x17, 0x3a, 0x13, 0x0b, 0xbd, 0x70, 0xc4, 0x56, 0xfa, 0x51, 0x67, 0xbf, 0xd3,
	0x35, 0xe4, 0x64, 0xf7, 0xb0, 0x02, 0xb9, 0xd3, 0x60, 0x26, 0xf5, 0x8a, 0x74, 0xc1, 0x9e, 0xe8,
	0x2d, 0xe8, 0xb9, 0x47, 0x01, 0xc9, 0x1d, 0x49, 0xaf, 0xd2, 0x47, 0xd3, 0xb7, 0xf6, 0x98, 0x89,
	0xd7, 0xf6, 0x18, 0xe6, 0x8d, 0x3d, 0x66, 0xbc, 0xbf, 0x0a, 0x8d, 0xc3, 0x89, 0xc5, 0x8f, 0x0e,
	0x83, 0x59, 0x27, 0xb9, 0xf5, 0xd9, 0xeb, 0xc7, 0xb7, 0x83, 0xe9, 0x81, 0xc8, 0xd2, 0x5b, 0xc9,
	0x8f, 0x50, 0xfe, 0xc8, 0x77, 0xd2, 0x34, 0x06, 0xc7, 0x69, 0x9d, 0x33, 0xb5, 0x1f, 0x67, 0x3a,
	0x6c, 0x19, 0x8c, 0xef, 0xdf, 0x4c, 0x26, 0xa2, 0x9f, 0x39, 0x22, 0x6a, 0xdd, 0xb1, 0xc7, 0x31,
	0x28, 0xb2, 0x27, 0x83, 0xfd, 0x56, 0x30, 0x97, 0x84, 0xc4, 0x9e, 0xb5, 0x7b, 0x3f, 0x64, 0xf3,
	0xcc, 0x51, 0xab, 0xe6, 0x81, 0xfd, 0x79, 0x4a, 0xec, 0x6c, 0x30, 0xf8, 0xb8, 0x73, 0xee, 0x3b,
	0xc1, 0x4c, 0x35, 0xae, 0xe7, 0x26, 0x4b, 0x00, 0x7b, 0x02, 0xc0, 0x8a, 0xe9, 0xad, 0xdb, 0xce,
	0x6a, 0xdd, 0x35, 0xf3, 0x35, 0xc7, 0xf2, 0x36, 0xe0, 0x10, 0x7b, 0x0c, 0xcc, 0x38, 0x86, 0x67,
	0xd6, 0x4b, 0x56, 0xd9, 0xf2, 0xac, 0xca, 0x0a, 0x64, 0xd8, 0x79, 0x70, 0xa2, 0x6a, 0x97, 0xac,
	0xfc, 0x46, 0x3d, 0x67, 0xb8, 0x66, 0xa1, 0xee, 0xd8, 0xb5, 0xf8, 0xc9, 0x30, 0x29, 0xbc, 0x6e,
	0x2c, 0xd7, 0xcd, 0xab, 0xf9, 0x52, 0xcd, 0xb5, 0xec, 0x0a, 0x1c, 0x21, 0x85, 0xdd, 0xa2, 0x51,
	0x35, 0xeb, 0x39, 0xdb, 0xab, 0x57, 0x1d, 0xdb, 0x33, 0xf3, 0x1e, 0x79, 0x92, 0x39, 0xe7, 0x82,
	0xd9, 0xbe, 0x02, 0x6e, 0xd0, 0x8a, 0x3f, 0x27, 0x9c, 0x49, 0x05, 0xbb, 0xa6, 0x57, 0x77, 0xf3,
	0x76, 0xd5, 0xac, 0x57, 0x8c, 0xb2, 0xe9, 0x56, 0x8d, 0xbc, 0x09, 0x87, 0xd8, 0xc7, 0xc1, 0xa3,
	0x77, 0x3c, 0x5f, 0xb3, 0x1c, 0xaf, 0x66, 0x94, 0xea, 0x45, 0xdb, 0xf5, 0x20, 0x73, 0xee, 0x2a,
	0x38, 0x95, 0xfc, 0x34, 0xc7, 0xb6, 0xdf, 0x68, 0x36, 0x9a, 0x9b, 0xc6, 0x16, 0x09, 0x8e, 0xdd,
	0xeb, 0xdb, 0xec, 0x1c, 0x98, 0x5a, 0xb6, 0x1c, 0xd7, 0xab, 0x97, 0x0d, 0x2f, 0x5f, 0x84, 0x43,
	0x2c, 0x0b, 0x66, 0x0b, 0x66, 0x65, 0xa3, 0x6e, 0xaf, 0x99, 0x8e, 0x63, 0x15, 0x4c, 0x17, 0x32,
	0xec, 0x71, 0x30, 0x67, 0x94, 0x4a, 0xf6, 0xfa, 0x00, 0x39, 0x7c, 0x86, 0x38, 0xeb, 0xd0, 0xb9,
	0x5b, 0x0c, 0x98, 0x1a, 0xf8, 0x36, 0xc4, 0x9e, 0x01, 0xd0, 0x73, 0x8c, 0x8a, 0xbb, 0x6c, 0x3b,
	0x65, 0xd3, 0xa9, 0x57, 0xec, 0x8a, 0x09, 0x87, 0xe2, 0xb2, 0x0c, 0x3b, 0x0b, 0x40, 0xc9, 0x5e,
	0x37, 0x9d, 0x7a, 0xde, 0x70, 0x4d, 0x18, 0xe3, 0x5a, 0xb5, 0xda, 0xc3, 0xb1, 0x9d, 0x88, 0xe9,
	0x14, 0xa9, 0x5e, 0x30, 0xf3, 0x76, 0xc1, 0x84, 0x23, 0x44, 0x9b, 0x8a, 0xed, 0x94, 0x8d, 0x92,
	0x75, 0xcd, 0xac, 0x57, 0x0d, 0xaf, 0x08, 0x33, 0xec, 0x49, 0x70, 0xcc, 0x31, 0xcb, 0xf6, 0x9a,
	0x59, 0x5f, 0x2f, 0x5a, 0x5e, 0x6a, 0x86, 0xd1, 0x58, 0x9a, 0x53, 0xea, 0x55, 0x1d, 0x63, 0x67,
	0xc0, 0xa4, 0xe7, 0x58, 0xe5, 0x7a, 0xc9, 0x5c, 0xf6, 0xe0, 0x38, 0x79, 0x1c, 0x43, 0xc7, 0x5a,
	0x29, 0x7a, 0x70, 0x82, 0x9d, 0x00, 0x19, 0x82, 0xe1, 0xe4, 0xb9, 0xdf, 0x9f, 0x01, 0x53, 0x35,
	0xa7, 0xd4, 0x0b, 0xc1, 0x44, 0x8d, 0x5a, 0x25, 0x6f, 0x78, 0xe6, 0x8a, 0xed, 0x58, 0xd7, 0xcc,
	0x02, 0x1c, 0x22, 0x56, 0x72, 0x4c, 0xa3, 0x54, 0x37, 0x5d, 0xcf, 0xf0, 0x88, 0xea, 0x8b, 0x60,
	0x21, 0x6f, 0x97, 0xab, 0x35, 0xcf, 0x74, 0xea, 0x46, 0xa5, 0x50, 0xb7, 0x2a, 0x9e, 0xe9, 0x54,
	0x88, 0xf9, 0x7b, 0x3e, 0x32, 0xcc, 0x9e, 0x02, 0xec, 0xb2, 0x55, 0x31, 0x2a, 0x79, 0xcb, 0x28,
	0xd5, 0x5d, 0xd3, 0x59, 0xb3, 0xf2, 0xa6, 0x9b, 0x8c, 0x7d, 0xae, 0xe6, 0x5a, 0x15, 0xd3, 0x75,
	0xe3, 0xba, 0x66, 0xde, 0xae, 0xd8, 0xe5, 0x0d, 0x98, 0x21, 0x23, 0x7d, 0xb8, 0x54, 0xab, 0xb2,
	0x6c, 0xc3, 0x51, 0x76, 0x1a, 0x4c, 0x18, 0xb5, 0xd8, 0x51, 0x5c, 0x38, 0x46, 0x90, 0x5b, 0xb4,
	0xab, 0x55, 0xe2, 0x64, 0xe3, 0x64, 0x8c, 0xf2, 0xb5, 0x92, 0x17, 0xd7, 0xb3, 0xf3, 0xe4, 0x4f,
	0x38, 0xc1, 0x02, 0x30, 0xe6, 0x39, 0xc6, 0x9a, 0x59, 0x82, 0x93, 0x2c, 0x04, 0xd3, 0x46, 0xae,
	0x46, 0x3c, 0xb3, 0xe0, 0xd4, 0x56, 0x5c, 0x08, 0xd8, 0xd3, 0xe0, 0xa4, 0x51, 0xe8, 0xd5, 0xa9,
	0xda, 0x4e, 0xc5, 0x5e, 0x71, 0x8c, 0x6a, 0x71, 0x03, 0x4e, 0x11, 0x69, 0x45, 0xbb, 0x6c, 0xc6,
	0x4f, 0x56, 0x0c, 0xa7, 0x60, 0x56, 0xe0, 0x34, 0x69, 0xb0, 0x6c, 0x95, 0x2c, 0xcf, 0x70, 0x36,
	0xe0, 0x0c, 0x19, 0x06, 0xd7, 0x8e, 0xfb, 0x96, 0xce, 0x0f, 0xa2, 0xc7, 0x2c, 0xb1, 0x73, 0xc1,
	0x34, 0x0a, 0x75, 0x97, 0x0c, 0x0d, 0x9c, 0x63, 0x9f, 0x02, 0x8f, 0x5b, 0x95, 0x82, 0xb5, 0x66,
	0x15, 0x88, 0x3f, 0xba, 0x9e, 0x9d, 0x5f, 0xad, 0x1b, 0x05, 0x62, 0x8b, 0x58, 0xb8, 0x67, 0xdb,
	0x25, 0x17, 0x42, 0x62, 0x2c, 0xcf, 0x31, 0xac, 0x8a, 0x55, 0x59, 0x19, 0xe0, 0x8f, 0x91, 0x1e,
	0x14, 0x8c, 0x78, 0x1e, 0xb1, 0x64, 0x60, 0x5c, 0xf3, 0x6a, 0xdd, 0x2c, 0xd4, 0xf2, 0x46, 0x3c,
	0x5b, 0x8e, 0x13, 0x95, 0x1c, 0xb3, 0x64, 0xad, 0x10, 0x74, 0x82, 0x3d, 0x03, 0x4e, 0x99, 0xc4,
	0x64, 0x9e, 0x61, 0x55, 0xca, 0x66, 0x25, 0xe9, 0x98, 0xe1, 0x78, 0x2e, 0x3c, 0xc9, 0x3e, 0x02,
	0xe6, 0xab, 0xa6, 0xe3, 0xda, 0x15, 0xa2, 0x05, 0xd1, 0x2d, 0x7e, 0x98, 0x2b, 0xd9, 0x2b, 0x2e,
	0x3c, 0xc5, 0x4e, 0x82, 0xd1, 0x92, 0xb9, 0x62, 0x94, 0xe0, 0x43, 0xa4, 0x5f, 0x25, 0x3b, 0x6f,
	0x94, 0x62, 0xa3, 0x3b, 0xe5, 0xa4, 0xa5, 0x79, 0x62, 0x11, 0xd7, 0x73, 0x4c, 0xa3, 0x4c, 0x34,
	0x2c, 0x9b, 0x05, 0xcb, 0x80, 0xa7, 0x49, 0x67, 0x2f, 0xdb, 0xb9, 0xba, 0x6b, 0x1a, 0x4e, 0xbe,
	0x08, 0xcf, 0x10, 0x75, 0x56, 0x8c, 0x72, 0xae, 0x44, 0xf4, 0x7d, 0x98, 0x78, 0x4d, 0x3c, 0x17,
	0x4a, 0x89, 0x8c, 0x47, 0x88, 0x7e, 0x8e, 0xb9, 0x6c, 0x3a, 0x66, 0x25, 0xed, 0xbd, 0x63, 0xa6,
	0x55, 0x1f, 0x25, 0xcf, 0xdc, 0xa2, 0xe1, 0x98, 0xeb, 0x86, 0x93, 0x3c, 0x5b, 0x76, 0xcc, 0x18,
	0xc0, 0x05, 0x32, 0x74, 0x55, 0xd3, 0x74, 0xea, 0x9e, 0x5d, 0x27, 0xff, 0xc2, 0xc7, 0x88, 0x73,
	0x97, 0x0d, 0xc7, 0xba, 0x5c, 0x33, 0x2a, 0x06, 0xcc, 0xb2, 0x53, 0x60, 0xbc, 0x68, 0xe4, 0xe3,
	0x11, 0x78, 0x9c, 0xf4, 0x65, 0x85, 0x84, 0x07, 0xb8, 0x48, 0x8c, 0x5f, 0x2d, 0x5a, 0x25, 0xdb,
	0xb5, 0xab, 0xc5, 0x8d, 0x74, 0x98, 0x4b, 0x96, 0x67, 0x91, 0xee, 0x19, 0x85, 0x35, 0x3b, 0x6f,
	0xe4, 0x37, 0xe0, 0x13, 0xa4, 0xfa, 0xba, 0x69, 0x54, 0x89, 0x5b, 0x3d, 0x49, 0xb4, 0xae, 0x1a,
	0x1b, 0xa4, 0x2d, 0xb7, 0xe6, 0x2c, 0xc3, 0xa7, 0xd8, 0x87, 0xc0, 0xf1, 0x62, 0xad, 0xe2, 0xf5,
	0x46, 0x66, 0xd9, 0x72, 0x8b, 0xa4, 0xa1, 0xa7, 0x49, 0x35, 0xe2, 0x01, 0xa6, 0xb7, 0x01, 0x9f,
	0x21, 0xf6, 0xed, 0x0f, 0x4c, 0x6c, 0x3c, 0xd7, 0xb3, 0xbc, 0x5a, 0xe2, 0xab, 0x67, 0x89, 0xab,
	0xd9, 0x95, 0x92, 0x55, 0x31, 0xeb, 0x2b, 0x8e, 0x69, 0xc6, 0xb2, 0xf2, 0x86, 0x53, 0x70, 0xe1,
	0xdb, 0xc8, 0x08, 0xbb, 0x55, 0x9b, 0x0c, 0xd2, 0x39, 0x32, 0xad, 0xdc, 0x75, 0xab, 0xec, 0xd6,
	0x2c, 0xcf, 0xed, 0xcd, 0x00, 0xab, 0x4c, 0x02, 0xad, 0x51, 0xad, 0x1a, 0x8e, 0x59, 0x82, 0x6f,
	0x27, 0xc6, 0xb8, 0x52, 0x33, 0xdd, 0xb8, 0x9d, 0x5c, 0xc9, 0x84, 0xe7, 0xc9, 0x54, 0x5e, 0xb5,
	0x0a, 0x2e, 0x7c, 0x36, 0x76, 0xdb, 0xb8, 0x34, 0xb1, 0xad, 0x91, 0xb7, 0xdc, 0x32, 0x5c, 0x22,
	0x11, 0x7c, 0x7f, 0xe4, 0x3d, 0xdb, 0x31, 0x56, 0x4c, 0x78, 0x81, 0x0c, 0xd5, 0x9a, 0x65, 0x97,
	0xc8, 0x50, 0x40, 0x8e, 0x7d, 0x14, 0x9c, 0x5e, 0x35, 0x37, 0x4a, 0xf6, 0xca, 0x8a, 0xe9, 0x24,
	0x2d, 0x97, 0xed, 0x8a, 0xe5, 0xd9, 0x0e, 0xe9, 0x29, 0x4f, 0xc2, 0x50, 0x32, 0x50, 0x75, 0xb3,
	0xb2, 0x42, 0x66, 0x2e, 0x14, 0x88, 0xd8, 0xfe, 0xfc, 0x24, 0xfa, 0x1b, 0x25, 0x17, 0x8a, 0xc4,
	0x8f, 0xd7, 0xcd, 0x1c, 0x31, 0xae, 0xe9, 0x78, 0x96, 0x6b, 0x12, 0x37, 0x74, 0xa1, 0x44, 0x9a,
	0xcb, 0x17, 0xcd, 0xc4, 0x93, 0xe5, 0x78, 0x88, 0x1c, 0xdb, 0x75, 0xa1, 0x42, 0x54, 0x26, 0x15,
	0x92, 0x35, 0xc3, 0x2c, 0x1b, 0x56, 0x09, 0xaa, 0xc4, 0xd3, 0xcb, 0x46, 0x29, 0x76, 0x85, 0x64,
	0x1e, 0x69, 0x44, 0xc3, 0x6a, 0x31, 0x31, 0x7d, 0x32, 0xc7, 0xbd, 0xa2, 0xe9, 0xd4, 0x97, 0x1d,
	0xa3, 0x56, 0x70, 0xa1, 0xce, 0x3e, 0x01, 0x1e, 0xab, 0x3a, 0xf6, 0xd5, 0x8d, 0xba, 0xb1, 0x66,
	0x5b, 0x05, 0xa3, 0xe7, 0x60, 0x46, 0xc5, 0xae, 0x6c, 0x94, 0xad, 0x6b, 0xa6, 0xe3, 0xc2, 0x8b,
	0x44, 0x39, 0xb7, 0xba, 0xd1, 0xf7, 0x30, 0xa3, 0x10, 0xfb, 0xd7, 0x37, 0x11, 0x75, 0xca, 0x35,
	0xd7, 0xca, 0xc3, 0x6f, 0x26, 0x1e, 0xbd, 0x42, 0xa2, 0x7c, 0x3c, 0x7f, 0xe0, 0x73, 0x64, 0x74,
	0x2a, 0xb5, 0x02, 0x09, 0x68, 0x97, 0xe2, 0x60, 0x6c, 0xae, 0xa7, 0xe6, 0x89, 0x67, 0xc0, 0xf3,
	0xc4, 0x07, 0xac, 0x52, 0x32, 0x75, 0x5e, 0x20, 0x3a, 0xe6, 0xed, 0x8a, 0x47, 0x66, 0x5e, 0xc1,
	0x2c, 0x59, 0x6b, 0xa6, 0xb3, 0xd1, 0x0b, 0x0e, 0x2e, 0x34, 0xd8, 0x87, 0xc1, 0x43, 0x7d, 0x8b,
	0xe5, 0xed, 0x72, 0xb9, 0x56, 0xb1, 0x12, 0x7f, 0x71, 0x61, 0x8e, 0x18, 0x88, 0xac, 0x85, 0x15,
	0xd3, 0x73, 0x61, 0x3e, 0x8e, 0x74, 0x39, 0xdb, 0x89, 0xe7, 0x4d, 0x21, 0xf6, 0x40, 0xd3, 0x28,
	0x79, 0xc5, 0x7e, 0xd3, 0x79, 0xab, 0x62, 0x42, 0x93, 0x4c, 0x9a, 0xbc, 0x5d, 0x59, 0xb6, 0x9c,
	0xb2, 0x59, 0xa8, 0xbb, 0x55, 0xa3, 0x5c, 0x77, 0xed, 0x9a, 0x43, 0xc2, 0xec, 0x32, 0x99, 0x22,
	0x31, 0x53, 0x73, 0x4a, 0x2e, 0x5c, 0x21, 0xfe, 0x59, 0xab, 0x1c, 0x51, 0xb8, 0x48, 0x26, 0xbd,
	0x5d, 0x35, 0x2b, 0xf5, 0xa2, 0xe7, 0x55, 0xc9, 0x7a, 0x7c, 0xd5, 0x32, 0x5d, 0x68, 0x91, 0xa5,
	0xb5, 0xb0, 0x51, 0x31, 0xca, 0x64, 0xc2, 0x94, 0x36, 0xea, 0x2b, 0x66, 0xc5, 0x24, 0xcb, 0x7e,
	0xa1, 0x9e, 0x76, 0x13, 0x5e, 0x26, 0x46, 0xa9, 0x1a, 0xce, 0x2a, 0x09, 0xab, 0x76, 0xd9, 0xb0,
	0x2a, 0x2e, 0x5c, 0x25, 0xfa, 0x1a, 0xa5, 0xbc, 0x5d, 0xb4, 0x4b, 0x69, 0x2c, 0xcb, 0x19, 0xf9,
	0xbc, 0x0d, 0x4b, 0x71, 0x8e, 0xe0, 0x58, 0x6b, 0xc4, 0x45, 0xad, 0x6a, 0xdd, 0x28, 0x14, 0x1c,
	0xd3, 0x75, 0x4d, 0x17, 0x96, 0x49, 0x4f, 0xac, 0xb2, 0xb1, 0x92, 0x0c, 0xcc, 0x9a, 0x55, 0x30,
	0xed, 0x5e, 0x54, 0xa9, 0xc4, 0x0b, 0x89, 0xe1, 0x16, 0x2d, 0xbb, 0x92, 0xc4, 0x2c, 0xd3, 0xa8,
	0x79, 0x1b, 0xd0, 0x4e, 0xc2, 0x49, 0xde, 0x31, 0x63, 0x1b, 0xc6, 0x8f, 0x8a, 0x76, 0x2e, 0x47,
	0x34, 0xaf, 0x12, 0xb5, 0xca, 0xb6, 0x67, 0x3b, 0xf5, 0x35, 0xb3, 0x68, 0xe5, 0x4b, 0xa6, 0x0b,
	0xaf, 0x90, 0x99, 0x4d, 0x5c, 0x8d, 0xe4, 0x04, 0xc4, 0x0d, 0x9d, 0x74, 0x09, 0xff, 0x25, 0x06,
	0xc0, 0x83, 0xef, 0x28, 0x64, 0x96, 0x51, 0x26, 0x1a, 0x22, 0xfe, 0xbe, 0x6e, 0x55, 0x0a, 0xf6,
	0xba, 0x5b, 0x37, 0xaf, 0x56, 0x4b, 0xb6, 0xe5, 0x91, 0xd4, 0x20, 0x95, 0x69, 0x78, 0x9e, 0x91,
	0x5f, 0x75, 0xe1, 0x30, 0x71, 0x88, 0x9c, 0xed, 0xc5, 0xc3, 0x38, 0x12, 0x2f, 0x51, 0x79, 0xa3,
	0x52, 0x21, 0xee, 0x97, 0x21, 0xbe, 0xe5, 0x98, 0xd5, 0x9a, 0x97, 0x84, 0xc3, 0x78, 0x39, 0xeb,
	0xb9, 0x34, 0x1c, 0x23, 0x4e, 0x18, 0x7b, 0x30, 0x1c, 0x4f, 0x94, 0xcf, 0x59, 0x25, 0xb3, 0xee,
	0x15, 0x49, 0xf7, 0x5c, 0x38, 0x11, 0x2f, 0xe7, 0xb6, 0x53, 0x4f, 0x8a, 0x4c, 0x92, 0x01, 0x2b,
	0x98, 0x15, 0xb2, 0xfa, 0xd8, 0xcb, 0xbd, 0xc5, 0x15, 0x02, 0xd2, 0x7a, 0xea, 0x70, 0x70, 0x2a,
	0xed, 0xde, 0xef, 0x32, 0x60, 0xfe, 0xa8, 0xcb, 0x92, 0xec, 0xa3, 0xe0, 0x84, 0x57, 0x72, 0xeb,
	0xcb, 0x56, 0x65, 0xc5, 0x74, 0xaa, 0x8e, 0x55, 0xf1, 0x7a, 0x29, 0xcb, 0xc8, 0x2b, 0xef, 0x62,
	0x88, 0x43, 0x1b, 0x95, 0x8d, 0x3a, 0xc9, 0x3f, 0xf2, 0x96, 0x5d, 0xa3, 0x0a, 0x42, 0x86, 0x4c,
	0x8e, 0x74, 0x0e, 0x0d, 0xa7, 0x7f, 0x5b, 0x95, 0x02, 0x1c, 0x89, 0x17, 0x2d, 0x92, 0x26, 0x5d,
	0x85, 0x19, 0xa2, 0xd1, 0x8a, 0x6d, 0x7b, 0xab, 0x96, 0x07, 0x47, 0x49, 0xa4, 0x5a, 0xb1, 0xaf,
	0x59, 0xc9, 0xe2, 0x7d, 0x39, 0x67, 0x2d, 0x3b, 0x24, 0x3f, 0x1b, 0x27, 0x85, 0xae, 0xd4, 0x8c,
	0xd5, 0x9c, 0x4d, 0x16, 0x6d, 0x62, 0x26, 0xa3, 0xe2, 0xda, 0xe5, 0x58, 0xf2, 0x24, 0x29, 0xea,
	0x39, 0x76, 0xa9, 0x60, 0xba, 0x45, 0x08, 0xe2, 0x25, 0xdd, 0x5e, 0x76, 0x4d, 0x13, 0x4e, 0x91,
	0x30, 0xe1, 0xd9, 0x8e, 0x63, 0x56, 0xbc, 0x92, 0x9d, 0x5f, 0x35, 0x9d, 0x64, 0x8d, 0xf6, 0x1c,
	0x2b, 0x1f, 0x8b, 0x9a, 0x39, 0xf7, 0xde, 0xc7, 0xc1, 0xd4, 0xc0, 0xae, 0x11, 0x7b, 0x16, 0x4c,
	0xe7, 0xed, 0x5a, 0xc5, 0x23, 0xf3, 0x32, 0xe9, 0xe6, 0xa9, 0xd7, 0xf7, 0x18, 0xf6, 0xce, 0xbd,
	0x1f, 0xa2, 0x44, 0xaf, 0xa4, 0x51, 0x48, 0x72, 0xb5, 0x3e, 0x26, 0xdd, 0x1d, 0xc4, 0xcb, 0x70,
	0x84, 0xc2, 0x2b, 0xc9, 0x58, 0xf7, 0xb1, 0x95, 0x64, 0x67, 0x7d, 0x5c, 0x82, 0x63, 0x14, 0x2e,
	0x27, 0xe9, 0x59, 0x1f, 0x57, 0x12, 0x23, 0xf4, 0xb1, 0x0d, 0x27, 0x29, 0x7c, 0x05, 0x02, 0x0a,
	0x3b, 0x70, 0x8a, 0xc2, 0x2e, 0x9c, 0xa6, 0xb0, 0x07, 0x67, 0x28, 0x5c, 0x4b, 0xd2, 0x94, 0x3e,
	0x5e, 0x87, 0x73, 0x14, 0xbe, 0x0a, 0x21, 0x85, 0xaf, 0xc1, 0x63, 0x83, 0x38, 0x67, 0x40, 0x96,
	0xc2, 0x39, 0x78, 0x9c, 0xc2, 0x05, 0x78, 0x82, 0xc2, 0x26, 0x3c, 0x49, 0xe1, 0x65, 0x78, 0x8a,
	0xc2, 0x2b, 0xf0, 0x21, 0x0a, 0x17, 0xe1, 0x3c, 0x85, 0xad, 0x24, 0xd3, 0xe8, 0xe3, 0xcb, 0xf0,
	0x0c, 0x85, 0x4b, 0xf0, 0x61, 0x0a, 0x97, 0xe1, 0x23, 0x14, 0xae, 0xc0, 0x47, 0x29, 0x6c, 0xc3,
	0x05, 0x0a, 0x5f, 0x81, 0x8f, 0x51, 0xd8, 0x81, 0x59, 0x0a, 0xbb, 0xf0, 0x71, 0x0a, 0x7b, 0x70,
	0x91, 0xc2, 0x6b, 0xf0, 0x09, 0x0a, 0xaf, 0xc3, 0x27, 0x29, 0xbc, 0x01, 0x9f, 0xa2, 0xf0, 0x35,
	0xf8, 0xf4, 0x20, 0xce, 0x1b, 0xf0, 0x19, 0x0a, 0xe7, 0xe1, 0x59, 0x0a, 0x17, 0xe0, 0xdb, 0x28,
	0xbc, 0x0c, 0xcf, 0x51, 0x78, 0x05, 0xbe, 0x9d, 0xc2, 0x45, 0x78, 0x9e, 0xc2, 0x16, 0x7c, 0x96,
	0xc2, 0xab, 0x70, 0x89, 0xc2, 0x25, 0x78, 0x81, 0xc2, 0x65, 0xc8, 0x51, 0xb8, 0x02, 0x79, 0x0a,
	0xdb, 0x50, 0xa0, 0xb0, 0x03, 0x45, 0x0a, 0x93, 0xf5, 0x7e, 0x10, 0xd7, 0xa0, 0x4c, 0xe1, 0x35,
	0xa8, 0x50, 0x78, 0x1d, 0xaa, 0x14, 0xbe, 0x0a, 0x35, 0x0a, 0x6f, 0x40, 0x9d, 0xc2, 0xd7, 0xe0,
	0xc5, 0x41, 0x5c, 0x20, 0x4b, 0xf8, 0x20, 0xbe, 0x9c, 0xac, 0xe3, 0x7d, 0xbc, 0x0a, 0x9f, 0xa3,
	0x70, 0x19, 0x5e, 0xa2, 0xb0, 0x0d, 0x9f, 0xa7, 0xf0, 0x35, 0xf8, 0xc2, 0x20, 0x36, 0xf3, 0xd0,
	0xa0, 0xb0, 0x09, 0x73, 0x14, 0x5e, 0x81, 0x79, 0x0a, 0x17, 0x61, 0x81, 0xc2, 0x0e, 0x34, 0x29,
	0x4c, 0x56, 0xe7, 0x41, 0xec, 0xc1, 0x95, 0x41, 0xbc, 0x6c, 0xc1, 0x22, 0x85, 0x2f, 0x43, 0x8b,
	0xc2, 0xab, 0xf0, 0x32, 0x85, 0xcb, 0x70, 0x95, 0xc2, 0x64, 0xa5, 0x1d, 0xc4, 0x0e, 0x2c, 0x0f,
	0xe2, 0x15, 0x03, 0x56, 0x28, 0x9c, 0x83, 0x36, 0x85, 0x0b, 0xb0, 0x4a, 0x61, 0x13, 0x5e, 0xa1,
	0xf0, 0x32, 0x74, 0x28, 0xbc, 0x02, 0x5d, 0x0a, 0x17, 0xa1, 0x47, 0x61, 0x0b, 0xd6, 0x28, 0x5c,
	0x82, 0x6b, 0x14, 0x2e, 0xc3, 0x75, 0x0a, 0x57, 0xe0, 0x55, 0x0a, 0x57, 0xe1, 0x06, 0x85, 0xaf,
	0xc0, 0x6b, 0x14, 0x76, 0xe0, 0xb7, 0x50, 0xd8, 0x85, 0xdf, 0x4a, 0x61, 0x0f, 0x7e, 0x1b, 0x85,
	0x6b, 0xf0, 0xdb, 0x29, 0xbc, 0x0e, 0xeb, 0x14, 0xde, 0x80, 0xdf, 0x31, 0x88, 0x8b, 0xab, 0x10,
	0x51, 0xb8, 0x0c, 0x7d, 0x0a, 0x57, 0x60, 0x40, 0x61, 0x07, 0x86, 0x14, 0xf6, 0x20, 0xa6, 0x70,
	0x0d, 0x46, 0x83, 0xd8, 0x2a, 0xc0, 0x4d, 0x0a, 0x9b, 0xf0, 0x3a, 0x85, 0x4b, 0xb0, 0x41, 0xe1,
	0x32, 0x7c, 0x07, 0x85, 0x2b, 0xf0, 0x45, 0x0a, 0xdb, 0x70, 0x8b, 0xc2, 0x57, 0xe0, 0x36, 0x85,
	0x1d, 0xd8, 0xa4, 0xb0, 0x0b, 0x5b, 0x14, 0xf6, 0xe0, 0xce, 0x20, 0xbe, 0x6c, 0xc2, 0x77, 0x52,
	0xb8, 0x0c, 0xa9, 0xf5, 0xf1, 0xb2, 0x0d, 0x3b, 0x14, 0xae, 0xc2, 0xee, 0x20, 0x5e, 0x35, 0xe1,
	0x2e, 0x85, 0x57, 0xe0, 0x4b, 0x14, 0x2e, 0xc2, 0x1b, 0x14, 0xb6, 0xe0, 0xcb, 0x14, 0x2e, 0xc3,
	0x9b, 0x14, 0xae, 0xc0, 0x3f, 0x46, 0xe1, 0x2a, 0xfc, 0xe3, 0x14, 0x76, 0xe0, 0x9f, 0xa0, 0xf0,
	0x3a, 0x7c, 0x17, 0x85, 0x37, 0xe0, 0x9f, 0xa4, 0xf0, 0x35, 0xf8, 0x9d, 0xec, 0xdc, 0x3e, 0x2e,
	0x19, 0xf0, 0x15, 0x86, 0x22, 0x72, 0xf0, 0xbb, 0x68, 0x22, 0x0f, 0xdf, 0x4d, 0x13, 0x16, 0xfc,
	0x53, 0x34, 0xb1, 0x0a, 0xdf, 0x43, 0x13, 0x0e, 0x7c, 0x2f, 0x4d, 0xb8, 0xf0, 0x7d, 0x34, 0xe1,
	0xc1, 0x3f, 0x4d, 0x13, 0x35, 0xf8, 0xdd, 0x34, 0xb1, 0x06, 0xbf, 0x87, 0x26, 0x36, 0xe0, 0xfb,
	0x29, 0xa2, 0x6c, 0xc0, 0xef, 0xa5, 0x89, 0x3c, 0xfc, 0x33, 0x34, 0x51, 0x80, 0x7f, 0x96, 0x26,
	0x4c, 0xf8, 0xe7, 0x68, 0x62, 0x19, 0x7e, 0x80, 0x26, 0x56, 0xe0, 0x07, 0x69, 0xa2, 0x08, 0xff,
	0x3c, 0x4d, 0xac, 0xc2, 0x0f, 0xd1, 0x44, 0x09, 0xfe, 0x05, 0x9a, 0x28, 0xc3, 0xbf, 0x48, 0x13,
	0x15, 0xf8, 0x7d, 0x34, 0x61, 0xc3, 0xbf, 0x44, 0x13, 0x55, 0xf8, 0xfd, 0x34, 0x71, 0x05, 0x7e,
	0x98, 0x26, 0x1c, 0xf8, 0x11, 0x9a, 0x70, 0xe1, 0x0f, 0xd0, 0x84, 0x07, 0xff, 0x32, 0x4d, 0xd4,
	0xe0, 0x0f, 0xd2, 0xc4, 0x1a, 0xfc, 0x28, 0x4d, 0xac, 0xc3, 0x8f, 0xd1, 0xc4, 0x55, 0xf8, 0x57,
	0x68, 0x62, 0x03, 0x7e, 0x9c, 0x26, 0xae, 0xc1, 0xbf, 0x4a, 0x11, 0x15, 0x03, 0x7e, 0x82, 0x26,
	0xf2, 0xf0, 0x87, 0x68, 0xc2, 0x84, 0x3f, 0x4c, 0x13, 0xcb, 0xf0, 0x47, 0x68, 0x62, 0x05, 0xfe,
	0x35, 0x9a, 0xb0, 0xe0, 0x8f, 0xd2, 0x44, 0x09, 0x7e, 0x92, 0x26, 0x6c, 0xf8, 0x63, 0x34, 0x51,
	0x85, 0x9f, 0xa2, 0x09, 0x07, 0xfe, 0x38, 0x4d, 0xd4, 0xe0, 0x5f, 0xa7, 0x89, 0x6b, 0xf0, 0xd3,
	0x14, 0x61, 0x97, 0xe1, 0xdf, 0xa0, 0x88, 0xaa, 0x01, 0xff, 0x26, 0x4d, 0x98, 0xf0, 0x33, 0x34,
	0xb1, 0x0c, 0x7f, 0x82, 0x26, 0x56, 0xe0, 0xdf, 0xa2, 0x89, 0x22, 0xfc, 0xdb, 0x34, 0xb1, 0x0a,
	0xff, 0x0e, 0x4d, 0x94, 0xe0, 0x4f, 0xd2, 0x44, 0x19, 0xfe, 0x14, 0x4d, 0x54, 0xe0, 0xdf, 0xa5,
	0x09, 0x07, 0xfe, 0x34, 0x4d, 0xb8, 0xf0, 0xef, 0xd1, 0x84, 0x07, 0x3f, 0x4b, 0x13, 0xeb, 0x70,
	0x8f, 0x26, 0x36, 0xe0, 0xab, 0x14, 0x71, 0xc5, 0x80, 0x7f, 0x9f, 0x22, 0x1c, 0x13, 0xfe, 0x03,
	0x9a, 0xb0, 0xe1, 0xcf, 0xd0, 0x84, 0x0b, 0x6f, 0xd1, 0x44, 0x0d, 0xfe, 0x43, 0x9a, 0x58, 0x87,
	0xff, 0x88, 0x22, 0x5c, 0x03, 0xfe, 0x63, 0x9a, 0xc8, 0xc1, 0x9f, 0xa5, 0x89, 0x3c, 0xfc, 0x27,
	0x34, 0x51, 0x80, 0x3f, 0x47, 0x13, 0x26, 0xfc, 0xa7, 0x34, 0xb1, 0x02, 0x5f, 0xa3, 0x89, 0x22,
	0xfc, 0x67, 0x34, 0x61, 0xc1, 0xd7, 0x69, 0xe2, 0x32, 0xfc, 0xe7, 0x34, 0xb1, 0x0a, 0x7f, 0x9e,
	0x26, 0x4a, 0xf0, 0x5f, 0xd0, 0x44, 0x19, 0xfe, 0x4b, 0x9a, 0xa8, 0xc0, 0x7f, 0x45, 0x13, 0x36,
	0x7c, 0x83, 0x26, 0x1c, 0xf8, 0xaf, 0x69, 0xc2, 0x85, 0xff, 0x86, 0x26, 0x3c, 0xf8, 0x6f, 0x69,
	0x62, 0x0d, 0xfe, 0x02, 0x4d, 0x5c, 0x85, 0xff, 0x8e, 0x26, 0x36, 0xe0, 0xbf, 0xa7, 0x89, 0x6b,
	0xf0, 0x17, 0x29, 0xc2, 0xcb, 0xc3, 0x37, 0x69, 0xa2, 0x00, 0xff, 0x03, 0x4d, 0x2c, 0xc3, 0xcf,
	0xd1, 0xc4, 0x0a, 0xfc, 0x8f, 0x34, 0x51, 0x84, 0xbf, 0x44, 0x13, 0x97, 0xe1, 0x7f, 0xa2, 0x89,
	0x55, 0xf8, 0x9f, 0x69, 0xa2, 0x04, 0x7f, 0x99, 0x26, 0xca, 0xf0, 0x57, 0x68, 0xa2, 0x02, 0x3f,
	0x4f, 0x13, 0x36, 0xbc, 0x4d, 0x13, 0x0e, 0xfc, 0x02, 0x4d, 0x78, 0xf0, 0xbf, 0xd0, 0xc4, 0x1a,
	0xfc, 0x55, 0x9a, 0x58, 0x87, 0xff, 0x95, 0x26, 0xae, 0xc1, 0xff, 0x46, 0x11, 0x35, 0x03, 0x7e,
	0x91, 0x26, 0x56, 0xe0, 0xaf, 0xd1, 0x44, 0x19, 0xfe, 0x3a, 0x4d, 0xb8, 0xf0, 0xbf, 0xd3, 0xc4,
	0x06, 0xfc, 0x1f, 0x34, 0x71, 0x0d, 0xfe, 0x4f, 0x8a, 0x58, 0x33, 0xe0, 0x6f, 0xd0, 0x44, 0x1e,
	0xfe, 0x26, 0x4d, 0x98, 0xf0, 0x4b, 0x34, 0xb1, 0x02, 0xff, 0x17, 0x4d, 0x58, 0xf0, 0x2d, 0x9a,
	0xa8, 0xc0, 0xdf, 0xa2, 0x89, 0x1a, 0xfc, 0x6d, 0x8a, 0x58, 0x5f, 0x86, 0xff, 0x9b, 0x26, 0x5c,
	0xf8, 0x3b, 0x14, 0x71, 0x75, 0x15, 0xfe, 0x1f, 0x9a, 0xf0, 0xe0, 0x97, 0x29, 0x62, 0xc3, 0x84,
	0xbf, 0x4b, 0x13, 0x1e, 0xfc, 0x0a, 0x45, 0x5c, 0x33, 0xe0, 0xef, 0xd1, 0x44, 0x19, 0xfe, 0x5f,
	0x9a, 0x58, 0x87, 0xbf, 0xcf, 0x9c, 0xfb, 0x2e, 0x06, 0x00, 0x67, 0x77, 0xab, 0xf7, 0xcb, 0xe4,
	0x13, 0x20, 0x53, 0x30, 0x2b, 0x1b, 0x70, 0x88, 0x9d, 0x04, 0xa3, 0xf1, 0x97, 0x25, 0xc8, 0xb0,
	0xa7, 0xc1, 0x5c, 0xc5, 0xbc, 0xea, 0xd5, 0xf7, 0xbf, 0x65, 0xa5, 0x1f, 0x99, 0xe2, 0x4d, 0xa6,
	0x81, 0x47, 0x70, 0x84, 0x3d, 0x09, 0xa6, 0x4a, 0x86, 0xdb, 0x27, 0x32, 0x69, 0xb9, 0x93, 0x60,
	0x6a, 0xc5, 0xf6, 0xec, 0x1e, 0x3d, 0x9a, 0xd0, 0xe9, 0x3e, 0xd0, 0x0f, 0x32, 0x60, 0x2e, 0x7f,
	0x1d, 0x6d, 0x6d, 0xe1, 0xe6, 0x66, 0x4f, 0x91, 0x78, 0x17, 0x69, 0xd9, 0xa8, 0x95, 0xbc, 0x7a,
	0xbe, 0x68, 0x94, 0x4a, 0x66, 0x65, 0xc5, 0x84, 0x43, 0xec, 0x63, 0xe0, 0x61, 0x33, 0xde, 0x5c,
	0xae, 0x5f, 0x36, 0xd6, 0x0c, 0x37, 0xef, 0x58, 0xd5, 0xc1, 0x02, 0x4c, 0xbc, 0xd9, 0x9d, 0x14,
	0xc8, 0x1b, 0x55, 0x2f, 0x5f, 0x34, 0x06, 0x9e, 0x0e, 0xc7, 0x52, 0x2d, 0x37, 0x79, 0xdc, 0xa7,
	0x47, 0xe2, 0x4f, 0x1c, 0x66, 0xb9, 0x6a, 0x3b, 0x46, 0xfc, 0xd2, 0x6e, 0x27, 0xfb, 0xf5, 0x99,
	0x54, 0xbd, 0xa7, 0xc0, 0x2c, 0xfd, 0x23, 0xe0, 0xec, 0x38, 0x18, 0x59, 0x37, 0x73, 0x70, 0x88,
	0x05, 0x60, 0x2c, 0xd9, 0x0e, 0x83, 0xcc, 0xb9, 0xe7, 0xc0, 0xf4, 0xe0, 0x8f, 0xa7, 0xb3, 0x33,
	0x60, 0x32, 0x67, 0xae, 0x58, 0x95, 0x0a, 0x91, 0x35, 0x44, 0xea, 0x98, 0x95, 0x42, 0xb2, 0x35,
	0x95, 0x33, 0x97, 0xed, 0x78, 0x6b, 0x8a, 0x18, 0x79, 0xd9, 0x33, 0x1d, 0x38, 0x92, 0xfb, 0x6e,
	0xe6, 0x8d, 0xcf, 0x2f, 0x0c, 0xbd, 0xf9, 0xf9, 0x85, 0xa1, 0x2f, 0x7d, 0x7e, 0x81, 0x79, 0xe5,
	0xf6, 0x02, 0xf3, 0xc9, 0xdb, 0x0b, 0xcc, 0x6b, 0xb7, 0x17, 0x98, 0x37, 0x6e, 0x2f, 0x30, 0x6f,
	0xde, 0x5e, 0x60, 0x7e, 0xe5, 0xf6, 0x02, 0xf3, 0xc5, 0xdb, 0x0b, 0x43, 0x5f, 0xba, 0xbd, 0xc0,
	0x7c, 0xf0, 0x0b, 0x0b, 0x43, 0xb7, 0xbe, 0xb0, 0xc0, 0xbc, 0xf1, 0x85, 0x85, 0xa1, 0x37, 0xbf,
	0xb0, 0x30, 0x74, 0xed, 0xf2, 0x66, 0x6b, 0xe7, 0xc5, 0xcd, 0xa5, 0x97, 0x5a, 0x5b, 0x5d, 0xdc,
	0x6e, 0xa3, 0xa5, 0xdd, 0xce, 0x85, 0xf8, 0x8f, 0xa8, 0xd5, 0xde, 0x7e, 0x76, 0xa7, 0xdd, 0x7a,
	0xa9, 0x11, 0xe2, 0xf6, 0xb3, 0xbd, 0xc7, 0x17, 0x76, 0xfc, 0xcd, 0xd6, 0x05, 0xfc, 0x72, 0x37,
	0xfd, 0x9f, 0x7f, 0xa8, 0xff, 0x41, 0xc9, 0x1f, 0x8b, 0x7f, 0xaf, 0x54, 0xfc, 0x7f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0xdc, 0x24, 0x89, 0x78, 0x60, 0x69, 0x00, 0x00,
}

func (x PolicySetType) String() string {
	s, ok := PolicySetType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PolicySetScope) String() string {
	s, ok := PolicySetScope_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RuleCombiningAlgorithm) String() string {
	s, ok := RuleCombiningAlgorithm_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Transformer) String() string {
	s, ok := Transformer_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x URLCategory) String() string {
	s, ok := URLCategory_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x IPThreatCategory) String() string {
	s, ok := IPThreatCategory_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x KnownTlsFingerprintClass) String() string {
	s, ok := KnownTlsFingerprintClass_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CountryCode) String() string {
	s, ok := CountryCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RuleAction) String() string {
	s, ok := RuleAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ChallengeAction) String() string {
	s, ok := ChallengeAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AppTrafficType) String() string {
	s, ok := AppTrafficType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HTMLPosition) String() string {
	s, ok := HTMLPosition_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *WafRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafRuleControl)
	if !ok {
		that2, ok := that.(WafRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExcludeRuleIds) != len(that1.ExcludeRuleIds) {
		return false
	}
	for i := range this.ExcludeRuleIds {
		if !this.ExcludeRuleIds[i].Equal(that1.ExcludeRuleIds[i]) {
			return false
		}
	}
	if this.MonitoringMode != that1.MonitoringMode {
		return false
	}
	return true
}
func (this *AppFirewallViolationContext) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppFirewallViolationContext)
	if !ok {
		that2, ok := that.(AppFirewallViolationContext)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExcludeViolation != that1.ExcludeViolation {
		return false
	}
	return true
}
func (this *AppFirewallSignatureContext) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppFirewallSignatureContext)
	if !ok {
		that2, ok := that.(AppFirewallSignatureContext)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SignatureId != that1.SignatureId {
		return false
	}
	return true
}
func (this *AppFirewallAttackTypeContext) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppFirewallAttackTypeContext)
	if !ok {
		that2, ok := that.(AppFirewallAttackTypeContext)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExcludeAttackType != that1.ExcludeAttackType {
		return false
	}
	return true
}
func (this *BotNameContext) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotNameContext)
	if !ok {
		that2, ok := that.(BotNameContext)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BotName != that1.BotName {
		return false
	}
	return true
}
func (this *AppFirewallDetectionControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppFirewallDetectionControl)
	if !ok {
		that2, ok := that.(AppFirewallDetectionControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExcludeSignatureContexts) != len(that1.ExcludeSignatureContexts) {
		return false
	}
	for i := range this.ExcludeSignatureContexts {
		if !this.ExcludeSignatureContexts[i].Equal(that1.ExcludeSignatureContexts[i]) {
			return false
		}
	}
	if len(this.ExcludeViolationContexts) != len(that1.ExcludeViolationContexts) {
		return false
	}
	for i := range this.ExcludeViolationContexts {
		if !this.ExcludeViolationContexts[i].Equal(that1.ExcludeViolationContexts[i]) {
			return false
		}
	}
	if len(this.ExcludeAttackTypeContexts) != len(that1.ExcludeAttackTypeContexts) {
		return false
	}
	for i := range this.ExcludeAttackTypeContexts {
		if !this.ExcludeAttackTypeContexts[i].Equal(that1.ExcludeAttackTypeContexts[i]) {
			return false
		}
	}
	if len(this.ExcludeBotNameContexts) != len(that1.ExcludeBotNameContexts) {
		return false
	}
	for i := range this.ExcludeBotNameContexts {
		if !this.ExcludeBotNameContexts[i].Equal(that1.ExcludeBotNameContexts[i]) {
			return false
		}
	}
	return true
}
func (this *DataGuardControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataGuardControl)
	if !ok {
		that2, ok := that.(DataGuardControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PolicyName != that1.PolicyName {
		return false
	}
	return true
}
func (this *WafInlineRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafInlineRuleControl)
	if !ok {
		that2, ok := that.(WafInlineRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExcludeRuleIds) != len(that1.ExcludeRuleIds) {
		return false
	}
	for i := range this.ExcludeRuleIds {
		if this.ExcludeRuleIds[i] != that1.ExcludeRuleIds[i] {
			return false
		}
	}
	if this.MonitoringMode != that1.MonitoringMode {
		return false
	}
	return true
}
func (this *BotAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotAction)
	if !ok {
		that2, ok := that.(BotAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionType == nil {
		if this.ActionType != nil {
			return false
		}
	} else if this.ActionType == nil {
		return false
	} else if !this.ActionType.Equal(that1.ActionType) {
		return false
	}
	return true
}
func (this *BotAction_None) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotAction_None)
	if !ok {
		that2, ok := that.(BotAction_None)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.None.Equal(that1.None) {
		return false
	}
	return true
}
func (this *BotAction_BotSkipProcessing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotAction_BotSkipProcessing)
	if !ok {
		that2, ok := that.(BotAction_BotSkipProcessing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BotSkipProcessing.Equal(that1.BotSkipProcessing) {
		return false
	}
	return true
}
func (this *ModifyAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModifyAction)
	if !ok {
		that2, ok := that.(ModifyAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionType == nil {
		if this.ActionType != nil {
			return false
		}
	} else if this.ActionType == nil {
		return false
	} else if !this.ActionType.Equal(that1.ActionType) {
		return false
	}
	return true
}
func (this *ModifyAction_Default) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModifyAction_Default)
	if !ok {
		that2, ok := that.(ModifyAction_Default)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Default.Equal(that1.Default) {
		return false
	}
	return true
}
func (this *ModifyAction_SkipProcessing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModifyAction_SkipProcessing)
	if !ok {
		that2, ok := that.(ModifyAction_SkipProcessing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SkipProcessing.Equal(that1.SkipProcessing) {
		return false
	}
	return true
}
func (this *WafAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction)
	if !ok {
		that2, ok := that.(WafAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionType == nil {
		if this.ActionType != nil {
			return false
		}
	} else if this.ActionType == nil {
		return false
	} else if !this.ActionType.Equal(that1.ActionType) {
		return false
	}
	return true
}
func (this *WafAction_None) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_None)
	if !ok {
		that2, ok := that.(WafAction_None)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.None.Equal(that1.None) {
		return false
	}
	return true
}
func (this *WafAction_WafSkipProcessing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafSkipProcessing)
	if !ok {
		that2, ok := that.(WafAction_WafSkipProcessing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafSkipProcessing.Equal(that1.WafSkipProcessing) {
		return false
	}
	return true
}
func (this *WafAction_WafRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafRuleControl)
	if !ok {
		that2, ok := that.(WafAction_WafRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafRuleControl.Equal(that1.WafRuleControl) {
		return false
	}
	return true
}
func (this *WafAction_WafInlineRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafInlineRuleControl)
	if !ok {
		that2, ok := that.(WafAction_WafInlineRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafInlineRuleControl.Equal(that1.WafInlineRuleControl) {
		return false
	}
	return true
}
func (this *WafAction_WafInMonitoringMode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafInMonitoringMode)
	if !ok {
		that2, ok := that.(WafAction_WafInMonitoringMode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafInMonitoringMode.Equal(that1.WafInMonitoringMode) {
		return false
	}
	return true
}
func (this *WafAction_AppFirewallDetectionControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_AppFirewallDetectionControl)
	if !ok {
		that2, ok := that.(WafAction_AppFirewallDetectionControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppFirewallDetectionControl.Equal(that1.AppFirewallDetectionControl) {
		return false
	}
	return true
}
func (this *WafAction_DataGuardControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_DataGuardControl)
	if !ok {
		that2, ok := that.(WafAction_DataGuardControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DataGuardControl.Equal(that1.DataGuardControl) {
		return false
	}
	return true
}
func (this *ContentRewriteAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContentRewriteAction)
	if !ok {
		that2, ok := that.(ContentRewriteAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InsertContent != that1.InsertContent {
		return false
	}
	if this.ElementSelector != that1.ElementSelector {
		return false
	}
	if this.Position != that1.Position {
		return false
	}
	if len(this.InsertedTypes) != len(that1.InsertedTypes) {
		return false
	}
	for i := range this.InsertedTypes {
		if this.InsertedTypes[i] != that1.InsertedTypes[i] {
			return false
		}
	}
	return true
}
func (this *ShapeProtectedEndpointAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeProtectedEndpointAction)
	if !ok {
		that2, ok := that.(ShapeProtectedEndpointAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppTrafficType != that1.AppTrafficType {
		return false
	}
	if !this.Mitigation.Equal(that1.Mitigation) {
		return false
	}
	if this.WebScraping != that1.WebScraping {
		return false
	}
	return true
}
func (this *ShapeBotMitigationAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotMitigationAction)
	if !ok {
		that2, ok := that.(ShapeBotMitigationAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionType == nil {
		if this.ActionType != nil {
			return false
		}
	} else if this.ActionType == nil {
		return false
	} else if !this.ActionType.Equal(that1.ActionType) {
		return false
	}
	return true
}
func (this *ShapeBotMitigationAction_None) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotMitigationAction_None)
	if !ok {
		that2, ok := that.(ShapeBotMitigationAction_None)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.None.Equal(that1.None) {
		return false
	}
	return true
}
func (this *ShapeBotMitigationAction_Block) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotMitigationAction_Block)
	if !ok {
		that2, ok := that.(ShapeBotMitigationAction_Block)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Block.Equal(that1.Block) {
		return false
	}
	return true
}
func (this *ShapeBotMitigationAction_Redirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotMitigationAction_Redirect)
	if !ok {
		that2, ok := that.(ShapeBotMitigationAction_Redirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Redirect.Equal(that1.Redirect) {
		return false
	}
	return true
}
func (this *ShapeBotMitigationAction_Flag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotMitigationAction_Flag)
	if !ok {
		that2, ok := that.(ShapeBotMitigationAction_Flag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Flag.Equal(that1.Flag) {
		return false
	}
	return true
}
func (this *ShapeBotFlagMitigationActionChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotFlagMitigationActionChoiceType)
	if !ok {
		that2, ok := that.(ShapeBotFlagMitigationActionChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SendHeadersChoice == nil {
		if this.SendHeadersChoice != nil {
			return false
		}
	} else if this.SendHeadersChoice == nil {
		return false
	} else if !this.SendHeadersChoice.Equal(that1.SendHeadersChoice) {
		return false
	}
	return true
}
func (this *ShapeBotFlagMitigationActionChoiceType_NoHeaders) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotFlagMitigationActionChoiceType_NoHeaders)
	if !ok {
		that2, ok := that.(ShapeBotFlagMitigationActionChoiceType_NoHeaders)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoHeaders.Equal(that1.NoHeaders) {
		return false
	}
	return true
}
func (this *ShapeBotFlagMitigationActionChoiceType_AppendHeaders) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotFlagMitigationActionChoiceType_AppendHeaders)
	if !ok {
		that2, ok := that.(ShapeBotFlagMitigationActionChoiceType_AppendHeaders)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppendHeaders.Equal(that1.AppendHeaders) {
		return false
	}
	return true
}
func (this *ShapeBotFlagMitigationActionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotFlagMitigationActionType)
	if !ok {
		that2, ok := that.(ShapeBotFlagMitigationActionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InferenceHeaderName != that1.InferenceHeaderName {
		return false
	}
	if this.AutoTypeHeaderName != that1.AutoTypeHeaderName {
		return false
	}
	return true
}
func (this *ShapeBotBlockMitigationActionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotBlockMitigationActionType)
	if !ok {
		that2, ok := that.(ShapeBotBlockMitigationActionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Body != that1.Body {
		return false
	}
	if this.BodyHash != that1.BodyHash {
		return false
	}
	return true
}
func (this *ShapeBotRedirectMitigationActionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShapeBotRedirectMitigationActionType)
	if !ok {
		that2, ok := that.(ShapeBotRedirectMitigationActionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uri != that1.Uri {
		return false
	}
	return true
}
func (this *PrefixMatchList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrefixMatchList)
	if !ok {
		that2, ok := that.(PrefixMatchList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.IpPrefixes) != len(that1.IpPrefixes) {
		return false
	}
	for i := range this.IpPrefixes {
		if this.IpPrefixes[i] != that1.IpPrefixes[i] {
			return false
		}
	}
	if this.InvertMatch != that1.InvertMatch {
		return false
	}
	return true
}
func (this *AsnMatchList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AsnMatchList)
	if !ok {
		that2, ok := that.(AsnMatchList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AsNumbers) != len(that1.AsNumbers) {
		return false
	}
	for i := range this.AsNumbers {
		if this.AsNumbers[i] != that1.AsNumbers[i] {
			return false
		}
	}
	return true
}
func (this *SimpleWafExclusionRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleWafExclusionRule)
	if !ok {
		that2, ok := that.(SimpleWafExclusionRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if this.PathRegex != that1.PathRegex {
		return false
	}
	if len(this.Methods) != len(that1.Methods) {
		return false
	}
	for i := range this.Methods {
		if this.Methods[i] != that1.Methods[i] {
			return false
		}
	}
	if len(this.ExcludeRuleIds) != len(that1.ExcludeRuleIds) {
		return false
	}
	for i := range this.ExcludeRuleIds {
		if this.ExcludeRuleIds[i] != that1.ExcludeRuleIds[i] {
			return false
		}
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.AppFirewallDetectionControl.Equal(that1.AppFirewallDetectionControl) {
		return false
	}
	return true
}
func (this *SimpleWafExclusionRule_AnyDomain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleWafExclusionRule_AnyDomain)
	if !ok {
		that2, ok := that.(SimpleWafExclusionRule_AnyDomain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDomain.Equal(that1.AnyDomain) {
		return false
	}
	return true
}
func (this *SimpleWafExclusionRule_ExactValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleWafExclusionRule_ExactValue)
	if !ok {
		that2, ok := that.(SimpleWafExclusionRule_ExactValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExactValue != that1.ExactValue {
		return false
	}
	return true
}
func (this *SimpleWafExclusionRule_SuffixValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleWafExclusionRule_SuffixValue)
	if !ok {
		that2, ok := that.(SimpleWafExclusionRule_SuffixValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SuffixValue != that1.SuffixValue {
		return false
	}
	return true
}
func (this *SimpleDataGuardRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleDataGuardRule)
	if !ok {
		that2, ok := that.(SimpleDataGuardRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if that1.ActionChoice == nil {
		if this.ActionChoice != nil {
			return false
		}
	} else if this.ActionChoice == nil {
		return false
	} else if !this.ActionChoice.Equal(that1.ActionChoice) {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	return true
}
func (this *SimpleDataGuardRule_ApplyDataGuard) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleDataGuardRule_ApplyDataGuard)
	if !ok {
		that2, ok := that.(SimpleDataGuardRule_ApplyDataGuard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ApplyDataGuard.Equal(that1.ApplyDataGuard) {
		return false
	}
	return true
}
func (this *SimpleDataGuardRule_SkipDataGuard) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleDataGuardRule_SkipDataGuard)
	if !ok {
		that2, ok := that.(SimpleDataGuardRule_SkipDataGuard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SkipDataGuard.Equal(that1.SkipDataGuard) {
		return false
	}
	return true
}
func (this *SimpleDataGuardRule_AnyDomain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleDataGuardRule_AnyDomain)
	if !ok {
		that2, ok := that.(SimpleDataGuardRule_AnyDomain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDomain.Equal(that1.AnyDomain) {
		return false
	}
	return true
}
func (this *SimpleDataGuardRule_ExactValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleDataGuardRule_ExactValue)
	if !ok {
		that2, ok := that.(SimpleDataGuardRule_ExactValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExactValue != that1.ExactValue {
		return false
	}
	return true
}
func (this *SimpleDataGuardRule_SuffixValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleDataGuardRule_SuffixValue)
	if !ok {
		that2, ok := that.(SimpleDataGuardRule_SuffixValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SuffixValue != that1.SuffixValue {
		return false
	}
	return true
}
func (this *DenyInformation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DenyInformation)
	if !ok {
		that2, ok := that.(DenyInformation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	if this.ErrorMessage != that1.ErrorMessage {
		return false
	}
	if that1.EventType == nil {
		if this.EventType != nil {
			return false
		}
	} else if this.EventType == nil {
		return false
	} else if !this.EventType.Equal(that1.EventType) {
		return false
	}
	return true
}
func (this *DenyInformation_UndefinedSecEvent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DenyInformation_UndefinedSecEvent)
	if !ok {
		that2, ok := that.(DenyInformation_UndefinedSecEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UndefinedSecEvent.Equal(that1.UndefinedSecEvent) {
		return false
	}
	return true
}
func (this *DenyInformation_ApiSecEvent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DenyInformation_ApiSecEvent)
	if !ok {
		that2, ok := that.(DenyInformation_ApiSecEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ApiSecEvent.Equal(that1.ApiSecEvent) {
		return false
	}
	return true
}
func (this *TlsFingerprintMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsFingerprintMatcherType)
	if !ok {
		that2, ok := that.(TlsFingerprintMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Classes) != len(that1.Classes) {
		return false
	}
	for i := range this.Classes {
		if this.Classes[i] != that1.Classes[i] {
			return false
		}
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.ExcludedValues) != len(that1.ExcludedValues) {
		return false
	}
	for i := range this.ExcludedValues {
		if this.ExcludedValues[i] != that1.ExcludedValues[i] {
			return false
		}
	}
	return true
}
func (this *PathMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType)
	if !ok {
		that2, ok := that.(PathMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PrefixValues) != len(that1.PrefixValues) {
		return false
	}
	for i := range this.PrefixValues {
		if this.PrefixValues[i] != that1.PrefixValues[i] {
			return false
		}
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.RegexValues) != len(that1.RegexValues) {
		return false
	}
	for i := range this.RegexValues {
		if this.RegexValues[i] != that1.RegexValues[i] {
			return false
		}
	}
	if len(this.SuffixValues) != len(that1.SuffixValues) {
		return false
	}
	for i := range this.SuffixValues {
		if this.SuffixValues[i] != that1.SuffixValues[i] {
			return false
		}
	}
	if len(this.Transformers) != len(that1.Transformers) {
		return false
	}
	for i := range this.Transformers {
		if this.Transformers[i] != that1.Transformers[i] {
			return false
		}
	}
	return true
}
func (this *MatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatcherType)
	if !ok {
		that2, ok := that.(MatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.RegexValues) != len(that1.RegexValues) {
		return false
	}
	for i := range this.RegexValues {
		if this.RegexValues[i] != that1.RegexValues[i] {
			return false
		}
	}
	if len(this.Transformers) != len(that1.Transformers) {
		return false
	}
	for i := range this.Transformers {
		if this.Transformers[i] != that1.Transformers[i] {
			return false
		}
	}
	return true
}
func (this *MatcherTypeBasic) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatcherTypeBasic)
	if !ok {
		that2, ok := that.(MatcherTypeBasic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.RegexValues) != len(that1.RegexValues) {
		return false
	}
	for i := range this.RegexValues {
		if this.RegexValues[i] != that1.RegexValues[i] {
			return false
		}
	}
	return true
}
func (this *CookieMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType)
	if !ok {
		that2, ok := that.(CookieMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *CookieMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_Presence)
	if !ok {
		that2, ok := that.(CookieMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *CookieMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(CookieMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *CookieMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(CookieMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *CookieMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_Item)
	if !ok {
		that2, ok := that.(CookieMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *ArgMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType)
	if !ok {
		that2, ok := that.(ArgMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *ArgMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_Presence)
	if !ok {
		that2, ok := that.(ArgMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *ArgMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(ArgMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *ArgMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(ArgMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *ArgMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_Item)
	if !ok {
		that2, ok := that.(ArgMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *HeaderMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType)
	if !ok {
		that2, ok := that.(HeaderMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Presence)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *HeaderMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(HeaderMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *HeaderMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(HeaderMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Item)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *HeaderMatcherTypeBasic) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherTypeBasic)
	if !ok {
		that2, ok := that.(HeaderMatcherTypeBasic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	return true
}
func (this *HeaderMatcherTypeBasic_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherTypeBasic_CheckPresent)
	if !ok {
		that2, ok := that.(HeaderMatcherTypeBasic_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *HeaderMatcherTypeBasic_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherTypeBasic_CheckNotPresent)
	if !ok {
		that2, ok := that.(HeaderMatcherTypeBasic_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *HeaderMatcherTypeBasic_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherTypeBasic_Item)
	if !ok {
		that2, ok := that.(HeaderMatcherTypeBasic_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Presence)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Item)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *HttpMethodMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HttpMethodMatcherType)
	if !ok {
		that2, ok := that.(HttpMethodMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Methods) != len(that1.Methods) {
		return false
	}
	for i := range this.Methods {
		if this.Methods[i] != that1.Methods[i] {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *RoleMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleMatcherType)
	if !ok {
		that2, ok := that.(RoleMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Match != that1.Match {
		return false
	}
	return true
}
func (this *StringMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StringMatcherType)
	if !ok {
		that2, ok := that.(StringMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Match) != len(that1.Match) {
		return false
	}
	for i := range this.Match {
		if this.Match[i] != that1.Match[i] {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *IpMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpMatcherType)
	if !ok {
		that2, ok := that.(IpMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PrefixSets) != len(that1.PrefixSets) {
		return false
	}
	for i := range this.PrefixSets {
		if !this.PrefixSets[i].Equal(that1.PrefixSets[i]) {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *AsnMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AsnMatcherType)
	if !ok {
		that2, ok := that.(AsnMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AsnSets) != len(that1.AsnSets) {
		return false
	}
	for i := range this.AsnSets {
		if !this.AsnSets[i].Equal(that1.AsnSets[i]) {
			return false
		}
	}
	return true
}
func (this *PortMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortMatcherType)
	if !ok {
		that2, ok := that.(PortMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *URLItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem)
	if !ok {
		that2, ok := that.(URLItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if that1.PathChoice == nil {
		if this.PathChoice != nil {
			return false
		}
	} else if this.PathChoice == nil {
		return false
	} else if !this.PathChoice.Equal(that1.PathChoice) {
		return false
	}
	return true
}
func (this *URLItem_DomainValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_DomainValue)
	if !ok {
		that2, ok := that.(URLItem_DomainValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainValue != that1.DomainValue {
		return false
	}
	return true
}
func (this *URLItem_DomainRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_DomainRegex)
	if !ok {
		that2, ok := that.(URLItem_DomainRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainRegex != that1.DomainRegex {
		return false
	}
	return true
}
func (this *URLItem_PathValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_PathValue)
	if !ok {
		that2, ok := that.(URLItem_PathValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathValue != that1.PathValue {
		return false
	}
	return true
}
func (this *URLItem_PathPrefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_PathPrefix)
	if !ok {
		that2, ok := that.(URLItem_PathPrefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathPrefix != that1.PathPrefix {
		return false
	}
	return true
}
func (this *URLItem_PathRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_PathRegex)
	if !ok {
		that2, ok := that.(URLItem_PathRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathRegex != that1.PathRegex {
		return false
	}
	return true
}
func (this *URLMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLMatcherType)
	if !ok {
		that2, ok := that.(URLMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.UrlItems) != len(that1.UrlItems) {
		return false
	}
	for i := range this.UrlItems {
		if !this.UrlItems[i].Equal(that1.UrlItems[i]) {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *L4DestMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L4DestMatcherType)
	if !ok {
		that2, ok := that.(L4DestMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.L4Dests) != len(that1.L4Dests) {
		return false
	}
	for i := range this.L4Dests {
		if !this.L4Dests[i].Equal(that1.L4Dests[i]) {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *CountryCodeList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CountryCodeList)
	if !ok {
		that2, ok := that.(CountryCodeList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CountryCodes) != len(that1.CountryCodes) {
		return false
	}
	for i := range this.CountryCodes {
		if this.CountryCodes[i] != that1.CountryCodes[i] {
			return false
		}
	}
	if this.InvertMatch != that1.InvertMatch {
		return false
	}
	return true
}
func (this *HttpHeaderName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HttpHeaderName)
	if !ok {
		that2, ok := that.(HttpHeaderName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *HttpCookieName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HttpCookieName)
	if !ok {
		that2, ok := that.(HttpCookieName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *HttpQueryParameterName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HttpQueryParameterName)
	if !ok {
		that2, ok := that.(HttpQueryParameterName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *JwtTokenAuthOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JwtTokenAuthOptions)
	if !ok {
		that2, ok := that.(JwtTokenAuthOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SecretKey.Equal(that1.SecretKey) {
		return false
	}
	if that1.TokenSource == nil {
		if this.TokenSource != nil {
			return false
		}
	} else if this.TokenSource == nil {
		return false
	} else if !this.TokenSource.Equal(that1.TokenSource) {
		return false
	}
	return true
}
func (this *JwtTokenAuthOptions_Header) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JwtTokenAuthOptions_Header)
	if !ok {
		that2, ok := that.(JwtTokenAuthOptions_Header)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	return true
}
func (this *JwtTokenAuthOptions_Cookie) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JwtTokenAuthOptions_Cookie)
	if !ok {
		that2, ok := that.(JwtTokenAuthOptions_Cookie)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cookie.Equal(that1.Cookie) {
		return false
	}
	return true
}
func (this *JwtTokenAuthOptions_QueryParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JwtTokenAuthOptions_QueryParam)
	if !ok {
		that2, ok := that.(JwtTokenAuthOptions_QueryParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.QueryParam.Equal(that1.QueryParam) {
		return false
	}
	return true
}
func (this *JwtTokenAuthOptions_BearerToken) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JwtTokenAuthOptions_BearerToken)
	if !ok {
		that2, ok := that.(JwtTokenAuthOptions_BearerToken)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BearerToken.Equal(that1.BearerToken) {
		return false
	}
	return true
}
func (this *IPThreatCategoryListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPThreatCategoryListType)
	if !ok {
		that2, ok := that.(IPThreatCategoryListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.IpThreatCategories) != len(that1.IpThreatCategories) {
		return false
	}
	for i := range this.IpThreatCategories {
		if this.IpThreatCategories[i] != that1.IpThreatCategories[i] {
			return false
		}
	}
	return true
}
func (this *ClientMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientMatcher)
	if !ok {
		that2, ok := that.(ClientMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if that1.IpAsnChoice == nil {
		if this.IpAsnChoice != nil {
			return false
		}
	} else if this.IpAsnChoice == nil {
		return false
	} else if !this.IpAsnChoice.Equal(that1.IpAsnChoice) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	return true
}
func (this *ClientMatcher_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientMatcher_AnyClient)
	if !ok {
		that2, ok := that.(ClientMatcher_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *ClientMatcher_IpThreatCategoryList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientMatcher_IpThreatCategoryList)
	if !ok {
		that2, ok := that.(ClientMatcher_IpThreatCategoryList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpThreatCategoryList.Equal(that1.IpThreatCategoryList) {
		return false
	}
	return true
}
func (this *ClientMatcher_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientMatcher_ClientSelector)
	if !ok {
		that2, ok := that.(ClientMatcher_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *ClientMatcher_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientMatcher_AnyIp)
	if !ok {
		that2, ok := that.(ClientMatcher_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *ClientMatcher_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientMatcher_IpPrefixList)
	if !ok {
		that2, ok := that.(ClientMatcher_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *ClientMatcher_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientMatcher_IpMatcher)
	if !ok {
		that2, ok := that.(ClientMatcher_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *ClientMatcher_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientMatcher_AsnList)
	if !ok {
		that2, ok := that.(ClientMatcher_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *ClientMatcher_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientMatcher_AsnMatcher)
	if !ok {
		that2, ok := that.(ClientMatcher_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *RequestMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestMatcher)
	if !ok {
		that2, ok := that.(RequestMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	return true
}
func (this *WafRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.WafRuleControl{")
	if this.ExcludeRuleIds != nil {
		s = append(s, "ExcludeRuleIds: "+fmt.Sprintf("%#v", this.ExcludeRuleIds)+",\n")
	}
	s = append(s, "MonitoringMode: "+fmt.Sprintf("%#v", this.MonitoringMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppFirewallViolationContext) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.AppFirewallViolationContext{")
	s = append(s, "ExcludeViolation: "+fmt.Sprintf("%#v", this.ExcludeViolation)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppFirewallSignatureContext) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.AppFirewallSignatureContext{")
	s = append(s, "SignatureId: "+fmt.Sprintf("%#v", this.SignatureId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppFirewallAttackTypeContext) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.AppFirewallAttackTypeContext{")
	s = append(s, "ExcludeAttackType: "+fmt.Sprintf("%#v", this.ExcludeAttackType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotNameContext) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.BotNameContext{")
	s = append(s, "BotName: "+fmt.Sprintf("%#v", this.BotName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppFirewallDetectionControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&policy.AppFirewallDetectionControl{")
	if this.ExcludeSignatureContexts != nil {
		s = append(s, "ExcludeSignatureContexts: "+fmt.Sprintf("%#v", this.ExcludeSignatureContexts)+",\n")
	}
	if this.ExcludeViolationContexts != nil {
		s = append(s, "ExcludeViolationContexts: "+fmt.Sprintf("%#v", this.ExcludeViolationContexts)+",\n")
	}
	if this.ExcludeAttackTypeContexts != nil {
		s = append(s, "ExcludeAttackTypeContexts: "+fmt.Sprintf("%#v", this.ExcludeAttackTypeContexts)+",\n")
	}
	if this.ExcludeBotNameContexts != nil {
		s = append(s, "ExcludeBotNameContexts: "+fmt.Sprintf("%#v", this.ExcludeBotNameContexts)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataGuardControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.DataGuardControl{")
	s = append(s, "PolicyName: "+fmt.Sprintf("%#v", this.PolicyName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafInlineRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.WafInlineRuleControl{")
	s = append(s, "ExcludeRuleIds: "+fmt.Sprintf("%#v", this.ExcludeRuleIds)+",\n")
	s = append(s, "MonitoringMode: "+fmt.Sprintf("%#v", this.MonitoringMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.BotAction{")
	if this.ActionType != nil {
		s = append(s, "ActionType: "+fmt.Sprintf("%#v", this.ActionType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotAction_None) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.BotAction_None{` +
		`None:` + fmt.Sprintf("%#v", this.None) + `}`}, ", ")
	return s
}
func (this *BotAction_BotSkipProcessing) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.BotAction_BotSkipProcessing{` +
		`BotSkipProcessing:` + fmt.Sprintf("%#v", this.BotSkipProcessing) + `}`}, ", ")
	return s
}
func (this *ModifyAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.ModifyAction{")
	if this.ActionType != nil {
		s = append(s, "ActionType: "+fmt.Sprintf("%#v", this.ActionType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModifyAction_Default) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ModifyAction_Default{` +
		`Default:` + fmt.Sprintf("%#v", this.Default) + `}`}, ", ")
	return s
}
func (this *ModifyAction_SkipProcessing) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ModifyAction_SkipProcessing{` +
		`SkipProcessing:` + fmt.Sprintf("%#v", this.SkipProcessing) + `}`}, ", ")
	return s
}
func (this *WafAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&policy.WafAction{")
	if this.ActionType != nil {
		s = append(s, "ActionType: "+fmt.Sprintf("%#v", this.ActionType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafAction_None) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_None{` +
		`None:` + fmt.Sprintf("%#v", this.None) + `}`}, ", ")
	return s
}
func (this *WafAction_WafSkipProcessing) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafSkipProcessing{` +
		`WafSkipProcessing:` + fmt.Sprintf("%#v", this.WafSkipProcessing) + `}`}, ", ")
	return s
}
func (this *WafAction_WafRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafRuleControl{` +
		`WafRuleControl:` + fmt.Sprintf("%#v", this.WafRuleControl) + `}`}, ", ")
	return s
}
func (this *WafAction_WafInlineRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafInlineRuleControl{` +
		`WafInlineRuleControl:` + fmt.Sprintf("%#v", this.WafInlineRuleControl) + `}`}, ", ")
	return s
}
func (this *WafAction_WafInMonitoringMode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafInMonitoringMode{` +
		`WafInMonitoringMode:` + fmt.Sprintf("%#v", this.WafInMonitoringMode) + `}`}, ", ")
	return s
}
func (this *WafAction_AppFirewallDetectionControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_AppFirewallDetectionControl{` +
		`AppFirewallDetectionControl:` + fmt.Sprintf("%#v", this.AppFirewallDetectionControl) + `}`}, ", ")
	return s
}
func (this *WafAction_DataGuardControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_DataGuardControl{` +
		`DataGuardControl:` + fmt.Sprintf("%#v", this.DataGuardControl) + `}`}, ", ")
	return s
}
func (this *ContentRewriteAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&policy.ContentRewriteAction{")
	s = append(s, "InsertContent: "+fmt.Sprintf("%#v", this.InsertContent)+",\n")
	s = append(s, "ElementSelector: "+fmt.Sprintf("%#v", this.ElementSelector)+",\n")
	s = append(s, "Position: "+fmt.Sprintf("%#v", this.Position)+",\n")
	keysForInsertedTypes := make([]string, 0, len(this.InsertedTypes))
	for k, _ := range this.InsertedTypes {
		keysForInsertedTypes = append(keysForInsertedTypes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInsertedTypes)
	mapStringForInsertedTypes := "map[string]bool{"
	for _, k := range keysForInsertedTypes {
		mapStringForInsertedTypes += fmt.Sprintf("%#v: %#v,", k, this.InsertedTypes[k])
	}
	mapStringForInsertedTypes += "}"
	if this.InsertedTypes != nil {
		s = append(s, "InsertedTypes: "+mapStringForInsertedTypes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ShapeProtectedEndpointAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&policy.ShapeProtectedEndpointAction{")
	s = append(s, "AppTrafficType: "+fmt.Sprintf("%#v", this.AppTrafficType)+",\n")
	if this.Mitigation != nil {
		s = append(s, "Mitigation: "+fmt.Sprintf("%#v", this.Mitigation)+",\n")
	}
	s = append(s, "WebScraping: "+fmt.Sprintf("%#v", this.WebScraping)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ShapeBotMitigationAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&policy.ShapeBotMitigationAction{")
	if this.ActionType != nil {
		s = append(s, "ActionType: "+fmt.Sprintf("%#v", this.ActionType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ShapeBotMitigationAction_None) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ShapeBotMitigationAction_None{` +
		`None:` + fmt.Sprintf("%#v", this.None) + `}`}, ", ")
	return s
}
func (this *ShapeBotMitigationAction_Block) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ShapeBotMitigationAction_Block{` +
		`Block:` + fmt.Sprintf("%#v", this.Block) + `}`}, ", ")
	return s
}
func (this *ShapeBotMitigationAction_Redirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ShapeBotMitigationAction_Redirect{` +
		`Redirect:` + fmt.Sprintf("%#v", this.Redirect) + `}`}, ", ")
	return s
}
func (this *ShapeBotMitigationAction_Flag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ShapeBotMitigationAction_Flag{` +
		`Flag:` + fmt.Sprintf("%#v", this.Flag) + `}`}, ", ")
	return s
}
func (this *ShapeBotFlagMitigationActionChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.ShapeBotFlagMitigationActionChoiceType{")
	if this.SendHeadersChoice != nil {
		s = append(s, "SendHeadersChoice: "+fmt.Sprintf("%#v", this.SendHeadersChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ShapeBotFlagMitigationActionChoiceType_NoHeaders) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ShapeBotFlagMitigationActionChoiceType_NoHeaders{` +
		`NoHeaders:` + fmt.Sprintf("%#v", this.NoHeaders) + `}`}, ", ")
	return s
}
func (this *ShapeBotFlagMitigationActionChoiceType_AppendHeaders) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ShapeBotFlagMitigationActionChoiceType_AppendHeaders{` +
		`AppendHeaders:` + fmt.Sprintf("%#v", this.AppendHeaders) + `}`}, ", ")
	return s
}
func (this *ShapeBotFlagMitigationActionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.ShapeBotFlagMitigationActionType{")
	s = append(s, "InferenceHeaderName: "+fmt.Sprintf("%#v", this.InferenceHeaderName)+",\n")
	s = append(s, "AutoTypeHeaderName: "+fmt.Sprintf("%#v", this.AutoTypeHeaderName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ShapeBotBlockMitigationActionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&policy.ShapeBotBlockMitigationActionType{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "BodyHash: "+fmt.Sprintf("%#v", this.BodyHash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ShapeBotRedirectMitigationActionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.ShapeBotRedirectMitigationActionType{")
	s = append(s, "Uri: "+fmt.Sprintf("%#v", this.Uri)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PrefixMatchList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.PrefixMatchList{")
	s = append(s, "IpPrefixes: "+fmt.Sprintf("%#v", this.IpPrefixes)+",\n")
	s = append(s, "InvertMatch: "+fmt.Sprintf("%#v", this.InvertMatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AsnMatchList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.AsnMatchList{")
	s = append(s, "AsNumbers: "+fmt.Sprintf("%#v", this.AsNumbers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SimpleWafExclusionRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&policy.SimpleWafExclusionRule{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	s = append(s, "PathRegex: "+fmt.Sprintf("%#v", this.PathRegex)+",\n")
	s = append(s, "Methods: "+fmt.Sprintf("%#v", this.Methods)+",\n")
	s = append(s, "ExcludeRuleIds: "+fmt.Sprintf("%#v", this.ExcludeRuleIds)+",\n")
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.AppFirewallDetectionControl != nil {
		s = append(s, "AppFirewallDetectionControl: "+fmt.Sprintf("%#v", this.AppFirewallDetectionControl)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SimpleWafExclusionRule_AnyDomain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleWafExclusionRule_AnyDomain{` +
		`AnyDomain:` + fmt.Sprintf("%#v", this.AnyDomain) + `}`}, ", ")
	return s
}
func (this *SimpleWafExclusionRule_ExactValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleWafExclusionRule_ExactValue{` +
		`ExactValue:` + fmt.Sprintf("%#v", this.ExactValue) + `}`}, ", ")
	return s
}
func (this *SimpleWafExclusionRule_SuffixValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleWafExclusionRule_SuffixValue{` +
		`SuffixValue:` + fmt.Sprintf("%#v", this.SuffixValue) + `}`}, ", ")
	return s
}
func (this *SimpleDataGuardRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&policy.SimpleDataGuardRule{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.ActionChoice != nil {
		s = append(s, "ActionChoice: "+fmt.Sprintf("%#v", this.ActionChoice)+",\n")
	}
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SimpleDataGuardRule_ApplyDataGuard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleDataGuardRule_ApplyDataGuard{` +
		`ApplyDataGuard:` + fmt.Sprintf("%#v", this.ApplyDataGuard) + `}`}, ", ")
	return s
}
func (this *SimpleDataGuardRule_SkipDataGuard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleDataGuardRule_SkipDataGuard{` +
		`SkipDataGuard:` + fmt.Sprintf("%#v", this.SkipDataGuard) + `}`}, ", ")
	return s
}
func (this *SimpleDataGuardRule_AnyDomain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleDataGuardRule_AnyDomain{` +
		`AnyDomain:` + fmt.Sprintf("%#v", this.AnyDomain) + `}`}, ", ")
	return s
}
func (this *SimpleDataGuardRule_ExactValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleDataGuardRule_ExactValue{` +
		`ExactValue:` + fmt.Sprintf("%#v", this.ExactValue) + `}`}, ", ")
	return s
}
func (this *SimpleDataGuardRule_SuffixValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleDataGuardRule_SuffixValue{` +
		`SuffixValue:` + fmt.Sprintf("%#v", this.SuffixValue) + `}`}, ", ")
	return s
}
func (this *DenyInformation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&policy.DenyInformation{")
	s = append(s, "ResponseCode: "+fmt.Sprintf("%#v", this.ResponseCode)+",\n")
	s = append(s, "ErrorMessage: "+fmt.Sprintf("%#v", this.ErrorMessage)+",\n")
	if this.EventType != nil {
		s = append(s, "EventType: "+fmt.Sprintf("%#v", this.EventType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DenyInformation_UndefinedSecEvent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.DenyInformation_UndefinedSecEvent{` +
		`UndefinedSecEvent:` + fmt.Sprintf("%#v", this.UndefinedSecEvent) + `}`}, ", ")
	return s
}
func (this *DenyInformation_ApiSecEvent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.DenyInformation_ApiSecEvent{` +
		`ApiSecEvent:` + fmt.Sprintf("%#v", this.ApiSecEvent) + `}`}, ", ")
	return s
}
func (this *TlsFingerprintMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&policy.TlsFingerprintMatcherType{")
	s = append(s, "Classes: "+fmt.Sprintf("%#v", this.Classes)+",\n")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "ExcludedValues: "+fmt.Sprintf("%#v", this.ExcludedValues)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PathMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&policy.PathMatcherType{")
	s = append(s, "PrefixValues: "+fmt.Sprintf("%#v", this.PrefixValues)+",\n")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "RegexValues: "+fmt.Sprintf("%#v", this.RegexValues)+",\n")
	s = append(s, "SuffixValues: "+fmt.Sprintf("%#v", this.SuffixValues)+",\n")
	s = append(s, "Transformers: "+fmt.Sprintf("%#v", this.Transformers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&policy.MatcherType{")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "RegexValues: "+fmt.Sprintf("%#v", this.RegexValues)+",\n")
	s = append(s, "Transformers: "+fmt.Sprintf("%#v", this.Transformers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatcherTypeBasic) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.MatcherTypeBasic{")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "RegexValues: "+fmt.Sprintf("%#v", this.RegexValues)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.CookieMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *CookieMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *CookieMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *CookieMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.ArgMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArgMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.HeaderMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherTypeBasic) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&policy.HeaderMatcherTypeBasic{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderMatcherTypeBasic_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherTypeBasic_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherTypeBasic_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherTypeBasic_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherTypeBasic_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherTypeBasic_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.QueryParameterMatcherType{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryParameterMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *HttpMethodMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.HttpMethodMatcherType{")
	s = append(s, "Methods: "+fmt.Sprintf("%#v", this.Methods)+",\n")
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoleMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.RoleMatcherType{")
	s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StringMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.StringMatcherType{")
	s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.IpMatcherType{")
	if this.PrefixSets != nil {
		s = append(s, "PrefixSets: "+fmt.Sprintf("%#v", this.PrefixSets)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AsnMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.AsnMatcherType{")
	if this.AsnSets != nil {
		s = append(s, "AsnSets: "+fmt.Sprintf("%#v", this.AsnSets)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.PortMatcherType{")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *URLItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&policy.URLItem{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	if this.PathChoice != nil {
		s = append(s, "PathChoice: "+fmt.Sprintf("%#v", this.PathChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *URLItem_DomainValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_DomainValue{` +
		`DomainValue:` + fmt.Sprintf("%#v", this.DomainValue) + `}`}, ", ")
	return s
}
func (this *URLItem_DomainRegex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_DomainRegex{` +
		`DomainRegex:` + fmt.Sprintf("%#v", this.DomainRegex) + `}`}, ", ")
	return s
}
func (this *URLItem_PathValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_PathValue{` +
		`PathValue:` + fmt.Sprintf("%#v", this.PathValue) + `}`}, ", ")
	return s
}
func (this *URLItem_PathPrefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_PathPrefix{` +
		`PathPrefix:` + fmt.Sprintf("%#v", this.PathPrefix) + `}`}, ", ")
	return s
}
func (this *URLItem_PathRegex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_PathRegex{` +
		`PathRegex:` + fmt.Sprintf("%#v", this.PathRegex) + `}`}, ", ")
	return s
}
func (this *URLMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.URLMatcherType{")
	if this.UrlItems != nil {
		s = append(s, "UrlItems: "+fmt.Sprintf("%#v", this.UrlItems)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L4DestMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.L4DestMatcherType{")
	if this.L4Dests != nil {
		s = append(s, "L4Dests: "+fmt.Sprintf("%#v", this.L4Dests)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CountryCodeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.CountryCodeList{")
	s = append(s, "CountryCodes: "+fmt.Sprintf("%#v", this.CountryCodes)+",\n")
	s = append(s, "InvertMatch: "+fmt.Sprintf("%#v", this.InvertMatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HttpHeaderName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.HttpHeaderName{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HttpCookieName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.HttpCookieName{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HttpQueryParameterName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.HttpQueryParameterName{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JwtTokenAuthOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&policy.JwtTokenAuthOptions{")
	if this.SecretKey != nil {
		s = append(s, "SecretKey: "+fmt.Sprintf("%#v", this.SecretKey)+",\n")
	}
	if this.TokenSource != nil {
		s = append(s, "TokenSource: "+fmt.Sprintf("%#v", this.TokenSource)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JwtTokenAuthOptions_Header) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.JwtTokenAuthOptions_Header{` +
		`Header:` + fmt.Sprintf("%#v", this.Header) + `}`}, ", ")
	return s
}
func (this *JwtTokenAuthOptions_Cookie) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.JwtTokenAuthOptions_Cookie{` +
		`Cookie:` + fmt.Sprintf("%#v", this.Cookie) + `}`}, ", ")
	return s
}
func (this *JwtTokenAuthOptions_QueryParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.JwtTokenAuthOptions_QueryParam{` +
		`QueryParam:` + fmt.Sprintf("%#v", this.QueryParam) + `}`}, ", ")
	return s
}
func (this *JwtTokenAuthOptions_BearerToken) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.JwtTokenAuthOptions_BearerToken{` +
		`BearerToken:` + fmt.Sprintf("%#v", this.BearerToken) + `}`}, ", ")
	return s
}
func (this *IPThreatCategoryListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.IPThreatCategoryListType{")
	s = append(s, "IpThreatCategories: "+fmt.Sprintf("%#v", this.IpThreatCategories)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClientMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&policy.ClientMatcher{")
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.IpAsnChoice != nil {
		s = append(s, "IpAsnChoice: "+fmt.Sprintf("%#v", this.IpAsnChoice)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClientMatcher_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ClientMatcher_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *ClientMatcher_IpThreatCategoryList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ClientMatcher_IpThreatCategoryList{` +
		`IpThreatCategoryList:` + fmt.Sprintf("%#v", this.IpThreatCategoryList) + `}`}, ", ")
	return s
}
func (this *ClientMatcher_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ClientMatcher_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *ClientMatcher_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ClientMatcher_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *ClientMatcher_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ClientMatcher_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *ClientMatcher_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ClientMatcher_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *ClientMatcher_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ClientMatcher_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *ClientMatcher_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ClientMatcher_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *RequestMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&policy.RequestMatcher{")
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *WafRuleControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafRuleControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafRuleControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MonitoringMode {
		i--
		if m.MonitoringMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ExcludeRuleIds) > 0 {
		for iNdEx := len(m.ExcludeRuleIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeRuleIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppFirewallViolationContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFirewallViolationContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppFirewallViolationContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExcludeViolation != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExcludeViolation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppFirewallSignatureContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFirewallSignatureContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppFirewallSignatureContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignatureId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SignatureId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppFirewallAttackTypeContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFirewallAttackTypeContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppFirewallAttackTypeContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExcludeAttackType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExcludeAttackType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BotNameContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotNameContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotNameContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BotName) > 0 {
		i -= len(m.BotName)
		copy(dAtA[i:], m.BotName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BotName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppFirewallDetectionControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFirewallDetectionControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppFirewallDetectionControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExcludeBotNameContexts) > 0 {
		for iNdEx := len(m.ExcludeBotNameContexts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeBotNameContexts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ExcludeAttackTypeContexts) > 0 {
		for iNdEx := len(m.ExcludeAttackTypeContexts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeAttackTypeContexts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ExcludeViolationContexts) > 0 {
		for iNdEx := len(m.ExcludeViolationContexts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeViolationContexts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ExcludeSignatureContexts) > 0 {
		for iNdEx := len(m.ExcludeSignatureContexts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeSignatureContexts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataGuardControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataGuardControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataGuardControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PolicyName) > 0 {
		i -= len(m.PolicyName)
		copy(dAtA[i:], m.PolicyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PolicyName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WafInlineRuleControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafInlineRuleControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafInlineRuleControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MonitoringMode {
		i--
		if m.MonitoringMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ExcludeRuleIds) > 0 {
		dAtA2 := make([]byte, len(m.ExcludeRuleIds)*10)
		var j1 int
		for _, num := range m.ExcludeRuleIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BotAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionType != nil {
		{
			size := m.ActionType.Size()
			i -= size
			if _, err := m.ActionType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotAction_None) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotAction_None) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.None != nil {
		{
			size, err := m.None.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BotAction_BotSkipProcessing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotAction_BotSkipProcessing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BotSkipProcessing != nil {
		{
			size, err := m.BotSkipProcessing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ModifyAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionType != nil {
		{
			size := m.ActionType.Size()
			i -= size
			if _, err := m.ActionType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ModifyAction_Default) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyAction_Default) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Default != nil {
		{
			size, err := m.Default.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ModifyAction_SkipProcessing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyAction_SkipProcessing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SkipProcessing != nil {
		{
			size, err := m.SkipProcessing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *WafAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionType != nil {
		{
			size := m.ActionType.Size()
			i -= size
			if _, err := m.ActionType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WafAction_WafSkipProcessing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_WafSkipProcessing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WafSkipProcessing != nil {
		{
			size, err := m.WafSkipProcessing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *WafAction_WafRuleControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_WafRuleControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WafRuleControl != nil {
		{
			size, err := m.WafRuleControl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WafAction_None) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_None) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.None != nil {
		{
			size, err := m.None.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *WafAction_WafInlineRuleControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_WafInlineRuleControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WafInlineRuleControl != nil {
		{
			size, err := m.WafInlineRuleControl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *WafAction_WafInMonitoringMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_WafInMonitoringMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WafInMonitoringMode != nil {
		{
			size, err := m.WafInMonitoringMode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *WafAction_AppFirewallDetectionControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_AppFirewallDetectionControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppFirewallDetectionControl != nil {
		{
			size, err := m.AppFirewallDetectionControl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *WafAction_DataGuardControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_DataGuardControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DataGuardControl != nil {
		{
			size, err := m.DataGuardControl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ContentRewriteAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentRewriteAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentRewriteAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InsertedTypes) > 0 {
		keysForInsertedTypes := make([]string, 0, len(m.InsertedTypes))
		for k := range m.InsertedTypes {
			keysForInsertedTypes = append(keysForInsertedTypes, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForInsertedTypes)
		for iNdEx := len(keysForInsertedTypes) - 1; iNdEx >= 0; iNdEx-- {
			v := m.InsertedTypes[string(keysForInsertedTypes[iNdEx])]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(keysForInsertedTypes[iNdEx])
			copy(dAtA[i:], keysForInsertedTypes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForInsertedTypes[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Position != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ElementSelector) > 0 {
		i -= len(m.ElementSelector)
		copy(dAtA[i:], m.ElementSelector)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ElementSelector)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InsertContent) > 0 {
		i -= len(m.InsertContent)
		copy(dAtA[i:], m.InsertContent)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsertContent)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShapeProtectedEndpointAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShapeProtectedEndpointAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeProtectedEndpointAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WebScraping {
		i--
		if m.WebScraping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Mitigation != nil {
		{
			size, err := m.Mitigation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AppTrafficType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AppTrafficType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShapeBotMitigationAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShapeBotMitigationAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotMitigationAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionType != nil {
		{
			size := m.ActionType.Size()
			i -= size
			if _, err := m.ActionType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ShapeBotMitigationAction_None) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotMitigationAction_None) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.None != nil {
		{
			size, err := m.None.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ShapeBotMitigationAction_Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotMitigationAction_Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ShapeBotMitigationAction_Redirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotMitigationAction_Redirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Redirect != nil {
		{
			size, err := m.Redirect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ShapeBotMitigationAction_Flag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotMitigationAction_Flag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Flag != nil {
		{
			size, err := m.Flag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ShapeBotFlagMitigationActionChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShapeBotFlagMitigationActionChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotFlagMitigationActionChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SendHeadersChoice != nil {
		{
			size := m.SendHeadersChoice.Size()
			i -= size
			if _, err := m.SendHeadersChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ShapeBotFlagMitigationActionChoiceType_NoHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotFlagMitigationActionChoiceType_NoHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoHeaders != nil {
		{
			size, err := m.NoHeaders.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ShapeBotFlagMitigationActionChoiceType_AppendHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotFlagMitigationActionChoiceType_AppendHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppendHeaders != nil {
		{
			size, err := m.AppendHeaders.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ShapeBotFlagMitigationActionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShapeBotFlagMitigationActionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotFlagMitigationActionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AutoTypeHeaderName) > 0 {
		i -= len(m.AutoTypeHeaderName)
		copy(dAtA[i:], m.AutoTypeHeaderName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AutoTypeHeaderName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InferenceHeaderName) > 0 {
		i -= len(m.InferenceHeaderName)
		copy(dAtA[i:], m.InferenceHeaderName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InferenceHeaderName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShapeBotBlockMitigationActionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShapeBotBlockMitigationActionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotBlockMitigationActionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BodyHash) > 0 {
		i -= len(m.BodyHash)
		copy(dAtA[i:], m.BodyHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BodyHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShapeBotRedirectMitigationActionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShapeBotRedirectMitigationActionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShapeBotRedirectMitigationActionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrefixMatchList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrefixMatchList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrefixMatchList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.IpPrefixes) > 0 {
		for iNdEx := len(m.IpPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpPrefixes[iNdEx])
			copy(dAtA[i:], m.IpPrefixes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpPrefixes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AsnMatchList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsnMatchList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AsnMatchList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AsNumbers) > 0 {
		dAtA22 := make([]byte, len(m.AsNumbers)*10)
		var j21 int
		for _, num := range m.AsNumbers {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintTypes(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimpleWafExclusionRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleWafExclusionRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleWafExclusionRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AppFirewallDetectionControl != nil {
		{
			size, err := m.AppFirewallDetectionControl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ExcludeRuleIds) > 0 {
		dAtA27 := make([]byte, len(m.ExcludeRuleIds)*10)
		var j26 int
		for _, num := range m.ExcludeRuleIds {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintTypes(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Methods) > 0 {
		dAtA29 := make([]byte, len(m.Methods)*10)
		var j28 int
		for _, num := range m.Methods {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintTypes(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PathRegex) > 0 {
		i -= len(m.PathRegex)
		copy(dAtA[i:], m.PathRegex)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PathRegex)))
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}

func (m *SimpleWafExclusionRule_AnyDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleWafExclusionRule_AnyDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDomain != nil {
		{
			size, err := m.AnyDomain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SimpleWafExclusionRule_ExactValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleWafExclusionRule_ExactValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExactValue)
	copy(dAtA[i:], m.ExactValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValue)))
	i--
	dAtA[i] = 0x62
	return len(dAtA) - i, nil
}
func (m *SimpleWafExclusionRule_SuffixValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleWafExclusionRule_SuffixValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SuffixValue)
	copy(dAtA[i:], m.SuffixValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.SuffixValue)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *SimpleDataGuardRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleDataGuardRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleDataGuardRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionChoice != nil {
		{
			size := m.ActionChoice.Size()
			i -= size
			if _, err := m.ActionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}

func (m *SimpleDataGuardRule_AnyDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleDataGuardRule_AnyDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDomain != nil {
		{
			size, err := m.AnyDomain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SimpleDataGuardRule_ExactValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleDataGuardRule_ExactValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExactValue)
	copy(dAtA[i:], m.ExactValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValue)))
	i--
	dAtA[i] = 0x62
	return len(dAtA) - i, nil
}
func (m *SimpleDataGuardRule_SuffixValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleDataGuardRule_SuffixValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SuffixValue)
	copy(dAtA[i:], m.SuffixValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.SuffixValue)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *SimpleDataGuardRule_ApplyDataGuard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleDataGuardRule_ApplyDataGuard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ApplyDataGuard != nil {
		{
			size, err := m.ApplyDataGuard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *SimpleDataGuardRule_SkipDataGuard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleDataGuardRule_SkipDataGuard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SkipDataGuard != nil {
		{
			size, err := m.SkipDataGuard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *DenyInformation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenyInformation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenyInformation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EventType != nil {
		{
			size := m.EventType.Size()
			i -= size
			if _, err := m.EventType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.ResponseCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DenyInformation_UndefinedSecEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenyInformation_UndefinedSecEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndefinedSecEvent != nil {
		{
			size, err := m.UndefinedSecEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DenyInformation_ApiSecEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenyInformation_ApiSecEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ApiSecEvent != nil {
		{
			size, err := m.ApiSecEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *TlsFingerprintMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsFingerprintMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsFingerprintMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExcludedValues) > 0 {
		for iNdEx := len(m.ExcludedValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExcludedValues[iNdEx])
			copy(dAtA[i:], m.ExcludedValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExcludedValues[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ExactValues) > 0 {
		for iNdEx := len(m.ExactValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExactValues[iNdEx])
			copy(dAtA[i:], m.ExactValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValues[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Classes) > 0 {
		dAtA39 := make([]byte, len(m.Classes)*10)
		var j38 int
		for _, num := range m.Classes {
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		i -= j38
		copy(dAtA[i:], dAtA39[:j38])
		i = encodeVarintTypes(dAtA, i, uint64(j38))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PathMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SuffixValues) > 0 {
		for iNdEx := len(m.SuffixValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SuffixValues[iNdEx])
			copy(dAtA[i:], m.SuffixValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SuffixValues[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Transformers) > 0 {
		dAtA41 := make([]byte, len(m.Transformers)*10)
		var j40 int
		for _, num := range m.Transformers {
			for num >= 1<<7 {
				dAtA41[j40] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j40++
			}
			dAtA41[j40] = uint8(num)
			j40++
		}
		i -= j40
		copy(dAtA[i:], dAtA41[:j40])
		i = encodeVarintTypes(dAtA, i, uint64(j40))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RegexValues) > 0 {
		for iNdEx := len(m.RegexValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RegexValues[iNdEx])
			copy(dAtA[i:], m.RegexValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RegexValues[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ExactValues) > 0 {
		for iNdEx := len(m.ExactValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExactValues[iNdEx])
			copy(dAtA[i:], m.ExactValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValues[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PrefixValues) > 0 {
		for iNdEx := len(m.PrefixValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PrefixValues[iNdEx])
			copy(dAtA[i:], m.PrefixValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.PrefixValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Transformers) > 0 {
		dAtA43 := make([]byte, len(m.Transformers)*10)
		var j42 int
		for _, num := range m.Transformers {
			for num >= 1<<7 {
				dAtA43[j42] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j42++
			}
			dAtA43[j42] = uint8(num)
			j42++
		}
		i -= j42
		copy(dAtA[i:], dAtA43[:j42])
		i = encodeVarintTypes(dAtA, i, uint64(j42))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RegexValues) > 0 {
		for iNdEx := len(m.RegexValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RegexValues[iNdEx])
			copy(dAtA[i:], m.RegexValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RegexValues[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ExactValues) > 0 {
		for iNdEx := len(m.ExactValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExactValues[iNdEx])
			copy(dAtA[i:], m.ExactValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatcherTypeBasic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatcherTypeBasic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatcherTypeBasic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RegexValues) > 0 {
		for iNdEx := len(m.RegexValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RegexValues[iNdEx])
			copy(dAtA[i:], m.RegexValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RegexValues[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ExactValues) > 0 {
		for iNdEx := len(m.ExactValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExactValues[iNdEx])
			copy(dAtA[i:], m.ExactValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CookieMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CookieMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		{
			size := m.Match.Size()
			i -= size
			if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CookieMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieMatcherType_Presence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *CookieMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieMatcherType_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CookieMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieMatcherType_CheckPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckPresent != nil {
		{
			size, err := m.CheckPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CookieMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieMatcherType_CheckNotPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckNotPresent != nil {
		{
			size, err := m.CheckNotPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ArgMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		{
			size := m.Match.Size()
			i -= size
			if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArgMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgMatcherType_Presence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ArgMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgMatcherType_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ArgMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgMatcherType_CheckPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckPresent != nil {
		{
			size, err := m.CheckPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ArgMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgMatcherType_CheckNotPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckNotPresent != nil {
		{
			size, err := m.CheckNotPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		{
			size := m.Match.Size()
			i -= size
			if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Presence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_CheckPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckPresent != nil {
		{
			size, err := m.CheckPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_CheckNotPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckNotPresent != nil {
		{
			size, err := m.CheckNotPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherTypeBasic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcherTypeBasic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherTypeBasic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		{
			size := m.Match.Size()
			i -= size
			if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcherTypeBasic_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherTypeBasic_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherTypeBasic_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherTypeBasic_CheckPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckPresent != nil {
		{
			size, err := m.CheckPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherTypeBasic_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherTypeBasic_CheckNotPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckNotPresent != nil {
		{
			size, err := m.CheckNotPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParameterMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		{
			size := m.Match.Size()
			i -= size
			if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryParameterMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_Presence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_CheckPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckPresent != nil {
		{
			size, err := m.CheckPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_CheckNotPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckNotPresent != nil {
		{
			size, err := m.CheckNotPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *HttpMethodMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpMethodMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpMethodMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Methods) > 0 {
		dAtA60 := make([]byte, len(m.Methods)*10)
		var j59 int
		for _, num := range m.Methods {
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		i -= j59
		copy(dAtA[i:], dAtA60[:j59])
		i = encodeVarintTypes(dAtA, i, uint64(j59))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Match) > 0 {
		i -= len(m.Match)
		copy(dAtA[i:], m.Match)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Match)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Match) > 0 {
		for iNdEx := len(m.Match) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Match[iNdEx])
			copy(dAtA[i:], m.Match[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Match[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IpMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.PrefixSets) > 0 {
		for iNdEx := len(m.PrefixSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrefixSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AsnMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsnMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AsnMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AsnSets) > 0 {
		for iNdEx := len(m.AsnSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AsnSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PortMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ports[iNdEx])
			copy(dAtA[i:], m.Ports[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Ports[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *URLItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PathChoice != nil {
		{
			size := m.PathChoice.Size()
			i -= size
			if _, err := m.PathChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *URLItem_DomainValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem_DomainValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DomainValue)
	copy(dAtA[i:], m.DomainValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainValue)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *URLItem_DomainRegex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem_DomainRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DomainRegex)
	copy(dAtA[i:], m.DomainRegex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainRegex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *URLItem_PathValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem_PathValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PathValue)
	copy(dAtA[i:], m.PathValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PathValue)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *URLItem_PathRegex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem_PathRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PathRegex)
	copy(dAtA[i:], m.PathRegex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PathRegex)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *URLItem_PathPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem_PathPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PathPrefix)
	copy(dAtA[i:], m.PathPrefix)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PathPrefix)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *URLMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.UrlItems) > 0 {
		for iNdEx := len(m.UrlItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UrlItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *L4DestMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4DestMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4DestMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.L4Dests) > 0 {
		for iNdEx := len(m.L4Dests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.L4Dests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *CountryCodeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountryCodeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CountryCodeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CountryCodes) > 0 {
		dAtA62 := make([]byte, len(m.CountryCodes)*10)
		var j61 int
		for _, num := range m.CountryCodes {
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA62[:j61])
		i = encodeVarintTypes(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpHeaderName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpHeaderName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpHeaderName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpCookieName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpCookieName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpCookieName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpQueryParameterName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpQueryParameterName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpQueryParameterName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JwtTokenAuthOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JwtTokenAuthOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JwtTokenAuthOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TokenSource != nil {
		{
			size := m.TokenSource.Size()
			i -= size
			if _, err := m.TokenSource.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SecretKey != nil {
		{
			size, err := m.SecretKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JwtTokenAuthOptions_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JwtTokenAuthOptions_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *JwtTokenAuthOptions_Cookie) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JwtTokenAuthOptions_Cookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cookie != nil {
		{
			size, err := m.Cookie.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *JwtTokenAuthOptions_QueryParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JwtTokenAuthOptions_QueryParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryParam != nil {
		{
			size, err := m.QueryParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *JwtTokenAuthOptions_BearerToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JwtTokenAuthOptions_BearerToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BearerToken != nil {
		{
			size, err := m.BearerToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *IPThreatCategoryListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPThreatCategoryListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPThreatCategoryListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IpThreatCategories) > 0 {
		dAtA69 := make([]byte, len(m.IpThreatCategories)*10)
		var j68 int
		for _, num := range m.IpThreatCategories {
			for num >= 1<<7 {
				dAtA69[j68] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j68++
			}
			dAtA69[j68] = uint8(num)
			j68++
		}
		i -= j68
		copy(dAtA[i:], dAtA69[:j68])
		i = encodeVarintTypes(dAtA, i, uint64(j68))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TlsFingerprintMatcher != nil {
		{
			size, err := m.TlsFingerprintMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.IpAsnChoice != nil {
		{
			size := m.IpAsnChoice.Size()
			i -= size
			if _, err := m.IpAsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ClientChoice != nil {
		{
			size := m.ClientChoice.Size()
			i -= size
			if _, err := m.ClientChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClientMatcher_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMatcher_AnyClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyClient != nil {
		{
			size, err := m.AnyClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ClientMatcher_IpThreatCategoryList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMatcher_IpThreatCategoryList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpThreatCategoryList != nil {
		{
			size, err := m.IpThreatCategoryList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ClientMatcher_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMatcher_ClientSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientSelector != nil {
		{
			size, err := m.ClientSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ClientMatcher_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMatcher_AnyIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyIp != nil {
		{
			size, err := m.AnyIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ClientMatcher_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMatcher_IpPrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixList != nil {
		{
			size, err := m.IpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ClientMatcher_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMatcher_IpMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpMatcher != nil {
		{
			size, err := m.IpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *ClientMatcher_AsnList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMatcher_AsnList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ClientMatcher_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMatcher_AsnMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnMatcher != nil {
		{
			size, err := m.AsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *RequestMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CookieMatchers) > 0 {
		for iNdEx := len(m.CookieMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CookieMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WafRuleControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExcludeRuleIds) > 0 {
		for _, e := range m.ExcludeRuleIds {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.MonitoringMode {
		n += 2
	}
	return n
}

func (m *AppFirewallViolationContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExcludeViolation != 0 {
		n += 1 + sovTypes(uint64(m.ExcludeViolation))
	}
	return n
}

func (m *AppFirewallSignatureContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignatureId != 0 {
		n += 1 + sovTypes(uint64(m.SignatureId))
	}
	return n
}

func (m *AppFirewallAttackTypeContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExcludeAttackType != 0 {
		n += 1 + sovTypes(uint64(m.ExcludeAttackType))
	}
	return n
}

func (m *BotNameContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BotName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AppFirewallDetectionControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExcludeSignatureContexts) > 0 {
		for _, e := range m.ExcludeSignatureContexts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExcludeViolationContexts) > 0 {
		for _, e := range m.ExcludeViolationContexts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExcludeAttackTypeContexts) > 0 {
		for _, e := range m.ExcludeAttackTypeContexts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExcludeBotNameContexts) > 0 {
		for _, e := range m.ExcludeBotNameContexts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DataGuardControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PolicyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *WafInlineRuleControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExcludeRuleIds) > 0 {
		l = 0
		for _, e := range m.ExcludeRuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.MonitoringMode {
		n += 2
	}
	return n
}

func (m *BotAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionType != nil {
		n += m.ActionType.Size()
	}
	return n
}

func (m *BotAction_None) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.None != nil {
		l = m.None.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotAction_BotSkipProcessing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BotSkipProcessing != nil {
		l = m.BotSkipProcessing.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ModifyAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionType != nil {
		n += m.ActionType.Size()
	}
	return n
}

func (m *ModifyAction_Default) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ModifyAction_SkipProcessing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SkipProcessing != nil {
		l = m.SkipProcessing.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionType != nil {
		n += m.ActionType.Size()
	}
	return n
}

func (m *WafAction_WafSkipProcessing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WafSkipProcessing != nil {
		l = m.WafSkipProcessing.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_WafRuleControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WafRuleControl != nil {
		l = m.WafRuleControl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_None) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.None != nil {
		l = m.None.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_WafInlineRuleControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WafInlineRuleControl != nil {
		l = m.WafInlineRuleControl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_WafInMonitoringMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WafInMonitoringMode != nil {
		l = m.WafInMonitoringMode.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_AppFirewallDetectionControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppFirewallDetectionControl != nil {
		l = m.AppFirewallDetectionControl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_DataGuardControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataGuardControl != nil {
		l = m.DataGuardControl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ContentRewriteAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InsertContent)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ElementSelector)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovTypes(uint64(m.Position))
	}
	if len(m.InsertedTypes) > 0 {
		for k, v := range m.InsertedTypes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ShapeProtectedEndpointAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppTrafficType != 0 {
		n += 1 + sovTypes(uint64(m.AppTrafficType))
	}
	if m.Mitigation != nil {
		l = m.Mitigation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.WebScraping {
		n += 2
	}
	return n
}

func (m *ShapeBotMitigationAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionType != nil {
		n += m.ActionType.Size()
	}
	return n
}

func (m *ShapeBotMitigationAction_None) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.None != nil {
		l = m.None.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ShapeBotMitigationAction_Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ShapeBotMitigationAction_Redirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Redirect != nil {
		l = m.Redirect.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ShapeBotMitigationAction_Flag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flag != nil {
		l = m.Flag.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ShapeBotFlagMitigationActionChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SendHeadersChoice != nil {
		n += m.SendHeadersChoice.Size()
	}
	return n
}

func (m *ShapeBotFlagMitigationActionChoiceType_NoHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoHeaders != nil {
		l = m.NoHeaders.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ShapeBotFlagMitigationActionChoiceType_AppendHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppendHeaders != nil {
		l = m.AppendHeaders.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ShapeBotFlagMitigationActionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InferenceHeaderName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AutoTypeHeaderName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ShapeBotBlockMitigationActionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BodyHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ShapeBotRedirectMitigationActionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PrefixMatchList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IpPrefixes) > 0 {
		for _, s := range m.IpPrefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatch {
		n += 2
	}
	return n
}

func (m *AsnMatchList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AsNumbers) > 0 {
		l = 0
		for _, e := range m.AsNumbers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *SimpleWafExclusionRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	l = len(m.PathRegex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Methods) > 0 {
		l = 0
		for _, e := range m.Methods {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.ExcludeRuleIds) > 0 {
		l = 0
		for _, e := range m.ExcludeRuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AppFirewallDetectionControl != nil {
		l = m.AppFirewallDetectionControl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SimpleWafExclusionRule_AnyDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDomain != nil {
		l = m.AnyDomain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SimpleWafExclusionRule_ExactValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExactValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *SimpleWafExclusionRule_SuffixValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SuffixValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *SimpleDataGuardRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ActionChoice != nil {
		n += m.ActionChoice.Size()
	}
	return n
}

func (m *SimpleDataGuardRule_AnyDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDomain != nil {
		l = m.AnyDomain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SimpleDataGuardRule_ExactValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExactValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *SimpleDataGuardRule_SuffixValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SuffixValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *SimpleDataGuardRule_ApplyDataGuard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApplyDataGuard != nil {
		l = m.ApplyDataGuard.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SimpleDataGuardRule_SkipDataGuard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SkipDataGuard != nil {
		l = m.SkipDataGuard.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DenyInformation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseCode != 0 {
		n += 1 + sovTypes(uint64(m.ResponseCode))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EventType != nil {
		n += m.EventType.Size()
	}
	return n
}

func (m *DenyInformation_UndefinedSecEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndefinedSecEvent != nil {
		l = m.UndefinedSecEvent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DenyInformation_ApiSecEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiSecEvent != nil {
		l = m.ApiSecEvent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsFingerprintMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Classes) > 0 {
		l = 0
		for _, e := range m.Classes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExcludedValues) > 0 {
		for _, s := range m.ExcludedValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PathMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PrefixValues) > 0 {
		for _, s := range m.PrefixValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Transformers) > 0 {
		l = 0
		for _, e := range m.Transformers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.SuffixValues) > 0 {
		for _, s := range m.SuffixValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *MatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Transformers) > 0 {
		l = 0
		for _, e := range m.Transformers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *MatcherTypeBasic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CookieMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *CookieMatcherType_Presence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *CookieMatcherType_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieMatcherType_CheckPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieMatcherType_CheckNotPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ArgMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *ArgMatcherType_Presence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ArgMatcherType_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ArgMatcherType_CheckPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ArgMatcherType_CheckNotPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *HeaderMatcherType_Presence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *HeaderMatcherType_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType_CheckPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType_CheckNotPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherTypeBasic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	return n
}

func (m *HeaderMatcherTypeBasic_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherTypeBasic_CheckPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherTypeBasic_CheckNotPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *QueryParameterMatcherType_Presence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *QueryParameterMatcherType_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcherType_CheckPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcherType_CheckNotPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HttpMethodMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Methods) > 0 {
		l = 0
		for _, e := range m.Methods {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *RoleMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Match)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StringMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, s := range m.Match {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *IpMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PrefixSets) > 0 {
		for _, e := range m.PrefixSets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *AsnMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AsnSets) > 0 {
		for _, e := range m.AsnSets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PortMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *URLItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	if m.PathChoice != nil {
		n += m.PathChoice.Size()
	}
	return n
}

func (m *URLItem_DomainValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DomainValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_DomainRegex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DomainRegex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_PathValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_PathRegex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathRegex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_PathPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathPrefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UrlItems) > 0 {
		for _, e := range m.UrlItems {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *L4DestMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvertMatcher {
		n += 2
	}
	if len(m.L4Dests) > 0 {
		for _, e := range m.L4Dests {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CountryCodeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CountryCodes) > 0 {
		l = 0
		for _, e := range m.CountryCodes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.InvertMatch {
		n += 2
	}
	return n
}

func (m *HttpHeaderName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *HttpCookieName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *HttpQueryParameterName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *JwtTokenAuthOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecretKey != nil {
		l = m.SecretKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TokenSource != nil {
		n += m.TokenSource.Size()
	}
	return n
}

func (m *JwtTokenAuthOptions_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *JwtTokenAuthOptions_Cookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cookie != nil {
		l = m.Cookie.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *JwtTokenAuthOptions_QueryParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryParam != nil {
		l = m.QueryParam.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *JwtTokenAuthOptions_BearerToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BearerToken != nil {
		l = m.BearerToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPThreatCategoryListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IpThreatCategories) > 0 {
		l = 0
		for _, e := range m.IpThreatCategories {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *ClientMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.IpAsnChoice != nil {
		n += m.IpAsnChoice.Size()
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ClientMatcher_AnyClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ClientMatcher_IpThreatCategoryList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpThreatCategoryList != nil {
		l = m.IpThreatCategoryList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ClientMatcher_ClientSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ClientMatcher_AnyIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ClientMatcher_IpPrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ClientMatcher_IpMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ClientMatcher_AsnList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ClientMatcher_AsnMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RequestMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WafRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForExcludeRuleIds := "[]*ObjectRefType{"
	for _, f := range this.ExcludeRuleIds {
		repeatedStringForExcludeRuleIds += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForExcludeRuleIds += "}"
	s := strings.Join([]string{`&WafRuleControl{`,
		`ExcludeRuleIds:` + repeatedStringForExcludeRuleIds + `,`,
		`MonitoringMode:` + fmt.Sprintf("%v", this.MonitoringMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppFirewallViolationContext) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppFirewallViolationContext{`,
		`ExcludeViolation:` + fmt.Sprintf("%v", this.ExcludeViolation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppFirewallSignatureContext) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppFirewallSignatureContext{`,
		`SignatureId:` + fmt.Sprintf("%v", this.SignatureId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppFirewallAttackTypeContext) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppFirewallAttackTypeContext{`,
		`ExcludeAttackType:` + fmt.Sprintf("%v", this.ExcludeAttackType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotNameContext) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotNameContext{`,
		`BotName:` + fmt.Sprintf("%v", this.BotName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppFirewallDetectionControl) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForExcludeSignatureContexts := "[]*AppFirewallSignatureContext{"
	for _, f := range this.ExcludeSignatureContexts {
		repeatedStringForExcludeSignatureContexts += strings.Replace(f.String(), "AppFirewallSignatureContext", "AppFirewallSignatureContext", 1) + ","
	}
	repeatedStringForExcludeSignatureContexts += "}"
	repeatedStringForExcludeViolationContexts := "[]*AppFirewallViolationContext{"
	for _, f := range this.ExcludeViolationContexts {
		repeatedStringForExcludeViolationContexts += strings.Replace(f.String(), "AppFirewallViolationContext", "AppFirewallViolationContext", 1) + ","
	}
	repeatedStringForExcludeViolationContexts += "}"
	repeatedStringForExcludeAttackTypeContexts := "[]*AppFirewallAttackTypeContext{"
	for _, f := range this.ExcludeAttackTypeContexts {
		repeatedStringForExcludeAttackTypeContexts += strings.Replace(f.String(), "AppFirewallAttackTypeContext", "AppFirewallAttackTypeContext", 1) + ","
	}
	repeatedStringForExcludeAttackTypeContexts += "}"
	repeatedStringForExcludeBotNameContexts := "[]*BotNameContext{"
	for _, f := range this.ExcludeBotNameContexts {
		repeatedStringForExcludeBotNameContexts += strings.Replace(f.String(), "BotNameContext", "BotNameContext", 1) + ","
	}
	repeatedStringForExcludeBotNameContexts += "}"
	s := strings.Join([]string{`&AppFirewallDetectionControl{`,
		`ExcludeSignatureContexts:` + repeatedStringForExcludeSignatureContexts + `,`,
		`ExcludeViolationContexts:` + repeatedStringForExcludeViolationContexts + `,`,
		`ExcludeAttackTypeContexts:` + repeatedStringForExcludeAttackTypeContexts + `,`,
		`ExcludeBotNameContexts:` + repeatedStringForExcludeBotNameContexts + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataGuardControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataGuardControl{`,
		`PolicyName:` + fmt.Sprintf("%v", this.PolicyName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafInlineRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafInlineRuleControl{`,
		`ExcludeRuleIds:` + fmt.Sprintf("%v", this.ExcludeRuleIds) + `,`,
		`MonitoringMode:` + fmt.Sprintf("%v", this.MonitoringMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotAction{`,
		`ActionType:` + fmt.Sprintf("%v", this.ActionType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotAction_None) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotAction_None{`,
		`None:` + strings.Replace(fmt.Sprintf("%v", this.None), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotAction_BotSkipProcessing) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotAction_BotSkipProcessing{`,
		`BotSkipProcessing:` + strings.Replace(fmt.Sprintf("%v", this.BotSkipProcessing), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyAction{`,
		`ActionType:` + fmt.Sprintf("%v", this.ActionType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyAction_Default) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyAction_Default{`,
		`Default:` + strings.Replace(fmt.Sprintf("%v", this.Default), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyAction_SkipProcessing) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyAction_SkipProcessing{`,
		`SkipProcessing:` + strings.Replace(fmt.Sprintf("%v", this.SkipProcessing), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction{`,
		`ActionType:` + fmt.Sprintf("%v", this.ActionType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafSkipProcessing) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafSkipProcessing{`,
		`WafSkipProcessing:` + strings.Replace(fmt.Sprintf("%v", this.WafSkipProcessing), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafRuleControl{`,
		`WafRuleControl:` + strings.Replace(fmt.Sprintf("%v", this.WafRuleControl), "WafRuleControl", "WafRuleControl", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_None) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_None{`,
		`None:` + strings.Replace(fmt.Sprintf("%v", this.None), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafInlineRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafInlineRuleControl{`,
		`WafInlineRuleControl:` + strings.Replace(fmt.Sprintf("%v", this.WafInlineRuleControl), "WafInlineRuleControl", "WafInlineRuleControl", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafInMonitoringMode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafInMonitoringMode{`,
		`WafInMonitoringMode:` + strings.Replace(fmt.Sprintf("%v", this.WafInMonitoringMode), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_AppFirewallDetectionControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_AppFirewallDetectionControl{`,
		`AppFirewallDetectionControl:` + strings.Replace(fmt.Sprintf("%v", this.AppFirewallDetectionControl), "AppFirewallDetectionControl", "AppFirewallDetectionControl", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_DataGuardControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_DataGuardControl{`,
		`DataGuardControl:` + strings.Replace(fmt.Sprintf("%v", this.DataGuardControl), "DataGuardControl", "DataGuardControl", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContentRewriteAction) String() string {
	if this == nil {
		return "nil"
	}
	keysForInsertedTypes := make([]string, 0, len(this.InsertedTypes))
	for k, _ := range this.InsertedTypes {
		keysForInsertedTypes = append(keysForInsertedTypes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInsertedTypes)
	mapStringForInsertedTypes := "map[string]bool{"
	for _, k := range keysForInsertedTypes {
		mapStringForInsertedTypes += fmt.Sprintf("%v: %v,", k, this.InsertedTypes[k])
	}
	mapStringForInsertedTypes += "}"
	s := strings.Join([]string{`&ContentRewriteAction{`,
		`InsertContent:` + fmt.Sprintf("%v", this.InsertContent) + `,`,
		`ElementSelector:` + fmt.Sprintf("%v", this.ElementSelector) + `,`,
		`Position:` + fmt.Sprintf("%v", this.Position) + `,`,
		`InsertedTypes:` + mapStringForInsertedTypes + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeProtectedEndpointAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeProtectedEndpointAction{`,
		`AppTrafficType:` + fmt.Sprintf("%v", this.AppTrafficType) + `,`,
		`Mitigation:` + strings.Replace(this.Mitigation.String(), "ShapeBotMitigationAction", "ShapeBotMitigationAction", 1) + `,`,
		`WebScraping:` + fmt.Sprintf("%v", this.WebScraping) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotMitigationAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotMitigationAction{`,
		`ActionType:` + fmt.Sprintf("%v", this.ActionType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotMitigationAction_None) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotMitigationAction_None{`,
		`None:` + strings.Replace(fmt.Sprintf("%v", this.None), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotMitigationAction_Block) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotMitigationAction_Block{`,
		`Block:` + strings.Replace(fmt.Sprintf("%v", this.Block), "ShapeBotBlockMitigationActionType", "ShapeBotBlockMitigationActionType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotMitigationAction_Redirect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotMitigationAction_Redirect{`,
		`Redirect:` + strings.Replace(fmt.Sprintf("%v", this.Redirect), "ShapeBotRedirectMitigationActionType", "ShapeBotRedirectMitigationActionType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotMitigationAction_Flag) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotMitigationAction_Flag{`,
		`Flag:` + strings.Replace(fmt.Sprintf("%v", this.Flag), "ShapeBotFlagMitigationActionChoiceType", "ShapeBotFlagMitigationActionChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotFlagMitigationActionChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotFlagMitigationActionChoiceType{`,
		`SendHeadersChoice:` + fmt.Sprintf("%v", this.SendHeadersChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotFlagMitigationActionChoiceType_NoHeaders) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotFlagMitigationActionChoiceType_NoHeaders{`,
		`NoHeaders:` + strings.Replace(fmt.Sprintf("%v", this.NoHeaders), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotFlagMitigationActionChoiceType_AppendHeaders) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotFlagMitigationActionChoiceType_AppendHeaders{`,
		`AppendHeaders:` + strings.Replace(fmt.Sprintf("%v", this.AppendHeaders), "ShapeBotFlagMitigationActionType", "ShapeBotFlagMitigationActionType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotFlagMitigationActionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotFlagMitigationActionType{`,
		`InferenceHeaderName:` + fmt.Sprintf("%v", this.InferenceHeaderName) + `,`,
		`AutoTypeHeaderName:` + fmt.Sprintf("%v", this.AutoTypeHeaderName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotBlockMitigationActionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotBlockMitigationActionType{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`BodyHash:` + fmt.Sprintf("%v", this.BodyHash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShapeBotRedirectMitigationActionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShapeBotRedirectMitigationActionType{`,
		`Uri:` + fmt.Sprintf("%v", this.Uri) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrefixMatchList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrefixMatchList{`,
		`IpPrefixes:` + fmt.Sprintf("%v", this.IpPrefixes) + `,`,
		`InvertMatch:` + fmt.Sprintf("%v", this.InvertMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AsnMatchList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AsnMatchList{`,
		`AsNumbers:` + fmt.Sprintf("%v", this.AsNumbers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleWafExclusionRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleWafExclusionRule{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`PathRegex:` + fmt.Sprintf("%v", this.PathRegex) + `,`,
		`Methods:` + fmt.Sprintf("%v", this.Methods) + `,`,
		`ExcludeRuleIds:` + fmt.Sprintf("%v", this.ExcludeRuleIds) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`AppFirewallDetectionControl:` + strings.Replace(this.AppFirewallDetectionControl.String(), "AppFirewallDetectionControl", "AppFirewallDetectionControl", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleWafExclusionRule_AnyDomain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleWafExclusionRule_AnyDomain{`,
		`AnyDomain:` + strings.Replace(fmt.Sprintf("%v", this.AnyDomain), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleWafExclusionRule_ExactValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleWafExclusionRule_ExactValue{`,
		`ExactValue:` + fmt.Sprintf("%v", this.ExactValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleWafExclusionRule_SuffixValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleWafExclusionRule_SuffixValue{`,
		`SuffixValue:` + fmt.Sprintf("%v", this.SuffixValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleDataGuardRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleDataGuardRule{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "schema.PathMatcherType", 1) + `,`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`ActionChoice:` + fmt.Sprintf("%v", this.ActionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleDataGuardRule_AnyDomain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleDataGuardRule_AnyDomain{`,
		`AnyDomain:` + strings.Replace(fmt.Sprintf("%v", this.AnyDomain), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleDataGuardRule_ExactValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleDataGuardRule_ExactValue{`,
		`ExactValue:` + fmt.Sprintf("%v", this.ExactValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleDataGuardRule_SuffixValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleDataGuardRule_SuffixValue{`,
		`SuffixValue:` + fmt.Sprintf("%v", this.SuffixValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleDataGuardRule_ApplyDataGuard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleDataGuardRule_ApplyDataGuard{`,
		`ApplyDataGuard:` + strings.Replace(fmt.Sprintf("%v", this.ApplyDataGuard), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleDataGuardRule_SkipDataGuard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleDataGuardRule_SkipDataGuard{`,
		`SkipDataGuard:` + strings.Replace(fmt.Sprintf("%v", this.SkipDataGuard), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DenyInformation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DenyInformation{`,
		`ResponseCode:` + fmt.Sprintf("%v", this.ResponseCode) + `,`,
		`ErrorMessage:` + fmt.Sprintf("%v", this.ErrorMessage) + `,`,
		`EventType:` + fmt.Sprintf("%v", this.EventType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DenyInformation_UndefinedSecEvent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DenyInformation_UndefinedSecEvent{`,
		`UndefinedSecEvent:` + strings.Replace(fmt.Sprintf("%v", this.UndefinedSecEvent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DenyInformation_ApiSecEvent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DenyInformation_ApiSecEvent{`,
		`ApiSecEvent:` + strings.Replace(fmt.Sprintf("%v", this.ApiSecEvent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsFingerprintMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsFingerprintMatcherType{`,
		`Classes:` + fmt.Sprintf("%v", this.Classes) + `,`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`ExcludedValues:` + fmt.Sprintf("%v", this.ExcludedValues) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType{`,
		`PrefixValues:` + fmt.Sprintf("%v", this.PrefixValues) + `,`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`RegexValues:` + fmt.Sprintf("%v", this.RegexValues) + `,`,
		`Transformers:` + fmt.Sprintf("%v", this.Transformers) + `,`,
		`SuffixValues:` + fmt.Sprintf("%v", this.SuffixValues) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatcherType{`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`RegexValues:` + fmt.Sprintf("%v", this.RegexValues) + `,`,
		`Transformers:` + fmt.Sprintf("%v", this.Transformers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatcherTypeBasic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatcherTypeBasic{`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`RegexValues:` + fmt.Sprintf("%v", this.RegexValues) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherTypeBasic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherTypeBasic{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherTypeBasic_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherTypeBasic_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherTypeBasic_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherTypeBasic_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherTypeBasic_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherTypeBasic_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HttpMethodMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HttpMethodMatcherType{`,
		`Methods:` + fmt.Sprintf("%v", this.Methods) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoleMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoleMatcherType{`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StringMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StringMatcherType{`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPrefixSets := "[]*ObjectRefType{"
	for _, f := range this.PrefixSets {
		repeatedStringForPrefixSets += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForPrefixSets += "}"
	s := strings.Join([]string{`&IpMatcherType{`,
		`PrefixSets:` + repeatedStringForPrefixSets + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AsnMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAsnSets := "[]*ObjectRefType{"
	for _, f := range this.AsnSets {
		repeatedStringForAsnSets += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForAsnSets += "}"
	s := strings.Join([]string{`&AsnMatcherType{`,
		`AsnSets:` + repeatedStringForAsnSets + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortMatcherType{`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`PathChoice:` + fmt.Sprintf("%v", this.PathChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_DomainValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_DomainValue{`,
		`DomainValue:` + fmt.Sprintf("%v", this.DomainValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_DomainRegex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_DomainRegex{`,
		`DomainRegex:` + fmt.Sprintf("%v", this.DomainRegex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_PathValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_PathValue{`,
		`PathValue:` + fmt.Sprintf("%v", this.PathValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_PathRegex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_PathRegex{`,
		`PathRegex:` + fmt.Sprintf("%v", this.PathRegex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_PathPrefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_PathPrefix{`,
		`PathPrefix:` + fmt.Sprintf("%v", this.PathPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUrlItems := "[]*URLItem{"
	for _, f := range this.UrlItems {
		repeatedStringForUrlItems += strings.Replace(f.String(), "URLItem", "URLItem", 1) + ","
	}
	repeatedStringForUrlItems += "}"
	s := strings.Join([]string{`&URLMatcherType{`,
		`UrlItems:` + repeatedStringForUrlItems + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L4DestMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForL4Dests := "[]*L4DestType{"
	for _, f := range this.L4Dests {
		repeatedStringForL4Dests += strings.Replace(fmt.Sprintf("%v", f), "L4DestType", "schema.L4DestType", 1) + ","
	}
	repeatedStringForL4Dests += "}"
	s := strings.Join([]string{`&L4DestMatcherType{`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`L4Dests:` + repeatedStringForL4Dests + `,`,
		`}`,
	}, "")
	return s
}
func (this *CountryCodeList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CountryCodeList{`,
		`CountryCodes:` + fmt.Sprintf("%v", this.CountryCodes) + `,`,
		`InvertMatch:` + fmt.Sprintf("%v", this.InvertMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HttpHeaderName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HttpHeaderName{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HttpCookieName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HttpCookieName{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HttpQueryParameterName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HttpQueryParameterName{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JwtTokenAuthOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JwtTokenAuthOptions{`,
		`SecretKey:` + strings.Replace(fmt.Sprintf("%v", this.SecretKey), "SecretType", "schema.SecretType", 1) + `,`,
		`TokenSource:` + fmt.Sprintf("%v", this.TokenSource) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JwtTokenAuthOptions_Header) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JwtTokenAuthOptions_Header{`,
		`Header:` + strings.Replace(fmt.Sprintf("%v", this.Header), "HttpHeaderName", "HttpHeaderName", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JwtTokenAuthOptions_Cookie) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JwtTokenAuthOptions_Cookie{`,
		`Cookie:` + strings.Replace(fmt.Sprintf("%v", this.Cookie), "HttpCookieName", "HttpCookieName", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JwtTokenAuthOptions_QueryParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JwtTokenAuthOptions_QueryParam{`,
		`QueryParam:` + strings.Replace(fmt.Sprintf("%v", this.QueryParam), "HttpQueryParameterName", "HttpQueryParameterName", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JwtTokenAuthOptions_BearerToken) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JwtTokenAuthOptions_BearerToken{`,
		`BearerToken:` + strings.Replace(fmt.Sprintf("%v", this.BearerToken), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPThreatCategoryListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPThreatCategoryListType{`,
		`IpThreatCategories:` + fmt.Sprintf("%v", this.IpThreatCategories) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientMatcher{`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`IpAsnChoice:` + fmt.Sprintf("%v", this.IpAsnChoice) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(this.TlsFingerprintMatcher.String(), "TlsFingerprintMatcherType", "TlsFingerprintMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientMatcher_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientMatcher_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientMatcher_IpThreatCategoryList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientMatcher_IpThreatCategoryList{`,
		`IpThreatCategoryList:` + strings.Replace(fmt.Sprintf("%v", this.IpThreatCategoryList), "IPThreatCategoryListType", "IPThreatCategoryListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientMatcher_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientMatcher_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientMatcher_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientMatcher_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientMatcher_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientMatcher_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientMatcher_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientMatcher_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientMatcher_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientMatcher_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientMatcher_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientMatcher_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestMatcher) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForQueryParams := "[]*QueryParameterMatcherType{"
	for _, f := range this.QueryParams {
		repeatedStringForQueryParams += strings.Replace(f.String(), "QueryParameterMatcherType", "QueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParams += "}"
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(f.String(), "HeaderMatcherType", "HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	repeatedStringForCookieMatchers := "[]*CookieMatcherType{"
	for _, f := range this.CookieMatchers {
		repeatedStringForCookieMatchers += strings.Replace(f.String(), "CookieMatcherType", "CookieMatcherType", 1) + ","
	}
	repeatedStringForCookieMatchers += "}"
	s := strings.Join([]string{`&RequestMatcher{`,
		`QueryParams:` + repeatedStringForQueryParams + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`CookieMatchers:` + repeatedStringForCookieMatchers + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *WafRuleControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafRuleControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafRuleControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeRuleIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeRuleIds = append(m.ExcludeRuleIds, &schema.ObjectRefType{})
			if err := m.ExcludeRuleIds[len(m.ExcludeRuleIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitoringMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MonitoringMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFirewallViolationContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFirewallViolationContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFirewallViolationContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeViolation", wireType)
			}
			m.ExcludeViolation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExcludeViolation |= app_firewall.AppFirewallViolationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFirewallSignatureContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFirewallSignatureContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFirewallSignatureContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureId", wireType)
			}
			m.SignatureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignatureId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFirewallAttackTypeContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFirewallAttackTypeContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFirewallAttackTypeContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeAttackType", wireType)
			}
			m.ExcludeAttackType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExcludeAttackType |= app_firewall.AttackType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotNameContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotNameContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotNameContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BotName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFirewallDetectionControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFirewallDetectionControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFirewallDetectionControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeSignatureContexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeSignatureContexts = append(m.ExcludeSignatureContexts, &AppFirewallSignatureContext{})
			if err := m.ExcludeSignatureContexts[len(m.ExcludeSignatureContexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeViolationContexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeViolationContexts = append(m.ExcludeViolationContexts, &AppFirewallViolationContext{})
			if err := m.ExcludeViolationContexts[len(m.ExcludeViolationContexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeAttackTypeContexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeAttackTypeContexts = append(m.ExcludeAttackTypeContexts, &AppFirewallAttackTypeContext{})
			if err := m.ExcludeAttackTypeContexts[len(m.ExcludeAttackTypeContexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeBotNameContexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeBotNameContexts = append(m.ExcludeBotNameContexts, &BotNameContext{})
			if err := m.ExcludeBotNameContexts[len(m.ExcludeBotNameContexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataGuardControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataGuardControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataGuardControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafInlineRuleControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafInlineRuleControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafInlineRuleControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= waf_rule_list.WafRuleID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ExcludeRuleIds) == 0 {
					m.ExcludeRuleIds = make([]waf_rule_list.WafRuleID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= waf_rule_list.WafRuleID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeRuleIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitoringMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MonitoringMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field None", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &BotAction_None{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotSkipProcessing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &BotAction_BotSkipProcessing{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &ModifyAction_Default{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipProcessing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &ModifyAction_SkipProcessing{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafSkipProcessing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafSkipProcessing{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafRuleControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WafRuleControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafRuleControl{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field None", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_None{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafInlineRuleControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WafInlineRuleControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafInlineRuleControl{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafInMonitoringMode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafInMonitoringMode{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFirewallDetectionControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppFirewallDetectionControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_AppFirewallDetectionControl{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataGuardControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataGuardControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_DataGuardControl{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentRewriteAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentRewriteAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentRewriteAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsertContent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementSelector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElementSelector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= HTMLPosition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertedTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsertedTypes == nil {
				m.InsertedTypes = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InsertedTypes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShapeProtectedEndpointAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShapeProtectedEndpointAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShapeProtectedEndpointAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppTrafficType", wireType)
			}
			m.AppTrafficType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppTrafficType |= AppTrafficType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mitigation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mitigation == nil {
				m.Mitigation = &ShapeBotMitigationAction{}
			}
			if err := m.Mitigation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebScraping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WebScraping = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShapeBotMitigationAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShapeBotMitigationAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShapeBotMitigationAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field None", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &ShapeBotMitigationAction_None{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShapeBotBlockMitigationActionType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &ShapeBotMitigationAction_Block{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShapeBotRedirectMitigationActionType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &ShapeBotMitigationAction_Redirect{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShapeBotFlagMitigationActionChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &ShapeBotMitigationAction_Flag{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShapeBotFlagMitigationActionChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShapeBotFlagMitigationActionChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShapeBotFlagMitigationActionChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SendHeadersChoice = &ShapeBotFlagMitigationActionChoiceType_NoHeaders{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShapeBotFlagMitigationActionType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SendHeadersChoice = &ShapeBotFlagMitigationActionChoiceType_AppendHeaders{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShapeBotFlagMitigationActionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShapeBotFlagMitigationActionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShapeBotFlagMitigationActionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferenceHeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InferenceHeaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoTypeHeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoTypeHeaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShapeBotBlockMitigationActionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShapeBotBlockMitigationActionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShapeBotBlockMitigationActionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= schema.HttpStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShapeBotRedirectMitigationActionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShapeBotRedirectMitigationActionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShapeBotRedirectMitigationActionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrefixMatchList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrefixMatchList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrefixMatchList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefixes = append(m.IpPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsnMatchList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsnMatchList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsnMatchList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AsNumbers = append(m.AsNumbers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AsNumbers) == 0 {
					m.AsNumbers = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AsNumbers = append(m.AsNumbers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumbers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleWafExclusionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleWafExclusionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleWafExclusionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &SimpleWafExclusionRule_AnyDomain{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v schema.HttpMethod
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.HttpMethod(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Methods = append(m.Methods, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Methods) == 0 {
					m.Methods = make([]schema.HttpMethod, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.HttpMethod
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.HttpMethod(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Methods = append(m.Methods, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
		case 8:
			if wireType == 0 {
				var v waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= waf_rule_list.WafRuleID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ExcludeRuleIds) == 0 {
					m.ExcludeRuleIds = make([]waf_rule_list.WafRuleID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= waf_rule_list.WafRuleID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeRuleIds", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFirewallDetectionControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppFirewallDetectionControl == nil {
				m.AppFirewallDetectionControl = &AppFirewallDetectionControl{}
			}
			if err := m.AppFirewallDetectionControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &SimpleWafExclusionRule_ExactValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &SimpleWafExclusionRule_SuffixValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleDataGuardRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleDataGuardRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleDataGuardRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &SimpleDataGuardRule_AnyDomain{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &schema.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &SimpleDataGuardRule_ExactValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &SimpleDataGuardRule_SuffixValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyDataGuard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &SimpleDataGuardRule_ApplyDataGuard{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipDataGuard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &SimpleDataGuardRule_SkipDataGuard{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenyInformation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenyInformation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenyInformation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndefinedSecEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EventType = &DenyInformation_UndefinedSecEvent{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiSecEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EventType = &DenyInformation_ApiSecEvent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsFingerprintMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsFingerprintMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsFingerprintMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v KnownTlsFingerprintClass
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= KnownTlsFingerprintClass(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Classes = append(m.Classes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Classes) == 0 {
					m.Classes = make([]KnownTlsFingerprintClass, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v KnownTlsFingerprintClass
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= KnownTlsFingerprintClass(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Classes = append(m.Classes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Classes", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludedValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludedValues = append(m.ExcludedValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixValues = append(m.PrefixValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegexValues = append(m.RegexValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v Transformer
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Transformer(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Transformers = append(m.Transformers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Transformers) == 0 {
					m.Transformers = make([]Transformer, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Transformer
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Transformer(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Transformers = append(m.Transformers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Transformers", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuffixValues = append(m.SuffixValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegexValues = append(m.RegexValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v Transformer
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Transformer(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Transformers = append(m.Transformers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Transformers) == 0 {
					m.Transformers = make([]Transformer, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Transformer
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Transformer(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Transformers = append(m.Transformers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Transformers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatcherTypeBasic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatcherTypeBasic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatcherTypeBasic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegexValues = append(m.RegexValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CookieMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CookieMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CookieMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &CookieMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &CookieMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &CookieMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &CookieMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &ArgMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ArgMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ArgMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ArgMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &HeaderMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcherTypeBasic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcherTypeBasic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcherTypeBasic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherTypeBasic_Item{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherTypeBasic_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherTypeBasic_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParameterMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParameterMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParameterMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &QueryParameterMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &QueryParameterMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &QueryParameterMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &QueryParameterMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpMethodMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpMethodMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpMethodMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v schema.HttpMethod
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.HttpMethod(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Methods = append(m.Methods, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Methods) == 0 {
					m.Methods = make([]schema.HttpMethod, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.HttpMethod
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.HttpMethod(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Methods = append(m.Methods, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixSets = append(m.PrefixSets, &schema.ObjectRefType{})
			if err := m.PrefixSets[len(m.PrefixSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsnMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsnMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsnMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsnSets = append(m.AsnSets, &schema.ObjectRefType{})
			if err := m.AsnSets[len(m.AsnSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &URLItem_DomainValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &URLItem_DomainRegex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathChoice = &URLItem_PathValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathChoice = &URLItem_PathRegex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathChoice = &URLItem_PathPrefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlItems = append(m.UrlItems, &URLItem{})
			if err := m.UrlItems[len(m.UrlItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4DestMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4DestMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4DestMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Dests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.L4Dests = append(m.L4Dests, &schema.L4DestType{})
			if err := m.L4Dests[len(m.L4Dests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountryCodeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountryCodeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountryCodeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v CountryCode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= CountryCode(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CountryCodes = append(m.CountryCodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.CountryCodes) == 0 {
					m.CountryCodes = make([]CountryCode, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v CountryCode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= CountryCode(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CountryCodes = append(m.CountryCodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCodes", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpHeaderName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpHeaderName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpHeaderName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpCookieName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpCookieName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpCookieName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpQueryParameterName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpQueryParameterName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpQueryParameterName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JwtTokenAuthOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JwtTokenAuthOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JwtTokenAuthOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretKey == nil {
				m.SecretKey = &schema.SecretType{}
			}
			if err := m.SecretKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HttpHeaderName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TokenSource = &JwtTokenAuthOptions_Header{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HttpCookieName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TokenSource = &JwtTokenAuthOptions_Cookie{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HttpQueryParameterName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TokenSource = &JwtTokenAuthOptions_QueryParam{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TokenSource = &JwtTokenAuthOptions_BearerToken{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPThreatCategoryListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPThreatCategoryListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPThreatCategoryListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v IPThreatCategory
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= IPThreatCategory(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IpThreatCategories = append(m.IpThreatCategories, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.IpThreatCategories) == 0 {
					m.IpThreatCategories = make([]IPThreatCategory, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v IPThreatCategory
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= IPThreatCategory(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IpThreatCategories = append(m.IpThreatCategories, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IpThreatCategories", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ClientMatcher_AnyClient{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpThreatCategoryList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPThreatCategoryListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ClientMatcher_IpThreatCategoryList{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ClientMatcher_ClientSelector{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpAsnChoice = &ClientMatcher_AnyIp{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpAsnChoice = &ClientMatcher_IpPrefixList{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpAsnChoice = &ClientMatcher_IpMatcher{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpAsnChoice = &ClientMatcher_AsnList{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpAsnChoice = &ClientMatcher_AsnMatcher{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
