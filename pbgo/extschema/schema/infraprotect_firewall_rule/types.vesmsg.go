// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package infraprotect_firewall_rule

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) ActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) DestinationPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_prefix")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) DestinationPrefixDestinationPrefixSingleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DestinationPrefixSingle, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_prefix_single")
	}
	return oValidatorFn_DestinationPrefixSingle, nil
}

func (v *ValidateCreateSpecType) FragmentsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fragments")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ProtocolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for protocol")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) SourcePrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_prefix")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) SourcePrefixSourcePrefixSingleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SourcePrefixSingle, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_prefix_single")
	}
	return oValidatorFn_SourcePrefixSingle, nil
}

func (v *ValidateCreateSpecType) StateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for state")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) VersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for version")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action"]; exists {
		val := m.GetAction()
		vOpts := append(opts,
			db.WithValidateField("action"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAction().(type) {
	case *CreateSpecType_ActionDeny:
		if fv, exists := v.FldValidators["action.action_deny"]; exists {
			val := m.GetAction().(*CreateSpecType_ActionDeny).ActionDeny
			vOpts := append(opts,
				db.WithValidateField("action"),
				db.WithValidateField("action_deny"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ActionAllow:
		if fv, exists := v.FldValidators["action.action_allow"]; exists {
			val := m.GetAction().(*CreateSpecType_ActionAllow).ActionAllow
			vOpts := append(opts,
				db.WithValidateField("action"),
				db.WithValidateField("action_allow"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["destination_prefix"]; exists {
		val := m.GetDestinationPrefix()
		vOpts := append(opts,
			db.WithValidateField("destination_prefix"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDestinationPrefix().(type) {
	case *CreateSpecType_DestinationPrefixSingle:
		if fv, exists := v.FldValidators["destination_prefix.destination_prefix_single"]; exists {
			val := m.GetDestinationPrefix().(*CreateSpecType_DestinationPrefixSingle).DestinationPrefixSingle
			vOpts := append(opts,
				db.WithValidateField("destination_prefix"),
				db.WithValidateField("destination_prefix_single"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DestinationPrefixAll:
		if fv, exists := v.FldValidators["destination_prefix.destination_prefix_all"]; exists {
			val := m.GetDestinationPrefix().(*CreateSpecType_DestinationPrefixAll).DestinationPrefixAll
			vOpts := append(opts,
				db.WithValidateField("destination_prefix"),
				db.WithValidateField("destination_prefix_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["fragments"]; exists {
		val := m.GetFragments()
		vOpts := append(opts,
			db.WithValidateField("fragments"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFragments().(type) {
	case *CreateSpecType_FragmentsDeny:
		if fv, exists := v.FldValidators["fragments.fragments_deny"]; exists {
			val := m.GetFragments().(*CreateSpecType_FragmentsDeny).FragmentsDeny
			vOpts := append(opts,
				db.WithValidateField("fragments"),
				db.WithValidateField("fragments_deny"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_FragmentsAllow:
		if fv, exists := v.FldValidators["fragments.fragments_allow"]; exists {
			val := m.GetFragments().(*CreateSpecType_FragmentsAllow).FragmentsAllow
			vOpts := append(opts,
				db.WithValidateField("fragments"),
				db.WithValidateField("fragments_allow"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {
		val := m.GetProtocol()
		vOpts := append(opts,
			db.WithValidateField("protocol"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetProtocol().(type) {
	case *CreateSpecType_ProtocolUdp:
		if fv, exists := v.FldValidators["protocol.protocol_udp"]; exists {
			val := m.GetProtocol().(*CreateSpecType_ProtocolUdp).ProtocolUdp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_udp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ProtocolTcp:
		if fv, exists := v.FldValidators["protocol.protocol_tcp"]; exists {
			val := m.GetProtocol().(*CreateSpecType_ProtocolTcp).ProtocolTcp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_tcp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ProtocolAh:
		if fv, exists := v.FldValidators["protocol.protocol_ah"]; exists {
			val := m.GetProtocol().(*CreateSpecType_ProtocolAh).ProtocolAh
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_ah"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ProtocolEsp:
		if fv, exists := v.FldValidators["protocol.protocol_esp"]; exists {
			val := m.GetProtocol().(*CreateSpecType_ProtocolEsp).ProtocolEsp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_esp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ProtocolGre:
		if fv, exists := v.FldValidators["protocol.protocol_gre"]; exists {
			val := m.GetProtocol().(*CreateSpecType_ProtocolGre).ProtocolGre
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_gre"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ProtocolIcmp:
		if fv, exists := v.FldValidators["protocol.protocol_icmp"]; exists {
			val := m.GetProtocol().(*CreateSpecType_ProtocolIcmp).ProtocolIcmp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_icmp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ProtocolIcmp6:
		if fv, exists := v.FldValidators["protocol.protocol_icmp6"]; exists {
			val := m.GetProtocol().(*CreateSpecType_ProtocolIcmp6).ProtocolIcmp6
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_icmp6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ProtocolIpv6:
		if fv, exists := v.FldValidators["protocol.protocol_ipv6"]; exists {
			val := m.GetProtocol().(*CreateSpecType_ProtocolIpv6).ProtocolIpv6
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ProtocolAll:
		if fv, exists := v.FldValidators["protocol.protocol_all"]; exists {
			val := m.GetProtocol().(*CreateSpecType_ProtocolAll).ProtocolAll
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["source_prefix"]; exists {
		val := m.GetSourcePrefix()
		vOpts := append(opts,
			db.WithValidateField("source_prefix"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSourcePrefix().(type) {
	case *CreateSpecType_SourcePrefixSingle:
		if fv, exists := v.FldValidators["source_prefix.source_prefix_single"]; exists {
			val := m.GetSourcePrefix().(*CreateSpecType_SourcePrefixSingle).SourcePrefixSingle
			vOpts := append(opts,
				db.WithValidateField("source_prefix"),
				db.WithValidateField("source_prefix_single"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_SourcePrefixAll:
		if fv, exists := v.FldValidators["source_prefix.source_prefix_all"]; exists {
			val := m.GetSourcePrefix().(*CreateSpecType_SourcePrefixAll).SourcePrefixAll
			vOpts := append(opts,
				db.WithValidateField("source_prefix"),
				db.WithValidateField("source_prefix_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {
		val := m.GetState()
		vOpts := append(opts,
			db.WithValidateField("state"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetState().(type) {
	case *CreateSpecType_StateOff:
		if fv, exists := v.FldValidators["state.state_off"]; exists {
			val := m.GetState().(*CreateSpecType_StateOff).StateOff
			vOpts := append(opts,
				db.WithValidateField("state"),
				db.WithValidateField("state_off"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_StateOn:
		if fv, exists := v.FldValidators["state.state_on"]; exists {
			val := m.GetState().(*CreateSpecType_StateOn).StateOn
			vOpts := append(opts,
				db.WithValidateField("state"),
				db.WithValidateField("state_on"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {
		val := m.GetVersion()
		vOpts := append(opts,
			db.WithValidateField("version"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVersion().(type) {
	case *CreateSpecType_VersionIpv4:
		if fv, exists := v.FldValidators["version.version_ipv4"]; exists {
			val := m.GetVersion().(*CreateSpecType_VersionIpv4).VersionIpv4
			vOpts := append(opts,
				db.WithValidateField("version"),
				db.WithValidateField("version_ipv4"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_VersionIpv6:
		if fv, exists := v.FldValidators["version.version_ipv6"]; exists {
			val := m.GetVersion().(*CreateSpecType_VersionIpv6).VersionIpv6
			vOpts := append(opts,
				db.WithValidateField("version"),
				db.WithValidateField("version_ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAction := v.ActionValidationRuleHandler
	rulesAction := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAction(rulesAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action"] = vFn

	vrhDestinationPrefix := v.DestinationPrefixValidationRuleHandler
	rulesDestinationPrefix := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDestinationPrefix(rulesDestinationPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.destination_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["destination_prefix"] = vFn

	vrhDestinationPrefixDestinationPrefixSingle := v.DestinationPrefixDestinationPrefixSingleValidationRuleHandler
	rulesDestinationPrefixDestinationPrefixSingle := map[string]string{
		"ves.io.schema.rules.string.ip_prefix_globally_routable": "true",
	}
	vFnMap["destination_prefix.destination_prefix_single"], err = vrhDestinationPrefixDestinationPrefixSingle(rulesDestinationPrefixDestinationPrefixSingle)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.destination_prefix_destination_prefix_single: %s", err)
		panic(errMsg)
	}

	v.FldValidators["destination_prefix.destination_prefix_single"] = vFnMap["destination_prefix.destination_prefix_single"]

	vrhFragments := v.FragmentsValidationRuleHandler
	rulesFragments := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFragments(rulesFragments)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.fragments: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fragments"] = vFn

	vrhProtocol := v.ProtocolValidationRuleHandler
	rulesProtocol := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhProtocol(rulesProtocol)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.protocol: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protocol"] = vFn

	vrhSourcePrefix := v.SourcePrefixValidationRuleHandler
	rulesSourcePrefix := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSourcePrefix(rulesSourcePrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.source_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["source_prefix"] = vFn

	vrhSourcePrefixSourcePrefixSingle := v.SourcePrefixSourcePrefixSingleValidationRuleHandler
	rulesSourcePrefixSourcePrefixSingle := map[string]string{
		"ves.io.schema.rules.string.ip_prefix_globally_routable": "true",
	}
	vFnMap["source_prefix.source_prefix_single"], err = vrhSourcePrefixSourcePrefixSingle(rulesSourcePrefixSourcePrefixSingle)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.source_prefix_source_prefix_single: %s", err)
		panic(errMsg)
	}

	v.FldValidators["source_prefix.source_prefix_single"] = vFnMap["source_prefix.source_prefix_single"]

	vrhState := v.StateValidationRuleHandler
	rulesState := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhState(rulesState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["state"] = vFn

	vrhVersion := v.VersionValidationRuleHandler
	rulesVersion := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVersion(rulesVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["version"] = vFn

	v.FldValidators["protocol.protocol_udp"] = UDPProtocolValidator().Validate
	v.FldValidators["protocol.protocol_tcp"] = TCPProtocolValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) ActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) DestinationPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_prefix")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) DestinationPrefixDestinationPrefixSingleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DestinationPrefixSingle, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_prefix_single")
	}
	return oValidatorFn_DestinationPrefixSingle, nil
}

func (v *ValidateGetSpecType) FragmentsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fragments")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) ProtocolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for protocol")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) SourcePrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_prefix")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) SourcePrefixSourcePrefixSingleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SourcePrefixSingle, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_prefix_single")
	}
	return oValidatorFn_SourcePrefixSingle, nil
}

func (v *ValidateGetSpecType) StateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for state")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) VersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for version")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action"]; exists {
		val := m.GetAction()
		vOpts := append(opts,
			db.WithValidateField("action"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAction().(type) {
	case *GetSpecType_ActionDeny:
		if fv, exists := v.FldValidators["action.action_deny"]; exists {
			val := m.GetAction().(*GetSpecType_ActionDeny).ActionDeny
			vOpts := append(opts,
				db.WithValidateField("action"),
				db.WithValidateField("action_deny"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ActionAllow:
		if fv, exists := v.FldValidators["action.action_allow"]; exists {
			val := m.GetAction().(*GetSpecType_ActionAllow).ActionAllow
			vOpts := append(opts,
				db.WithValidateField("action"),
				db.WithValidateField("action_allow"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["destination_prefix"]; exists {
		val := m.GetDestinationPrefix()
		vOpts := append(opts,
			db.WithValidateField("destination_prefix"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDestinationPrefix().(type) {
	case *GetSpecType_DestinationPrefixSingle:
		if fv, exists := v.FldValidators["destination_prefix.destination_prefix_single"]; exists {
			val := m.GetDestinationPrefix().(*GetSpecType_DestinationPrefixSingle).DestinationPrefixSingle
			vOpts := append(opts,
				db.WithValidateField("destination_prefix"),
				db.WithValidateField("destination_prefix_single"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DestinationPrefixAll:
		if fv, exists := v.FldValidators["destination_prefix.destination_prefix_all"]; exists {
			val := m.GetDestinationPrefix().(*GetSpecType_DestinationPrefixAll).DestinationPrefixAll
			vOpts := append(opts,
				db.WithValidateField("destination_prefix"),
				db.WithValidateField("destination_prefix_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["fragments"]; exists {
		val := m.GetFragments()
		vOpts := append(opts,
			db.WithValidateField("fragments"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFragments().(type) {
	case *GetSpecType_FragmentsDeny:
		if fv, exists := v.FldValidators["fragments.fragments_deny"]; exists {
			val := m.GetFragments().(*GetSpecType_FragmentsDeny).FragmentsDeny
			vOpts := append(opts,
				db.WithValidateField("fragments"),
				db.WithValidateField("fragments_deny"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_FragmentsAllow:
		if fv, exists := v.FldValidators["fragments.fragments_allow"]; exists {
			val := m.GetFragments().(*GetSpecType_FragmentsAllow).FragmentsAllow
			vOpts := append(opts,
				db.WithValidateField("fragments"),
				db.WithValidateField("fragments_allow"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {
		val := m.GetProtocol()
		vOpts := append(opts,
			db.WithValidateField("protocol"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetProtocol().(type) {
	case *GetSpecType_ProtocolUdp:
		if fv, exists := v.FldValidators["protocol.protocol_udp"]; exists {
			val := m.GetProtocol().(*GetSpecType_ProtocolUdp).ProtocolUdp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_udp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ProtocolTcp:
		if fv, exists := v.FldValidators["protocol.protocol_tcp"]; exists {
			val := m.GetProtocol().(*GetSpecType_ProtocolTcp).ProtocolTcp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_tcp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ProtocolAh:
		if fv, exists := v.FldValidators["protocol.protocol_ah"]; exists {
			val := m.GetProtocol().(*GetSpecType_ProtocolAh).ProtocolAh
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_ah"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ProtocolEsp:
		if fv, exists := v.FldValidators["protocol.protocol_esp"]; exists {
			val := m.GetProtocol().(*GetSpecType_ProtocolEsp).ProtocolEsp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_esp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ProtocolGre:
		if fv, exists := v.FldValidators["protocol.protocol_gre"]; exists {
			val := m.GetProtocol().(*GetSpecType_ProtocolGre).ProtocolGre
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_gre"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ProtocolIcmp:
		if fv, exists := v.FldValidators["protocol.protocol_icmp"]; exists {
			val := m.GetProtocol().(*GetSpecType_ProtocolIcmp).ProtocolIcmp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_icmp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ProtocolIcmp6:
		if fv, exists := v.FldValidators["protocol.protocol_icmp6"]; exists {
			val := m.GetProtocol().(*GetSpecType_ProtocolIcmp6).ProtocolIcmp6
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_icmp6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ProtocolIpv6:
		if fv, exists := v.FldValidators["protocol.protocol_ipv6"]; exists {
			val := m.GetProtocol().(*GetSpecType_ProtocolIpv6).ProtocolIpv6
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ProtocolAll:
		if fv, exists := v.FldValidators["protocol.protocol_all"]; exists {
			val := m.GetProtocol().(*GetSpecType_ProtocolAll).ProtocolAll
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["source_prefix"]; exists {
		val := m.GetSourcePrefix()
		vOpts := append(opts,
			db.WithValidateField("source_prefix"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSourcePrefix().(type) {
	case *GetSpecType_SourcePrefixSingle:
		if fv, exists := v.FldValidators["source_prefix.source_prefix_single"]; exists {
			val := m.GetSourcePrefix().(*GetSpecType_SourcePrefixSingle).SourcePrefixSingle
			vOpts := append(opts,
				db.WithValidateField("source_prefix"),
				db.WithValidateField("source_prefix_single"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_SourcePrefixAll:
		if fv, exists := v.FldValidators["source_prefix.source_prefix_all"]; exists {
			val := m.GetSourcePrefix().(*GetSpecType_SourcePrefixAll).SourcePrefixAll
			vOpts := append(opts,
				db.WithValidateField("source_prefix"),
				db.WithValidateField("source_prefix_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {
		val := m.GetState()
		vOpts := append(opts,
			db.WithValidateField("state"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetState().(type) {
	case *GetSpecType_StateOff:
		if fv, exists := v.FldValidators["state.state_off"]; exists {
			val := m.GetState().(*GetSpecType_StateOff).StateOff
			vOpts := append(opts,
				db.WithValidateField("state"),
				db.WithValidateField("state_off"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_StateOn:
		if fv, exists := v.FldValidators["state.state_on"]; exists {
			val := m.GetState().(*GetSpecType_StateOn).StateOn
			vOpts := append(opts,
				db.WithValidateField("state"),
				db.WithValidateField("state_on"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {
		val := m.GetVersion()
		vOpts := append(opts,
			db.WithValidateField("version"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVersion().(type) {
	case *GetSpecType_VersionIpv4:
		if fv, exists := v.FldValidators["version.version_ipv4"]; exists {
			val := m.GetVersion().(*GetSpecType_VersionIpv4).VersionIpv4
			vOpts := append(opts,
				db.WithValidateField("version"),
				db.WithValidateField("version_ipv4"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_VersionIpv6:
		if fv, exists := v.FldValidators["version.version_ipv6"]; exists {
			val := m.GetVersion().(*GetSpecType_VersionIpv6).VersionIpv6
			vOpts := append(opts,
				db.WithValidateField("version"),
				db.WithValidateField("version_ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAction := v.ActionValidationRuleHandler
	rulesAction := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAction(rulesAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action"] = vFn

	vrhDestinationPrefix := v.DestinationPrefixValidationRuleHandler
	rulesDestinationPrefix := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDestinationPrefix(rulesDestinationPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.destination_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["destination_prefix"] = vFn

	vrhDestinationPrefixDestinationPrefixSingle := v.DestinationPrefixDestinationPrefixSingleValidationRuleHandler
	rulesDestinationPrefixDestinationPrefixSingle := map[string]string{
		"ves.io.schema.rules.string.ip_prefix_globally_routable": "true",
	}
	vFnMap["destination_prefix.destination_prefix_single"], err = vrhDestinationPrefixDestinationPrefixSingle(rulesDestinationPrefixDestinationPrefixSingle)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.destination_prefix_destination_prefix_single: %s", err)
		panic(errMsg)
	}

	v.FldValidators["destination_prefix.destination_prefix_single"] = vFnMap["destination_prefix.destination_prefix_single"]

	vrhFragments := v.FragmentsValidationRuleHandler
	rulesFragments := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFragments(rulesFragments)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.fragments: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fragments"] = vFn

	vrhProtocol := v.ProtocolValidationRuleHandler
	rulesProtocol := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhProtocol(rulesProtocol)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.protocol: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protocol"] = vFn

	vrhSourcePrefix := v.SourcePrefixValidationRuleHandler
	rulesSourcePrefix := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSourcePrefix(rulesSourcePrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.source_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["source_prefix"] = vFn

	vrhSourcePrefixSourcePrefixSingle := v.SourcePrefixSourcePrefixSingleValidationRuleHandler
	rulesSourcePrefixSourcePrefixSingle := map[string]string{
		"ves.io.schema.rules.string.ip_prefix_globally_routable": "true",
	}
	vFnMap["source_prefix.source_prefix_single"], err = vrhSourcePrefixSourcePrefixSingle(rulesSourcePrefixSourcePrefixSingle)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.source_prefix_source_prefix_single: %s", err)
		panic(errMsg)
	}

	v.FldValidators["source_prefix.source_prefix_single"] = vFnMap["source_prefix.source_prefix_single"]

	vrhState := v.StateValidationRuleHandler
	rulesState := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhState(rulesState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["state"] = vFn

	vrhVersion := v.VersionValidationRuleHandler
	rulesVersion := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVersion(rulesVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["version"] = vFn

	v.FldValidators["protocol.protocol_udp"] = UDPProtocolValidator().Validate
	v.FldValidators["protocol.protocol_tcp"] = TCPProtocolValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) ActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DestinationPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_prefix")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DestinationPrefixDestinationPrefixSingleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DestinationPrefixSingle, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_prefix_single")
	}
	return oValidatorFn_DestinationPrefixSingle, nil
}

func (v *ValidateGlobalSpecType) FragmentsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fragments")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ProtocolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for protocol")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) SourcePrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_prefix")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) SourcePrefixSourcePrefixSingleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SourcePrefixSingle, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_prefix_single")
	}
	return oValidatorFn_SourcePrefixSingle, nil
}

func (v *ValidateGlobalSpecType) StateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for state")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for version")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action"]; exists {
		val := m.GetAction()
		vOpts := append(opts,
			db.WithValidateField("action"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAction().(type) {
	case *GlobalSpecType_ActionDeny:
		if fv, exists := v.FldValidators["action.action_deny"]; exists {
			val := m.GetAction().(*GlobalSpecType_ActionDeny).ActionDeny
			vOpts := append(opts,
				db.WithValidateField("action"),
				db.WithValidateField("action_deny"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ActionAllow:
		if fv, exists := v.FldValidators["action.action_allow"]; exists {
			val := m.GetAction().(*GlobalSpecType_ActionAllow).ActionAllow
			vOpts := append(opts,
				db.WithValidateField("action"),
				db.WithValidateField("action_allow"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["destination_prefix"]; exists {
		val := m.GetDestinationPrefix()
		vOpts := append(opts,
			db.WithValidateField("destination_prefix"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDestinationPrefix().(type) {
	case *GlobalSpecType_DestinationPrefixSingle:
		if fv, exists := v.FldValidators["destination_prefix.destination_prefix_single"]; exists {
			val := m.GetDestinationPrefix().(*GlobalSpecType_DestinationPrefixSingle).DestinationPrefixSingle
			vOpts := append(opts,
				db.WithValidateField("destination_prefix"),
				db.WithValidateField("destination_prefix_single"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DestinationPrefixAll:
		if fv, exists := v.FldValidators["destination_prefix.destination_prefix_all"]; exists {
			val := m.GetDestinationPrefix().(*GlobalSpecType_DestinationPrefixAll).DestinationPrefixAll
			vOpts := append(opts,
				db.WithValidateField("destination_prefix"),
				db.WithValidateField("destination_prefix_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["fragments"]; exists {
		val := m.GetFragments()
		vOpts := append(opts,
			db.WithValidateField("fragments"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFragments().(type) {
	case *GlobalSpecType_FragmentsDeny:
		if fv, exists := v.FldValidators["fragments.fragments_deny"]; exists {
			val := m.GetFragments().(*GlobalSpecType_FragmentsDeny).FragmentsDeny
			vOpts := append(opts,
				db.WithValidateField("fragments"),
				db.WithValidateField("fragments_deny"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_FragmentsAllow:
		if fv, exists := v.FldValidators["fragments.fragments_allow"]; exists {
			val := m.GetFragments().(*GlobalSpecType_FragmentsAllow).FragmentsAllow
			vOpts := append(opts,
				db.WithValidateField("fragments"),
				db.WithValidateField("fragments_allow"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {
		val := m.GetProtocol()
		vOpts := append(opts,
			db.WithValidateField("protocol"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetProtocol().(type) {
	case *GlobalSpecType_ProtocolUdp:
		if fv, exists := v.FldValidators["protocol.protocol_udp"]; exists {
			val := m.GetProtocol().(*GlobalSpecType_ProtocolUdp).ProtocolUdp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_udp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ProtocolTcp:
		if fv, exists := v.FldValidators["protocol.protocol_tcp"]; exists {
			val := m.GetProtocol().(*GlobalSpecType_ProtocolTcp).ProtocolTcp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_tcp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ProtocolAh:
		if fv, exists := v.FldValidators["protocol.protocol_ah"]; exists {
			val := m.GetProtocol().(*GlobalSpecType_ProtocolAh).ProtocolAh
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_ah"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ProtocolEsp:
		if fv, exists := v.FldValidators["protocol.protocol_esp"]; exists {
			val := m.GetProtocol().(*GlobalSpecType_ProtocolEsp).ProtocolEsp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_esp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ProtocolGre:
		if fv, exists := v.FldValidators["protocol.protocol_gre"]; exists {
			val := m.GetProtocol().(*GlobalSpecType_ProtocolGre).ProtocolGre
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_gre"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ProtocolIcmp:
		if fv, exists := v.FldValidators["protocol.protocol_icmp"]; exists {
			val := m.GetProtocol().(*GlobalSpecType_ProtocolIcmp).ProtocolIcmp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_icmp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ProtocolIcmp6:
		if fv, exists := v.FldValidators["protocol.protocol_icmp6"]; exists {
			val := m.GetProtocol().(*GlobalSpecType_ProtocolIcmp6).ProtocolIcmp6
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_icmp6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ProtocolIpv6:
		if fv, exists := v.FldValidators["protocol.protocol_ipv6"]; exists {
			val := m.GetProtocol().(*GlobalSpecType_ProtocolIpv6).ProtocolIpv6
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ProtocolAll:
		if fv, exists := v.FldValidators["protocol.protocol_all"]; exists {
			val := m.GetProtocol().(*GlobalSpecType_ProtocolAll).ProtocolAll
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["source_prefix"]; exists {
		val := m.GetSourcePrefix()
		vOpts := append(opts,
			db.WithValidateField("source_prefix"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSourcePrefix().(type) {
	case *GlobalSpecType_SourcePrefixSingle:
		if fv, exists := v.FldValidators["source_prefix.source_prefix_single"]; exists {
			val := m.GetSourcePrefix().(*GlobalSpecType_SourcePrefixSingle).SourcePrefixSingle
			vOpts := append(opts,
				db.WithValidateField("source_prefix"),
				db.WithValidateField("source_prefix_single"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_SourcePrefixAll:
		if fv, exists := v.FldValidators["source_prefix.source_prefix_all"]; exists {
			val := m.GetSourcePrefix().(*GlobalSpecType_SourcePrefixAll).SourcePrefixAll
			vOpts := append(opts,
				db.WithValidateField("source_prefix"),
				db.WithValidateField("source_prefix_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {
		val := m.GetState()
		vOpts := append(opts,
			db.WithValidateField("state"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetState().(type) {
	case *GlobalSpecType_StateOff:
		if fv, exists := v.FldValidators["state.state_off"]; exists {
			val := m.GetState().(*GlobalSpecType_StateOff).StateOff
			vOpts := append(opts,
				db.WithValidateField("state"),
				db.WithValidateField("state_off"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_StateOn:
		if fv, exists := v.FldValidators["state.state_on"]; exists {
			val := m.GetState().(*GlobalSpecType_StateOn).StateOn
			vOpts := append(opts,
				db.WithValidateField("state"),
				db.WithValidateField("state_on"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {
		val := m.GetVersion()
		vOpts := append(opts,
			db.WithValidateField("version"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVersion().(type) {
	case *GlobalSpecType_VersionIpv4:
		if fv, exists := v.FldValidators["version.version_ipv4"]; exists {
			val := m.GetVersion().(*GlobalSpecType_VersionIpv4).VersionIpv4
			vOpts := append(opts,
				db.WithValidateField("version"),
				db.WithValidateField("version_ipv4"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_VersionIpv6:
		if fv, exists := v.FldValidators["version.version_ipv6"]; exists {
			val := m.GetVersion().(*GlobalSpecType_VersionIpv6).VersionIpv6
			vOpts := append(opts,
				db.WithValidateField("version"),
				db.WithValidateField("version_ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAction := v.ActionValidationRuleHandler
	rulesAction := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAction(rulesAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action"] = vFn

	vrhDestinationPrefix := v.DestinationPrefixValidationRuleHandler
	rulesDestinationPrefix := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDestinationPrefix(rulesDestinationPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.destination_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["destination_prefix"] = vFn

	vrhDestinationPrefixDestinationPrefixSingle := v.DestinationPrefixDestinationPrefixSingleValidationRuleHandler
	rulesDestinationPrefixDestinationPrefixSingle := map[string]string{
		"ves.io.schema.rules.string.ip_prefix_globally_routable": "true",
	}
	vFnMap["destination_prefix.destination_prefix_single"], err = vrhDestinationPrefixDestinationPrefixSingle(rulesDestinationPrefixDestinationPrefixSingle)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.destination_prefix_destination_prefix_single: %s", err)
		panic(errMsg)
	}

	v.FldValidators["destination_prefix.destination_prefix_single"] = vFnMap["destination_prefix.destination_prefix_single"]

	vrhFragments := v.FragmentsValidationRuleHandler
	rulesFragments := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFragments(rulesFragments)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.fragments: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fragments"] = vFn

	vrhProtocol := v.ProtocolValidationRuleHandler
	rulesProtocol := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhProtocol(rulesProtocol)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.protocol: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protocol"] = vFn

	vrhSourcePrefix := v.SourcePrefixValidationRuleHandler
	rulesSourcePrefix := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSourcePrefix(rulesSourcePrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.source_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["source_prefix"] = vFn

	vrhSourcePrefixSourcePrefixSingle := v.SourcePrefixSourcePrefixSingleValidationRuleHandler
	rulesSourcePrefixSourcePrefixSingle := map[string]string{
		"ves.io.schema.rules.string.ip_prefix_globally_routable": "true",
	}
	vFnMap["source_prefix.source_prefix_single"], err = vrhSourcePrefixSourcePrefixSingle(rulesSourcePrefixSourcePrefixSingle)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.source_prefix_source_prefix_single: %s", err)
		panic(errMsg)
	}

	v.FldValidators["source_prefix.source_prefix_single"] = vFnMap["source_prefix.source_prefix_single"]

	vrhState := v.StateValidationRuleHandler
	rulesState := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhState(rulesState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["state"] = vFn

	vrhVersion := v.VersionValidationRuleHandler
	rulesVersion := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVersion(rulesVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["version"] = vFn

	v.FldValidators["protocol.protocol_udp"] = UDPProtocolValidator().Validate
	v.FldValidators["protocol.protocol_tcp"] = TCPProtocolValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ICMP6Protocol) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ICMP6Protocol) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ICMP6Protocol) DeepCopy() *ICMP6Protocol {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ICMP6Protocol{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ICMP6Protocol) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ICMP6Protocol) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ICMP6ProtocolValidator().Validate(ctx, m, opts...)
}

type ValidateICMP6Protocol struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateICMP6Protocol) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ICMP6Protocol)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ICMP6Protocol got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["destination_unreachable"]; exists {

		vOpts := append(opts, db.WithValidateField("destination_unreachable"))
		if err := fv(ctx, m.GetDestinationUnreachable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["echo_reply"]; exists {

		vOpts := append(opts, db.WithValidateField("echo_reply"))
		if err := fv(ctx, m.GetEchoReply(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["echo_request"]; exists {

		vOpts := append(opts, db.WithValidateField("echo_request"))
		if err := fv(ctx, m.GetEchoRequest(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["neighbor_advertisement"]; exists {

		vOpts := append(opts, db.WithValidateField("neighbor_advertisement"))
		if err := fv(ctx, m.GetNeighborAdvertisement(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["neighbor_solicit"]; exists {

		vOpts := append(opts, db.WithValidateField("neighbor_solicit"))
		if err := fv(ctx, m.GetNeighborSolicit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["packet_too_big"]; exists {

		vOpts := append(opts, db.WithValidateField("packet_too_big"))
		if err := fv(ctx, m.GetPacketTooBig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["parameter_problem"]; exists {

		vOpts := append(opts, db.WithValidateField("parameter_problem"))
		if err := fv(ctx, m.GetParameterProblem(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("redirect"))
		if err := fv(ctx, m.GetRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["router_advertisement"]; exists {

		vOpts := append(opts, db.WithValidateField("router_advertisement"))
		if err := fv(ctx, m.GetRouterAdvertisement(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["router_solicit"]; exists {

		vOpts := append(opts, db.WithValidateField("router_solicit"))
		if err := fv(ctx, m.GetRouterSolicit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["time_exceeded"]; exists {

		vOpts := append(opts, db.WithValidateField("time_exceeded"))
		if err := fv(ctx, m.GetTimeExceeded(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultICMP6ProtocolValidator = func() *ValidateICMP6Protocol {
	v := &ValidateICMP6Protocol{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ICMP6ProtocolValidator() db.Validator {
	return DefaultICMP6ProtocolValidator
}

// augmented methods on protoc/std generated struct

func (m *ICMPProtocol) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ICMPProtocol) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ICMPProtocol) DeepCopy() *ICMPProtocol {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ICMPProtocol{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ICMPProtocol) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ICMPProtocol) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ICMPProtocolValidator().Validate(ctx, m, opts...)
}

type ValidateICMPProtocol struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateICMPProtocol) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ICMPProtocol)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ICMPProtocol got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["echo_reply"]; exists {

		vOpts := append(opts, db.WithValidateField("echo_reply"))
		if err := fv(ctx, m.GetEchoReply(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["echo_request"]; exists {

		vOpts := append(opts, db.WithValidateField("echo_request"))
		if err := fv(ctx, m.GetEchoRequest(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["parameter_problem"]; exists {

		vOpts := append(opts, db.WithValidateField("parameter_problem"))
		if err := fv(ctx, m.GetParameterProblem(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("redirect"))
		if err := fv(ctx, m.GetRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["source_quench"]; exists {

		vOpts := append(opts, db.WithValidateField("source_quench"))
		if err := fv(ctx, m.GetSourceQuench(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["time_exceeded"]; exists {

		vOpts := append(opts, db.WithValidateField("time_exceeded"))
		if err := fv(ctx, m.GetTimeExceeded(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unreachable"]; exists {

		vOpts := append(opts, db.WithValidateField("unreachable"))
		if err := fv(ctx, m.GetUnreachable(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultICMPProtocolValidator = func() *ValidateICMPProtocol {
	v := &ValidateICMPProtocol{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ICMPProtocolValidator() db.Validator {
	return DefaultICMPProtocolValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) ActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) DestinationPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_prefix")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) DestinationPrefixDestinationPrefixSingleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DestinationPrefixSingle, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_prefix_single")
	}
	return oValidatorFn_DestinationPrefixSingle, nil
}

func (v *ValidateReplaceSpecType) FragmentsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fragments")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ProtocolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for protocol")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) SourcePrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_prefix")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) SourcePrefixSourcePrefixSingleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SourcePrefixSingle, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_prefix_single")
	}
	return oValidatorFn_SourcePrefixSingle, nil
}

func (v *ValidateReplaceSpecType) StateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for state")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) VersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for version")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action"]; exists {
		val := m.GetAction()
		vOpts := append(opts,
			db.WithValidateField("action"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAction().(type) {
	case *ReplaceSpecType_ActionDeny:
		if fv, exists := v.FldValidators["action.action_deny"]; exists {
			val := m.GetAction().(*ReplaceSpecType_ActionDeny).ActionDeny
			vOpts := append(opts,
				db.WithValidateField("action"),
				db.WithValidateField("action_deny"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ActionAllow:
		if fv, exists := v.FldValidators["action.action_allow"]; exists {
			val := m.GetAction().(*ReplaceSpecType_ActionAllow).ActionAllow
			vOpts := append(opts,
				db.WithValidateField("action"),
				db.WithValidateField("action_allow"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["destination_prefix"]; exists {
		val := m.GetDestinationPrefix()
		vOpts := append(opts,
			db.WithValidateField("destination_prefix"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDestinationPrefix().(type) {
	case *ReplaceSpecType_DestinationPrefixSingle:
		if fv, exists := v.FldValidators["destination_prefix.destination_prefix_single"]; exists {
			val := m.GetDestinationPrefix().(*ReplaceSpecType_DestinationPrefixSingle).DestinationPrefixSingle
			vOpts := append(opts,
				db.WithValidateField("destination_prefix"),
				db.WithValidateField("destination_prefix_single"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DestinationPrefixAll:
		if fv, exists := v.FldValidators["destination_prefix.destination_prefix_all"]; exists {
			val := m.GetDestinationPrefix().(*ReplaceSpecType_DestinationPrefixAll).DestinationPrefixAll
			vOpts := append(opts,
				db.WithValidateField("destination_prefix"),
				db.WithValidateField("destination_prefix_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["fragments"]; exists {
		val := m.GetFragments()
		vOpts := append(opts,
			db.WithValidateField("fragments"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFragments().(type) {
	case *ReplaceSpecType_FragmentsDeny:
		if fv, exists := v.FldValidators["fragments.fragments_deny"]; exists {
			val := m.GetFragments().(*ReplaceSpecType_FragmentsDeny).FragmentsDeny
			vOpts := append(opts,
				db.WithValidateField("fragments"),
				db.WithValidateField("fragments_deny"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_FragmentsAllow:
		if fv, exists := v.FldValidators["fragments.fragments_allow"]; exists {
			val := m.GetFragments().(*ReplaceSpecType_FragmentsAllow).FragmentsAllow
			vOpts := append(opts,
				db.WithValidateField("fragments"),
				db.WithValidateField("fragments_allow"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {
		val := m.GetProtocol()
		vOpts := append(opts,
			db.WithValidateField("protocol"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetProtocol().(type) {
	case *ReplaceSpecType_ProtocolUdp:
		if fv, exists := v.FldValidators["protocol.protocol_udp"]; exists {
			val := m.GetProtocol().(*ReplaceSpecType_ProtocolUdp).ProtocolUdp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_udp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ProtocolTcp:
		if fv, exists := v.FldValidators["protocol.protocol_tcp"]; exists {
			val := m.GetProtocol().(*ReplaceSpecType_ProtocolTcp).ProtocolTcp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_tcp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ProtocolAh:
		if fv, exists := v.FldValidators["protocol.protocol_ah"]; exists {
			val := m.GetProtocol().(*ReplaceSpecType_ProtocolAh).ProtocolAh
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_ah"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ProtocolEsp:
		if fv, exists := v.FldValidators["protocol.protocol_esp"]; exists {
			val := m.GetProtocol().(*ReplaceSpecType_ProtocolEsp).ProtocolEsp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_esp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ProtocolGre:
		if fv, exists := v.FldValidators["protocol.protocol_gre"]; exists {
			val := m.GetProtocol().(*ReplaceSpecType_ProtocolGre).ProtocolGre
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_gre"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ProtocolIcmp:
		if fv, exists := v.FldValidators["protocol.protocol_icmp"]; exists {
			val := m.GetProtocol().(*ReplaceSpecType_ProtocolIcmp).ProtocolIcmp
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_icmp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ProtocolIcmp6:
		if fv, exists := v.FldValidators["protocol.protocol_icmp6"]; exists {
			val := m.GetProtocol().(*ReplaceSpecType_ProtocolIcmp6).ProtocolIcmp6
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_icmp6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ProtocolIpv6:
		if fv, exists := v.FldValidators["protocol.protocol_ipv6"]; exists {
			val := m.GetProtocol().(*ReplaceSpecType_ProtocolIpv6).ProtocolIpv6
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ProtocolAll:
		if fv, exists := v.FldValidators["protocol.protocol_all"]; exists {
			val := m.GetProtocol().(*ReplaceSpecType_ProtocolAll).ProtocolAll
			vOpts := append(opts,
				db.WithValidateField("protocol"),
				db.WithValidateField("protocol_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["source_prefix"]; exists {
		val := m.GetSourcePrefix()
		vOpts := append(opts,
			db.WithValidateField("source_prefix"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSourcePrefix().(type) {
	case *ReplaceSpecType_SourcePrefixSingle:
		if fv, exists := v.FldValidators["source_prefix.source_prefix_single"]; exists {
			val := m.GetSourcePrefix().(*ReplaceSpecType_SourcePrefixSingle).SourcePrefixSingle
			vOpts := append(opts,
				db.WithValidateField("source_prefix"),
				db.WithValidateField("source_prefix_single"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_SourcePrefixAll:
		if fv, exists := v.FldValidators["source_prefix.source_prefix_all"]; exists {
			val := m.GetSourcePrefix().(*ReplaceSpecType_SourcePrefixAll).SourcePrefixAll
			vOpts := append(opts,
				db.WithValidateField("source_prefix"),
				db.WithValidateField("source_prefix_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {
		val := m.GetState()
		vOpts := append(opts,
			db.WithValidateField("state"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetState().(type) {
	case *ReplaceSpecType_StateOff:
		if fv, exists := v.FldValidators["state.state_off"]; exists {
			val := m.GetState().(*ReplaceSpecType_StateOff).StateOff
			vOpts := append(opts,
				db.WithValidateField("state"),
				db.WithValidateField("state_off"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_StateOn:
		if fv, exists := v.FldValidators["state.state_on"]; exists {
			val := m.GetState().(*ReplaceSpecType_StateOn).StateOn
			vOpts := append(opts,
				db.WithValidateField("state"),
				db.WithValidateField("state_on"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {
		val := m.GetVersion()
		vOpts := append(opts,
			db.WithValidateField("version"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVersion().(type) {
	case *ReplaceSpecType_VersionIpv4:
		if fv, exists := v.FldValidators["version.version_ipv4"]; exists {
			val := m.GetVersion().(*ReplaceSpecType_VersionIpv4).VersionIpv4
			vOpts := append(opts,
				db.WithValidateField("version"),
				db.WithValidateField("version_ipv4"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_VersionIpv6:
		if fv, exists := v.FldValidators["version.version_ipv6"]; exists {
			val := m.GetVersion().(*ReplaceSpecType_VersionIpv6).VersionIpv6
			vOpts := append(opts,
				db.WithValidateField("version"),
				db.WithValidateField("version_ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAction := v.ActionValidationRuleHandler
	rulesAction := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAction(rulesAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action"] = vFn

	vrhDestinationPrefix := v.DestinationPrefixValidationRuleHandler
	rulesDestinationPrefix := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDestinationPrefix(rulesDestinationPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.destination_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["destination_prefix"] = vFn

	vrhDestinationPrefixDestinationPrefixSingle := v.DestinationPrefixDestinationPrefixSingleValidationRuleHandler
	rulesDestinationPrefixDestinationPrefixSingle := map[string]string{
		"ves.io.schema.rules.string.ip_prefix_globally_routable": "true",
	}
	vFnMap["destination_prefix.destination_prefix_single"], err = vrhDestinationPrefixDestinationPrefixSingle(rulesDestinationPrefixDestinationPrefixSingle)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.destination_prefix_destination_prefix_single: %s", err)
		panic(errMsg)
	}

	v.FldValidators["destination_prefix.destination_prefix_single"] = vFnMap["destination_prefix.destination_prefix_single"]

	vrhFragments := v.FragmentsValidationRuleHandler
	rulesFragments := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFragments(rulesFragments)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.fragments: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fragments"] = vFn

	vrhProtocol := v.ProtocolValidationRuleHandler
	rulesProtocol := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhProtocol(rulesProtocol)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.protocol: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protocol"] = vFn

	vrhSourcePrefix := v.SourcePrefixValidationRuleHandler
	rulesSourcePrefix := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSourcePrefix(rulesSourcePrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.source_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["source_prefix"] = vFn

	vrhSourcePrefixSourcePrefixSingle := v.SourcePrefixSourcePrefixSingleValidationRuleHandler
	rulesSourcePrefixSourcePrefixSingle := map[string]string{
		"ves.io.schema.rules.string.ip_prefix_globally_routable": "true",
	}
	vFnMap["source_prefix.source_prefix_single"], err = vrhSourcePrefixSourcePrefixSingle(rulesSourcePrefixSourcePrefixSingle)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.source_prefix_source_prefix_single: %s", err)
		panic(errMsg)
	}

	v.FldValidators["source_prefix.source_prefix_single"] = vFnMap["source_prefix.source_prefix_single"]

	vrhState := v.StateValidationRuleHandler
	rulesState := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhState(rulesState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["state"] = vFn

	vrhVersion := v.VersionValidationRuleHandler
	rulesVersion := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVersion(rulesVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["version"] = vFn

	v.FldValidators["protocol.protocol_udp"] = UDPProtocolValidator().Validate
	v.FldValidators["protocol.protocol_tcp"] = TCPProtocolValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TCPProtocol) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TCPProtocol) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TCPProtocol) DeepCopy() *TCPProtocol {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TCPProtocol{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TCPProtocol) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TCPProtocol) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TCPProtocolValidator().Validate(ctx, m, opts...)
}

type ValidateTCPProtocol struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTCPProtocol) DestinationPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_port")
	}
	return validatorFn, nil
}

func (v *ValidateTCPProtocol) DestinationPortDestinationPortRangeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DestinationPortRange, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_port_range")
	}
	return oValidatorFn_DestinationPortRange, nil
}

func (v *ValidateTCPProtocol) SourcePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_port")
	}
	return validatorFn, nil
}

func (v *ValidateTCPProtocol) SourcePortSourcePortRangeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SourcePortRange, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_port_range")
	}
	return oValidatorFn_SourcePortRange, nil
}

func (v *ValidateTCPProtocol) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TCPProtocol)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TCPProtocol got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["destination_port"]; exists {
		val := m.GetDestinationPort()
		vOpts := append(opts,
			db.WithValidateField("destination_port"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDestinationPort().(type) {
	case *TCPProtocol_DestinationPortRange:
		if fv, exists := v.FldValidators["destination_port.destination_port_range"]; exists {
			val := m.GetDestinationPort().(*TCPProtocol_DestinationPortRange).DestinationPortRange
			vOpts := append(opts,
				db.WithValidateField("destination_port"),
				db.WithValidateField("destination_port_range"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TCPProtocol_DestinationPortAll:
		if fv, exists := v.FldValidators["destination_port.destination_port_all"]; exists {
			val := m.GetDestinationPort().(*TCPProtocol_DestinationPortAll).DestinationPortAll
			vOpts := append(opts,
				db.WithValidateField("destination_port"),
				db.WithValidateField("destination_port_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["source_port"]; exists {
		val := m.GetSourcePort()
		vOpts := append(opts,
			db.WithValidateField("source_port"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSourcePort().(type) {
	case *TCPProtocol_SourcePortRange:
		if fv, exists := v.FldValidators["source_port.source_port_range"]; exists {
			val := m.GetSourcePort().(*TCPProtocol_SourcePortRange).SourcePortRange
			vOpts := append(opts,
				db.WithValidateField("source_port"),
				db.WithValidateField("source_port_range"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TCPProtocol_SourcePortAll:
		if fv, exists := v.FldValidators["source_port.source_port_all"]; exists {
			val := m.GetSourcePort().(*TCPProtocol_SourcePortAll).SourcePortAll
			vOpts := append(opts,
				db.WithValidateField("source_port"),
				db.WithValidateField("source_port_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTCPProtocolValidator = func() *ValidateTCPProtocol {
	v := &ValidateTCPProtocol{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDestinationPort := v.DestinationPortValidationRuleHandler
	rulesDestinationPort := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDestinationPort(rulesDestinationPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPProtocol.destination_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["destination_port"] = vFn

	vrhDestinationPortDestinationPortRange := v.DestinationPortDestinationPortRangeValidationRuleHandler
	rulesDestinationPortDestinationPortRange := map[string]string{
		"ves.io.schema.rules.string.port_range": "true",
	}
	vFnMap["destination_port.destination_port_range"], err = vrhDestinationPortDestinationPortRange(rulesDestinationPortDestinationPortRange)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TCPProtocol.destination_port_destination_port_range: %s", err)
		panic(errMsg)
	}

	v.FldValidators["destination_port.destination_port_range"] = vFnMap["destination_port.destination_port_range"]

	vrhSourcePort := v.SourcePortValidationRuleHandler
	rulesSourcePort := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSourcePort(rulesSourcePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPProtocol.source_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["source_port"] = vFn

	vrhSourcePortSourcePortRange := v.SourcePortSourcePortRangeValidationRuleHandler
	rulesSourcePortSourcePortRange := map[string]string{
		"ves.io.schema.rules.string.port_range": "true",
	}
	vFnMap["source_port.source_port_range"], err = vrhSourcePortSourcePortRange(rulesSourcePortSourcePortRange)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TCPProtocol.source_port_source_port_range: %s", err)
		panic(errMsg)
	}

	v.FldValidators["source_port.source_port_range"] = vFnMap["source_port.source_port_range"]

	return v
}()

func TCPProtocolValidator() db.Validator {
	return DefaultTCPProtocolValidator
}

// augmented methods on protoc/std generated struct

func (m *UDPProtocol) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UDPProtocol) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UDPProtocol) DeepCopy() *UDPProtocol {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UDPProtocol{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UDPProtocol) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UDPProtocol) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UDPProtocolValidator().Validate(ctx, m, opts...)
}

type ValidateUDPProtocol struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUDPProtocol) DestinationPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_port")
	}
	return validatorFn, nil
}

func (v *ValidateUDPProtocol) DestinationPortDestinationPortRangeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DestinationPortRange, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_port_range")
	}
	return oValidatorFn_DestinationPortRange, nil
}

func (v *ValidateUDPProtocol) SourcePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_port")
	}
	return validatorFn, nil
}

func (v *ValidateUDPProtocol) SourcePortSourcePortRangeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SourcePortRange, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for source_port_range")
	}
	return oValidatorFn_SourcePortRange, nil
}

func (v *ValidateUDPProtocol) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UDPProtocol)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UDPProtocol got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["destination_port"]; exists {
		val := m.GetDestinationPort()
		vOpts := append(opts,
			db.WithValidateField("destination_port"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDestinationPort().(type) {
	case *UDPProtocol_DestinationPortRange:
		if fv, exists := v.FldValidators["destination_port.destination_port_range"]; exists {
			val := m.GetDestinationPort().(*UDPProtocol_DestinationPortRange).DestinationPortRange
			vOpts := append(opts,
				db.WithValidateField("destination_port"),
				db.WithValidateField("destination_port_range"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UDPProtocol_DestinationPortAll:
		if fv, exists := v.FldValidators["destination_port.destination_port_all"]; exists {
			val := m.GetDestinationPort().(*UDPProtocol_DestinationPortAll).DestinationPortAll
			vOpts := append(opts,
				db.WithValidateField("destination_port"),
				db.WithValidateField("destination_port_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["source_port"]; exists {
		val := m.GetSourcePort()
		vOpts := append(opts,
			db.WithValidateField("source_port"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSourcePort().(type) {
	case *UDPProtocol_SourcePortRange:
		if fv, exists := v.FldValidators["source_port.source_port_range"]; exists {
			val := m.GetSourcePort().(*UDPProtocol_SourcePortRange).SourcePortRange
			vOpts := append(opts,
				db.WithValidateField("source_port"),
				db.WithValidateField("source_port_range"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UDPProtocol_SourcePortAll:
		if fv, exists := v.FldValidators["source_port.source_port_all"]; exists {
			val := m.GetSourcePort().(*UDPProtocol_SourcePortAll).SourcePortAll
			vOpts := append(opts,
				db.WithValidateField("source_port"),
				db.WithValidateField("source_port_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUDPProtocolValidator = func() *ValidateUDPProtocol {
	v := &ValidateUDPProtocol{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDestinationPort := v.DestinationPortValidationRuleHandler
	rulesDestinationPort := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDestinationPort(rulesDestinationPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UDPProtocol.destination_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["destination_port"] = vFn

	vrhDestinationPortDestinationPortRange := v.DestinationPortDestinationPortRangeValidationRuleHandler
	rulesDestinationPortDestinationPortRange := map[string]string{
		"ves.io.schema.rules.string.port_range": "true",
	}
	vFnMap["destination_port.destination_port_range"], err = vrhDestinationPortDestinationPortRange(rulesDestinationPortDestinationPortRange)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field UDPProtocol.destination_port_destination_port_range: %s", err)
		panic(errMsg)
	}

	v.FldValidators["destination_port.destination_port_range"] = vFnMap["destination_port.destination_port_range"]

	vrhSourcePort := v.SourcePortValidationRuleHandler
	rulesSourcePort := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSourcePort(rulesSourcePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UDPProtocol.source_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["source_port"] = vFn

	vrhSourcePortSourcePortRange := v.SourcePortSourcePortRangeValidationRuleHandler
	rulesSourcePortSourcePortRange := map[string]string{
		"ves.io.schema.rules.string.port_range": "true",
	}
	vFnMap["source_port.source_port_range"], err = vrhSourcePortSourcePortRange(rulesSourcePortSourcePortRange)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field UDPProtocol.source_port_source_port_range: %s", err)
		panic(errMsg)
	}

	v.FldValidators["source_port.source_port_range"] = vFnMap["source_port.source_port_range"]

	return v
}()

func UDPProtocolValidator() db.Validator {
	return DefaultUDPProtocolValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetActionToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Action.(type) {
	case nil:
		o.Action = nil

	case *CreateSpecType_ActionAllow:
		o.Action = &GlobalSpecType_ActionAllow{ActionAllow: of.ActionAllow}

	case *CreateSpecType_ActionDeny:
		o.Action = &GlobalSpecType_ActionDeny{ActionDeny: of.ActionDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetActionFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Action.(type) {
	case nil:
		r.Action = nil

	case *GlobalSpecType_ActionAllow:
		r.Action = &CreateSpecType_ActionAllow{ActionAllow: of.ActionAllow}

	case *GlobalSpecType_ActionDeny:
		r.Action = &CreateSpecType_ActionDeny{ActionDeny: of.ActionDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetDestinationPrefixToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DestinationPrefix.(type) {
	case nil:
		o.DestinationPrefix = nil

	case *CreateSpecType_DestinationPrefixAll:
		o.DestinationPrefix = &GlobalSpecType_DestinationPrefixAll{DestinationPrefixAll: of.DestinationPrefixAll}

	case *CreateSpecType_DestinationPrefixSingle:
		o.DestinationPrefix = &GlobalSpecType_DestinationPrefixSingle{DestinationPrefixSingle: of.DestinationPrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetDestinationPrefixFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DestinationPrefix.(type) {
	case nil:
		r.DestinationPrefix = nil

	case *GlobalSpecType_DestinationPrefixAll:
		r.DestinationPrefix = &CreateSpecType_DestinationPrefixAll{DestinationPrefixAll: of.DestinationPrefixAll}

	case *GlobalSpecType_DestinationPrefixSingle:
		r.DestinationPrefix = &CreateSpecType_DestinationPrefixSingle{DestinationPrefixSingle: of.DestinationPrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetFragmentsToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Fragments.(type) {
	case nil:
		o.Fragments = nil

	case *CreateSpecType_FragmentsAllow:
		o.Fragments = &GlobalSpecType_FragmentsAllow{FragmentsAllow: of.FragmentsAllow}

	case *CreateSpecType_FragmentsDeny:
		o.Fragments = &GlobalSpecType_FragmentsDeny{FragmentsDeny: of.FragmentsDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetFragmentsFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Fragments.(type) {
	case nil:
		r.Fragments = nil

	case *GlobalSpecType_FragmentsAllow:
		r.Fragments = &CreateSpecType_FragmentsAllow{FragmentsAllow: of.FragmentsAllow}

	case *GlobalSpecType_FragmentsDeny:
		r.Fragments = &CreateSpecType_FragmentsDeny{FragmentsDeny: of.FragmentsDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetProtocolToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Protocol.(type) {
	case nil:
		o.Protocol = nil

	case *CreateSpecType_ProtocolAh:
		o.Protocol = &GlobalSpecType_ProtocolAh{ProtocolAh: of.ProtocolAh}

	case *CreateSpecType_ProtocolAll:
		o.Protocol = &GlobalSpecType_ProtocolAll{ProtocolAll: of.ProtocolAll}

	case *CreateSpecType_ProtocolEsp:
		o.Protocol = &GlobalSpecType_ProtocolEsp{ProtocolEsp: of.ProtocolEsp}

	case *CreateSpecType_ProtocolGre:
		o.Protocol = &GlobalSpecType_ProtocolGre{ProtocolGre: of.ProtocolGre}

	case *CreateSpecType_ProtocolIcmp:
		o.Protocol = &GlobalSpecType_ProtocolIcmp{ProtocolIcmp: of.ProtocolIcmp}

	case *CreateSpecType_ProtocolIcmp6:
		o.Protocol = &GlobalSpecType_ProtocolIcmp6{ProtocolIcmp6: of.ProtocolIcmp6}

	case *CreateSpecType_ProtocolIpv6:
		o.Protocol = &GlobalSpecType_ProtocolIpv6{ProtocolIpv6: of.ProtocolIpv6}

	case *CreateSpecType_ProtocolTcp:
		o.Protocol = &GlobalSpecType_ProtocolTcp{ProtocolTcp: of.ProtocolTcp}

	case *CreateSpecType_ProtocolUdp:
		o.Protocol = &GlobalSpecType_ProtocolUdp{ProtocolUdp: of.ProtocolUdp}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetProtocolFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Protocol.(type) {
	case nil:
		r.Protocol = nil

	case *GlobalSpecType_ProtocolAh:
		r.Protocol = &CreateSpecType_ProtocolAh{ProtocolAh: of.ProtocolAh}

	case *GlobalSpecType_ProtocolAll:
		r.Protocol = &CreateSpecType_ProtocolAll{ProtocolAll: of.ProtocolAll}

	case *GlobalSpecType_ProtocolEsp:
		r.Protocol = &CreateSpecType_ProtocolEsp{ProtocolEsp: of.ProtocolEsp}

	case *GlobalSpecType_ProtocolGre:
		r.Protocol = &CreateSpecType_ProtocolGre{ProtocolGre: of.ProtocolGre}

	case *GlobalSpecType_ProtocolIcmp:
		r.Protocol = &CreateSpecType_ProtocolIcmp{ProtocolIcmp: of.ProtocolIcmp}

	case *GlobalSpecType_ProtocolIcmp6:
		r.Protocol = &CreateSpecType_ProtocolIcmp6{ProtocolIcmp6: of.ProtocolIcmp6}

	case *GlobalSpecType_ProtocolIpv6:
		r.Protocol = &CreateSpecType_ProtocolIpv6{ProtocolIpv6: of.ProtocolIpv6}

	case *GlobalSpecType_ProtocolTcp:
		r.Protocol = &CreateSpecType_ProtocolTcp{ProtocolTcp: of.ProtocolTcp}

	case *GlobalSpecType_ProtocolUdp:
		r.Protocol = &CreateSpecType_ProtocolUdp{ProtocolUdp: of.ProtocolUdp}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetSourcePrefixToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.SourcePrefix.(type) {
	case nil:
		o.SourcePrefix = nil

	case *CreateSpecType_SourcePrefixAll:
		o.SourcePrefix = &GlobalSpecType_SourcePrefixAll{SourcePrefixAll: of.SourcePrefixAll}

	case *CreateSpecType_SourcePrefixSingle:
		o.SourcePrefix = &GlobalSpecType_SourcePrefixSingle{SourcePrefixSingle: of.SourcePrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetSourcePrefixFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.SourcePrefix.(type) {
	case nil:
		r.SourcePrefix = nil

	case *GlobalSpecType_SourcePrefixAll:
		r.SourcePrefix = &CreateSpecType_SourcePrefixAll{SourcePrefixAll: of.SourcePrefixAll}

	case *GlobalSpecType_SourcePrefixSingle:
		r.SourcePrefix = &CreateSpecType_SourcePrefixSingle{SourcePrefixSingle: of.SourcePrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetStateToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.State.(type) {
	case nil:
		o.State = nil

	case *CreateSpecType_StateOff:
		o.State = &GlobalSpecType_StateOff{StateOff: of.StateOff}

	case *CreateSpecType_StateOn:
		o.State = &GlobalSpecType_StateOn{StateOn: of.StateOn}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetStateFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.State.(type) {
	case nil:
		r.State = nil

	case *GlobalSpecType_StateOff:
		r.State = &CreateSpecType_StateOff{StateOff: of.StateOff}

	case *GlobalSpecType_StateOn:
		r.State = &CreateSpecType_StateOn{StateOn: of.StateOn}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetVersionToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Version.(type) {
	case nil:
		o.Version = nil

	case *CreateSpecType_VersionIpv4:
		o.Version = &GlobalSpecType_VersionIpv4{VersionIpv4: of.VersionIpv4}

	case *CreateSpecType_VersionIpv6:
		o.Version = &GlobalSpecType_VersionIpv6{VersionIpv6: of.VersionIpv6}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetVersionFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Version.(type) {
	case nil:
		r.Version = nil

	case *GlobalSpecType_VersionIpv4:
		r.Version = &CreateSpecType_VersionIpv4{VersionIpv4: of.VersionIpv4}

	case *GlobalSpecType_VersionIpv6:
		r.Version = &CreateSpecType_VersionIpv6{VersionIpv6: of.VersionIpv6}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetActionFromGlobalSpecType(f)
	m.GetDestinationPrefixFromGlobalSpecType(f)
	m.GetFragmentsFromGlobalSpecType(f)
	m.GetProtocolFromGlobalSpecType(f)
	m.GetSourcePrefixFromGlobalSpecType(f)
	m.GetStateFromGlobalSpecType(f)
	m.GetVersionFromGlobalSpecType(f)
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetActionToGlobalSpecType(f)
	m1.SetDestinationPrefixToGlobalSpecType(f)
	m1.SetFragmentsToGlobalSpecType(f)
	m1.SetProtocolToGlobalSpecType(f)
	m1.SetSourcePrefixToGlobalSpecType(f)
	m1.SetStateToGlobalSpecType(f)
	m1.SetVersionToGlobalSpecType(f)
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetActionToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Action.(type) {
	case nil:
		o.Action = nil

	case *GetSpecType_ActionAllow:
		o.Action = &GlobalSpecType_ActionAllow{ActionAllow: of.ActionAllow}

	case *GetSpecType_ActionDeny:
		o.Action = &GlobalSpecType_ActionDeny{ActionDeny: of.ActionDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetActionFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Action.(type) {
	case nil:
		r.Action = nil

	case *GlobalSpecType_ActionAllow:
		r.Action = &GetSpecType_ActionAllow{ActionAllow: of.ActionAllow}

	case *GlobalSpecType_ActionDeny:
		r.Action = &GetSpecType_ActionDeny{ActionDeny: of.ActionDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDestinationPrefixToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DestinationPrefix.(type) {
	case nil:
		o.DestinationPrefix = nil

	case *GetSpecType_DestinationPrefixAll:
		o.DestinationPrefix = &GlobalSpecType_DestinationPrefixAll{DestinationPrefixAll: of.DestinationPrefixAll}

	case *GetSpecType_DestinationPrefixSingle:
		o.DestinationPrefix = &GlobalSpecType_DestinationPrefixSingle{DestinationPrefixSingle: of.DestinationPrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDestinationPrefixFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DestinationPrefix.(type) {
	case nil:
		r.DestinationPrefix = nil

	case *GlobalSpecType_DestinationPrefixAll:
		r.DestinationPrefix = &GetSpecType_DestinationPrefixAll{DestinationPrefixAll: of.DestinationPrefixAll}

	case *GlobalSpecType_DestinationPrefixSingle:
		r.DestinationPrefix = &GetSpecType_DestinationPrefixSingle{DestinationPrefixSingle: of.DestinationPrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetFragmentsToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Fragments.(type) {
	case nil:
		o.Fragments = nil

	case *GetSpecType_FragmentsAllow:
		o.Fragments = &GlobalSpecType_FragmentsAllow{FragmentsAllow: of.FragmentsAllow}

	case *GetSpecType_FragmentsDeny:
		o.Fragments = &GlobalSpecType_FragmentsDeny{FragmentsDeny: of.FragmentsDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetFragmentsFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Fragments.(type) {
	case nil:
		r.Fragments = nil

	case *GlobalSpecType_FragmentsAllow:
		r.Fragments = &GetSpecType_FragmentsAllow{FragmentsAllow: of.FragmentsAllow}

	case *GlobalSpecType_FragmentsDeny:
		r.Fragments = &GetSpecType_FragmentsDeny{FragmentsDeny: of.FragmentsDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetProtocolToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Protocol.(type) {
	case nil:
		o.Protocol = nil

	case *GetSpecType_ProtocolAh:
		o.Protocol = &GlobalSpecType_ProtocolAh{ProtocolAh: of.ProtocolAh}

	case *GetSpecType_ProtocolAll:
		o.Protocol = &GlobalSpecType_ProtocolAll{ProtocolAll: of.ProtocolAll}

	case *GetSpecType_ProtocolEsp:
		o.Protocol = &GlobalSpecType_ProtocolEsp{ProtocolEsp: of.ProtocolEsp}

	case *GetSpecType_ProtocolGre:
		o.Protocol = &GlobalSpecType_ProtocolGre{ProtocolGre: of.ProtocolGre}

	case *GetSpecType_ProtocolIcmp:
		o.Protocol = &GlobalSpecType_ProtocolIcmp{ProtocolIcmp: of.ProtocolIcmp}

	case *GetSpecType_ProtocolIcmp6:
		o.Protocol = &GlobalSpecType_ProtocolIcmp6{ProtocolIcmp6: of.ProtocolIcmp6}

	case *GetSpecType_ProtocolIpv6:
		o.Protocol = &GlobalSpecType_ProtocolIpv6{ProtocolIpv6: of.ProtocolIpv6}

	case *GetSpecType_ProtocolTcp:
		o.Protocol = &GlobalSpecType_ProtocolTcp{ProtocolTcp: of.ProtocolTcp}

	case *GetSpecType_ProtocolUdp:
		o.Protocol = &GlobalSpecType_ProtocolUdp{ProtocolUdp: of.ProtocolUdp}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetProtocolFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Protocol.(type) {
	case nil:
		r.Protocol = nil

	case *GlobalSpecType_ProtocolAh:
		r.Protocol = &GetSpecType_ProtocolAh{ProtocolAh: of.ProtocolAh}

	case *GlobalSpecType_ProtocolAll:
		r.Protocol = &GetSpecType_ProtocolAll{ProtocolAll: of.ProtocolAll}

	case *GlobalSpecType_ProtocolEsp:
		r.Protocol = &GetSpecType_ProtocolEsp{ProtocolEsp: of.ProtocolEsp}

	case *GlobalSpecType_ProtocolGre:
		r.Protocol = &GetSpecType_ProtocolGre{ProtocolGre: of.ProtocolGre}

	case *GlobalSpecType_ProtocolIcmp:
		r.Protocol = &GetSpecType_ProtocolIcmp{ProtocolIcmp: of.ProtocolIcmp}

	case *GlobalSpecType_ProtocolIcmp6:
		r.Protocol = &GetSpecType_ProtocolIcmp6{ProtocolIcmp6: of.ProtocolIcmp6}

	case *GlobalSpecType_ProtocolIpv6:
		r.Protocol = &GetSpecType_ProtocolIpv6{ProtocolIpv6: of.ProtocolIpv6}

	case *GlobalSpecType_ProtocolTcp:
		r.Protocol = &GetSpecType_ProtocolTcp{ProtocolTcp: of.ProtocolTcp}

	case *GlobalSpecType_ProtocolUdp:
		r.Protocol = &GetSpecType_ProtocolUdp{ProtocolUdp: of.ProtocolUdp}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetSourcePrefixToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.SourcePrefix.(type) {
	case nil:
		o.SourcePrefix = nil

	case *GetSpecType_SourcePrefixAll:
		o.SourcePrefix = &GlobalSpecType_SourcePrefixAll{SourcePrefixAll: of.SourcePrefixAll}

	case *GetSpecType_SourcePrefixSingle:
		o.SourcePrefix = &GlobalSpecType_SourcePrefixSingle{SourcePrefixSingle: of.SourcePrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetSourcePrefixFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.SourcePrefix.(type) {
	case nil:
		r.SourcePrefix = nil

	case *GlobalSpecType_SourcePrefixAll:
		r.SourcePrefix = &GetSpecType_SourcePrefixAll{SourcePrefixAll: of.SourcePrefixAll}

	case *GlobalSpecType_SourcePrefixSingle:
		r.SourcePrefix = &GetSpecType_SourcePrefixSingle{SourcePrefixSingle: of.SourcePrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetStateToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.State.(type) {
	case nil:
		o.State = nil

	case *GetSpecType_StateOff:
		o.State = &GlobalSpecType_StateOff{StateOff: of.StateOff}

	case *GetSpecType_StateOn:
		o.State = &GlobalSpecType_StateOn{StateOn: of.StateOn}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetStateFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.State.(type) {
	case nil:
		r.State = nil

	case *GlobalSpecType_StateOff:
		r.State = &GetSpecType_StateOff{StateOff: of.StateOff}

	case *GlobalSpecType_StateOn:
		r.State = &GetSpecType_StateOn{StateOn: of.StateOn}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetVersionToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Version.(type) {
	case nil:
		o.Version = nil

	case *GetSpecType_VersionIpv4:
		o.Version = &GlobalSpecType_VersionIpv4{VersionIpv4: of.VersionIpv4}

	case *GetSpecType_VersionIpv6:
		o.Version = &GlobalSpecType_VersionIpv6{VersionIpv6: of.VersionIpv6}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetVersionFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Version.(type) {
	case nil:
		r.Version = nil

	case *GlobalSpecType_VersionIpv4:
		r.Version = &GetSpecType_VersionIpv4{VersionIpv4: of.VersionIpv4}

	case *GlobalSpecType_VersionIpv6:
		r.Version = &GetSpecType_VersionIpv6{VersionIpv6: of.VersionIpv6}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetActionFromGlobalSpecType(f)
	m.GetDestinationPrefixFromGlobalSpecType(f)
	m.GetFragmentsFromGlobalSpecType(f)
	m.GetProtocolFromGlobalSpecType(f)
	m.GetSourcePrefixFromGlobalSpecType(f)
	m.GetStateFromGlobalSpecType(f)
	m.GetVersionFromGlobalSpecType(f)
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetActionToGlobalSpecType(f)
	m1.SetDestinationPrefixToGlobalSpecType(f)
	m1.SetFragmentsToGlobalSpecType(f)
	m1.SetProtocolToGlobalSpecType(f)
	m1.SetSourcePrefixToGlobalSpecType(f)
	m1.SetStateToGlobalSpecType(f)
	m1.SetVersionToGlobalSpecType(f)
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetActionToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Action.(type) {
	case nil:
		o.Action = nil

	case *ReplaceSpecType_ActionAllow:
		o.Action = &GlobalSpecType_ActionAllow{ActionAllow: of.ActionAllow}

	case *ReplaceSpecType_ActionDeny:
		o.Action = &GlobalSpecType_ActionDeny{ActionDeny: of.ActionDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetActionFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Action.(type) {
	case nil:
		r.Action = nil

	case *GlobalSpecType_ActionAllow:
		r.Action = &ReplaceSpecType_ActionAllow{ActionAllow: of.ActionAllow}

	case *GlobalSpecType_ActionDeny:
		r.Action = &ReplaceSpecType_ActionDeny{ActionDeny: of.ActionDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetDestinationPrefixToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DestinationPrefix.(type) {
	case nil:
		o.DestinationPrefix = nil

	case *ReplaceSpecType_DestinationPrefixAll:
		o.DestinationPrefix = &GlobalSpecType_DestinationPrefixAll{DestinationPrefixAll: of.DestinationPrefixAll}

	case *ReplaceSpecType_DestinationPrefixSingle:
		o.DestinationPrefix = &GlobalSpecType_DestinationPrefixSingle{DestinationPrefixSingle: of.DestinationPrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetDestinationPrefixFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DestinationPrefix.(type) {
	case nil:
		r.DestinationPrefix = nil

	case *GlobalSpecType_DestinationPrefixAll:
		r.DestinationPrefix = &ReplaceSpecType_DestinationPrefixAll{DestinationPrefixAll: of.DestinationPrefixAll}

	case *GlobalSpecType_DestinationPrefixSingle:
		r.DestinationPrefix = &ReplaceSpecType_DestinationPrefixSingle{DestinationPrefixSingle: of.DestinationPrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetFragmentsToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Fragments.(type) {
	case nil:
		o.Fragments = nil

	case *ReplaceSpecType_FragmentsAllow:
		o.Fragments = &GlobalSpecType_FragmentsAllow{FragmentsAllow: of.FragmentsAllow}

	case *ReplaceSpecType_FragmentsDeny:
		o.Fragments = &GlobalSpecType_FragmentsDeny{FragmentsDeny: of.FragmentsDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetFragmentsFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Fragments.(type) {
	case nil:
		r.Fragments = nil

	case *GlobalSpecType_FragmentsAllow:
		r.Fragments = &ReplaceSpecType_FragmentsAllow{FragmentsAllow: of.FragmentsAllow}

	case *GlobalSpecType_FragmentsDeny:
		r.Fragments = &ReplaceSpecType_FragmentsDeny{FragmentsDeny: of.FragmentsDeny}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetProtocolToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Protocol.(type) {
	case nil:
		o.Protocol = nil

	case *ReplaceSpecType_ProtocolAh:
		o.Protocol = &GlobalSpecType_ProtocolAh{ProtocolAh: of.ProtocolAh}

	case *ReplaceSpecType_ProtocolAll:
		o.Protocol = &GlobalSpecType_ProtocolAll{ProtocolAll: of.ProtocolAll}

	case *ReplaceSpecType_ProtocolEsp:
		o.Protocol = &GlobalSpecType_ProtocolEsp{ProtocolEsp: of.ProtocolEsp}

	case *ReplaceSpecType_ProtocolGre:
		o.Protocol = &GlobalSpecType_ProtocolGre{ProtocolGre: of.ProtocolGre}

	case *ReplaceSpecType_ProtocolIcmp:
		o.Protocol = &GlobalSpecType_ProtocolIcmp{ProtocolIcmp: of.ProtocolIcmp}

	case *ReplaceSpecType_ProtocolIcmp6:
		o.Protocol = &GlobalSpecType_ProtocolIcmp6{ProtocolIcmp6: of.ProtocolIcmp6}

	case *ReplaceSpecType_ProtocolIpv6:
		o.Protocol = &GlobalSpecType_ProtocolIpv6{ProtocolIpv6: of.ProtocolIpv6}

	case *ReplaceSpecType_ProtocolTcp:
		o.Protocol = &GlobalSpecType_ProtocolTcp{ProtocolTcp: of.ProtocolTcp}

	case *ReplaceSpecType_ProtocolUdp:
		o.Protocol = &GlobalSpecType_ProtocolUdp{ProtocolUdp: of.ProtocolUdp}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetProtocolFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Protocol.(type) {
	case nil:
		r.Protocol = nil

	case *GlobalSpecType_ProtocolAh:
		r.Protocol = &ReplaceSpecType_ProtocolAh{ProtocolAh: of.ProtocolAh}

	case *GlobalSpecType_ProtocolAll:
		r.Protocol = &ReplaceSpecType_ProtocolAll{ProtocolAll: of.ProtocolAll}

	case *GlobalSpecType_ProtocolEsp:
		r.Protocol = &ReplaceSpecType_ProtocolEsp{ProtocolEsp: of.ProtocolEsp}

	case *GlobalSpecType_ProtocolGre:
		r.Protocol = &ReplaceSpecType_ProtocolGre{ProtocolGre: of.ProtocolGre}

	case *GlobalSpecType_ProtocolIcmp:
		r.Protocol = &ReplaceSpecType_ProtocolIcmp{ProtocolIcmp: of.ProtocolIcmp}

	case *GlobalSpecType_ProtocolIcmp6:
		r.Protocol = &ReplaceSpecType_ProtocolIcmp6{ProtocolIcmp6: of.ProtocolIcmp6}

	case *GlobalSpecType_ProtocolIpv6:
		r.Protocol = &ReplaceSpecType_ProtocolIpv6{ProtocolIpv6: of.ProtocolIpv6}

	case *GlobalSpecType_ProtocolTcp:
		r.Protocol = &ReplaceSpecType_ProtocolTcp{ProtocolTcp: of.ProtocolTcp}

	case *GlobalSpecType_ProtocolUdp:
		r.Protocol = &ReplaceSpecType_ProtocolUdp{ProtocolUdp: of.ProtocolUdp}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetSourcePrefixToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.SourcePrefix.(type) {
	case nil:
		o.SourcePrefix = nil

	case *ReplaceSpecType_SourcePrefixAll:
		o.SourcePrefix = &GlobalSpecType_SourcePrefixAll{SourcePrefixAll: of.SourcePrefixAll}

	case *ReplaceSpecType_SourcePrefixSingle:
		o.SourcePrefix = &GlobalSpecType_SourcePrefixSingle{SourcePrefixSingle: of.SourcePrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetSourcePrefixFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.SourcePrefix.(type) {
	case nil:
		r.SourcePrefix = nil

	case *GlobalSpecType_SourcePrefixAll:
		r.SourcePrefix = &ReplaceSpecType_SourcePrefixAll{SourcePrefixAll: of.SourcePrefixAll}

	case *GlobalSpecType_SourcePrefixSingle:
		r.SourcePrefix = &ReplaceSpecType_SourcePrefixSingle{SourcePrefixSingle: of.SourcePrefixSingle}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetStateToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.State.(type) {
	case nil:
		o.State = nil

	case *ReplaceSpecType_StateOff:
		o.State = &GlobalSpecType_StateOff{StateOff: of.StateOff}

	case *ReplaceSpecType_StateOn:
		o.State = &GlobalSpecType_StateOn{StateOn: of.StateOn}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetStateFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.State.(type) {
	case nil:
		r.State = nil

	case *GlobalSpecType_StateOff:
		r.State = &ReplaceSpecType_StateOff{StateOff: of.StateOff}

	case *GlobalSpecType_StateOn:
		r.State = &ReplaceSpecType_StateOn{StateOn: of.StateOn}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetVersionToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.Version.(type) {
	case nil:
		o.Version = nil

	case *ReplaceSpecType_VersionIpv4:
		o.Version = &GlobalSpecType_VersionIpv4{VersionIpv4: of.VersionIpv4}

	case *ReplaceSpecType_VersionIpv6:
		o.Version = &GlobalSpecType_VersionIpv6{VersionIpv6: of.VersionIpv6}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetVersionFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.Version.(type) {
	case nil:
		r.Version = nil

	case *GlobalSpecType_VersionIpv4:
		r.Version = &ReplaceSpecType_VersionIpv4{VersionIpv4: of.VersionIpv4}

	case *GlobalSpecType_VersionIpv6:
		r.Version = &ReplaceSpecType_VersionIpv6{VersionIpv6: of.VersionIpv6}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetActionFromGlobalSpecType(f)
	m.GetDestinationPrefixFromGlobalSpecType(f)
	m.GetFragmentsFromGlobalSpecType(f)
	m.GetProtocolFromGlobalSpecType(f)
	m.GetSourcePrefixFromGlobalSpecType(f)
	m.GetStateFromGlobalSpecType(f)
	m.GetVersionFromGlobalSpecType(f)
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetActionToGlobalSpecType(f)
	m1.SetDestinationPrefixToGlobalSpecType(f)
	m1.SetFragmentsToGlobalSpecType(f)
	m1.SetProtocolToGlobalSpecType(f)
	m1.SetSourcePrefixToGlobalSpecType(f)
	m1.SetStateToGlobalSpecType(f)
	m1.SetVersionToGlobalSpecType(f)
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
