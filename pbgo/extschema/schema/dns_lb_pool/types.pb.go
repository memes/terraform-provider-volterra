// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/dns_lb_pool/types.proto

package dns_lb_pool

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// LoadBalancing Mode
//
// x-displayName: "LoadBalancing Algorithm"
type LoadBalancingMode int32

const (
	// Round-Robin
	//
	// x-displayName: "Round-Robin"
	// Round Robin will ensure random equal distribution of requests among all pool members in a pool.
	ROUND_ROBIN LoadBalancingMode = 0
	// Ratio-Member
	//
	// x-displayName: "Ratio-Member"
	// Ratio-Member performs load balancing of requests across the pool members based on the ratio assigned to each pool member
	RATIO_MEMBER LoadBalancingMode = 1
	// Static-Persist
	//
	// x-displayName: "Static-Persist"
	// The Static Persist load balancing method uses the persist mask, with the source IP address of the Local Domain Name Server (LDNS), in a deterministic algorithm to send requests to a specific pool member
	STATIC_PERSIST LoadBalancingMode = 2
	// Priority
	//
	// x-displayName: "Priority"
	// The Priority load balancing method returns all available endpoints in a pool with the highest priority. Pool Members have a priority value, starting from zero, where a lower value means a higher priority.
	PRIORITY LoadBalancingMode = 3
)

var LoadBalancingMode_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "RATIO_MEMBER",
	2: "STATIC_PERSIST",
	3: "PRIORITY",
}

var LoadBalancingMode_value = map[string]int32{
	"ROUND_ROBIN":    0,
	"RATIO_MEMBER":   1,
	"STATIC_PERSIST": 2,
	"PRIORITY":       3,
}

func (LoadBalancingMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{0}
}

// DNS Load Balancer Pool specification
//
// x-displayName: "Specification"
// Desired state of DNS Load Balancer Pool
type GlobalSpecType struct {
	// Pool Type
	//
	// x-displayName: "Pool Type"
	// x-required
	//
	// Types that are valid to be assigned to PoolTypeChoice:
	//	*GlobalSpecType_APool
	//	*GlobalSpecType_AaaaPool
	//	*GlobalSpecType_CnamePool
	//	*GlobalSpecType_MxPool
	//	*GlobalSpecType_SrvPool
	PoolTypeChoice isGlobalSpecType_PoolTypeChoice `protobuf_oneof:"pool_type_choice"`
	// Load Balancing Mode
	//
	// x-displayName: "Load Balancing Mode"
	// x-required
	LoadBalancingMode LoadBalancingMode `protobuf:"varint,4,opt,name=load_balancing_mode,json=loadBalancingMode,proto3,enum=ves.io.schema.dns_lb_pool.LoadBalancingMode" json:"load_balancing_mode,omitempty"`
	// TTL choice
	//
	// x-displayName: "TTL choice"
	// TTL in seconds
	// x-required
	//
	// Types that are valid to be assigned to TtlChoice:
	//	*GlobalSpecType_UseRrsetTtl
	//	*GlobalSpecType_Ttl
	TtlChoice isGlobalSpecType_TtlChoice `protobuf_oneof:"ttl_choice"`
	// backref_objs
	//
	// x-displayName: "DNS Load balancers"
	// a list of Load balancers associated with this load balancer pool
	DnsLoadBalancers []*views.ObjectRefType `protobuf:"bytes,16,rep,name=dns_load_balancers,json=dnsLoadBalancers,proto3" json:"dns_load_balancers,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{0}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_PoolTypeChoice interface {
	isGlobalSpecType_PoolTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_TtlChoice interface {
	isGlobalSpecType_TtlChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_APool struct {
	APool *APool `protobuf:"bytes,10,opt,name=a_pool,json=aPool,proto3,oneof" json:"a_pool,omitempty"`
}
type GlobalSpecType_AaaaPool struct {
	AaaaPool *AAAAPool `protobuf:"bytes,11,opt,name=aaaa_pool,json=aaaaPool,proto3,oneof" json:"aaaa_pool,omitempty"`
}
type GlobalSpecType_CnamePool struct {
	CnamePool *CNAMEPool `protobuf:"bytes,12,opt,name=cname_pool,json=cnamePool,proto3,oneof" json:"cname_pool,omitempty"`
}
type GlobalSpecType_MxPool struct {
	MxPool *MXPool `protobuf:"bytes,13,opt,name=mx_pool,json=mxPool,proto3,oneof" json:"mx_pool,omitempty"`
}
type GlobalSpecType_SrvPool struct {
	SrvPool *SRVPool `protobuf:"bytes,17,opt,name=srv_pool,json=srvPool,proto3,oneof" json:"srv_pool,omitempty"`
}
type GlobalSpecType_UseRrsetTtl struct {
	UseRrsetTtl *schema.Empty `protobuf:"bytes,15,opt,name=use_rrset_ttl,json=useRrsetTtl,proto3,oneof" json:"use_rrset_ttl,omitempty"`
}
type GlobalSpecType_Ttl struct {
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3,oneof" json:"ttl,omitempty"`
}

func (*GlobalSpecType_APool) isGlobalSpecType_PoolTypeChoice()     {}
func (*GlobalSpecType_AaaaPool) isGlobalSpecType_PoolTypeChoice()  {}
func (*GlobalSpecType_CnamePool) isGlobalSpecType_PoolTypeChoice() {}
func (*GlobalSpecType_MxPool) isGlobalSpecType_PoolTypeChoice()    {}
func (*GlobalSpecType_SrvPool) isGlobalSpecType_PoolTypeChoice()   {}
func (*GlobalSpecType_UseRrsetTtl) isGlobalSpecType_TtlChoice()    {}
func (*GlobalSpecType_Ttl) isGlobalSpecType_TtlChoice()            {}

func (m *GlobalSpecType) GetPoolTypeChoice() isGlobalSpecType_PoolTypeChoice {
	if m != nil {
		return m.PoolTypeChoice
	}
	return nil
}
func (m *GlobalSpecType) GetTtlChoice() isGlobalSpecType_TtlChoice {
	if m != nil {
		return m.TtlChoice
	}
	return nil
}

func (m *GlobalSpecType) GetAPool() *APool {
	if x, ok := m.GetPoolTypeChoice().(*GlobalSpecType_APool); ok {
		return x.APool
	}
	return nil
}

func (m *GlobalSpecType) GetAaaaPool() *AAAAPool {
	if x, ok := m.GetPoolTypeChoice().(*GlobalSpecType_AaaaPool); ok {
		return x.AaaaPool
	}
	return nil
}

func (m *GlobalSpecType) GetCnamePool() *CNAMEPool {
	if x, ok := m.GetPoolTypeChoice().(*GlobalSpecType_CnamePool); ok {
		return x.CnamePool
	}
	return nil
}

func (m *GlobalSpecType) GetMxPool() *MXPool {
	if x, ok := m.GetPoolTypeChoice().(*GlobalSpecType_MxPool); ok {
		return x.MxPool
	}
	return nil
}

func (m *GlobalSpecType) GetSrvPool() *SRVPool {
	if x, ok := m.GetPoolTypeChoice().(*GlobalSpecType_SrvPool); ok {
		return x.SrvPool
	}
	return nil
}

func (m *GlobalSpecType) GetLoadBalancingMode() LoadBalancingMode {
	if m != nil {
		return m.LoadBalancingMode
	}
	return ROUND_ROBIN
}

func (m *GlobalSpecType) GetUseRrsetTtl() *schema.Empty {
	if x, ok := m.GetTtlChoice().(*GlobalSpecType_UseRrsetTtl); ok {
		return x.UseRrsetTtl
	}
	return nil
}

func (m *GlobalSpecType) GetTtl() uint32 {
	if x, ok := m.GetTtlChoice().(*GlobalSpecType_Ttl); ok {
		return x.Ttl
	}
	return 0
}

func (m *GlobalSpecType) GetDnsLoadBalancers() []*views.ObjectRefType {
	if m != nil {
		return m.DnsLoadBalancers
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_APool)(nil),
		(*GlobalSpecType_AaaaPool)(nil),
		(*GlobalSpecType_CnamePool)(nil),
		(*GlobalSpecType_MxPool)(nil),
		(*GlobalSpecType_SrvPool)(nil),
		(*GlobalSpecType_UseRrsetTtl)(nil),
		(*GlobalSpecType_Ttl)(nil),
	}
}

// A Pool
//
// x-displayName: "Pool for A Record"
type APool struct {
	// Collection of A record members
	//
	// x-displayName: "Pool Members"
	// x-required
	Members []*AddressMember `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty"`
	// DNS Load Balancer Health Check
	//
	// x-displayName: "DNS Load Balancer Health Check"
	// x-required
	//
	// Types that are valid to be assigned to HealthCheckChoice:
	//	*APool_DisableHealthCheck
	//	*APool_HealthCheck
	HealthCheckChoice isAPool_HealthCheckChoice `protobuf_oneof:"health_check_choice"`
	// Maximum Answers
	//
	// x-displayName: "Maximum Answers"
	// x-example: "1"
	// x-required
	// Limit on number of Resource Records to be included in the response to query
	MaxAnswers uint32 `protobuf:"varint,5,opt,name=max_answers,json=maxAnswers,proto3" json:"max_answers,omitempty"`
}

func (m *APool) Reset()      { *m = APool{} }
func (*APool) ProtoMessage() {}
func (*APool) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{1}
}
func (m *APool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *APool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *APool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_APool.Merge(m, src)
}
func (m *APool) XXX_Size() int {
	return m.Size()
}
func (m *APool) XXX_DiscardUnknown() {
	xxx_messageInfo_APool.DiscardUnknown(m)
}

var xxx_messageInfo_APool proto.InternalMessageInfo

type isAPool_HealthCheckChoice interface {
	isAPool_HealthCheckChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type APool_DisableHealthCheck struct {
	DisableHealthCheck *schema.Empty `protobuf:"bytes,3,opt,name=disable_health_check,json=disableHealthCheck,proto3,oneof" json:"disable_health_check,omitempty"`
}
type APool_HealthCheck struct {
	HealthCheck *views.ObjectRefType `protobuf:"bytes,4,opt,name=health_check,json=healthCheck,proto3,oneof" json:"health_check,omitempty"`
}

func (*APool_DisableHealthCheck) isAPool_HealthCheckChoice() {}
func (*APool_HealthCheck) isAPool_HealthCheckChoice()        {}

func (m *APool) GetHealthCheckChoice() isAPool_HealthCheckChoice {
	if m != nil {
		return m.HealthCheckChoice
	}
	return nil
}

func (m *APool) GetMembers() []*AddressMember {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *APool) GetDisableHealthCheck() *schema.Empty {
	if x, ok := m.GetHealthCheckChoice().(*APool_DisableHealthCheck); ok {
		return x.DisableHealthCheck
	}
	return nil
}

func (m *APool) GetHealthCheck() *views.ObjectRefType {
	if x, ok := m.GetHealthCheckChoice().(*APool_HealthCheck); ok {
		return x.HealthCheck
	}
	return nil
}

func (m *APool) GetMaxAnswers() uint32 {
	if m != nil {
		return m.MaxAnswers
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*APool) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*APool_DisableHealthCheck)(nil),
		(*APool_HealthCheck)(nil),
	}
}

// AAAA Pool
//
// x-displayName: "Pool for AAAA Record"
type AAAAPool struct {
	// Collection of AAAA record members
	//
	// x-displayName: "Pool Members"
	// x-required
	Members []*AddressMember `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty"`
	// Maximum Answers
	//
	// x-displayName: "Maximum Answers"
	// x-example: "1"
	// x-required
	// Limit on number of Resource Records to be included in the response to query
	MaxAnswers uint32 `protobuf:"varint,5,opt,name=max_answers,json=maxAnswers,proto3" json:"max_answers,omitempty"`
}

func (m *AAAAPool) Reset()      { *m = AAAAPool{} }
func (*AAAAPool) ProtoMessage() {}
func (*AAAAPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{2}
}
func (m *AAAAPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AAAAPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AAAAPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AAAAPool.Merge(m, src)
}
func (m *AAAAPool) XXX_Size() int {
	return m.Size()
}
func (m *AAAAPool) XXX_DiscardUnknown() {
	xxx_messageInfo_AAAAPool.DiscardUnknown(m)
}

var xxx_messageInfo_AAAAPool proto.InternalMessageInfo

func (m *AAAAPool) GetMembers() []*AddressMember {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *AAAAPool) GetMaxAnswers() uint32 {
	if m != nil {
		return m.MaxAnswers
	}
	return 0
}

// CNAME Pool
//
// x-displayName: "Pool for CNAME Record"
type CNAMEPool struct {
	// Collection of CNAME record members
	//
	// x-displayName: "Pool Members"
	// x-required
	Members []*CNAMEMember `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty"`
}

func (m *CNAMEPool) Reset()      { *m = CNAMEPool{} }
func (*CNAMEPool) ProtoMessage() {}
func (*CNAMEPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{3}
}
func (m *CNAMEPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNAMEPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CNAMEPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNAMEPool.Merge(m, src)
}
func (m *CNAMEPool) XXX_Size() int {
	return m.Size()
}
func (m *CNAMEPool) XXX_DiscardUnknown() {
	xxx_messageInfo_CNAMEPool.DiscardUnknown(m)
}

var xxx_messageInfo_CNAMEPool proto.InternalMessageInfo

func (m *CNAMEPool) GetMembers() []*CNAMEMember {
	if m != nil {
		return m.Members
	}
	return nil
}

// MX Pool
//
// x-displayName: "Pool for MX Record"
type MXPool struct {
	// Collection of MX record members
	//
	// x-displayName: "Pool Members"
	// x-required
	Members []*MXMember `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty"`
	// Maximum Answers
	//
	// x-displayName: "Maximum Answers"
	// x-example: "1"
	// x-required
	// Limit on number of Resource Records to be included in the response to query
	MaxAnswers uint32 `protobuf:"varint,2,opt,name=max_answers,json=maxAnswers,proto3" json:"max_answers,omitempty"`
}

func (m *MXPool) Reset()      { *m = MXPool{} }
func (*MXPool) ProtoMessage() {}
func (*MXPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{4}
}
func (m *MXPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MXPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MXPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MXPool.Merge(m, src)
}
func (m *MXPool) XXX_Size() int {
	return m.Size()
}
func (m *MXPool) XXX_DiscardUnknown() {
	xxx_messageInfo_MXPool.DiscardUnknown(m)
}

var xxx_messageInfo_MXPool proto.InternalMessageInfo

func (m *MXPool) GetMembers() []*MXMember {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *MXPool) GetMaxAnswers() uint32 {
	if m != nil {
		return m.MaxAnswers
	}
	return 0
}

// SRV Pool
//
// x-displayName: "Pool for SRV Record"
type SRVPool struct {
	// Collection of SRV record members
	//
	// x-displayName: "Pool Members"
	// x-required
	Members []*SRVMember `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty"`
	// Maximum Answers
	//
	// x-displayName: "Maximum Answers"
	// x-example: "1"
	// x-required
	// Limit on number of Resource Records to be included in the response to query
	MaxAnswers uint32 `protobuf:"varint,2,opt,name=max_answers,json=maxAnswers,proto3" json:"max_answers,omitempty"`
}

func (m *SRVPool) Reset()      { *m = SRVPool{} }
func (*SRVPool) ProtoMessage() {}
func (*SRVPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{5}
}
func (m *SRVPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SRVPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SRVPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SRVPool.Merge(m, src)
}
func (m *SRVPool) XXX_Size() int {
	return m.Size()
}
func (m *SRVPool) XXX_DiscardUnknown() {
	xxx_messageInfo_SRVPool.DiscardUnknown(m)
}

var xxx_messageInfo_SRVPool proto.InternalMessageInfo

func (m *SRVPool) GetMembers() []*SRVMember {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *SRVPool) GetMaxAnswers() uint32 {
	if m != nil {
		return m.MaxAnswers
	}
	return 0
}

// AddressMember
//
// x-displayName: "IP Endpoint"
// Public IP address which can be IPv4 or IPv6. This can be a member of only A/AAAA type Pool
type AddressMember struct {
	// IP
	//
	// x-displayName: "Public IP"
	// x-example: "8.8.8.8"
	// x-required
	// Public IP address
	IpEndpoint string `protobuf:"bytes,1,opt,name=ip_endpoint,json=ipEndpoint,proto3" json:"ip_endpoint,omitempty"`
	// Ratio
	//
	// x-displayName: "Load Balancing Ratio"
	// x-example: "10"
	// Used if the pool’s load balancing mode is set to Ratio-Member
	Ratio uint32 `protobuf:"varint,5,opt,name=ratio,proto3" json:"ratio,omitempty"`
	// Priority
	//
	// x-displayName: "Load Balancing Priority"
	// x-example: "10"
	// Used if the pool’s load balancing mode is set to Priority
	Priority uint32 `protobuf:"varint,6,opt,name=priority,proto3" json:"priority,omitempty"`
	// Disable pool-member
	//
	// x-displayName: "Disable"
	// x-example: "true"
	// A value of true will disable the pool-member
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-example: "web server 1"
	// Pool member name
	Name string `protobuf:"bytes,8,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *AddressMember) Reset()      { *m = AddressMember{} }
func (*AddressMember) ProtoMessage() {}
func (*AddressMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{6}
}
func (m *AddressMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AddressMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressMember.Merge(m, src)
}
func (m *AddressMember) XXX_Size() int {
	return m.Size()
}
func (m *AddressMember) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressMember.DiscardUnknown(m)
}

var xxx_messageInfo_AddressMember proto.InternalMessageInfo

func (m *AddressMember) GetIpEndpoint() string {
	if m != nil {
		return m.IpEndpoint
	}
	return ""
}

func (m *AddressMember) GetRatio() uint32 {
	if m != nil {
		return m.Ratio
	}
	return 0
}

func (m *AddressMember) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *AddressMember) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

func (m *AddressMember) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// MXMember
//
// x-displayName: "MX Record"
// MX Record which can be a member of a MX type pool
type MXMember struct {
	// Domain
	//
	// x-displayName: "Domain"
	// x-example: "mail.example.com"
	// x-required
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// Priority
	//
	// x-displayName: "MX Record Priority"
	// x-example: "10"
	// MX Record priority
	Priority uint32 `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
	// Ratio
	//
	// x-displayName: "Load Balancing Ratio"
	// x-example: "10"
	// Load Balancing Ratio
	Ratio uint32 `protobuf:"varint,3,opt,name=ratio,proto3" json:"ratio,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-example: "web server 1"
	// Pool member name
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *MXMember) Reset()      { *m = MXMember{} }
func (*MXMember) ProtoMessage() {}
func (*MXMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{7}
}
func (m *MXMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MXMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MXMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MXMember.Merge(m, src)
}
func (m *MXMember) XXX_Size() int {
	return m.Size()
}
func (m *MXMember) XXX_DiscardUnknown() {
	xxx_messageInfo_MXMember.DiscardUnknown(m)
}

var xxx_messageInfo_MXMember proto.InternalMessageInfo

func (m *MXMember) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *MXMember) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *MXMember) GetRatio() uint32 {
	if m != nil {
		return m.Ratio
	}
	return 0
}

func (m *MXMember) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// CNAMEMember
//
// x-displayName: "CNAME member"
// CNAME Record which can be a member of a CNAME type pool
type CNAMEMember struct {
	// Domain
	//
	// x-displayName: "Domain"
	// x-example: "app.example.com"
	// x-required
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// Ratio
	//
	// x-displayName: "Load Balancing Ratio"
	// x-example: "10"
	// Ratio
	Ratio uint32 `protobuf:"varint,2,opt,name=ratio,proto3" json:"ratio,omitempty"`
	// Final Translation
	//
	// x-displayName: "Final Translation"
	// If this flag is true, the CNAME record will not be translated further.
	FinalTranslation bool `protobuf:"varint,3,opt,name=final_translation,json=finalTranslation,proto3" json:"final_translation,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-example: "web server 1"
	// Pool member name
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CNAMEMember) Reset()      { *m = CNAMEMember{} }
func (*CNAMEMember) ProtoMessage() {}
func (*CNAMEMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{8}
}
func (m *CNAMEMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNAMEMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CNAMEMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNAMEMember.Merge(m, src)
}
func (m *CNAMEMember) XXX_Size() int {
	return m.Size()
}
func (m *CNAMEMember) XXX_DiscardUnknown() {
	xxx_messageInfo_CNAMEMember.DiscardUnknown(m)
}

var xxx_messageInfo_CNAMEMember proto.InternalMessageInfo

func (m *CNAMEMember) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *CNAMEMember) GetRatio() uint32 {
	if m != nil {
		return m.Ratio
	}
	return 0
}

func (m *CNAMEMember) GetFinalTranslation() bool {
	if m != nil {
		return m.FinalTranslation
	}
	return false
}

func (m *CNAMEMember) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// SRVMember
//
// x-displayName: "SRV member"
// SRV Record which can be a member of a SRV type pool
type SRVMember struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "web server 1"
	// Pool member name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "10"
	// Priority of the target. A lower number indicates a higher preference.
	// x-required
	Priority uint32 `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
	// Weight
	//
	// x-displayName: "Weight"
	// x-example: "10"
	// Weight of the target. A higher number indicates a higher preference.
	// x-required
	Weight uint32 `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	// Port
	//
	// x-displayName: "Port"
	// x-example: "10"
	// Port on which the service can be found
	// x-required
	Port uint32 `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	// Target
	//
	// x-displayName: "Target"
	// x-example: "my.example.com"
	// Domain name of the machine providing the service
	// x-required
	Target string `protobuf:"bytes,5,opt,name=target,proto3" json:"target,omitempty"`
	// Final Translation
	//
	// x-displayName: "Final Translation"
	// If this flag is true, the SRV record will not be translated further.
	FinalTranslation bool `protobuf:"varint,6,opt,name=final_translation,json=finalTranslation,proto3" json:"final_translation,omitempty"`
	// Ratio
	//
	// x-displayName: "Load Balancing Ratio"
	// x-example: "10"
	// Ratio
	Ratio uint32 `protobuf:"varint,7,opt,name=ratio,proto3" json:"ratio,omitempty"`
}

func (m *SRVMember) Reset()      { *m = SRVMember{} }
func (*SRVMember) ProtoMessage() {}
func (*SRVMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{9}
}
func (m *SRVMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SRVMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SRVMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SRVMember.Merge(m, src)
}
func (m *SRVMember) XXX_Size() int {
	return m.Size()
}
func (m *SRVMember) XXX_DiscardUnknown() {
	xxx_messageInfo_SRVMember.DiscardUnknown(m)
}

var xxx_messageInfo_SRVMember proto.InternalMessageInfo

func (m *SRVMember) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SRVMember) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *SRVMember) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *SRVMember) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SRVMember) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *SRVMember) GetFinalTranslation() bool {
	if m != nil {
		return m.FinalTranslation
	}
	return false
}

func (m *SRVMember) GetRatio() uint32 {
	if m != nil {
		return m.Ratio
	}
	return 0
}

// Create DNS Load Balancer Pool
//
// x-displayName: "Create DNS Load Balancer Pool"
// Create DNS Load Balancer Pool in a given namespace. If one already exist it will give a error.
type CreateSpecType struct {
	// Types that are valid to be assigned to PoolTypeChoice:
	//	*CreateSpecType_APool
	//	*CreateSpecType_AaaaPool
	//	*CreateSpecType_CnamePool
	//	*CreateSpecType_MxPool
	//	*CreateSpecType_SrvPool
	PoolTypeChoice    isCreateSpecType_PoolTypeChoice `protobuf_oneof:"pool_type_choice"`
	LoadBalancingMode LoadBalancingMode               `protobuf:"varint,4,opt,name=load_balancing_mode,json=loadBalancingMode,proto3,enum=ves.io.schema.dns_lb_pool.LoadBalancingMode" json:"load_balancing_mode,omitempty"`
	// Types that are valid to be assigned to TtlChoice:
	//	*CreateSpecType_UseRrsetTtl
	//	*CreateSpecType_Ttl
	TtlChoice isCreateSpecType_TtlChoice `protobuf_oneof:"ttl_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{10}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_PoolTypeChoice interface {
	isCreateSpecType_PoolTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_TtlChoice interface {
	isCreateSpecType_TtlChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_APool struct {
	APool *APool `protobuf:"bytes,10,opt,name=a_pool,json=aPool,proto3,oneof" json:"a_pool,omitempty"`
}
type CreateSpecType_AaaaPool struct {
	AaaaPool *AAAAPool `protobuf:"bytes,11,opt,name=aaaa_pool,json=aaaaPool,proto3,oneof" json:"aaaa_pool,omitempty"`
}
type CreateSpecType_CnamePool struct {
	CnamePool *CNAMEPool `protobuf:"bytes,12,opt,name=cname_pool,json=cnamePool,proto3,oneof" json:"cname_pool,omitempty"`
}
type CreateSpecType_MxPool struct {
	MxPool *MXPool `protobuf:"bytes,13,opt,name=mx_pool,json=mxPool,proto3,oneof" json:"mx_pool,omitempty"`
}
type CreateSpecType_SrvPool struct {
	SrvPool *SRVPool `protobuf:"bytes,17,opt,name=srv_pool,json=srvPool,proto3,oneof" json:"srv_pool,omitempty"`
}
type CreateSpecType_UseRrsetTtl struct {
	UseRrsetTtl *schema.Empty `protobuf:"bytes,15,opt,name=use_rrset_ttl,json=useRrsetTtl,proto3,oneof" json:"use_rrset_ttl,omitempty"`
}
type CreateSpecType_Ttl struct {
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3,oneof" json:"ttl,omitempty"`
}

func (*CreateSpecType_APool) isCreateSpecType_PoolTypeChoice()     {}
func (*CreateSpecType_AaaaPool) isCreateSpecType_PoolTypeChoice()  {}
func (*CreateSpecType_CnamePool) isCreateSpecType_PoolTypeChoice() {}
func (*CreateSpecType_MxPool) isCreateSpecType_PoolTypeChoice()    {}
func (*CreateSpecType_SrvPool) isCreateSpecType_PoolTypeChoice()   {}
func (*CreateSpecType_UseRrsetTtl) isCreateSpecType_TtlChoice()    {}
func (*CreateSpecType_Ttl) isCreateSpecType_TtlChoice()            {}

func (m *CreateSpecType) GetPoolTypeChoice() isCreateSpecType_PoolTypeChoice {
	if m != nil {
		return m.PoolTypeChoice
	}
	return nil
}
func (m *CreateSpecType) GetTtlChoice() isCreateSpecType_TtlChoice {
	if m != nil {
		return m.TtlChoice
	}
	return nil
}

func (m *CreateSpecType) GetAPool() *APool {
	if x, ok := m.GetPoolTypeChoice().(*CreateSpecType_APool); ok {
		return x.APool
	}
	return nil
}

func (m *CreateSpecType) GetAaaaPool() *AAAAPool {
	if x, ok := m.GetPoolTypeChoice().(*CreateSpecType_AaaaPool); ok {
		return x.AaaaPool
	}
	return nil
}

func (m *CreateSpecType) GetCnamePool() *CNAMEPool {
	if x, ok := m.GetPoolTypeChoice().(*CreateSpecType_CnamePool); ok {
		return x.CnamePool
	}
	return nil
}

func (m *CreateSpecType) GetMxPool() *MXPool {
	if x, ok := m.GetPoolTypeChoice().(*CreateSpecType_MxPool); ok {
		return x.MxPool
	}
	return nil
}

func (m *CreateSpecType) GetSrvPool() *SRVPool {
	if x, ok := m.GetPoolTypeChoice().(*CreateSpecType_SrvPool); ok {
		return x.SrvPool
	}
	return nil
}

func (m *CreateSpecType) GetLoadBalancingMode() LoadBalancingMode {
	if m != nil {
		return m.LoadBalancingMode
	}
	return ROUND_ROBIN
}

func (m *CreateSpecType) GetUseRrsetTtl() *schema.Empty {
	if x, ok := m.GetTtlChoice().(*CreateSpecType_UseRrsetTtl); ok {
		return x.UseRrsetTtl
	}
	return nil
}

func (m *CreateSpecType) GetTtl() uint32 {
	if x, ok := m.GetTtlChoice().(*CreateSpecType_Ttl); ok {
		return x.Ttl
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_APool)(nil),
		(*CreateSpecType_AaaaPool)(nil),
		(*CreateSpecType_CnamePool)(nil),
		(*CreateSpecType_MxPool)(nil),
		(*CreateSpecType_SrvPool)(nil),
		(*CreateSpecType_UseRrsetTtl)(nil),
		(*CreateSpecType_Ttl)(nil),
	}
}

// Replace DNS Load Balancer Pool
//
// x-displayName: "Replace DNS Load Balancer Pool"
// Replace DNS Load Balancer Pool in a given namespace.
type ReplaceSpecType struct {
	// Types that are valid to be assigned to PoolTypeChoice:
	//	*ReplaceSpecType_APool
	//	*ReplaceSpecType_AaaaPool
	//	*ReplaceSpecType_CnamePool
	//	*ReplaceSpecType_MxPool
	//	*ReplaceSpecType_SrvPool
	PoolTypeChoice    isReplaceSpecType_PoolTypeChoice `protobuf_oneof:"pool_type_choice"`
	LoadBalancingMode LoadBalancingMode                `protobuf:"varint,4,opt,name=load_balancing_mode,json=loadBalancingMode,proto3,enum=ves.io.schema.dns_lb_pool.LoadBalancingMode" json:"load_balancing_mode,omitempty"`
	// Types that are valid to be assigned to TtlChoice:
	//	*ReplaceSpecType_UseRrsetTtl
	//	*ReplaceSpecType_Ttl
	TtlChoice isReplaceSpecType_TtlChoice `protobuf_oneof:"ttl_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{11}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_PoolTypeChoice interface {
	isReplaceSpecType_PoolTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_TtlChoice interface {
	isReplaceSpecType_TtlChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_APool struct {
	APool *APool `protobuf:"bytes,10,opt,name=a_pool,json=aPool,proto3,oneof" json:"a_pool,omitempty"`
}
type ReplaceSpecType_AaaaPool struct {
	AaaaPool *AAAAPool `protobuf:"bytes,11,opt,name=aaaa_pool,json=aaaaPool,proto3,oneof" json:"aaaa_pool,omitempty"`
}
type ReplaceSpecType_CnamePool struct {
	CnamePool *CNAMEPool `protobuf:"bytes,12,opt,name=cname_pool,json=cnamePool,proto3,oneof" json:"cname_pool,omitempty"`
}
type ReplaceSpecType_MxPool struct {
	MxPool *MXPool `protobuf:"bytes,13,opt,name=mx_pool,json=mxPool,proto3,oneof" json:"mx_pool,omitempty"`
}
type ReplaceSpecType_SrvPool struct {
	SrvPool *SRVPool `protobuf:"bytes,17,opt,name=srv_pool,json=srvPool,proto3,oneof" json:"srv_pool,omitempty"`
}
type ReplaceSpecType_UseRrsetTtl struct {
	UseRrsetTtl *schema.Empty `protobuf:"bytes,15,opt,name=use_rrset_ttl,json=useRrsetTtl,proto3,oneof" json:"use_rrset_ttl,omitempty"`
}
type ReplaceSpecType_Ttl struct {
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3,oneof" json:"ttl,omitempty"`
}

func (*ReplaceSpecType_APool) isReplaceSpecType_PoolTypeChoice()     {}
func (*ReplaceSpecType_AaaaPool) isReplaceSpecType_PoolTypeChoice()  {}
func (*ReplaceSpecType_CnamePool) isReplaceSpecType_PoolTypeChoice() {}
func (*ReplaceSpecType_MxPool) isReplaceSpecType_PoolTypeChoice()    {}
func (*ReplaceSpecType_SrvPool) isReplaceSpecType_PoolTypeChoice()   {}
func (*ReplaceSpecType_UseRrsetTtl) isReplaceSpecType_TtlChoice()    {}
func (*ReplaceSpecType_Ttl) isReplaceSpecType_TtlChoice()            {}

func (m *ReplaceSpecType) GetPoolTypeChoice() isReplaceSpecType_PoolTypeChoice {
	if m != nil {
		return m.PoolTypeChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetTtlChoice() isReplaceSpecType_TtlChoice {
	if m != nil {
		return m.TtlChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetAPool() *APool {
	if x, ok := m.GetPoolTypeChoice().(*ReplaceSpecType_APool); ok {
		return x.APool
	}
	return nil
}

func (m *ReplaceSpecType) GetAaaaPool() *AAAAPool {
	if x, ok := m.GetPoolTypeChoice().(*ReplaceSpecType_AaaaPool); ok {
		return x.AaaaPool
	}
	return nil
}

func (m *ReplaceSpecType) GetCnamePool() *CNAMEPool {
	if x, ok := m.GetPoolTypeChoice().(*ReplaceSpecType_CnamePool); ok {
		return x.CnamePool
	}
	return nil
}

func (m *ReplaceSpecType) GetMxPool() *MXPool {
	if x, ok := m.GetPoolTypeChoice().(*ReplaceSpecType_MxPool); ok {
		return x.MxPool
	}
	return nil
}

func (m *ReplaceSpecType) GetSrvPool() *SRVPool {
	if x, ok := m.GetPoolTypeChoice().(*ReplaceSpecType_SrvPool); ok {
		return x.SrvPool
	}
	return nil
}

func (m *ReplaceSpecType) GetLoadBalancingMode() LoadBalancingMode {
	if m != nil {
		return m.LoadBalancingMode
	}
	return ROUND_ROBIN
}

func (m *ReplaceSpecType) GetUseRrsetTtl() *schema.Empty {
	if x, ok := m.GetTtlChoice().(*ReplaceSpecType_UseRrsetTtl); ok {
		return x.UseRrsetTtl
	}
	return nil
}

func (m *ReplaceSpecType) GetTtl() uint32 {
	if x, ok := m.GetTtlChoice().(*ReplaceSpecType_Ttl); ok {
		return x.Ttl
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_APool)(nil),
		(*ReplaceSpecType_AaaaPool)(nil),
		(*ReplaceSpecType_CnamePool)(nil),
		(*ReplaceSpecType_MxPool)(nil),
		(*ReplaceSpecType_SrvPool)(nil),
		(*ReplaceSpecType_UseRrsetTtl)(nil),
		(*ReplaceSpecType_Ttl)(nil),
	}
}

// Get DNS Load Balancer Pool
//
// x-displayName: "Get DNS Load Balancer Pool"
// Get DNS Load Balancer Pool details.
type GetSpecType struct {
	// Types that are valid to be assigned to PoolTypeChoice:
	//	*GetSpecType_APool
	//	*GetSpecType_AaaaPool
	//	*GetSpecType_CnamePool
	//	*GetSpecType_MxPool
	//	*GetSpecType_SrvPool
	PoolTypeChoice    isGetSpecType_PoolTypeChoice `protobuf_oneof:"pool_type_choice"`
	LoadBalancingMode LoadBalancingMode            `protobuf:"varint,4,opt,name=load_balancing_mode,json=loadBalancingMode,proto3,enum=ves.io.schema.dns_lb_pool.LoadBalancingMode" json:"load_balancing_mode,omitempty"`
	// Types that are valid to be assigned to TtlChoice:
	//	*GetSpecType_UseRrsetTtl
	//	*GetSpecType_Ttl
	TtlChoice        isGetSpecType_TtlChoice `protobuf_oneof:"ttl_choice"`
	DnsLoadBalancers []*views.ObjectRefType  `protobuf:"bytes,16,rep,name=dns_load_balancers,json=dnsLoadBalancers,proto3" json:"dns_load_balancers,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8f0dcaab98ebde2, []int{12}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_PoolTypeChoice interface {
	isGetSpecType_PoolTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_TtlChoice interface {
	isGetSpecType_TtlChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_APool struct {
	APool *APool `protobuf:"bytes,10,opt,name=a_pool,json=aPool,proto3,oneof" json:"a_pool,omitempty"`
}
type GetSpecType_AaaaPool struct {
	AaaaPool *AAAAPool `protobuf:"bytes,11,opt,name=aaaa_pool,json=aaaaPool,proto3,oneof" json:"aaaa_pool,omitempty"`
}
type GetSpecType_CnamePool struct {
	CnamePool *CNAMEPool `protobuf:"bytes,12,opt,name=cname_pool,json=cnamePool,proto3,oneof" json:"cname_pool,omitempty"`
}
type GetSpecType_MxPool struct {
	MxPool *MXPool `protobuf:"bytes,13,opt,name=mx_pool,json=mxPool,proto3,oneof" json:"mx_pool,omitempty"`
}
type GetSpecType_SrvPool struct {
	SrvPool *SRVPool `protobuf:"bytes,17,opt,name=srv_pool,json=srvPool,proto3,oneof" json:"srv_pool,omitempty"`
}
type GetSpecType_UseRrsetTtl struct {
	UseRrsetTtl *schema.Empty `protobuf:"bytes,15,opt,name=use_rrset_ttl,json=useRrsetTtl,proto3,oneof" json:"use_rrset_ttl,omitempty"`
}
type GetSpecType_Ttl struct {
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3,oneof" json:"ttl,omitempty"`
}

func (*GetSpecType_APool) isGetSpecType_PoolTypeChoice()     {}
func (*GetSpecType_AaaaPool) isGetSpecType_PoolTypeChoice()  {}
func (*GetSpecType_CnamePool) isGetSpecType_PoolTypeChoice() {}
func (*GetSpecType_MxPool) isGetSpecType_PoolTypeChoice()    {}
func (*GetSpecType_SrvPool) isGetSpecType_PoolTypeChoice()   {}
func (*GetSpecType_UseRrsetTtl) isGetSpecType_TtlChoice()    {}
func (*GetSpecType_Ttl) isGetSpecType_TtlChoice()            {}

func (m *GetSpecType) GetPoolTypeChoice() isGetSpecType_PoolTypeChoice {
	if m != nil {
		return m.PoolTypeChoice
	}
	return nil
}
func (m *GetSpecType) GetTtlChoice() isGetSpecType_TtlChoice {
	if m != nil {
		return m.TtlChoice
	}
	return nil
}

func (m *GetSpecType) GetAPool() *APool {
	if x, ok := m.GetPoolTypeChoice().(*GetSpecType_APool); ok {
		return x.APool
	}
	return nil
}

func (m *GetSpecType) GetAaaaPool() *AAAAPool {
	if x, ok := m.GetPoolTypeChoice().(*GetSpecType_AaaaPool); ok {
		return x.AaaaPool
	}
	return nil
}

func (m *GetSpecType) GetCnamePool() *CNAMEPool {
	if x, ok := m.GetPoolTypeChoice().(*GetSpecType_CnamePool); ok {
		return x.CnamePool
	}
	return nil
}

func (m *GetSpecType) GetMxPool() *MXPool {
	if x, ok := m.GetPoolTypeChoice().(*GetSpecType_MxPool); ok {
		return x.MxPool
	}
	return nil
}

func (m *GetSpecType) GetSrvPool() *SRVPool {
	if x, ok := m.GetPoolTypeChoice().(*GetSpecType_SrvPool); ok {
		return x.SrvPool
	}
	return nil
}

func (m *GetSpecType) GetLoadBalancingMode() LoadBalancingMode {
	if m != nil {
		return m.LoadBalancingMode
	}
	return ROUND_ROBIN
}

func (m *GetSpecType) GetUseRrsetTtl() *schema.Empty {
	if x, ok := m.GetTtlChoice().(*GetSpecType_UseRrsetTtl); ok {
		return x.UseRrsetTtl
	}
	return nil
}

func (m *GetSpecType) GetTtl() uint32 {
	if x, ok := m.GetTtlChoice().(*GetSpecType_Ttl); ok {
		return x.Ttl
	}
	return 0
}

func (m *GetSpecType) GetDnsLoadBalancers() []*views.ObjectRefType {
	if m != nil {
		return m.DnsLoadBalancers
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_APool)(nil),
		(*GetSpecType_AaaaPool)(nil),
		(*GetSpecType_CnamePool)(nil),
		(*GetSpecType_MxPool)(nil),
		(*GetSpecType_SrvPool)(nil),
		(*GetSpecType_UseRrsetTtl)(nil),
		(*GetSpecType_Ttl)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.dns_lb_pool.LoadBalancingMode", LoadBalancingMode_name, LoadBalancingMode_value)
	golang_proto.RegisterEnum("ves.io.schema.dns_lb_pool.LoadBalancingMode", LoadBalancingMode_name, LoadBalancingMode_value)
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.dns_lb_pool.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.dns_lb_pool.GlobalSpecType")
	proto.RegisterType((*APool)(nil), "ves.io.schema.dns_lb_pool.APool")
	golang_proto.RegisterType((*APool)(nil), "ves.io.schema.dns_lb_pool.APool")
	proto.RegisterType((*AAAAPool)(nil), "ves.io.schema.dns_lb_pool.AAAAPool")
	golang_proto.RegisterType((*AAAAPool)(nil), "ves.io.schema.dns_lb_pool.AAAAPool")
	proto.RegisterType((*CNAMEPool)(nil), "ves.io.schema.dns_lb_pool.CNAMEPool")
	golang_proto.RegisterType((*CNAMEPool)(nil), "ves.io.schema.dns_lb_pool.CNAMEPool")
	proto.RegisterType((*MXPool)(nil), "ves.io.schema.dns_lb_pool.MXPool")
	golang_proto.RegisterType((*MXPool)(nil), "ves.io.schema.dns_lb_pool.MXPool")
	proto.RegisterType((*SRVPool)(nil), "ves.io.schema.dns_lb_pool.SRVPool")
	golang_proto.RegisterType((*SRVPool)(nil), "ves.io.schema.dns_lb_pool.SRVPool")
	proto.RegisterType((*AddressMember)(nil), "ves.io.schema.dns_lb_pool.AddressMember")
	golang_proto.RegisterType((*AddressMember)(nil), "ves.io.schema.dns_lb_pool.AddressMember")
	proto.RegisterType((*MXMember)(nil), "ves.io.schema.dns_lb_pool.MXMember")
	golang_proto.RegisterType((*MXMember)(nil), "ves.io.schema.dns_lb_pool.MXMember")
	proto.RegisterType((*CNAMEMember)(nil), "ves.io.schema.dns_lb_pool.CNAMEMember")
	golang_proto.RegisterType((*CNAMEMember)(nil), "ves.io.schema.dns_lb_pool.CNAMEMember")
	proto.RegisterType((*SRVMember)(nil), "ves.io.schema.dns_lb_pool.SRVMember")
	golang_proto.RegisterType((*SRVMember)(nil), "ves.io.schema.dns_lb_pool.SRVMember")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.dns_lb_pool.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.dns_lb_pool.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.dns_lb_pool.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.dns_lb_pool.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.dns_lb_pool.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.dns_lb_pool.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/dns_lb_pool/types.proto", fileDescriptor_a8f0dcaab98ebde2)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/dns_lb_pool/types.proto", fileDescriptor_a8f0dcaab98ebde2)
}

var fileDescriptor_a8f0dcaab98ebde2 = []byte{
	// 1666 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x4f, 0x6c, 0xdb, 0xd6,
	0x1d, 0xd6, 0xa3, 0x28, 0x8a, 0xfa, 0x29, 0x96, 0xe9, 0x17, 0xb7, 0x63, 0xd5, 0x82, 0x55, 0xd5,
	0xac, 0x50, 0x0d, 0x5a, 0xb2, 0x6c, 0xc7, 0x59, 0x8c, 0xc1, 0x81, 0x99, 0x78, 0xb5, 0x8d, 0x39,
	0x36, 0x68, 0xed, 0x5f, 0x9b, 0x98, 0xa3, 0xa4, 0x67, 0x89, 0x2b, 0x29, 0x12, 0x24, 0xed, 0x38,
	0xed, 0x8c, 0x15, 0x3d, 0x0d, 0x03, 0x06, 0x0c, 0xbb, 0xec, 0x56, 0xec, 0xb0, 0xc3, 0xd0, 0xeb,
	0x0e, 0xc3, 0xa6, 0x1d, 0x7c, 0x1c, 0x72, 0xf2, 0x31, 0xc8, 0x69, 0x51, 0x2e, 0xfb, 0x73, 0x29,
	0x72, 0x1a, 0x3a, 0x0c, 0x1e, 0xf8, 0x44, 0xc9, 0x92, 0x2d, 0xcb, 0x5d, 0x82, 0xe6, 0x12, 0xdf,
	0x48, 0xbe, 0xef, 0xf7, 0xbd, 0xef, 0xf7, 0xbd, 0x4f, 0x4f, 0x78, 0x0f, 0xbe, 0xb9, 0x4b, 0xbc,
	0xbc, 0x61, 0x17, 0xbc, 0x4a, 0x9d, 0x58, 0x7a, 0xa1, 0xda, 0xf0, 0x34, 0xb3, 0xac, 0x39, 0xb6,
	0x6d, 0x16, 0xfc, 0xfb, 0x0e, 0xf1, 0xf2, 0x8e, 0x6b, 0xfb, 0x36, 0x7e, 0xad, 0x0d, 0xcb, 0xb7,
	0x61, 0xf9, 0x1e, 0x58, 0x7a, 0xb2, 0x66, 0xf8, 0xf5, 0x9d, 0x72, 0xbe, 0x62, 0x5b, 0x85, 0x9a,
	0x5d, 0xb3, 0x0b, 0xb4, 0xa2, 0xbc, 0xb3, 0x4d, 0xdf, 0xe8, 0x0b, 0x7d, 0x6a, 0x33, 0xa5, 0xdf,
	0xac, 0xd9, 0x76, 0xcd, 0x24, 0xc7, 0x28, 0xdf, 0xb0, 0x88, 0xe7, 0xeb, 0x96, 0x13, 0x02, 0xbe,
	0xd1, 0xaf, 0xa8, 0x41, 0xfc, 0x70, 0xe0, 0xf5, 0xfe, 0x01, 0xdb, 0xf1, 0x0d, 0xbb, 0x11, 0x0a,
	0x4c, 0xbf, 0xd6, 0x3f, 0xd8, 0xa3, 0x3d, 0xfd, 0x46, 0xff, 0xd0, 0xae, 0x6e, 0x1a, 0x55, 0xdd,
	0x27, 0xe1, 0x68, 0xe6, 0xc4, 0xa8, 0x41, 0xee, 0x69, 0xfd, 0xd4, 0x6f, 0x9e, 0x46, 0x78, 0xbd,
	0x13, 0x64, 0xff, 0x1b, 0x83, 0xd4, 0x7b, 0xa6, 0x5d, 0xd6, 0xcd, 0x4d, 0x87, 0x54, 0x4a, 0xf7,
	0x1d, 0x82, 0xaf, 0x03, 0xa7, 0x53, 0x7b, 0x44, 0xc8, 0xa0, 0x5c, 0x72, 0x3a, 0x93, 0x3f, 0xd3,
	0xc0, 0xfc, 0xe2, 0x86, 0x6d, 0x9b, 0xcb, 0x11, 0x35, 0xa6, 0x07, 0x0f, 0x58, 0x81, 0x84, 0xae,
	0xeb, 0x61, 0x75, 0x92, 0x56, 0xbf, 0x3d, 0xac, 0x7a, 0x71, 0xb1, 0x43, 0xc0, 0x07, 0x75, 0x94,
	0x63, 0x09, 0xa0, 0xd2, 0xd0, 0x2d, 0xd2, 0x26, 0xb9, 0x44, 0x49, 0xae, 0x0c, 0x21, 0xb9, 0x79,
	0x7b, 0x71, 0x6d, 0x29, 0x64, 0x49, 0xd0, 0x4a, 0x4a, 0xf3, 0x6d, 0x88, 0x5b, 0x7b, 0x6d, 0x8e,
	0x11, 0xca, 0xf1, 0xd6, 0x10, 0x8e, 0xb5, 0x1f, 0x86, 0x04, 0x9c, 0xb5, 0x47, 0xab, 0x6f, 0x00,
	0xef, 0xb9, 0xbb, 0xed, 0xf2, 0x31, 0x5a, 0x9e, 0x1d, 0x52, 0xbe, 0xa9, 0x7e, 0x3f, 0xac, 0x8f,
	0x7b, 0xee, 0x2e, 0x25, 0xb8, 0x03, 0x97, 0x4d, 0x5b, 0xaf, 0x6a, 0x65, 0xdd, 0xd4, 0x1b, 0x15,
	0xa3, 0x51, 0xd3, 0x2c, 0xbb, 0x4a, 0x44, 0x36, 0x83, 0x72, 0xa9, 0x69, 0x79, 0x08, 0xd7, 0x77,
	0x6d, 0xbd, 0xaa, 0x74, 0x8a, 0xd6, 0xec, 0x2a, 0x51, 0xc7, 0xcc, 0x93, 0x9f, 0xf0, 0x3c, 0x8c,
	0xec, 0x78, 0x44, 0x73, 0x5d, 0x8f, 0xf8, 0x9a, 0xef, 0x9b, 0xe2, 0x28, 0xd5, 0x38, 0x7e, 0x82,
	0x77, 0xc9, 0x72, 0xfc, 0xfb, 0xcb, 0x48, 0x4d, 0xee, 0x78, 0x44, 0x0d, 0xb0, 0x25, 0xdf, 0xc4,
	0x05, 0x88, 0x06, 0x15, 0xd1, 0x0c, 0xca, 0x8d, 0x28, 0xaf, 0x3f, 0x6a, 0x22, 0x66, 0x66, 0xea,
	0xdf, 0x4d, 0x14, 0xf9, 0xf9, 0x5f, 0x10, 0xfa, 0xf3, 0x3f, 0x0e, 0xa2, 0xfc, 0x04, 0x27, 0x1e,
	0x1d, 0x1d, 0x1d, 0xc5, 0x97, 0x91, 0x1a, 0x20, 0xf1, 0x36, 0x60, 0x2a, 0xf0, 0xb8, 0x1d, 0xe2,
	0x7a, 0xa2, 0x90, 0x89, 0x0e, 0x70, 0x85, 0x06, 0x2c, 0xbf, 0x5e, 0xfe, 0x09, 0xa9, 0xf8, 0x2a,
	0xd9, 0x0e, 0xf2, 0xa4, 0x8c, 0x7f, 0xbe, 0x3f, 0x76, 0x8a, 0x40, 0x15, 0xaa, 0x0d, 0xef, 0xb8,
	0x57, 0xe2, 0x7a, 0xf3, 0xc9, 0xa7, 0x0b, 0xfc, 0xac, 0x7c, 0x5d, 0x2e, 0xce, 0xca, 0x73, 0x4a,
	0x1e, 0x84, 0xc0, 0x0e, 0x2d, 0xc8, 0xaa, 0x56, 0xa9, 0xdb, 0x46, 0x85, 0xe0, 0xf4, 0x41, 0x13,
	0xc1, 0x61, 0x13, 0x25, 0x5a, 0x4d, 0x94, 0x2a, 0x4e, 0xc9, 0xc5, 0xa2, 0x5c, 0x9c, 0x96, 0x8b,
	0x33, 0x72, 0xf1, 0x9a, 0x22, 0x01, 0xf8, 0xbe, 0xd9, 0x41, 0x0a, 0x07, 0x4d, 0x14, 0x3d, 0x6c,
	0xa2, 0x54, 0xab, 0x89, 0xd8, 0xe2, 0x55, 0x79, 0x66, 0x95, 0xe5, 0x91, 0xc0, 0xac, 0xb2, 0x3c,
	0x27, 0xc4, 0x57, 0x59, 0x3e, 0x21, 0xc0, 0x2a, 0xcb, 0xa7, 0x84, 0xd1, 0xec, 0x7f, 0x18, 0x88,
	0xd1, 0x0c, 0xe2, 0x32, 0xc4, 0x2d, 0x62, 0x95, 0x83, 0xde, 0x10, 0xed, 0x2d, 0x37, 0x2c, 0xb9,
	0xd5, 0xaa, 0x4b, 0x3c, 0x6f, 0x8d, 0x16, 0x28, 0x52, 0xe0, 0x5b, 0xec, 0xd7, 0x88, 0x11, 0x32,
	0x9d, 0x27, 0x1e, 0x75, 0x9e, 0x44, 0xa4, 0x76, 0x88, 0xf1, 0x32, 0x8c, 0x57, 0x0d, 0x4f, 0x2f,
	0x9b, 0x44, 0xab, 0x13, 0xdd, 0xf4, 0xeb, 0x5a, 0xa5, 0x4e, 0x2a, 0x1f, 0xd2, 0xc5, 0x38, 0x6b,
	0xf9, 0x22, 0x2a, 0x0e, 0x6b, 0x96, 0x69, 0xc9, 0xcd, 0xa0, 0x02, 0x6b, 0x70, 0xa9, 0x8f, 0x81,
	0x1d, 0x18, 0xd2, 0x41, 0xcb, 0xf1, 0xea, 0xe7, 0xfb, 0x97, 0xc3, 0x56, 0x7a, 0x19, 0x96, 0x23,
	0x6a, 0xb2, 0xde, 0x33, 0xc1, 0x55, 0x48, 0x5a, 0xfa, 0x9e, 0xa6, 0x37, 0xbc, 0x7b, 0x81, 0x25,
	0x31, 0x1a, 0x97, 0xf1, 0x47, 0x4d, 0x84, 0x8a, 0x41, 0x5a, 0x82, 0xee, 0xb8, 0x09, 0x56, 0xcc,
	0xe4, 0x90, 0x0a, 0x96, 0xbe, 0xb7, 0xd8, 0xc6, 0x29, 0xef, 0xc0, 0xe5, 0x5e, 0xd6, 0xce, 0x82,
	0x8c, 0x86, 0x0b, 0xc2, 0xb4, 0x9a, 0x28, 0x3a, 0x23, 0xcf, 0xae, 0xb2, 0x3c, 0x23, 0x44, 0xb3,
	0x7f, 0x44, 0xc0, 0x77, 0x36, 0x81, 0x17, 0xb2, 0x00, 0xcf, 0xd6, 0x55, 0x5b, 0xed, 0x2a, 0xcb,
	0x47, 0x05, 0x76, 0x95, 0xe5, 0x59, 0x21, 0x96, 0xb5, 0x20, 0xd1, 0xdd, 0x78, 0xf0, 0x8f, 0x4f,
	0x2a, 0x7f, 0xe7, 0xbc, 0xfd, 0xea, 0xff, 0xd4, 0x9d, 0xfd, 0x0c, 0x01, 0xd7, 0xde, 0xa4, 0xf0,
	0xdd, 0x93, 0x93, 0xbd, 0x3d, 0x74, 0x63, 0x7b, 0x4e, 0x87, 0x98, 0xaf, 0xe6, 0x50, 0xf6, 0xb7,
	0x08, 0xe2, 0xe1, 0x36, 0x88, 0xb7, 0x4e, 0x2a, 0xbc, 0x32, 0x7c, 0xef, 0x7c, 0x41, 0x12, 0x0f,
	0x19, 0x18, 0xe9, 0x8b, 0x0d, 0x9e, 0x80, 0xa4, 0xe1, 0x68, 0xa4, 0x51, 0x75, 0x6c, 0xa3, 0xe1,
	0x8b, 0x28, 0x83, 0x72, 0x09, 0x25, 0x11, 0xd4, 0xb3, 0x2e, 0xe3, 0x20, 0x15, 0x0c, 0x67, 0x29,
	0x1c, 0xc4, 0x39, 0x88, 0xb9, 0xba, 0x6f, 0xd8, 0x61, 0x66, 0x70, 0xdf, 0x74, 0xec, 0x04, 0x23,
	0x56, 0xd5, 0x36, 0x00, 0x4f, 0x01, 0xef, 0xb8, 0x86, 0xed, 0x1a, 0xfe, 0x7d, 0x91, 0xeb, 0x6a,
	0x63, 0x8a, 0x53, 0x1d, 0x74, 0x6c, 0x22, 0x2a, 0x1e, 0x21, 0xb5, 0x8b, 0xc2, 0x22, 0xc4, 0xc3,
	0x9f, 0xb8, 0x18, 0xcf, 0xa0, 0x1c, 0xaf, 0x76, 0x5e, 0xb1, 0x04, 0x6c, 0xf0, 0x8f, 0x26, 0xf2,
	0x54, 0x1a, 0xd0, 0x6a, 0x37, 0x2a, 0x7e, 0xc2, 0xa8, 0xf4, 0xfb, 0xfc, 0xfe, 0xd3, 0x85, 0x44,
	0x51, 0xfe, 0x96, 0x7c, 0x55, 0x9e, 0x93, 0xaf, 0x3d, 0x68, 0x22, 0x0b, 0x44, 0x88, 0x87, 0x4d,
	0xa6, 0x47, 0xfa, 0xda, 0x03, 0x01, 0xd8, 0xdb, 0xba, 0x45, 0x04, 0x94, 0xe6, 0xda, 0xac, 0x20,
	0x40, 0x4c, 0x0d, 0x24, 0xa7, 0xe3, 0x61, 0x73, 0xf0, 0x2a, 0xf0, 0x1b, 0xa1, 0xaa, 0x34, 0x1c,
	0xf7, 0x01, 0xaf, 0x00, 0x7f, 0xab, 0x2d, 0xa9, 0x9a, 0x4e, 0x74, 0xd5, 0x66, 0x7f, 0xc1, 0x00,
	0xdf, 0x89, 0x18, 0x7e, 0x0b, 0xb8, 0xaa, 0x6d, 0xe9, 0x46, 0xe3, 0x84, 0x91, 0x75, 0xa4, 0x86,
	0x03, 0xb8, 0xd8, 0x63, 0x4d, 0x7b, 0xd9, 0x5e, 0xe9, 0xb7, 0x26, 0x58, 0xb7, 0xa3, 0xa3, 0x68,
	0x8f, 0x37, 0x5d, 0xdf, 0xa3, 0xe7, 0xf9, 0xde, 0xf1, 0x8a, 0x3d, 0xc3, 0xab, 0xad, 0xa7, 0x0b,
	0xf1, 0xa2, 0x3c, 0x2b, 0x4f, 0xcb, 0x33, 0x0f, 0x9a, 0x68, 0x03, 0x30, 0x70, 0xb7, 0xa8, 0xac,
	0x34, 0xdf, 0x51, 0xfe, 0x3c, 0x1e, 0x65, 0x7f, 0xc7, 0x40, 0xb2, 0xe7, 0xc7, 0xfd, 0x55, 0xfc,
	0xe8, 0x36, 0xc7, 0x9c, 0xd7, 0xdc, 0x1c, 0x8c, 0x6d, 0x1b, 0x0d, 0xdd, 0xd4, 0x7c, 0x57, 0x6f,
	0x78, 0x66, 0xf0, 0xad, 0x41, 0x2d, 0xe1, 0x95, 0xc4, 0xa3, 0x26, 0x8a, 0x6d, 0xeb, 0xa6, 0x47,
	0x54, 0x81, 0x62, 0x4a, 0xc7, 0x90, 0x73, 0x4d, 0x71, 0xfa, 0x4c, 0x29, 0x3f, 0xb3, 0x29, 0x39,
	0x18, 0xfb, 0x4e, 0x30, 0x77, 0xa6, 0x67, 0xf2, 0xf4, 0xe5, 0x01, 0xa2, 0xb3, 0xff, 0x64, 0x21,
	0xd1, 0xfd, 0xd1, 0x77, 0xf5, 0xa1, 0xc1, 0xfa, 0x9e, 0x25, 0x31, 0x93, 0xc0, 0xdd, 0x23, 0x46,
	0xad, 0xee, 0x87, 0x91, 0x39, 0xa3, 0x20, 0x04, 0xe1, 0x77, 0x81, 0x75, 0x6c, 0xd7, 0xa7, 0x0e,
	0x9d, 0x09, 0xa6, 0x10, 0xfc, 0x1b, 0x04, 0x9c, 0xaf, 0xbb, 0x35, 0xe2, 0xd3, 0x5d, 0x20, 0xa1,
	0xfc, 0x2c, 0xc0, 0x7c, 0xe4, 0xee, 0x4d, 0xef, 0x6e, 0x7d, 0x90, 0xbf, 0x7b, 0xe5, 0xa7, 0x5b,
	0xb9, 0x0f, 0xf4, 0xc9, 0x8f, 0x16, 0x27, 0xdf, 0x9f, 0x9a, 0xbc, 0x7e, 0xf7, 0xe3, 0xe2, 0xfe,
	0xf1, 0x9b, 0x36, 0x79, 0xf7, 0xe3, 0x29, 0x79, 0x6e, 0x7a, 0xff, 0xdd, 0xdc, 0x9d, 0x7c, 0xcf,
	0xe7, 0xb3, 0x50, 0x13, 0x37, 0x8e, 0x71, 0xfd, 0x98, 0x0e, 0xe2, 0x4e, 0xfe, 0xc6, 0x15, 0x35,
	0x94, 0x33, 0x38, 0x1e, 0xdc, 0xf9, 0xf1, 0xe8, 0x06, 0x30, 0x7e, 0x4e, 0x00, 0xe7, 0xff, 0x80,
	0x9e, 0x2e, 0x8c, 0x14, 0xe5, 0xab, 0x41, 0x52, 0xe4, 0x59, 0xf9, 0x9a, 0x3c, 0xf7, 0xa0, 0x89,
	0x3e, 0x43, 0x03, 0xc2, 0x81, 0x81, 0x2b, 0x51, 0x55, 0x41, 0x84, 0xda, 0xfa, 0xce, 0xdc, 0x57,
	0x30, 0x70, 0x3f, 0xa0, 0xcb, 0x10, 0x60, 0xdb, 0x0b, 0x02, 0x29, 0x60, 0x37, 0x6c, 0xd7, 0x0f,
	0xf8, 0x02, 0xd7, 0x9f, 0x37, 0x6c, 0xa9, 0x9b, 0x2e, 0xd1, 0x7d, 0x72, 0x71, 0xbc, 0x79, 0x39,
	0x8e, 0x37, 0xb8, 0xe7, 0x78, 0x13, 0x9e, 0x60, 0xe6, 0xc7, 0x1e, 0x2c, 0x9c, 0x38, 0xe4, 0x2a,
	0xb9, 0x01, 0xe7, 0x8b, 0xf1, 0x4f, 0xbf, 0x44, 0xa7, 0xbe, 0x2a, 0x6f, 0xf4, 0x9d, 0x2c, 0x52,
	0x9f, 0x7e, 0x89, 0x7a, 0xde, 0x7b, 0x4f, 0x14, 0xd9, 0x7f, 0xb1, 0x30, 0xaa, 0x12, 0xc7, 0xd4,
	0x2b, 0x17, 0x69, 0xbb, 0x48, 0xdb, 0xd7, 0x9d, 0xb6, 0x3f, 0xc5, 0x20, 0xf9, 0x1e, 0xf1, 0x2f,
	0x92, 0xf6, 0xd2, 0x26, 0x0d, 0x6f, 0x3c, 0xdf, 0xcd, 0xcc, 0x80, 0x3b, 0x98, 0x17, 0x93, 0xdd,
	0x89, 0x2d, 0x18, 0x3b, 0x65, 0x18, 0x1e, 0x85, 0xa4, 0xba, 0xfe, 0xbd, 0xdb, 0xb7, 0x34, 0x75,
	0x5d, 0x59, 0xb9, 0x2d, 0x44, 0xb0, 0x00, 0x97, 0xd4, 0xc5, 0xd2, 0xca, 0xba, 0xb6, 0xb6, 0xb4,
	0xa6, 0x2c, 0xa9, 0x02, 0xc2, 0x18, 0x52, 0x9b, 0xa5, 0xc5, 0xd2, 0xca, 0x4d, 0x6d, 0x63, 0x49,
	0xdd, 0x5c, 0xd9, 0x2c, 0x09, 0x0c, 0xbe, 0x04, 0xfc, 0x86, 0xba, 0xb2, 0xae, 0xae, 0x94, 0x7e,
	0x24, 0x44, 0xd3, 0xec, 0x41, 0x13, 0x45, 0x94, 0x5f, 0xa2, 0xc3, 0xc7, 0x52, 0xe4, 0xe1, 0x63,
	0x29, 0xf2, 0xc5, 0x63, 0x09, 0x7d, 0xd2, 0x92, 0xd0, 0xef, 0x5b, 0x12, 0xfa, 0x6b, 0x4b, 0x42,
	0x87, 0x2d, 0x09, 0x3d, 0x6c, 0x49, 0xe8, 0x6f, 0x2d, 0x09, 0xfd, 0xbd, 0x25, 0x45, 0xbe, 0x68,
	0x49, 0xe8, 0x57, 0x4f, 0xa4, 0xc8, 0xc1, 0x13, 0x09, 0x1d, 0x3e, 0x91, 0x22, 0x0f, 0x9f, 0x48,
	0x91, 0xf7, 0xd7, 0x6b, 0xb6, 0xf3, 0x61, 0x2d, 0xbf, 0x6b, 0x9b, 0x3e, 0x71, 0x5d, 0x3d, 0xbf,
	0xe3, 0x15, 0xe8, 0xc3, 0xb6, 0xed, 0x5a, 0x93, 0x8e, 0x6b, 0xef, 0x1a, 0x55, 0xe2, 0x4e, 0x76,
	0x86, 0x0b, 0x4e, 0xb9, 0x66, 0x17, 0xc8, 0x9e, 0x1f, 0x5e, 0xb2, 0x9e, 0xbe, 0x8e, 0x2e, 0x73,
	0xf4, 0xb2, 0x75, 0xe6, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xfc, 0xf2, 0x72, 0xc0, 0xb2, 0x16,
	0x00, 0x00,
}

func (x LoadBalancingMode) String() string {
	s, ok := LoadBalancingMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PoolTypeChoice == nil {
		if this.PoolTypeChoice != nil {
			return false
		}
	} else if this.PoolTypeChoice == nil {
		return false
	} else if !this.PoolTypeChoice.Equal(that1.PoolTypeChoice) {
		return false
	}
	if this.LoadBalancingMode != that1.LoadBalancingMode {
		return false
	}
	if that1.TtlChoice == nil {
		if this.TtlChoice != nil {
			return false
		}
	} else if this.TtlChoice == nil {
		return false
	} else if !this.TtlChoice.Equal(that1.TtlChoice) {
		return false
	}
	if len(this.DnsLoadBalancers) != len(that1.DnsLoadBalancers) {
		return false
	}
	for i := range this.DnsLoadBalancers {
		if !this.DnsLoadBalancers[i].Equal(that1.DnsLoadBalancers[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_APool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_APool)
	if !ok {
		that2, ok := that.(GlobalSpecType_APool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.APool.Equal(that1.APool) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AaaaPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AaaaPool)
	if !ok {
		that2, ok := that.(GlobalSpecType_AaaaPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AaaaPool.Equal(that1.AaaaPool) {
		return false
	}
	return true
}
func (this *GlobalSpecType_CnamePool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_CnamePool)
	if !ok {
		that2, ok := that.(GlobalSpecType_CnamePool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CnamePool.Equal(that1.CnamePool) {
		return false
	}
	return true
}
func (this *GlobalSpecType_MxPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_MxPool)
	if !ok {
		that2, ok := that.(GlobalSpecType_MxPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MxPool.Equal(that1.MxPool) {
		return false
	}
	return true
}
func (this *GlobalSpecType_SrvPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_SrvPool)
	if !ok {
		that2, ok := that.(GlobalSpecType_SrvPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SrvPool.Equal(that1.SrvPool) {
		return false
	}
	return true
}
func (this *GlobalSpecType_UseRrsetTtl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_UseRrsetTtl)
	if !ok {
		that2, ok := that.(GlobalSpecType_UseRrsetTtl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseRrsetTtl.Equal(that1.UseRrsetTtl) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Ttl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Ttl)
	if !ok {
		that2, ok := that.(GlobalSpecType_Ttl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	return true
}
func (this *APool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*APool)
	if !ok {
		that2, ok := that.(APool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Members) != len(that1.Members) {
		return false
	}
	for i := range this.Members {
		if !this.Members[i].Equal(that1.Members[i]) {
			return false
		}
	}
	if that1.HealthCheckChoice == nil {
		if this.HealthCheckChoice != nil {
			return false
		}
	} else if this.HealthCheckChoice == nil {
		return false
	} else if !this.HealthCheckChoice.Equal(that1.HealthCheckChoice) {
		return false
	}
	if this.MaxAnswers != that1.MaxAnswers {
		return false
	}
	return true
}
func (this *APool_DisableHealthCheck) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*APool_DisableHealthCheck)
	if !ok {
		that2, ok := that.(APool_DisableHealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableHealthCheck.Equal(that1.DisableHealthCheck) {
		return false
	}
	return true
}
func (this *APool_HealthCheck) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*APool_HealthCheck)
	if !ok {
		that2, ok := that.(APool_HealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HealthCheck.Equal(that1.HealthCheck) {
		return false
	}
	return true
}
func (this *AAAAPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AAAAPool)
	if !ok {
		that2, ok := that.(AAAAPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Members) != len(that1.Members) {
		return false
	}
	for i := range this.Members {
		if !this.Members[i].Equal(that1.Members[i]) {
			return false
		}
	}
	if this.MaxAnswers != that1.MaxAnswers {
		return false
	}
	return true
}
func (this *CNAMEPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNAMEPool)
	if !ok {
		that2, ok := that.(CNAMEPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Members) != len(that1.Members) {
		return false
	}
	for i := range this.Members {
		if !this.Members[i].Equal(that1.Members[i]) {
			return false
		}
	}
	return true
}
func (this *MXPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MXPool)
	if !ok {
		that2, ok := that.(MXPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Members) != len(that1.Members) {
		return false
	}
	for i := range this.Members {
		if !this.Members[i].Equal(that1.Members[i]) {
			return false
		}
	}
	if this.MaxAnswers != that1.MaxAnswers {
		return false
	}
	return true
}
func (this *SRVPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SRVPool)
	if !ok {
		that2, ok := that.(SRVPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Members) != len(that1.Members) {
		return false
	}
	for i := range this.Members {
		if !this.Members[i].Equal(that1.Members[i]) {
			return false
		}
	}
	if this.MaxAnswers != that1.MaxAnswers {
		return false
	}
	return true
}
func (this *AddressMember) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddressMember)
	if !ok {
		that2, ok := that.(AddressMember)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IpEndpoint != that1.IpEndpoint {
		return false
	}
	if this.Ratio != that1.Ratio {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *MXMember) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MXMember)
	if !ok {
		that2, ok := that.(MXMember)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.Ratio != that1.Ratio {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *CNAMEMember) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNAMEMember)
	if !ok {
		that2, ok := that.(CNAMEMember)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.Ratio != that1.Ratio {
		return false
	}
	if this.FinalTranslation != that1.FinalTranslation {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *SRVMember) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SRVMember)
	if !ok {
		that2, ok := that.(SRVMember)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Target != that1.Target {
		return false
	}
	if this.FinalTranslation != that1.FinalTranslation {
		return false
	}
	if this.Ratio != that1.Ratio {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PoolTypeChoice == nil {
		if this.PoolTypeChoice != nil {
			return false
		}
	} else if this.PoolTypeChoice == nil {
		return false
	} else if !this.PoolTypeChoice.Equal(that1.PoolTypeChoice) {
		return false
	}
	if this.LoadBalancingMode != that1.LoadBalancingMode {
		return false
	}
	if that1.TtlChoice == nil {
		if this.TtlChoice != nil {
			return false
		}
	} else if this.TtlChoice == nil {
		return false
	} else if !this.TtlChoice.Equal(that1.TtlChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_APool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_APool)
	if !ok {
		that2, ok := that.(CreateSpecType_APool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.APool.Equal(that1.APool) {
		return false
	}
	return true
}
func (this *CreateSpecType_AaaaPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AaaaPool)
	if !ok {
		that2, ok := that.(CreateSpecType_AaaaPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AaaaPool.Equal(that1.AaaaPool) {
		return false
	}
	return true
}
func (this *CreateSpecType_CnamePool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_CnamePool)
	if !ok {
		that2, ok := that.(CreateSpecType_CnamePool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CnamePool.Equal(that1.CnamePool) {
		return false
	}
	return true
}
func (this *CreateSpecType_MxPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_MxPool)
	if !ok {
		that2, ok := that.(CreateSpecType_MxPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MxPool.Equal(that1.MxPool) {
		return false
	}
	return true
}
func (this *CreateSpecType_SrvPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_SrvPool)
	if !ok {
		that2, ok := that.(CreateSpecType_SrvPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SrvPool.Equal(that1.SrvPool) {
		return false
	}
	return true
}
func (this *CreateSpecType_UseRrsetTtl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_UseRrsetTtl)
	if !ok {
		that2, ok := that.(CreateSpecType_UseRrsetTtl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseRrsetTtl.Equal(that1.UseRrsetTtl) {
		return false
	}
	return true
}
func (this *CreateSpecType_Ttl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Ttl)
	if !ok {
		that2, ok := that.(CreateSpecType_Ttl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PoolTypeChoice == nil {
		if this.PoolTypeChoice != nil {
			return false
		}
	} else if this.PoolTypeChoice == nil {
		return false
	} else if !this.PoolTypeChoice.Equal(that1.PoolTypeChoice) {
		return false
	}
	if this.LoadBalancingMode != that1.LoadBalancingMode {
		return false
	}
	if that1.TtlChoice == nil {
		if this.TtlChoice != nil {
			return false
		}
	} else if this.TtlChoice == nil {
		return false
	} else if !this.TtlChoice.Equal(that1.TtlChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_APool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_APool)
	if !ok {
		that2, ok := that.(ReplaceSpecType_APool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.APool.Equal(that1.APool) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AaaaPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AaaaPool)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AaaaPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AaaaPool.Equal(that1.AaaaPool) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_CnamePool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_CnamePool)
	if !ok {
		that2, ok := that.(ReplaceSpecType_CnamePool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CnamePool.Equal(that1.CnamePool) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_MxPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_MxPool)
	if !ok {
		that2, ok := that.(ReplaceSpecType_MxPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MxPool.Equal(that1.MxPool) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_SrvPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_SrvPool)
	if !ok {
		that2, ok := that.(ReplaceSpecType_SrvPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SrvPool.Equal(that1.SrvPool) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_UseRrsetTtl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_UseRrsetTtl)
	if !ok {
		that2, ok := that.(ReplaceSpecType_UseRrsetTtl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseRrsetTtl.Equal(that1.UseRrsetTtl) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Ttl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Ttl)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Ttl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PoolTypeChoice == nil {
		if this.PoolTypeChoice != nil {
			return false
		}
	} else if this.PoolTypeChoice == nil {
		return false
	} else if !this.PoolTypeChoice.Equal(that1.PoolTypeChoice) {
		return false
	}
	if this.LoadBalancingMode != that1.LoadBalancingMode {
		return false
	}
	if that1.TtlChoice == nil {
		if this.TtlChoice != nil {
			return false
		}
	} else if this.TtlChoice == nil {
		return false
	} else if !this.TtlChoice.Equal(that1.TtlChoice) {
		return false
	}
	if len(this.DnsLoadBalancers) != len(that1.DnsLoadBalancers) {
		return false
	}
	for i := range this.DnsLoadBalancers {
		if !this.DnsLoadBalancers[i].Equal(that1.DnsLoadBalancers[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType_APool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_APool)
	if !ok {
		that2, ok := that.(GetSpecType_APool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.APool.Equal(that1.APool) {
		return false
	}
	return true
}
func (this *GetSpecType_AaaaPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AaaaPool)
	if !ok {
		that2, ok := that.(GetSpecType_AaaaPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AaaaPool.Equal(that1.AaaaPool) {
		return false
	}
	return true
}
func (this *GetSpecType_CnamePool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_CnamePool)
	if !ok {
		that2, ok := that.(GetSpecType_CnamePool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CnamePool.Equal(that1.CnamePool) {
		return false
	}
	return true
}
func (this *GetSpecType_MxPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_MxPool)
	if !ok {
		that2, ok := that.(GetSpecType_MxPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MxPool.Equal(that1.MxPool) {
		return false
	}
	return true
}
func (this *GetSpecType_SrvPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_SrvPool)
	if !ok {
		that2, ok := that.(GetSpecType_SrvPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SrvPool.Equal(that1.SrvPool) {
		return false
	}
	return true
}
func (this *GetSpecType_UseRrsetTtl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_UseRrsetTtl)
	if !ok {
		that2, ok := that.(GetSpecType_UseRrsetTtl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseRrsetTtl.Equal(that1.UseRrsetTtl) {
		return false
	}
	return true
}
func (this *GetSpecType_Ttl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Ttl)
	if !ok {
		that2, ok := that.(GetSpecType_Ttl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&dns_lb_pool.GlobalSpecType{")
	if this.PoolTypeChoice != nil {
		s = append(s, "PoolTypeChoice: "+fmt.Sprintf("%#v", this.PoolTypeChoice)+",\n")
	}
	s = append(s, "LoadBalancingMode: "+fmt.Sprintf("%#v", this.LoadBalancingMode)+",\n")
	if this.TtlChoice != nil {
		s = append(s, "TtlChoice: "+fmt.Sprintf("%#v", this.TtlChoice)+",\n")
	}
	if this.DnsLoadBalancers != nil {
		s = append(s, "DnsLoadBalancers: "+fmt.Sprintf("%#v", this.DnsLoadBalancers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_APool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GlobalSpecType_APool{` +
		`APool:` + fmt.Sprintf("%#v", this.APool) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AaaaPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GlobalSpecType_AaaaPool{` +
		`AaaaPool:` + fmt.Sprintf("%#v", this.AaaaPool) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_CnamePool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GlobalSpecType_CnamePool{` +
		`CnamePool:` + fmt.Sprintf("%#v", this.CnamePool) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_MxPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GlobalSpecType_MxPool{` +
		`MxPool:` + fmt.Sprintf("%#v", this.MxPool) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_SrvPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GlobalSpecType_SrvPool{` +
		`SrvPool:` + fmt.Sprintf("%#v", this.SrvPool) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_UseRrsetTtl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GlobalSpecType_UseRrsetTtl{` +
		`UseRrsetTtl:` + fmt.Sprintf("%#v", this.UseRrsetTtl) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Ttl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GlobalSpecType_Ttl{` +
		`Ttl:` + fmt.Sprintf("%#v", this.Ttl) + `}`}, ", ")
	return s
}
func (this *APool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dns_lb_pool.APool{")
	if this.Members != nil {
		s = append(s, "Members: "+fmt.Sprintf("%#v", this.Members)+",\n")
	}
	if this.HealthCheckChoice != nil {
		s = append(s, "HealthCheckChoice: "+fmt.Sprintf("%#v", this.HealthCheckChoice)+",\n")
	}
	s = append(s, "MaxAnswers: "+fmt.Sprintf("%#v", this.MaxAnswers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *APool_DisableHealthCheck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.APool_DisableHealthCheck{` +
		`DisableHealthCheck:` + fmt.Sprintf("%#v", this.DisableHealthCheck) + `}`}, ", ")
	return s
}
func (this *APool_HealthCheck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.APool_HealthCheck{` +
		`HealthCheck:` + fmt.Sprintf("%#v", this.HealthCheck) + `}`}, ", ")
	return s
}
func (this *AAAAPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dns_lb_pool.AAAAPool{")
	if this.Members != nil {
		s = append(s, "Members: "+fmt.Sprintf("%#v", this.Members)+",\n")
	}
	s = append(s, "MaxAnswers: "+fmt.Sprintf("%#v", this.MaxAnswers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNAMEPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dns_lb_pool.CNAMEPool{")
	if this.Members != nil {
		s = append(s, "Members: "+fmt.Sprintf("%#v", this.Members)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MXPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dns_lb_pool.MXPool{")
	if this.Members != nil {
		s = append(s, "Members: "+fmt.Sprintf("%#v", this.Members)+",\n")
	}
	s = append(s, "MaxAnswers: "+fmt.Sprintf("%#v", this.MaxAnswers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SRVPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dns_lb_pool.SRVPool{")
	if this.Members != nil {
		s = append(s, "Members: "+fmt.Sprintf("%#v", this.Members)+",\n")
	}
	s = append(s, "MaxAnswers: "+fmt.Sprintf("%#v", this.MaxAnswers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddressMember) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dns_lb_pool.AddressMember{")
	s = append(s, "IpEndpoint: "+fmt.Sprintf("%#v", this.IpEndpoint)+",\n")
	s = append(s, "Ratio: "+fmt.Sprintf("%#v", this.Ratio)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MXMember) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dns_lb_pool.MXMember{")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "Ratio: "+fmt.Sprintf("%#v", this.Ratio)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNAMEMember) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dns_lb_pool.CNAMEMember{")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "Ratio: "+fmt.Sprintf("%#v", this.Ratio)+",\n")
	s = append(s, "FinalTranslation: "+fmt.Sprintf("%#v", this.FinalTranslation)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SRVMember) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&dns_lb_pool.SRVMember{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "Weight: "+fmt.Sprintf("%#v", this.Weight)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Target: "+fmt.Sprintf("%#v", this.Target)+",\n")
	s = append(s, "FinalTranslation: "+fmt.Sprintf("%#v", this.FinalTranslation)+",\n")
	s = append(s, "Ratio: "+fmt.Sprintf("%#v", this.Ratio)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&dns_lb_pool.CreateSpecType{")
	if this.PoolTypeChoice != nil {
		s = append(s, "PoolTypeChoice: "+fmt.Sprintf("%#v", this.PoolTypeChoice)+",\n")
	}
	s = append(s, "LoadBalancingMode: "+fmt.Sprintf("%#v", this.LoadBalancingMode)+",\n")
	if this.TtlChoice != nil {
		s = append(s, "TtlChoice: "+fmt.Sprintf("%#v", this.TtlChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_APool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.CreateSpecType_APool{` +
		`APool:` + fmt.Sprintf("%#v", this.APool) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AaaaPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.CreateSpecType_AaaaPool{` +
		`AaaaPool:` + fmt.Sprintf("%#v", this.AaaaPool) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_CnamePool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.CreateSpecType_CnamePool{` +
		`CnamePool:` + fmt.Sprintf("%#v", this.CnamePool) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_MxPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.CreateSpecType_MxPool{` +
		`MxPool:` + fmt.Sprintf("%#v", this.MxPool) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_SrvPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.CreateSpecType_SrvPool{` +
		`SrvPool:` + fmt.Sprintf("%#v", this.SrvPool) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_UseRrsetTtl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.CreateSpecType_UseRrsetTtl{` +
		`UseRrsetTtl:` + fmt.Sprintf("%#v", this.UseRrsetTtl) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_Ttl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.CreateSpecType_Ttl{` +
		`Ttl:` + fmt.Sprintf("%#v", this.Ttl) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&dns_lb_pool.ReplaceSpecType{")
	if this.PoolTypeChoice != nil {
		s = append(s, "PoolTypeChoice: "+fmt.Sprintf("%#v", this.PoolTypeChoice)+",\n")
	}
	s = append(s, "LoadBalancingMode: "+fmt.Sprintf("%#v", this.LoadBalancingMode)+",\n")
	if this.TtlChoice != nil {
		s = append(s, "TtlChoice: "+fmt.Sprintf("%#v", this.TtlChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_APool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.ReplaceSpecType_APool{` +
		`APool:` + fmt.Sprintf("%#v", this.APool) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AaaaPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.ReplaceSpecType_AaaaPool{` +
		`AaaaPool:` + fmt.Sprintf("%#v", this.AaaaPool) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_CnamePool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.ReplaceSpecType_CnamePool{` +
		`CnamePool:` + fmt.Sprintf("%#v", this.CnamePool) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_MxPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.ReplaceSpecType_MxPool{` +
		`MxPool:` + fmt.Sprintf("%#v", this.MxPool) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_SrvPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.ReplaceSpecType_SrvPool{` +
		`SrvPool:` + fmt.Sprintf("%#v", this.SrvPool) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_UseRrsetTtl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.ReplaceSpecType_UseRrsetTtl{` +
		`UseRrsetTtl:` + fmt.Sprintf("%#v", this.UseRrsetTtl) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_Ttl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.ReplaceSpecType_Ttl{` +
		`Ttl:` + fmt.Sprintf("%#v", this.Ttl) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&dns_lb_pool.GetSpecType{")
	if this.PoolTypeChoice != nil {
		s = append(s, "PoolTypeChoice: "+fmt.Sprintf("%#v", this.PoolTypeChoice)+",\n")
	}
	s = append(s, "LoadBalancingMode: "+fmt.Sprintf("%#v", this.LoadBalancingMode)+",\n")
	if this.TtlChoice != nil {
		s = append(s, "TtlChoice: "+fmt.Sprintf("%#v", this.TtlChoice)+",\n")
	}
	if this.DnsLoadBalancers != nil {
		s = append(s, "DnsLoadBalancers: "+fmt.Sprintf("%#v", this.DnsLoadBalancers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_APool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GetSpecType_APool{` +
		`APool:` + fmt.Sprintf("%#v", this.APool) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AaaaPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GetSpecType_AaaaPool{` +
		`AaaaPool:` + fmt.Sprintf("%#v", this.AaaaPool) + `}`}, ", ")
	return s
}
func (this *GetSpecType_CnamePool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GetSpecType_CnamePool{` +
		`CnamePool:` + fmt.Sprintf("%#v", this.CnamePool) + `}`}, ", ")
	return s
}
func (this *GetSpecType_MxPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GetSpecType_MxPool{` +
		`MxPool:` + fmt.Sprintf("%#v", this.MxPool) + `}`}, ", ")
	return s
}
func (this *GetSpecType_SrvPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GetSpecType_SrvPool{` +
		`SrvPool:` + fmt.Sprintf("%#v", this.SrvPool) + `}`}, ", ")
	return s
}
func (this *GetSpecType_UseRrsetTtl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GetSpecType_UseRrsetTtl{` +
		`UseRrsetTtl:` + fmt.Sprintf("%#v", this.UseRrsetTtl) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Ttl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_lb_pool.GetSpecType_Ttl{` +
		`Ttl:` + fmt.Sprintf("%#v", this.Ttl) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolTypeChoice != nil {
		{
			size := m.PoolTypeChoice.Size()
			i -= size
			if _, err := m.PoolTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.DnsLoadBalancers) > 0 {
		for iNdEx := len(m.DnsLoadBalancers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsLoadBalancers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.TtlChoice != nil {
		{
			size := m.TtlChoice.Size()
			i -= size
			if _, err := m.TtlChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LoadBalancingMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LoadBalancingMode))
		i--
		dAtA[i] = 0x20
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_Ttl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Ttl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Ttl))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_APool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_APool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.APool != nil {
		{
			size, err := m.APool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AaaaPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AaaaPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AaaaPool != nil {
		{
			size, err := m.AaaaPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_CnamePool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_CnamePool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CnamePool != nil {
		{
			size, err := m.CnamePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_MxPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_MxPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MxPool != nil {
		{
			size, err := m.MxPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_UseRrsetTtl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_UseRrsetTtl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseRrsetTtl != nil {
		{
			size, err := m.UseRrsetTtl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_SrvPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_SrvPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SrvPool != nil {
		{
			size, err := m.SrvPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *APool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *APool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *APool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxAnswers != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxAnswers))
		i--
		dAtA[i] = 0x28
	}
	if m.HealthCheckChoice != nil {
		{
			size := m.HealthCheckChoice.Size()
			i -= size
			if _, err := m.HealthCheckChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *APool_DisableHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *APool_DisableHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableHealthCheck != nil {
		{
			size, err := m.DisableHealthCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *APool_HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *APool_HealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HealthCheck != nil {
		{
			size, err := m.HealthCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AAAAPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AAAAPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AAAAPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxAnswers != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxAnswers))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CNAMEPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNAMEPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNAMEPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MXPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MXPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MXPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxAnswers != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxAnswers))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SRVPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SRVPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SRVPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxAnswers != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxAnswers))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddressMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x42
	}
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x30
	}
	if m.Ratio != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Ratio))
		i--
		dAtA[i] = 0x28
	}
	if len(m.IpEndpoint) > 0 {
		i -= len(m.IpEndpoint)
		copy(dAtA[i:], m.IpEndpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IpEndpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MXMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MXMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MXMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Ratio != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Ratio))
		i--
		dAtA[i] = 0x18
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CNAMEMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNAMEMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNAMEMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.FinalTranslation {
		i--
		if m.FinalTranslation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Ratio != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Ratio))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SRVMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SRVMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SRVMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ratio != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Ratio))
		i--
		dAtA[i] = 0x38
	}
	if m.FinalTranslation {
		i--
		if m.FinalTranslation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x20
	}
	if m.Weight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x18
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolTypeChoice != nil {
		{
			size := m.PoolTypeChoice.Size()
			i -= size
			if _, err := m.PoolTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TtlChoice != nil {
		{
			size := m.TtlChoice.Size()
			i -= size
			if _, err := m.TtlChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LoadBalancingMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LoadBalancingMode))
		i--
		dAtA[i] = 0x20
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_Ttl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Ttl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Ttl))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_APool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_APool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.APool != nil {
		{
			size, err := m.APool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AaaaPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AaaaPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AaaaPool != nil {
		{
			size, err := m.AaaaPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_CnamePool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_CnamePool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CnamePool != nil {
		{
			size, err := m.CnamePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_MxPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_MxPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MxPool != nil {
		{
			size, err := m.MxPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_UseRrsetTtl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_UseRrsetTtl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseRrsetTtl != nil {
		{
			size, err := m.UseRrsetTtl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_SrvPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_SrvPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SrvPool != nil {
		{
			size, err := m.SrvPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolTypeChoice != nil {
		{
			size := m.PoolTypeChoice.Size()
			i -= size
			if _, err := m.PoolTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TtlChoice != nil {
		{
			size := m.TtlChoice.Size()
			i -= size
			if _, err := m.TtlChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LoadBalancingMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LoadBalancingMode))
		i--
		dAtA[i] = 0x20
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_Ttl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Ttl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Ttl))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_APool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_APool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.APool != nil {
		{
			size, err := m.APool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AaaaPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AaaaPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AaaaPool != nil {
		{
			size, err := m.AaaaPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_CnamePool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_CnamePool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CnamePool != nil {
		{
			size, err := m.CnamePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_MxPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_MxPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MxPool != nil {
		{
			size, err := m.MxPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_UseRrsetTtl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_UseRrsetTtl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseRrsetTtl != nil {
		{
			size, err := m.UseRrsetTtl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_SrvPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_SrvPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SrvPool != nil {
		{
			size, err := m.SrvPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolTypeChoice != nil {
		{
			size := m.PoolTypeChoice.Size()
			i -= size
			if _, err := m.PoolTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.DnsLoadBalancers) > 0 {
		for iNdEx := len(m.DnsLoadBalancers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsLoadBalancers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.TtlChoice != nil {
		{
			size := m.TtlChoice.Size()
			i -= size
			if _, err := m.TtlChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LoadBalancingMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LoadBalancingMode))
		i--
		dAtA[i] = 0x20
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_Ttl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Ttl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Ttl))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *GetSpecType_APool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_APool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.APool != nil {
		{
			size, err := m.APool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AaaaPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AaaaPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AaaaPool != nil {
		{
			size, err := m.AaaaPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_CnamePool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_CnamePool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CnamePool != nil {
		{
			size, err := m.CnamePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_MxPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_MxPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MxPool != nil {
		{
			size, err := m.MxPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_UseRrsetTtl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_UseRrsetTtl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseRrsetTtl != nil {
		{
			size, err := m.UseRrsetTtl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_SrvPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_SrvPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SrvPool != nil {
		{
			size, err := m.SrvPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TtlChoice != nil {
		n += m.TtlChoice.Size()
	}
	if m.LoadBalancingMode != 0 {
		n += 1 + sovTypes(uint64(m.LoadBalancingMode))
	}
	if m.PoolTypeChoice != nil {
		n += m.PoolTypeChoice.Size()
	}
	if len(m.DnsLoadBalancers) > 0 {
		for _, e := range m.DnsLoadBalancers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_Ttl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Ttl))
	return n
}
func (m *GlobalSpecType_APool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.APool != nil {
		l = m.APool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AaaaPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AaaaPool != nil {
		l = m.AaaaPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_CnamePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CnamePool != nil {
		l = m.CnamePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_MxPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MxPool != nil {
		l = m.MxPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_UseRrsetTtl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseRrsetTtl != nil {
		l = m.UseRrsetTtl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_SrvPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrvPool != nil {
		l = m.SrvPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *APool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HealthCheckChoice != nil {
		n += m.HealthCheckChoice.Size()
	}
	if m.MaxAnswers != 0 {
		n += 1 + sovTypes(uint64(m.MaxAnswers))
	}
	return n
}

func (m *APool_DisableHealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableHealthCheck != nil {
		l = m.DisableHealthCheck.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *APool_HealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HealthCheck != nil {
		l = m.HealthCheck.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AAAAPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.MaxAnswers != 0 {
		n += 1 + sovTypes(uint64(m.MaxAnswers))
	}
	return n
}

func (m *CNAMEPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *MXPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.MaxAnswers != 0 {
		n += 1 + sovTypes(uint64(m.MaxAnswers))
	}
	return n
}

func (m *SRVPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.MaxAnswers != 0 {
		n += 1 + sovTypes(uint64(m.MaxAnswers))
	}
	return n
}

func (m *AddressMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IpEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Ratio != 0 {
		n += 1 + sovTypes(uint64(m.Ratio))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if m.Disable {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MXMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if m.Ratio != 0 {
		n += 1 + sovTypes(uint64(m.Ratio))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CNAMEMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Ratio != 0 {
		n += 1 + sovTypes(uint64(m.Ratio))
	}
	if m.FinalTranslation {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SRVMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if m.Weight != 0 {
		n += 1 + sovTypes(uint64(m.Weight))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FinalTranslation {
		n += 2
	}
	if m.Ratio != 0 {
		n += 1 + sovTypes(uint64(m.Ratio))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TtlChoice != nil {
		n += m.TtlChoice.Size()
	}
	if m.LoadBalancingMode != 0 {
		n += 1 + sovTypes(uint64(m.LoadBalancingMode))
	}
	if m.PoolTypeChoice != nil {
		n += m.PoolTypeChoice.Size()
	}
	return n
}

func (m *CreateSpecType_Ttl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Ttl))
	return n
}
func (m *CreateSpecType_APool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.APool != nil {
		l = m.APool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AaaaPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AaaaPool != nil {
		l = m.AaaaPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_CnamePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CnamePool != nil {
		l = m.CnamePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_MxPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MxPool != nil {
		l = m.MxPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_UseRrsetTtl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseRrsetTtl != nil {
		l = m.UseRrsetTtl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_SrvPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrvPool != nil {
		l = m.SrvPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TtlChoice != nil {
		n += m.TtlChoice.Size()
	}
	if m.LoadBalancingMode != 0 {
		n += 1 + sovTypes(uint64(m.LoadBalancingMode))
	}
	if m.PoolTypeChoice != nil {
		n += m.PoolTypeChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_Ttl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Ttl))
	return n
}
func (m *ReplaceSpecType_APool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.APool != nil {
		l = m.APool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AaaaPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AaaaPool != nil {
		l = m.AaaaPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_CnamePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CnamePool != nil {
		l = m.CnamePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_MxPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MxPool != nil {
		l = m.MxPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_UseRrsetTtl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseRrsetTtl != nil {
		l = m.UseRrsetTtl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_SrvPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrvPool != nil {
		l = m.SrvPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TtlChoice != nil {
		n += m.TtlChoice.Size()
	}
	if m.LoadBalancingMode != 0 {
		n += 1 + sovTypes(uint64(m.LoadBalancingMode))
	}
	if m.PoolTypeChoice != nil {
		n += m.PoolTypeChoice.Size()
	}
	if len(m.DnsLoadBalancers) > 0 {
		for _, e := range m.DnsLoadBalancers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_Ttl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Ttl))
	return n
}
func (m *GetSpecType_APool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.APool != nil {
		l = m.APool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AaaaPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AaaaPool != nil {
		l = m.AaaaPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_CnamePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CnamePool != nil {
		l = m.CnamePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_MxPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MxPool != nil {
		l = m.MxPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_UseRrsetTtl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseRrsetTtl != nil {
		l = m.UseRrsetTtl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_SrvPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrvPool != nil {
		l = m.SrvPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDnsLoadBalancers := "[]*ObjectRefType{"
	for _, f := range this.DnsLoadBalancers {
		repeatedStringForDnsLoadBalancers += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForDnsLoadBalancers += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`TtlChoice:` + fmt.Sprintf("%v", this.TtlChoice) + `,`,
		`LoadBalancingMode:` + fmt.Sprintf("%v", this.LoadBalancingMode) + `,`,
		`PoolTypeChoice:` + fmt.Sprintf("%v", this.PoolTypeChoice) + `,`,
		`DnsLoadBalancers:` + repeatedStringForDnsLoadBalancers + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Ttl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Ttl{`,
		`Ttl:` + fmt.Sprintf("%v", this.Ttl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_APool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_APool{`,
		`APool:` + strings.Replace(fmt.Sprintf("%v", this.APool), "APool", "APool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AaaaPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AaaaPool{`,
		`AaaaPool:` + strings.Replace(fmt.Sprintf("%v", this.AaaaPool), "AAAAPool", "AAAAPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_CnamePool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_CnamePool{`,
		`CnamePool:` + strings.Replace(fmt.Sprintf("%v", this.CnamePool), "CNAMEPool", "CNAMEPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_MxPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_MxPool{`,
		`MxPool:` + strings.Replace(fmt.Sprintf("%v", this.MxPool), "MXPool", "MXPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_UseRrsetTtl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_UseRrsetTtl{`,
		`UseRrsetTtl:` + strings.Replace(fmt.Sprintf("%v", this.UseRrsetTtl), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_SrvPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_SrvPool{`,
		`SrvPool:` + strings.Replace(fmt.Sprintf("%v", this.SrvPool), "SRVPool", "SRVPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *APool) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMembers := "[]*AddressMember{"
	for _, f := range this.Members {
		repeatedStringForMembers += strings.Replace(f.String(), "AddressMember", "AddressMember", 1) + ","
	}
	repeatedStringForMembers += "}"
	s := strings.Join([]string{`&APool{`,
		`Members:` + repeatedStringForMembers + `,`,
		`HealthCheckChoice:` + fmt.Sprintf("%v", this.HealthCheckChoice) + `,`,
		`MaxAnswers:` + fmt.Sprintf("%v", this.MaxAnswers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *APool_DisableHealthCheck) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&APool_DisableHealthCheck{`,
		`DisableHealthCheck:` + strings.Replace(fmt.Sprintf("%v", this.DisableHealthCheck), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *APool_HealthCheck) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&APool_HealthCheck{`,
		`HealthCheck:` + strings.Replace(fmt.Sprintf("%v", this.HealthCheck), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AAAAPool) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMembers := "[]*AddressMember{"
	for _, f := range this.Members {
		repeatedStringForMembers += strings.Replace(f.String(), "AddressMember", "AddressMember", 1) + ","
	}
	repeatedStringForMembers += "}"
	s := strings.Join([]string{`&AAAAPool{`,
		`Members:` + repeatedStringForMembers + `,`,
		`MaxAnswers:` + fmt.Sprintf("%v", this.MaxAnswers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNAMEPool) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMembers := "[]*CNAMEMember{"
	for _, f := range this.Members {
		repeatedStringForMembers += strings.Replace(f.String(), "CNAMEMember", "CNAMEMember", 1) + ","
	}
	repeatedStringForMembers += "}"
	s := strings.Join([]string{`&CNAMEPool{`,
		`Members:` + repeatedStringForMembers + `,`,
		`}`,
	}, "")
	return s
}
func (this *MXPool) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMembers := "[]*MXMember{"
	for _, f := range this.Members {
		repeatedStringForMembers += strings.Replace(f.String(), "MXMember", "MXMember", 1) + ","
	}
	repeatedStringForMembers += "}"
	s := strings.Join([]string{`&MXPool{`,
		`Members:` + repeatedStringForMembers + `,`,
		`MaxAnswers:` + fmt.Sprintf("%v", this.MaxAnswers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SRVPool) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMembers := "[]*SRVMember{"
	for _, f := range this.Members {
		repeatedStringForMembers += strings.Replace(f.String(), "SRVMember", "SRVMember", 1) + ","
	}
	repeatedStringForMembers += "}"
	s := strings.Join([]string{`&SRVPool{`,
		`Members:` + repeatedStringForMembers + `,`,
		`MaxAnswers:` + fmt.Sprintf("%v", this.MaxAnswers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AddressMember) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddressMember{`,
		`IpEndpoint:` + fmt.Sprintf("%v", this.IpEndpoint) + `,`,
		`Ratio:` + fmt.Sprintf("%v", this.Ratio) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MXMember) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MXMember{`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`Ratio:` + fmt.Sprintf("%v", this.Ratio) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNAMEMember) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNAMEMember{`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`Ratio:` + fmt.Sprintf("%v", this.Ratio) + `,`,
		`FinalTranslation:` + fmt.Sprintf("%v", this.FinalTranslation) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SRVMember) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SRVMember{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`Weight:` + fmt.Sprintf("%v", this.Weight) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Target:` + fmt.Sprintf("%v", this.Target) + `,`,
		`FinalTranslation:` + fmt.Sprintf("%v", this.FinalTranslation) + `,`,
		`Ratio:` + fmt.Sprintf("%v", this.Ratio) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`TtlChoice:` + fmt.Sprintf("%v", this.TtlChoice) + `,`,
		`LoadBalancingMode:` + fmt.Sprintf("%v", this.LoadBalancingMode) + `,`,
		`PoolTypeChoice:` + fmt.Sprintf("%v", this.PoolTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Ttl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Ttl{`,
		`Ttl:` + fmt.Sprintf("%v", this.Ttl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_APool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_APool{`,
		`APool:` + strings.Replace(fmt.Sprintf("%v", this.APool), "APool", "APool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AaaaPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AaaaPool{`,
		`AaaaPool:` + strings.Replace(fmt.Sprintf("%v", this.AaaaPool), "AAAAPool", "AAAAPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_CnamePool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_CnamePool{`,
		`CnamePool:` + strings.Replace(fmt.Sprintf("%v", this.CnamePool), "CNAMEPool", "CNAMEPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_MxPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_MxPool{`,
		`MxPool:` + strings.Replace(fmt.Sprintf("%v", this.MxPool), "MXPool", "MXPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_UseRrsetTtl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_UseRrsetTtl{`,
		`UseRrsetTtl:` + strings.Replace(fmt.Sprintf("%v", this.UseRrsetTtl), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_SrvPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_SrvPool{`,
		`SrvPool:` + strings.Replace(fmt.Sprintf("%v", this.SrvPool), "SRVPool", "SRVPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`TtlChoice:` + fmt.Sprintf("%v", this.TtlChoice) + `,`,
		`LoadBalancingMode:` + fmt.Sprintf("%v", this.LoadBalancingMode) + `,`,
		`PoolTypeChoice:` + fmt.Sprintf("%v", this.PoolTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Ttl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Ttl{`,
		`Ttl:` + fmt.Sprintf("%v", this.Ttl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_APool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_APool{`,
		`APool:` + strings.Replace(fmt.Sprintf("%v", this.APool), "APool", "APool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AaaaPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AaaaPool{`,
		`AaaaPool:` + strings.Replace(fmt.Sprintf("%v", this.AaaaPool), "AAAAPool", "AAAAPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_CnamePool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_CnamePool{`,
		`CnamePool:` + strings.Replace(fmt.Sprintf("%v", this.CnamePool), "CNAMEPool", "CNAMEPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_MxPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_MxPool{`,
		`MxPool:` + strings.Replace(fmt.Sprintf("%v", this.MxPool), "MXPool", "MXPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_UseRrsetTtl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_UseRrsetTtl{`,
		`UseRrsetTtl:` + strings.Replace(fmt.Sprintf("%v", this.UseRrsetTtl), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_SrvPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_SrvPool{`,
		`SrvPool:` + strings.Replace(fmt.Sprintf("%v", this.SrvPool), "SRVPool", "SRVPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDnsLoadBalancers := "[]*ObjectRefType{"
	for _, f := range this.DnsLoadBalancers {
		repeatedStringForDnsLoadBalancers += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForDnsLoadBalancers += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`TtlChoice:` + fmt.Sprintf("%v", this.TtlChoice) + `,`,
		`LoadBalancingMode:` + fmt.Sprintf("%v", this.LoadBalancingMode) + `,`,
		`PoolTypeChoice:` + fmt.Sprintf("%v", this.PoolTypeChoice) + `,`,
		`DnsLoadBalancers:` + repeatedStringForDnsLoadBalancers + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Ttl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Ttl{`,
		`Ttl:` + fmt.Sprintf("%v", this.Ttl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_APool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_APool{`,
		`APool:` + strings.Replace(fmt.Sprintf("%v", this.APool), "APool", "APool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AaaaPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AaaaPool{`,
		`AaaaPool:` + strings.Replace(fmt.Sprintf("%v", this.AaaaPool), "AAAAPool", "AAAAPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_CnamePool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_CnamePool{`,
		`CnamePool:` + strings.Replace(fmt.Sprintf("%v", this.CnamePool), "CNAMEPool", "CNAMEPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_MxPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_MxPool{`,
		`MxPool:` + strings.Replace(fmt.Sprintf("%v", this.MxPool), "MXPool", "MXPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_UseRrsetTtl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_UseRrsetTtl{`,
		`UseRrsetTtl:` + strings.Replace(fmt.Sprintf("%v", this.UseRrsetTtl), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_SrvPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_SrvPool{`,
		`SrvPool:` + strings.Replace(fmt.Sprintf("%v", this.SrvPool), "SRVPool", "SRVPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlChoice = &GlobalSpecType_Ttl{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancingMode", wireType)
			}
			m.LoadBalancingMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalancingMode |= LoadBalancingMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &APool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &GlobalSpecType_APool{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AaaaPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AAAAPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &GlobalSpecType_AaaaPool{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CnamePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNAMEPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &GlobalSpecType_CnamePool{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MxPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MXPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &GlobalSpecType_MxPool{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRrsetTtl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TtlChoice = &GlobalSpecType_UseRrsetTtl{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsLoadBalancers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsLoadBalancers = append(m.DnsLoadBalancers, &views.ObjectRefType{})
			if err := m.DnsLoadBalancers[len(m.DnsLoadBalancers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SRVPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &GlobalSpecType_SrvPool{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *APool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: APool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: APool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &AddressMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableHealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HealthCheckChoice = &APool_DisableHealthCheck{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HealthCheckChoice = &APool_HealthCheck{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAnswers", wireType)
			}
			m.MaxAnswers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAnswers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AAAAPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AAAAPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AAAAPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &AddressMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAnswers", wireType)
			}
			m.MaxAnswers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAnswers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNAMEPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNAMEPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNAMEPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &CNAMEMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MXPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MXPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MXPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &MXMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAnswers", wireType)
			}
			m.MaxAnswers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAnswers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SRVPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SRVPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SRVPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &SRVMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAnswers", wireType)
			}
			m.MaxAnswers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAnswers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratio", wireType)
			}
			m.Ratio = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ratio |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MXMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MXMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MXMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratio", wireType)
			}
			m.Ratio = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ratio |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNAMEMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNAMEMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNAMEMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratio", wireType)
			}
			m.Ratio = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ratio |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalTranslation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FinalTranslation = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SRVMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SRVMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SRVMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalTranslation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FinalTranslation = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratio", wireType)
			}
			m.Ratio = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ratio |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlChoice = &CreateSpecType_Ttl{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancingMode", wireType)
			}
			m.LoadBalancingMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalancingMode |= LoadBalancingMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &APool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &CreateSpecType_APool{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AaaaPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AAAAPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &CreateSpecType_AaaaPool{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CnamePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNAMEPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &CreateSpecType_CnamePool{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MxPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MXPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &CreateSpecType_MxPool{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRrsetTtl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TtlChoice = &CreateSpecType_UseRrsetTtl{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SRVPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &CreateSpecType_SrvPool{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlChoice = &ReplaceSpecType_Ttl{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancingMode", wireType)
			}
			m.LoadBalancingMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalancingMode |= LoadBalancingMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &APool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &ReplaceSpecType_APool{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AaaaPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AAAAPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &ReplaceSpecType_AaaaPool{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CnamePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNAMEPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &ReplaceSpecType_CnamePool{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MxPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MXPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &ReplaceSpecType_MxPool{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRrsetTtl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TtlChoice = &ReplaceSpecType_UseRrsetTtl{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SRVPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &ReplaceSpecType_SrvPool{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlChoice = &GetSpecType_Ttl{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancingMode", wireType)
			}
			m.LoadBalancingMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalancingMode |= LoadBalancingMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &APool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &GetSpecType_APool{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AaaaPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AAAAPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &GetSpecType_AaaaPool{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CnamePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNAMEPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &GetSpecType_CnamePool{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MxPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MXPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &GetSpecType_MxPool{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRrsetTtl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TtlChoice = &GetSpecType_UseRrsetTtl{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsLoadBalancers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsLoadBalancers = append(m.DnsLoadBalancers, &views.ObjectRefType{})
			if err := m.DnsLoadBalancers[len(m.DnsLoadBalancers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SRVPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PoolTypeChoice = &GetSpecType_SrvPool{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
