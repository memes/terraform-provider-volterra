// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package signup

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CityItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CityItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CityItem) DeepCopy() *CityItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CityItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CityItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CityItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CityItemValidator().Validate(ctx, m, opts...)
}

type ValidateCityItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCityItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CityItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CityItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["additional_info"]; exists {

		vOpts := append(opts, db.WithValidateField("additional_info"))
		for key, value := range m.GetAdditionalInfo() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["city_name"]; exists {

		vOpts := append(opts, db.WithValidateField("city_name"))
		if err := fv(ctx, m.GetCityName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCityItemValidator = func() *ValidateCityItem {
	v := &ValidateCityItem{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CityItemValidator() db.Validator {
	return DefaultCityItemValidator
}

// augmented methods on protoc/std generated struct

func (m *CountryItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CountryItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CountryItem) DeepCopy() *CountryItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CountryItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CountryItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CountryItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CountryItemValidator().Validate(ctx, m, opts...)
}

type ValidateCountryItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCountryItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CountryItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CountryItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["additional_info"]; exists {

		vOpts := append(opts, db.WithValidateField("additional_info"))
		for key, value := range m.GetAdditionalInfo() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["country_code"]; exists {

		vOpts := append(opts, db.WithValidateField("country_code"))
		if err := fv(ctx, m.GetCountryCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["country_name"]; exists {

		vOpts := append(opts, db.WithValidateField("country_name"))
		if err := fv(ctx, m.GetCountryName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCountryItemValidator = func() *ValidateCountryItem {
	v := &ValidateCountryItem{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CountryItemValidator() db.Validator {
	return DefaultCountryItemValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateRequest) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetSpec().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateRequest.spec")
	}

	return nil
}

func (m *CreateRequest) DeepCopy() *CreateRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateRequestValidator().Validate(ctx, m, opts...)
}

func (m *CreateRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSpecDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CreateRequest) GetSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "spec." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["spec"]; exists {

		vOpts := append(opts, db.WithValidateField("spec"))
		if err := fv(ctx, m.GetSpec(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateRequestValidator = func() *ValidateCreateRequest {
	v := &ValidateCreateRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["spec"] = CreateSpecTypeValidator().Validate

	return v
}()

func CreateRequestValidator() db.Validator {
	return DefaultCreateRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetRequest) DeepCopy() *GetRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetRequestValidator = func() *ValidateGetRequest {
	v := &ValidateGetRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetRequestValidator() db.Validator {
	return DefaultGetRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetResponse) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetObject().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetResponse.object")
	}

	return nil
}

func (m *GetResponse) DeepCopy() *GetResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetResponseValidator().Validate(ctx, m, opts...)
}

func (m *GetResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo

	return drInfos, nil

}

type ValidateGetResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["object"]; exists {

		vOpts := append(opts, db.WithValidateField("object"))
		if err := fv(ctx, m.GetObject(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		for idx, item := range m.GetStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetResponseValidator = func() *ValidateGetResponse {
	v := &ValidateGetResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["object"] = ObjectValidator().Validate

	v.FldValidators["status"] = StatusObjectValidator().Validate

	return v
}()

func GetResponseValidator() db.Validator {
	return DefaultGetResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListCitiesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListCitiesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListCitiesRequest) DeepCopy() *ListCitiesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListCitiesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListCitiesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListCitiesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListCitiesRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListCitiesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListCitiesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListCitiesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListCitiesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["country_code"]; exists {

		vOpts := append(opts, db.WithValidateField("country_code"))
		if err := fv(ctx, m.GetCountryCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("prefix"))
		if err := fv(ctx, m.GetPrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state_code"]; exists {

		vOpts := append(opts, db.WithValidateField("state_code"))
		if err := fv(ctx, m.GetStateCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListCitiesRequestValidator = func() *ValidateListCitiesRequest {
	v := &ValidateListCitiesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListCitiesRequestValidator() db.Validator {
	return DefaultListCitiesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListCitiesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListCitiesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListCitiesResponse) DeepCopy() *ListCitiesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListCitiesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListCitiesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListCitiesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListCitiesResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListCitiesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListCitiesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListCitiesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListCitiesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cities"]; exists {

		vOpts := append(opts, db.WithValidateField("cities"))
		for idx, item := range m.GetCities() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["error_code"]; exists {

		vOpts := append(opts, db.WithValidateField("error_code"))
		if err := fv(ctx, m.GetErrorCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListCitiesResponseValidator = func() *ValidateListCitiesResponse {
	v := &ValidateListCitiesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListCitiesResponseValidator() db.Validator {
	return DefaultListCitiesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListCountriesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListCountriesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListCountriesRequest) DeepCopy() *ListCountriesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListCountriesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListCountriesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListCountriesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListCountriesRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListCountriesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListCountriesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListCountriesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListCountriesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("prefix"))
		if err := fv(ctx, m.GetPrefix(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListCountriesRequestValidator = func() *ValidateListCountriesRequest {
	v := &ValidateListCountriesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListCountriesRequestValidator() db.Validator {
	return DefaultListCountriesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListCountriesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListCountriesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListCountriesResponse) DeepCopy() *ListCountriesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListCountriesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListCountriesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListCountriesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListCountriesResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListCountriesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListCountriesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListCountriesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListCountriesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["countries"]; exists {

		vOpts := append(opts, db.WithValidateField("countries"))
		for idx, item := range m.GetCountries() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListCountriesResponseValidator = func() *ValidateListCountriesResponse {
	v := &ValidateListCountriesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListCountriesResponseValidator() db.Validator {
	return DefaultListCountriesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListStatesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListStatesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListStatesRequest) DeepCopy() *ListStatesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListStatesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListStatesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListStatesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListStatesRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListStatesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListStatesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListStatesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListStatesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["country_code"]; exists {

		vOpts := append(opts, db.WithValidateField("country_code"))
		if err := fv(ctx, m.GetCountryCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("prefix"))
		if err := fv(ctx, m.GetPrefix(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListStatesRequestValidator = func() *ValidateListStatesRequest {
	v := &ValidateListStatesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListStatesRequestValidator() db.Validator {
	return DefaultListStatesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListStatesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListStatesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListStatesResponse) DeepCopy() *ListStatesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListStatesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListStatesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListStatesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListStatesResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListStatesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListStatesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListStatesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListStatesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error_code"]; exists {

		vOpts := append(opts, db.WithValidateField("error_code"))
		if err := fv(ctx, m.GetErrorCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["states"]; exists {

		vOpts := append(opts, db.WithValidateField("states"))
		for idx, item := range m.GetStates() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListStatesResponseValidator = func() *ValidateListStatesResponse {
	v := &ValidateListStatesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListStatesResponseValidator() db.Validator {
	return DefaultListStatesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SendPasswordEmailRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SendPasswordEmailRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SendPasswordEmailRequest) DeepCopy() *SendPasswordEmailRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SendPasswordEmailRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SendPasswordEmailRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SendPasswordEmailRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SendPasswordEmailRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSendPasswordEmailRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSendPasswordEmailRequest) EmailValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for email")
	}

	return validatorFn, nil
}

func (v *ValidateSendPasswordEmailRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SendPasswordEmailRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SendPasswordEmailRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cname"]; exists {

		vOpts := append(opts, db.WithValidateField("cname"))
		if err := fv(ctx, m.GetCname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSendPasswordEmailRequestValidator = func() *ValidateSendPasswordEmailRequest {
	v := &ValidateSendPasswordEmailRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEmail := v.EmailValidationRuleHandler
	rulesEmail := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEmail(rulesEmail)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SendPasswordEmailRequest.email: %s", err)
		panic(errMsg)
	}
	v.FldValidators["email"] = vFn

	return v
}()

func SendPasswordEmailRequestValidator() db.Validator {
	return DefaultSendPasswordEmailRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SendPasswordEmailResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SendPasswordEmailResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SendPasswordEmailResponse) DeepCopy() *SendPasswordEmailResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SendPasswordEmailResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SendPasswordEmailResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SendPasswordEmailResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SendPasswordEmailResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSendPasswordEmailResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSendPasswordEmailResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SendPasswordEmailResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SendPasswordEmailResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSendPasswordEmailResponseValidator = func() *ValidateSendPasswordEmailResponse {
	v := &ValidateSendPasswordEmailResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SendPasswordEmailResponseValidator() db.Validator {
	return DefaultSendPasswordEmailResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *StateItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StateItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StateItem) DeepCopy() *StateItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StateItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StateItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StateItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StateItemValidator().Validate(ctx, m, opts...)
}

type ValidateStateItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStateItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StateItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StateItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["additional_info"]; exists {

		vOpts := append(opts, db.WithValidateField("additional_info"))
		for key, value := range m.GetAdditionalInfo() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["state_code"]; exists {

		vOpts := append(opts, db.WithValidateField("state_code"))
		if err := fv(ctx, m.GetStateCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state_name"]; exists {

		vOpts := append(opts, db.WithValidateField("state_name"))
		if err := fv(ctx, m.GetStateName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStateItemValidator = func() *ValidateStateItem {
	v := &ValidateStateItem{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StateItemValidator() db.Validator {
	return DefaultStateItemValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidateContactRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidateContactRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidateContactRequest) DeepCopy() *ValidateContactRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidateContactRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidateContactRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidateContactRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidateContactRequestValidator().Validate(ctx, m, opts...)
}

type ValidateValidateContactRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidateContactRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidateContactRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidateContactRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["spec"]; exists {

		vOpts := append(opts, db.WithValidateField("spec"))
		if err := fv(ctx, m.GetSpec(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidateContactRequestValidator = func() *ValidateValidateContactRequest {
	v := &ValidateValidateContactRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ValidateContactRequestValidator() db.Validator {
	return DefaultValidateContactRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidateContactResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidateContactResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidateContactResponse) DeepCopy() *ValidateContactResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidateContactResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidateContactResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidateContactResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidateContactResponseValidator().Validate(ctx, m, opts...)
}

type ValidateValidateContactResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidateContactResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidateContactResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidateContactResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["err"]; exists {

		vOpts := append(opts, db.WithValidateField("err"))
		if err := fv(ctx, m.GetErr(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["is_valid"]; exists {

		vOpts := append(opts, db.WithValidateField("is_valid"))
		if err := fv(ctx, m.GetIsValid(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validation_errors"]; exists {

		vOpts := append(opts, db.WithValidateField("validation_errors"))
		for idx, item := range m.GetValidationErrors() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidateContactResponseValidator = func() *ValidateValidateContactResponse {
	v := &ValidateValidateContactResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ValidateContactResponseValidator() db.Validator {
	return DefaultValidateContactResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidateRegistrationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidateRegistrationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidateRegistrationRequest) DeepCopy() *ValidateRegistrationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidateRegistrationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidateRegistrationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidateRegistrationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidateRegistrationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateValidateRegistrationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidateRegistrationRequest) TenantTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.TenantType)
		return int32(i)
	}
	// ves_io_schema.TenantType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.TenantType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tenant_type")
	}

	return validatorFn, nil
}

func (v *ValidateValidateRegistrationRequest) EmailValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for email")
	}

	return validatorFn, nil
}

func (v *ValidateValidateRegistrationRequest) TokenValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for token")
	}

	return validatorFn, nil
}

func (v *ValidateValidateRegistrationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidateRegistrationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidateRegistrationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_type"))
		if err := fv(ctx, m.GetTenantType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["token"]; exists {

		vOpts := append(opts, db.WithValidateField("token"))
		if err := fv(ctx, m.GetToken(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidateRegistrationRequestValidator = func() *ValidateValidateRegistrationRequest {
	v := &ValidateValidateRegistrationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTenantType := v.TenantTypeValidationRuleHandler
	rulesTenantType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTenantType(rulesTenantType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ValidateRegistrationRequest.tenant_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tenant_type"] = vFn

	vrhEmail := v.EmailValidationRuleHandler
	rulesEmail := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEmail(rulesEmail)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ValidateRegistrationRequest.email: %s", err)
		panic(errMsg)
	}
	v.FldValidators["email"] = vFn

	vrhToken := v.TokenValidationRuleHandler
	rulesToken := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhToken(rulesToken)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ValidateRegistrationRequest.token: %s", err)
		panic(errMsg)
	}
	v.FldValidators["token"] = vFn

	return v
}()

func ValidateRegistrationRequestValidator() db.Validator {
	return DefaultValidateRegistrationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidateRegistrationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidateRegistrationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidateRegistrationResponse) DeepCopy() *ValidateRegistrationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidateRegistrationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidateRegistrationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidateRegistrationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidateRegistrationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateValidateRegistrationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidateRegistrationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidateRegistrationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidateRegistrationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["err"]; exists {

		vOpts := append(opts, db.WithValidateField("err"))
		if err := fv(ctx, m.GetErr(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["valid_registration"]; exists {

		vOpts := append(opts, db.WithValidateField("valid_registration"))
		if err := fv(ctx, m.GetValidRegistration(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidateRegistrationResponseValidator = func() *ValidateValidateRegistrationResponse {
	v := &ValidateValidateRegistrationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ValidateRegistrationResponseValidator() db.Validator {
	return DefaultValidateRegistrationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidationErrorField) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidationErrorField) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidationErrorField) DeepCopy() *ValidationErrorField {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidationErrorField{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidationErrorField) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidationErrorField) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidationErrorFieldValidator().Validate(ctx, m, opts...)
}

type ValidateValidationErrorField struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidationErrorField) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidationErrorField)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidationErrorField got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error_field"]; exists {

		vOpts := append(opts, db.WithValidateField("error_field"))
		if err := fv(ctx, m.GetErrorField(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["error_message"]; exists {

		vOpts := append(opts, db.WithValidateField("error_message"))
		if err := fv(ctx, m.GetErrorMessage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidationErrorFieldValidator = func() *ValidateValidationErrorField {
	v := &ValidateValidationErrorField{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ValidationErrorFieldValidator() db.Validator {
	return DefaultValidationErrorFieldValidator
}

func (m *CreateRequest) fromObject(e db.Entry, withDeepCopy bool) {
	f := e.(*DBObject)
	if withDeepCopy {
		f = e.DeepCopy().(*DBObject)
	}
	_ = f

	if m.Spec == nil {
		m.Spec = &CreateSpecType{}
	}
	m.Spec.FromGlobalSpecTypeWithoutDeepCopy(f.GetSpec().GetGcSpec())

}

func (m *CreateRequest) FromObject(e db.Entry) {
	m.fromObject(e, true)
}

func (m *CreateRequest) FromObjectWithoutDeepCopy(e db.Entry) {
	m.fromObject(e, false)
}

func (m *CreateRequest) toObject(e db.Entry, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1
	f := e.(*DBObject)
	_ = f

	if m1.Spec != nil {
		if f.Spec == nil {
			f.Spec = &SpecType{}
		}
	} else if f.Spec != nil {
		f.Spec = nil
	}

	if m1.Spec != nil {
		if f.Spec.GcSpec == nil {
			f.Spec.GcSpec = &GlobalSpecType{}
		}
	} else if f.Spec != nil {
		f.Spec.GcSpec = nil
	}

	if m1.Spec != nil {
		m1.Spec.ToGlobalSpecTypeWithoutDeepCopy(f.Spec.GcSpec)
	}

}

func (m *CreateRequest) ToObject(e db.Entry) {
	m.toObject(e, true)
}

func (m *CreateRequest) ToObjectWithoutDeepCopy(e db.Entry) {
	m.toObject(e, false)
}
